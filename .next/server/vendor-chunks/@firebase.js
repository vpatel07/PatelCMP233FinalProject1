"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@firebase";
exports.ids = ["vendor-chunks/@firebase"];
exports.modules = {

/***/ "(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js":
/*!**************************************************************!*\
  !*** ./node_modules/@firebase/app/dist/esm/index.esm2017.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FirebaseError: () => (/* reexport safe */ _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError),\n/* harmony export */   SDK_VERSION: () => (/* binding */ SDK_VERSION),\n/* harmony export */   _DEFAULT_ENTRY_NAME: () => (/* binding */ DEFAULT_ENTRY_NAME),\n/* harmony export */   _addComponent: () => (/* binding */ _addComponent),\n/* harmony export */   _addOrOverwriteComponent: () => (/* binding */ _addOrOverwriteComponent),\n/* harmony export */   _apps: () => (/* binding */ _apps),\n/* harmony export */   _clearComponents: () => (/* binding */ _clearComponents),\n/* harmony export */   _components: () => (/* binding */ _components),\n/* harmony export */   _getProvider: () => (/* binding */ _getProvider),\n/* harmony export */   _isFirebaseApp: () => (/* binding */ _isFirebaseApp),\n/* harmony export */   _isFirebaseServerApp: () => (/* binding */ _isFirebaseServerApp),\n/* harmony export */   _registerComponent: () => (/* binding */ _registerComponent),\n/* harmony export */   _removeServiceInstance: () => (/* binding */ _removeServiceInstance),\n/* harmony export */   _serverApps: () => (/* binding */ _serverApps),\n/* harmony export */   deleteApp: () => (/* binding */ deleteApp),\n/* harmony export */   getApp: () => (/* binding */ getApp),\n/* harmony export */   getApps: () => (/* binding */ getApps),\n/* harmony export */   initializeApp: () => (/* binding */ initializeApp),\n/* harmony export */   initializeServerApp: () => (/* binding */ initializeServerApp),\n/* harmony export */   onLog: () => (/* binding */ onLog),\n/* harmony export */   registerVersion: () => (/* binding */ registerVersion),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! idb */ \"(ssr)/./node_modules/idb/build/index.js\");\n\n\n\n\n\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass PlatformLoggerServiceImpl {\n    constructor(container) {\n        this.container = container;\n    }\n    // In initial implementation, this will be called by installations on\n    // auth token refresh, and installations will send this string.\n    getPlatformInfoString() {\n        const providers = this.container.getProviders();\n        // Loop through providers and get library/version pairs from any that are\n        // version components.\n        return providers\n            .map(provider => {\n            if (isVersionServiceProvider(provider)) {\n                const service = provider.getImmediate();\n                return `${service.library}/${service.version}`;\n            }\n            else {\n                return null;\n            }\n        })\n            .filter(logString => logString)\n            .join(' ');\n    }\n}\n/**\n *\n * @param provider check if this provider provides a VersionService\n *\n * NOTE: Using Provider<'app-version'> is a hack to indicate that the provider\n * provides VersionService. The provider is not necessarily a 'app-version'\n * provider.\n */\nfunction isVersionServiceProvider(provider) {\n    const component = provider.getComponent();\n    return (component === null || component === void 0 ? void 0 : component.type) === \"VERSION\" /* ComponentType.VERSION */;\n}\n\nconst name$q = \"@firebase/app\";\nconst version$1 = \"0.10.17\";\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst logger = new _firebase_logger__WEBPACK_IMPORTED_MODULE_1__.Logger('@firebase/app');\n\nconst name$p = \"@firebase/app-compat\";\n\nconst name$o = \"@firebase/analytics-compat\";\n\nconst name$n = \"@firebase/analytics\";\n\nconst name$m = \"@firebase/app-check-compat\";\n\nconst name$l = \"@firebase/app-check\";\n\nconst name$k = \"@firebase/auth\";\n\nconst name$j = \"@firebase/auth-compat\";\n\nconst name$i = \"@firebase/database\";\n\nconst name$h = \"@firebase/data-connect\";\n\nconst name$g = \"@firebase/database-compat\";\n\nconst name$f = \"@firebase/functions\";\n\nconst name$e = \"@firebase/functions-compat\";\n\nconst name$d = \"@firebase/installations\";\n\nconst name$c = \"@firebase/installations-compat\";\n\nconst name$b = \"@firebase/messaging\";\n\nconst name$a = \"@firebase/messaging-compat\";\n\nconst name$9 = \"@firebase/performance\";\n\nconst name$8 = \"@firebase/performance-compat\";\n\nconst name$7 = \"@firebase/remote-config\";\n\nconst name$6 = \"@firebase/remote-config-compat\";\n\nconst name$5 = \"@firebase/storage\";\n\nconst name$4 = \"@firebase/storage-compat\";\n\nconst name$3 = \"@firebase/firestore\";\n\nconst name$2 = \"@firebase/vertexai\";\n\nconst name$1 = \"@firebase/firestore-compat\";\n\nconst name = \"firebase\";\nconst version = \"11.1.0\";\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The default app name\n *\n * @internal\n */\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\nconst PLATFORM_LOG_STRING = {\n    [name$q]: 'fire-core',\n    [name$p]: 'fire-core-compat',\n    [name$n]: 'fire-analytics',\n    [name$o]: 'fire-analytics-compat',\n    [name$l]: 'fire-app-check',\n    [name$m]: 'fire-app-check-compat',\n    [name$k]: 'fire-auth',\n    [name$j]: 'fire-auth-compat',\n    [name$i]: 'fire-rtdb',\n    [name$h]: 'fire-data-connect',\n    [name$g]: 'fire-rtdb-compat',\n    [name$f]: 'fire-fn',\n    [name$e]: 'fire-fn-compat',\n    [name$d]: 'fire-iid',\n    [name$c]: 'fire-iid-compat',\n    [name$b]: 'fire-fcm',\n    [name$a]: 'fire-fcm-compat',\n    [name$9]: 'fire-perf',\n    [name$8]: 'fire-perf-compat',\n    [name$7]: 'fire-rc',\n    [name$6]: 'fire-rc-compat',\n    [name$5]: 'fire-gcs',\n    [name$4]: 'fire-gcs-compat',\n    [name$3]: 'fire-fst',\n    [name$1]: 'fire-fst-compat',\n    [name$2]: 'fire-vertex',\n    'fire-js': 'fire-js', // Platform identifier for JS SDK.\n    [name]: 'fire-js-all'\n};\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @internal\n */\nconst _apps = new Map();\n/**\n * @internal\n */\nconst _serverApps = new Map();\n/**\n * Registered components.\n *\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst _components = new Map();\n/**\n * @param component - the component being added to this app's container\n *\n * @internal\n */\nfunction _addComponent(app, component) {\n    try {\n        app.container.addComponent(component);\n    }\n    catch (e) {\n        logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e);\n    }\n}\n/**\n *\n * @internal\n */\nfunction _addOrOverwriteComponent(app, component) {\n    app.container.addOrOverwriteComponent(component);\n}\n/**\n *\n * @param component - the component to register\n * @returns whether or not the component is registered successfully\n *\n * @internal\n */\nfunction _registerComponent(component) {\n    const componentName = component.name;\n    if (_components.has(componentName)) {\n        logger.debug(`There were multiple attempts to register component ${componentName}.`);\n        return false;\n    }\n    _components.set(componentName, component);\n    // add the component to existing app instances\n    for (const app of _apps.values()) {\n        _addComponent(app, component);\n    }\n    for (const serverApp of _serverApps.values()) {\n        _addComponent(serverApp, component);\n    }\n    return true;\n}\n/**\n *\n * @param app - FirebaseApp instance\n * @param name - service name\n *\n * @returns the provider for the service with the matching name\n *\n * @internal\n */\nfunction _getProvider(app, name) {\n    const heartbeatController = app.container\n        .getProvider('heartbeat')\n        .getImmediate({ optional: true });\n    if (heartbeatController) {\n        void heartbeatController.triggerHeartbeat();\n    }\n    return app.container.getProvider(name);\n}\n/**\n *\n * @param app - FirebaseApp instance\n * @param name - service name\n * @param instanceIdentifier - service instance identifier in case the service supports multiple instances\n *\n * @internal\n */\nfunction _removeServiceInstance(app, name, instanceIdentifier = DEFAULT_ENTRY_NAME) {\n    _getProvider(app, name).clearInstance(instanceIdentifier);\n}\n/**\n *\n * @param obj - an object of type FirebaseApp or FirebaseOptions.\n *\n * @returns true if the provide object is of type FirebaseApp.\n *\n * @internal\n */\nfunction _isFirebaseApp(obj) {\n    return obj.options !== undefined;\n}\n/**\n *\n * @param obj - an object of type FirebaseApp.\n *\n * @returns true if the provided object is of type FirebaseServerAppImpl.\n *\n * @internal\n */\nfunction _isFirebaseServerApp(obj) {\n    return obj.settings !== undefined;\n}\n/**\n * Test only\n *\n * @internal\n */\nfunction _clearComponents() {\n    _components.clear();\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst ERRORS = {\n    [\"no-app\" /* AppError.NO_APP */]: \"No Firebase App '{$appName}' has been created - \" +\n        'call initializeApp() first',\n    [\"bad-app-name\" /* AppError.BAD_APP_NAME */]: \"Illegal App name: '{$appName}'\",\n    [\"duplicate-app\" /* AppError.DUPLICATE_APP */]: \"Firebase App named '{$appName}' already exists with different options or config\",\n    [\"app-deleted\" /* AppError.APP_DELETED */]: \"Firebase App named '{$appName}' already deleted\",\n    [\"server-app-deleted\" /* AppError.SERVER_APP_DELETED */]: 'Firebase Server App has been deleted',\n    [\"no-options\" /* AppError.NO_OPTIONS */]: 'Need to provide options, when not being deployed to hosting via source.',\n    [\"invalid-app-argument\" /* AppError.INVALID_APP_ARGUMENT */]: 'firebase.{$appName}() takes either no argument or a ' +\n        'Firebase App instance.',\n    [\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */]: 'First argument to `onLog` must be null or a function.',\n    [\"idb-open\" /* AppError.IDB_OPEN */]: 'Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.',\n    [\"idb-get\" /* AppError.IDB_GET */]: 'Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.',\n    [\"idb-set\" /* AppError.IDB_WRITE */]: 'Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.',\n    [\"idb-delete\" /* AppError.IDB_DELETE */]: 'Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.',\n    [\"finalization-registry-not-supported\" /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */]: 'FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.',\n    [\"invalid-server-app-environment\" /* AppError.INVALID_SERVER_APP_ENVIRONMENT */]: 'FirebaseServerApp is not for use in browser environments.'\n};\nconst ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.ErrorFactory('app', 'Firebase', ERRORS);\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass FirebaseAppImpl {\n    constructor(options, config, container) {\n        this._isDeleted = false;\n        this._options = Object.assign({}, options);\n        this._config = Object.assign({}, config);\n        this._name = config.name;\n        this._automaticDataCollectionEnabled =\n            config.automaticDataCollectionEnabled;\n        this._container = container;\n        this.container.addComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('app', () => this, \"PUBLIC\" /* ComponentType.PUBLIC */));\n    }\n    get automaticDataCollectionEnabled() {\n        this.checkDestroyed();\n        return this._automaticDataCollectionEnabled;\n    }\n    set automaticDataCollectionEnabled(val) {\n        this.checkDestroyed();\n        this._automaticDataCollectionEnabled = val;\n    }\n    get name() {\n        this.checkDestroyed();\n        return this._name;\n    }\n    get options() {\n        this.checkDestroyed();\n        return this._options;\n    }\n    get config() {\n        this.checkDestroyed();\n        return this._config;\n    }\n    get container() {\n        return this._container;\n    }\n    get isDeleted() {\n        return this._isDeleted;\n    }\n    set isDeleted(val) {\n        this._isDeleted = val;\n    }\n    /**\n     * This function will throw an Error if the App has already been deleted -\n     * use before performing API actions on the App.\n     */\n    checkDestroyed() {\n        if (this.isDeleted) {\n            throw ERROR_FACTORY.create(\"app-deleted\" /* AppError.APP_DELETED */, { appName: this._name });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass FirebaseServerAppImpl extends FirebaseAppImpl {\n    constructor(options, serverConfig, name, container) {\n        // Build configuration parameters for the FirebaseAppImpl base class.\n        const automaticDataCollectionEnabled = serverConfig.automaticDataCollectionEnabled !== undefined\n            ? serverConfig.automaticDataCollectionEnabled\n            : false;\n        // Create the FirebaseAppSettings object for the FirebaseAppImp constructor.\n        const config = {\n            name,\n            automaticDataCollectionEnabled\n        };\n        if (options.apiKey !== undefined) {\n            // Construct the parent FirebaseAppImp object.\n            super(options, config, container);\n        }\n        else {\n            const appImpl = options;\n            super(appImpl.options, config, container);\n        }\n        // Now construct the data for the FirebaseServerAppImpl.\n        this._serverConfig = Object.assign({ automaticDataCollectionEnabled }, serverConfig);\n        this._finalizationRegistry = null;\n        if (typeof FinalizationRegistry !== 'undefined') {\n            this._finalizationRegistry = new FinalizationRegistry(() => {\n                this.automaticCleanup();\n            });\n        }\n        this._refCount = 0;\n        this.incRefCount(this._serverConfig.releaseOnDeref);\n        // Do not retain a hard reference to the dref object, otherwise the FinalizationRegistry\n        // will never trigger.\n        this._serverConfig.releaseOnDeref = undefined;\n        serverConfig.releaseOnDeref = undefined;\n        registerVersion(name$q, version$1, 'serverapp');\n    }\n    toJSON() {\n        return undefined;\n    }\n    get refCount() {\n        return this._refCount;\n    }\n    // Increment the reference count of this server app. If an object is provided, register it\n    // with the finalization registry.\n    incRefCount(obj) {\n        if (this.isDeleted) {\n            return;\n        }\n        this._refCount++;\n        if (obj !== undefined && this._finalizationRegistry !== null) {\n            this._finalizationRegistry.register(obj, this);\n        }\n    }\n    // Decrement the reference count.\n    decRefCount() {\n        if (this.isDeleted) {\n            return 0;\n        }\n        return --this._refCount;\n    }\n    // Invoked by the FinalizationRegistry callback to note that this app should go through its\n    // reference counts and delete itself if no reference count remain. The coordinating logic that\n    // handles this is in deleteApp(...).\n    automaticCleanup() {\n        void deleteApp(this);\n    }\n    get settings() {\n        this.checkDestroyed();\n        return this._serverConfig;\n    }\n    /**\n     * This function will throw an Error if the App has already been deleted -\n     * use before performing API actions on the App.\n     */\n    checkDestroyed() {\n        if (this.isDeleted) {\n            throw ERROR_FACTORY.create(\"server-app-deleted\" /* AppError.SERVER_APP_DELETED */);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The current SDK version.\n *\n * @public\n */\nconst SDK_VERSION = version;\nfunction initializeApp(_options, rawConfig = {}) {\n    let options = _options;\n    if (typeof rawConfig !== 'object') {\n        const name = rawConfig;\n        rawConfig = { name };\n    }\n    const config = Object.assign({ name: DEFAULT_ENTRY_NAME, automaticDataCollectionEnabled: false }, rawConfig);\n    const name = config.name;\n    if (typeof name !== 'string' || !name) {\n        throw ERROR_FACTORY.create(\"bad-app-name\" /* AppError.BAD_APP_NAME */, {\n            appName: String(name)\n        });\n    }\n    options || (options = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getDefaultAppConfig)());\n    if (!options) {\n        throw ERROR_FACTORY.create(\"no-options\" /* AppError.NO_OPTIONS */);\n    }\n    const existingApp = _apps.get(name);\n    if (existingApp) {\n        // return the existing app if options and config deep equal the ones in the existing app.\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(options, existingApp.options) &&\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(config, existingApp.config)) {\n            return existingApp;\n        }\n        else {\n            throw ERROR_FACTORY.create(\"duplicate-app\" /* AppError.DUPLICATE_APP */, { appName: name });\n        }\n    }\n    const container = new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.ComponentContainer(name);\n    for (const component of _components.values()) {\n        container.addComponent(component);\n    }\n    const newApp = new FirebaseAppImpl(options, config, container);\n    _apps.set(name, newApp);\n    return newApp;\n}\nfunction initializeServerApp(_options, _serverAppConfig) {\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isBrowser)() && !(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isWebWorker)()) {\n        // FirebaseServerApp isn't designed to be run in browsers.\n        throw ERROR_FACTORY.create(\"invalid-server-app-environment\" /* AppError.INVALID_SERVER_APP_ENVIRONMENT */);\n    }\n    if (_serverAppConfig.automaticDataCollectionEnabled === undefined) {\n        _serverAppConfig.automaticDataCollectionEnabled = false;\n    }\n    let appOptions;\n    if (_isFirebaseApp(_options)) {\n        appOptions = _options.options;\n    }\n    else {\n        appOptions = _options;\n    }\n    // Build an app name based on a hash of the configuration options.\n    const nameObj = Object.assign(Object.assign({}, _serverAppConfig), appOptions);\n    // However, Do not mangle the name based on releaseOnDeref, since it will vary between the\n    // construction of FirebaseServerApp instances. For example, if the object is the request headers.\n    if (nameObj.releaseOnDeref !== undefined) {\n        delete nameObj.releaseOnDeref;\n    }\n    const hashCode = (s) => {\n        return [...s].reduce((hash, c) => (Math.imul(31, hash) + c.charCodeAt(0)) | 0, 0);\n    };\n    if (_serverAppConfig.releaseOnDeref !== undefined) {\n        if (typeof FinalizationRegistry === 'undefined') {\n            throw ERROR_FACTORY.create(\"finalization-registry-not-supported\" /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */, {});\n        }\n    }\n    const nameString = '' + hashCode(JSON.stringify(nameObj));\n    const existingApp = _serverApps.get(nameString);\n    if (existingApp) {\n        existingApp.incRefCount(_serverAppConfig.releaseOnDeref);\n        return existingApp;\n    }\n    const container = new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.ComponentContainer(nameString);\n    for (const component of _components.values()) {\n        container.addComponent(component);\n    }\n    const newApp = new FirebaseServerAppImpl(appOptions, _serverAppConfig, nameString, container);\n    _serverApps.set(nameString, newApp);\n    return newApp;\n}\n/**\n * Retrieves a {@link @firebase/app#FirebaseApp} instance.\n *\n * When called with no arguments, the default app is returned. When an app name\n * is provided, the app corresponding to that name is returned.\n *\n * An exception is thrown if the app being retrieved has not yet been\n * initialized.\n *\n * @example\n * ```javascript\n * // Return the default app\n * const app = getApp();\n * ```\n *\n * @example\n * ```javascript\n * // Return a named app\n * const otherApp = getApp(\"otherApp\");\n * ```\n *\n * @param name - Optional name of the app to return. If no name is\n *   provided, the default is `\"[DEFAULT]\"`.\n *\n * @returns The app corresponding to the provided app name.\n *   If no app name is provided, the default app is returned.\n *\n * @public\n */\nfunction getApp(name = DEFAULT_ENTRY_NAME) {\n    const app = _apps.get(name);\n    if (!app && name === DEFAULT_ENTRY_NAME && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getDefaultAppConfig)()) {\n        return initializeApp();\n    }\n    if (!app) {\n        throw ERROR_FACTORY.create(\"no-app\" /* AppError.NO_APP */, { appName: name });\n    }\n    return app;\n}\n/**\n * A (read-only) array of all initialized apps.\n * @public\n */\nfunction getApps() {\n    return Array.from(_apps.values());\n}\n/**\n * Renders this app unusable and frees the resources of all associated\n * services.\n *\n * @example\n * ```javascript\n * deleteApp(app)\n *   .then(function() {\n *     console.log(\"App deleted successfully\");\n *   })\n *   .catch(function(error) {\n *     console.log(\"Error deleting app:\", error);\n *   });\n * ```\n *\n * @public\n */\nasync function deleteApp(app) {\n    let cleanupProviders = false;\n    const name = app.name;\n    if (_apps.has(name)) {\n        cleanupProviders = true;\n        _apps.delete(name);\n    }\n    else if (_serverApps.has(name)) {\n        const firebaseServerApp = app;\n        if (firebaseServerApp.decRefCount() <= 0) {\n            _serverApps.delete(name);\n            cleanupProviders = true;\n        }\n    }\n    if (cleanupProviders) {\n        await Promise.all(app.container\n            .getProviders()\n            .map(provider => provider.delete()));\n        app.isDeleted = true;\n    }\n}\n/**\n * Registers a library's name and version for platform logging purposes.\n * @param library - Name of 1p or 3p library (e.g. firestore, angularfire)\n * @param version - Current version of that library.\n * @param variant - Bundle variant, e.g., node, rn, etc.\n *\n * @public\n */\nfunction registerVersion(libraryKeyOrName, version, variant) {\n    var _a;\n    // TODO: We can use this check to whitelist strings when/if we set up\n    // a good whitelist system.\n    let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;\n    if (variant) {\n        library += `-${variant}`;\n    }\n    const libraryMismatch = library.match(/\\s|\\//);\n    const versionMismatch = version.match(/\\s|\\//);\n    if (libraryMismatch || versionMismatch) {\n        const warning = [\n            `Unable to register library \"${library}\" with version \"${version}\":`\n        ];\n        if (libraryMismatch) {\n            warning.push(`library name \"${library}\" contains illegal characters (whitespace or \"/\")`);\n        }\n        if (libraryMismatch && versionMismatch) {\n            warning.push('and');\n        }\n        if (versionMismatch) {\n            warning.push(`version name \"${version}\" contains illegal characters (whitespace or \"/\")`);\n        }\n        logger.warn(warning.join(' '));\n        return;\n    }\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(`${library}-version`, () => ({ library, version }), \"VERSION\" /* ComponentType.VERSION */));\n}\n/**\n * Sets log handler for all Firebase SDKs.\n * @param logCallback - An optional custom log handler that executes user code whenever\n * the Firebase SDK makes a logging call.\n *\n * @public\n */\nfunction onLog(logCallback, options) {\n    if (logCallback !== null && typeof logCallback !== 'function') {\n        throw ERROR_FACTORY.create(\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */);\n    }\n    (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setUserLogHandler)(logCallback, options);\n}\n/**\n * Sets log level for all Firebase SDKs.\n *\n * All of the log types above the current log level are captured (i.e. if\n * you set the log level to `info`, errors are logged, but `debug` and\n * `verbose` logs are not).\n *\n * @public\n */\nfunction setLogLevel(logLevel) {\n    (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setLogLevel)(logLevel);\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DB_NAME = 'firebase-heartbeat-database';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'firebase-heartbeat-store';\nlet dbPromise = null;\nfunction getDbPromise() {\n    if (!dbPromise) {\n        dbPromise = (0,idb__WEBPACK_IMPORTED_MODULE_3__.openDB)(DB_NAME, DB_VERSION, {\n            upgrade: (db, oldVersion) => {\n                // We don't use 'break' in this switch statement, the fall-through\n                // behavior is what we want, because if there are multiple versions between\n                // the old version and the current version, we want ALL the migrations\n                // that correspond to those versions to run, not only the last one.\n                // eslint-disable-next-line default-case\n                switch (oldVersion) {\n                    case 0:\n                        try {\n                            db.createObjectStore(STORE_NAME);\n                        }\n                        catch (e) {\n                            // Safari/iOS browsers throw occasional exceptions on\n                            // db.createObjectStore() that may be a bug. Avoid blocking\n                            // the rest of the app functionality.\n                            console.warn(e);\n                        }\n                }\n            }\n        }).catch(e => {\n            throw ERROR_FACTORY.create(\"idb-open\" /* AppError.IDB_OPEN */, {\n                originalErrorMessage: e.message\n            });\n        });\n    }\n    return dbPromise;\n}\nasync function readHeartbeatsFromIndexedDB(app) {\n    try {\n        const db = await getDbPromise();\n        const tx = db.transaction(STORE_NAME);\n        const result = await tx.objectStore(STORE_NAME).get(computeKey(app));\n        // We already have the value but tx.done can throw,\n        // so we need to await it here to catch errors\n        await tx.done;\n        return result;\n    }\n    catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) {\n            logger.warn(e.message);\n        }\n        else {\n            const idbGetError = ERROR_FACTORY.create(\"idb-get\" /* AppError.IDB_GET */, {\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n            });\n            logger.warn(idbGetError.message);\n        }\n    }\n}\nasync function writeHeartbeatsToIndexedDB(app, heartbeatObject) {\n    try {\n        const db = await getDbPromise();\n        const tx = db.transaction(STORE_NAME, 'readwrite');\n        const objectStore = tx.objectStore(STORE_NAME);\n        await objectStore.put(heartbeatObject, computeKey(app));\n        await tx.done;\n    }\n    catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) {\n            logger.warn(e.message);\n        }\n        else {\n            const idbGetError = ERROR_FACTORY.create(\"idb-set\" /* AppError.IDB_WRITE */, {\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n            });\n            logger.warn(idbGetError.message);\n        }\n    }\n}\nfunction computeKey(app) {\n    return `${app.name}!${app.options.appId}`;\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst MAX_HEADER_BYTES = 1024;\n// 30 days\nconst STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1000;\nclass HeartbeatServiceImpl {\n    constructor(container) {\n        this.container = container;\n        /**\n         * In-memory cache for heartbeats, used by getHeartbeatsHeader() to generate\n         * the header string.\n         * Stores one record per date. This will be consolidated into the standard\n         * format of one record per user agent string before being sent as a header.\n         * Populated from indexedDB when the controller is instantiated and should\n         * be kept in sync with indexedDB.\n         * Leave public for easier testing.\n         */\n        this._heartbeatsCache = null;\n        const app = this.container.getProvider('app').getImmediate();\n        this._storage = new HeartbeatStorageImpl(app);\n        this._heartbeatsCachePromise = this._storage.read().then(result => {\n            this._heartbeatsCache = result;\n            return result;\n        });\n    }\n    /**\n     * Called to report a heartbeat. The function will generate\n     * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it\n     * to IndexedDB.\n     * Note that we only store one heartbeat per day. So if a heartbeat for today is\n     * already logged, subsequent calls to this function in the same day will be ignored.\n     */\n    async triggerHeartbeat() {\n        var _a, _b;\n        try {\n            const platformLogger = this.container\n                .getProvider('platform-logger')\n                .getImmediate();\n            // This is the \"Firebase user agent\" string from the platform logger\n            // service, not the browser user agent.\n            const agent = platformLogger.getPlatformInfoString();\n            const date = getUTCDateString();\n            if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null) {\n                this._heartbeatsCache = await this._heartbeatsCachePromise;\n                // If we failed to construct a heartbeats cache, then return immediately.\n                if (((_b = this._heartbeatsCache) === null || _b === void 0 ? void 0 : _b.heartbeats) == null) {\n                    return;\n                }\n            }\n            // Do not store a heartbeat if one is already stored for this day\n            // or if a header has already been sent today.\n            if (this._heartbeatsCache.lastSentHeartbeatDate === date ||\n                this._heartbeatsCache.heartbeats.some(singleDateHeartbeat => singleDateHeartbeat.date === date)) {\n                return;\n            }\n            else {\n                // There is no entry for this date. Create one.\n                this._heartbeatsCache.heartbeats.push({ date, agent });\n            }\n            // Remove entries older than 30 days.\n            this._heartbeatsCache.heartbeats =\n                this._heartbeatsCache.heartbeats.filter(singleDateHeartbeat => {\n                    const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();\n                    const now = Date.now();\n                    return now - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;\n                });\n            return this._storage.overwrite(this._heartbeatsCache);\n        }\n        catch (e) {\n            logger.warn(e);\n        }\n    }\n    /**\n     * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.\n     * It also clears all heartbeats from memory as well as in IndexedDB.\n     *\n     * NOTE: Consuming product SDKs should not send the header if this method\n     * returns an empty string.\n     */\n    async getHeartbeatsHeader() {\n        var _a;\n        try {\n            if (this._heartbeatsCache === null) {\n                await this._heartbeatsCachePromise;\n            }\n            // If it's still null or the array is empty, there is no data to send.\n            if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null ||\n                this._heartbeatsCache.heartbeats.length === 0) {\n                return '';\n            }\n            const date = getUTCDateString();\n            // Extract as many heartbeats from the cache as will fit under the size limit.\n            const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);\n            const headerString = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64urlEncodeWithoutPadding)(JSON.stringify({ version: 2, heartbeats: heartbeatsToSend }));\n            // Store last sent date to prevent another being logged/sent for the same day.\n            this._heartbeatsCache.lastSentHeartbeatDate = date;\n            if (unsentEntries.length > 0) {\n                // Store any unsent entries if they exist.\n                this._heartbeatsCache.heartbeats = unsentEntries;\n                // This seems more likely than emptying the array (below) to lead to some odd state\n                // since the cache isn't empty and this will be called again on the next request,\n                // and is probably safest if we await it.\n                await this._storage.overwrite(this._heartbeatsCache);\n            }\n            else {\n                this._heartbeatsCache.heartbeats = [];\n                // Do not wait for this, to reduce latency.\n                void this._storage.overwrite(this._heartbeatsCache);\n            }\n            return headerString;\n        }\n        catch (e) {\n            logger.warn(e);\n            return '';\n        }\n    }\n}\nfunction getUTCDateString() {\n    const today = new Date();\n    // Returns date format 'YYYY-MM-DD'\n    return today.toISOString().substring(0, 10);\n}\nfunction extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {\n    // Heartbeats grouped by user agent in the standard format to be sent in\n    // the header.\n    const heartbeatsToSend = [];\n    // Single date format heartbeats that are not sent.\n    let unsentEntries = heartbeatsCache.slice();\n    for (const singleDateHeartbeat of heartbeatsCache) {\n        // Look for an existing entry with the same user agent.\n        const heartbeatEntry = heartbeatsToSend.find(hb => hb.agent === singleDateHeartbeat.agent);\n        if (!heartbeatEntry) {\n            // If no entry for this user agent exists, create one.\n            heartbeatsToSend.push({\n                agent: singleDateHeartbeat.agent,\n                dates: [singleDateHeartbeat.date]\n            });\n            if (countBytes(heartbeatsToSend) > maxSize) {\n                // If the header would exceed max size, remove the added heartbeat\n                // entry and stop adding to the header.\n                heartbeatsToSend.pop();\n                break;\n            }\n        }\n        else {\n            heartbeatEntry.dates.push(singleDateHeartbeat.date);\n            // If the header would exceed max size, remove the added date\n            // and stop adding to the header.\n            if (countBytes(heartbeatsToSend) > maxSize) {\n                heartbeatEntry.dates.pop();\n                break;\n            }\n        }\n        // Pop unsent entry from queue. (Skipped if adding the entry exceeded\n        // quota and the loop breaks early.)\n        unsentEntries = unsentEntries.slice(1);\n    }\n    return {\n        heartbeatsToSend,\n        unsentEntries\n    };\n}\nclass HeartbeatStorageImpl {\n    constructor(app) {\n        this.app = app;\n        this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();\n    }\n    async runIndexedDBEnvironmentCheck() {\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isIndexedDBAvailable)()) {\n            return false;\n        }\n        else {\n            return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateIndexedDBOpenable)()\n                .then(() => true)\n                .catch(() => false);\n        }\n    }\n    /**\n     * Read all heartbeats.\n     */\n    async read() {\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return { heartbeats: [] };\n        }\n        else {\n            const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);\n            if (idbHeartbeatObject === null || idbHeartbeatObject === void 0 ? void 0 : idbHeartbeatObject.heartbeats) {\n                return idbHeartbeatObject;\n            }\n            else {\n                return { heartbeats: [] };\n            }\n        }\n    }\n    // overwrite the storage with the provided heartbeats\n    async overwrite(heartbeatsObject) {\n        var _a;\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return;\n        }\n        else {\n            const existingHeartbeatsObject = await this.read();\n            return writeHeartbeatsToIndexedDB(this.app, {\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\n                heartbeats: heartbeatsObject.heartbeats\n            });\n        }\n    }\n    // add heartbeats\n    async add(heartbeatsObject) {\n        var _a;\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return;\n        }\n        else {\n            const existingHeartbeatsObject = await this.read();\n            return writeHeartbeatsToIndexedDB(this.app, {\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\n                heartbeats: [\n                    ...existingHeartbeatsObject.heartbeats,\n                    ...heartbeatsObject.heartbeats\n                ]\n            });\n        }\n    }\n}\n/**\n * Calculate bytes of a HeartbeatsByUserAgent array after being wrapped\n * in a platform logging header JSON object, stringified, and converted\n * to base 64.\n */\nfunction countBytes(heartbeatsCache) {\n    // base64 has a restricted set of characters, all of which should be 1 byte.\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64urlEncodeWithoutPadding)(\n    // heartbeatsCache wrapper properties\n    JSON.stringify({ version: 2, heartbeats: heartbeatsCache })).length;\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction registerCoreComponents(variant) {\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('platform-logger', container => new PlatformLoggerServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */));\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('heartbeat', container => new HeartbeatServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */));\n    // Register `app` package.\n    registerVersion(name$q, version$1, variant);\n    // BUILD_TARGET will be replaced by values like esm2017, cjs2017, etc during the compilation\n    registerVersion(name$q, version$1, 'esm2017');\n    // Register platform SDK identifier (no version).\n    registerVersion('fire-js', '');\n}\n\n/**\n * Firebase App\n *\n * @remarks This package coordinates the communication between the different Firebase components\n * @packageDocumentation\n */\nregisterCoreComponents('');\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9FO0FBQ3VCO0FBQzBHO0FBQ3RKO0FBQ2xCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCLEdBQUcsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0RBQU07O0FBRXpCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnQkFBZ0Isc0NBQXNDLFNBQVM7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsY0FBYztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsU0FBUztBQUNsRTtBQUNBLHVFQUF1RSxTQUFTO0FBQ2hGLDBFQUEwRSxTQUFTO0FBQ25GLHNFQUFzRSxTQUFTO0FBQy9FO0FBQ0E7QUFDQSw2RUFBNkUsU0FBUztBQUN0RjtBQUNBO0FBQ0EsaUdBQWlHLHNCQUFzQjtBQUN2SCxvR0FBb0csc0JBQXNCO0FBQzFILG9HQUFvRyxzQkFBc0I7QUFDMUgsMkdBQTJHLHNCQUFzQjtBQUNqSTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0RBQVk7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywwREFBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYscUJBQXFCO0FBQ3hHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0NBQWdDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsbUNBQW1DLGlFQUFpRTtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDBCQUEwQixtRUFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBUztBQUNyQixZQUFZLHlEQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixlQUFlO0FBQ3RHO0FBQ0E7QUFDQSwwQkFBMEIsbUVBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlEQUFTLE9BQU8sMkRBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1JQUFtSTtBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1FQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlDQUFpQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG1FQUFtQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsZUFBZTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUSxrQkFBa0IsUUFBUTtBQUM3RTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBEQUFTLElBQUksUUFBUSxvQkFBb0Isa0JBQWtCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbUVBQWlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZEQUFhO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJDQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseURBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix5REFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVMsR0FBRyxrQkFBa0I7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGFBQWE7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQ0FBa0M7QUFDdEQsaUNBQWlDLDZFQUE2QixrQkFBa0IsMENBQTBDO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0VBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5RUFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZFQUE2QjtBQUN4QztBQUNBLHFCQUFxQix5Q0FBeUM7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwREFBUztBQUNwQywyQkFBMkIsMERBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1XO0FBQ25XIiwic291cmNlcyI6WyIvVXNlcnMvdnRwYXRlbDA3L1BhdGVsQ01QMjMzRmluYWxQcm9qZWN0L25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXBwL2Rpc3QvZXNtL2luZGV4LmVzbTIwMTcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBDb21wb25lbnRDb250YWluZXIgfSBmcm9tICdAZmlyZWJhc2UvY29tcG9uZW50JztcbmltcG9ydCB7IExvZ2dlciwgc2V0VXNlckxvZ0hhbmRsZXIsIHNldExvZ0xldmVsIGFzIHNldExvZ0xldmVsJDEgfSBmcm9tICdAZmlyZWJhc2UvbG9nZ2VyJztcbmltcG9ydCB7IEVycm9yRmFjdG9yeSwgZ2V0RGVmYXVsdEFwcENvbmZpZywgZGVlcEVxdWFsLCBpc0Jyb3dzZXIsIGlzV2ViV29ya2VyLCBGaXJlYmFzZUVycm9yLCBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZywgaXNJbmRleGVkREJBdmFpbGFibGUsIHZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5leHBvcnQgeyBGaXJlYmFzZUVycm9yIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgb3BlbkRCIH0gZnJvbSAnaWRiJztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIFBsYXRmb3JtTG9nZ2VyU2VydmljZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9XG4gICAgLy8gSW4gaW5pdGlhbCBpbXBsZW1lbnRhdGlvbiwgdGhpcyB3aWxsIGJlIGNhbGxlZCBieSBpbnN0YWxsYXRpb25zIG9uXG4gICAgLy8gYXV0aCB0b2tlbiByZWZyZXNoLCBhbmQgaW5zdGFsbGF0aW9ucyB3aWxsIHNlbmQgdGhpcyBzdHJpbmcuXG4gICAgZ2V0UGxhdGZvcm1JbmZvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBwcm92aWRlcnMgPSB0aGlzLmNvbnRhaW5lci5nZXRQcm92aWRlcnMoKTtcbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIHByb3ZpZGVycyBhbmQgZ2V0IGxpYnJhcnkvdmVyc2lvbiBwYWlycyBmcm9tIGFueSB0aGF0IGFyZVxuICAgICAgICAvLyB2ZXJzaW9uIGNvbXBvbmVudHMuXG4gICAgICAgIHJldHVybiBwcm92aWRlcnNcbiAgICAgICAgICAgIC5tYXAocHJvdmlkZXIgPT4ge1xuICAgICAgICAgICAgaWYgKGlzVmVyc2lvblNlcnZpY2VQcm92aWRlcihwcm92aWRlcikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2aWNlID0gcHJvdmlkZXIuZ2V0SW1tZWRpYXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3NlcnZpY2UubGlicmFyeX0vJHtzZXJ2aWNlLnZlcnNpb259YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihsb2dTdHJpbmcgPT4gbG9nU3RyaW5nKVxuICAgICAgICAgICAgLmpvaW4oJyAnKTtcbiAgICB9XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gcHJvdmlkZXIgY2hlY2sgaWYgdGhpcyBwcm92aWRlciBwcm92aWRlcyBhIFZlcnNpb25TZXJ2aWNlXG4gKlxuICogTk9URTogVXNpbmcgUHJvdmlkZXI8J2FwcC12ZXJzaW9uJz4gaXMgYSBoYWNrIHRvIGluZGljYXRlIHRoYXQgdGhlIHByb3ZpZGVyXG4gKiBwcm92aWRlcyBWZXJzaW9uU2VydmljZS4gVGhlIHByb3ZpZGVyIGlzIG5vdCBuZWNlc3NhcmlseSBhICdhcHAtdmVyc2lvbidcbiAqIHByb3ZpZGVyLlxuICovXG5mdW5jdGlvbiBpc1ZlcnNpb25TZXJ2aWNlUHJvdmlkZXIocHJvdmlkZXIpIHtcbiAgICBjb25zdCBjb21wb25lbnQgPSBwcm92aWRlci5nZXRDb21wb25lbnQoKTtcbiAgICByZXR1cm4gKGNvbXBvbmVudCA9PT0gbnVsbCB8fCBjb21wb25lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbXBvbmVudC50eXBlKSA9PT0gXCJWRVJTSU9OXCIgLyogQ29tcG9uZW50VHlwZS5WRVJTSU9OICovO1xufVxuXG5jb25zdCBuYW1lJHEgPSBcIkBmaXJlYmFzZS9hcHBcIjtcbmNvbnN0IHZlcnNpb24kMSA9IFwiMC4xMC4xN1wiO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcignQGZpcmViYXNlL2FwcCcpO1xuXG5jb25zdCBuYW1lJHAgPSBcIkBmaXJlYmFzZS9hcHAtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkbyA9IFwiQGZpcmViYXNlL2FuYWx5dGljcy1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRuID0gXCJAZmlyZWJhc2UvYW5hbHl0aWNzXCI7XG5cbmNvbnN0IG5hbWUkbSA9IFwiQGZpcmViYXNlL2FwcC1jaGVjay1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRsID0gXCJAZmlyZWJhc2UvYXBwLWNoZWNrXCI7XG5cbmNvbnN0IG5hbWUkayA9IFwiQGZpcmViYXNlL2F1dGhcIjtcblxuY29uc3QgbmFtZSRqID0gXCJAZmlyZWJhc2UvYXV0aC1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRpID0gXCJAZmlyZWJhc2UvZGF0YWJhc2VcIjtcblxuY29uc3QgbmFtZSRoID0gXCJAZmlyZWJhc2UvZGF0YS1jb25uZWN0XCI7XG5cbmNvbnN0IG5hbWUkZyA9IFwiQGZpcmViYXNlL2RhdGFiYXNlLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGYgPSBcIkBmaXJlYmFzZS9mdW5jdGlvbnNcIjtcblxuY29uc3QgbmFtZSRlID0gXCJAZmlyZWJhc2UvZnVuY3Rpb25zLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGQgPSBcIkBmaXJlYmFzZS9pbnN0YWxsYXRpb25zXCI7XG5cbmNvbnN0IG5hbWUkYyA9IFwiQGZpcmViYXNlL2luc3RhbGxhdGlvbnMtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkYiA9IFwiQGZpcmViYXNlL21lc3NhZ2luZ1wiO1xuXG5jb25zdCBuYW1lJGEgPSBcIkBmaXJlYmFzZS9tZXNzYWdpbmctY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkOSA9IFwiQGZpcmViYXNlL3BlcmZvcm1hbmNlXCI7XG5cbmNvbnN0IG5hbWUkOCA9IFwiQGZpcmViYXNlL3BlcmZvcm1hbmNlLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJDcgPSBcIkBmaXJlYmFzZS9yZW1vdGUtY29uZmlnXCI7XG5cbmNvbnN0IG5hbWUkNiA9IFwiQGZpcmViYXNlL3JlbW90ZS1jb25maWctY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkNSA9IFwiQGZpcmViYXNlL3N0b3JhZ2VcIjtcblxuY29uc3QgbmFtZSQ0ID0gXCJAZmlyZWJhc2Uvc3RvcmFnZS1jb21wYXRcIjtcblxuY29uc3QgbmFtZSQzID0gXCJAZmlyZWJhc2UvZmlyZXN0b3JlXCI7XG5cbmNvbnN0IG5hbWUkMiA9IFwiQGZpcmViYXNlL3ZlcnRleGFpXCI7XG5cbmNvbnN0IG5hbWUkMSA9IFwiQGZpcmViYXNlL2ZpcmVzdG9yZS1jb21wYXRcIjtcblxuY29uc3QgbmFtZSA9IFwiZmlyZWJhc2VcIjtcbmNvbnN0IHZlcnNpb24gPSBcIjExLjEuMFwiO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBhcHAgbmFtZVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBERUZBVUxUX0VOVFJZX05BTUUgPSAnW0RFRkFVTFRdJztcbmNvbnN0IFBMQVRGT1JNX0xPR19TVFJJTkcgPSB7XG4gICAgW25hbWUkcV06ICdmaXJlLWNvcmUnLFxuICAgIFtuYW1lJHBdOiAnZmlyZS1jb3JlLWNvbXBhdCcsXG4gICAgW25hbWUkbl06ICdmaXJlLWFuYWx5dGljcycsXG4gICAgW25hbWUkb106ICdmaXJlLWFuYWx5dGljcy1jb21wYXQnLFxuICAgIFtuYW1lJGxdOiAnZmlyZS1hcHAtY2hlY2snLFxuICAgIFtuYW1lJG1dOiAnZmlyZS1hcHAtY2hlY2stY29tcGF0JyxcbiAgICBbbmFtZSRrXTogJ2ZpcmUtYXV0aCcsXG4gICAgW25hbWUkal06ICdmaXJlLWF1dGgtY29tcGF0JyxcbiAgICBbbmFtZSRpXTogJ2ZpcmUtcnRkYicsXG4gICAgW25hbWUkaF06ICdmaXJlLWRhdGEtY29ubmVjdCcsXG4gICAgW25hbWUkZ106ICdmaXJlLXJ0ZGItY29tcGF0JyxcbiAgICBbbmFtZSRmXTogJ2ZpcmUtZm4nLFxuICAgIFtuYW1lJGVdOiAnZmlyZS1mbi1jb21wYXQnLFxuICAgIFtuYW1lJGRdOiAnZmlyZS1paWQnLFxuICAgIFtuYW1lJGNdOiAnZmlyZS1paWQtY29tcGF0JyxcbiAgICBbbmFtZSRiXTogJ2ZpcmUtZmNtJyxcbiAgICBbbmFtZSRhXTogJ2ZpcmUtZmNtLWNvbXBhdCcsXG4gICAgW25hbWUkOV06ICdmaXJlLXBlcmYnLFxuICAgIFtuYW1lJDhdOiAnZmlyZS1wZXJmLWNvbXBhdCcsXG4gICAgW25hbWUkN106ICdmaXJlLXJjJyxcbiAgICBbbmFtZSQ2XTogJ2ZpcmUtcmMtY29tcGF0JyxcbiAgICBbbmFtZSQ1XTogJ2ZpcmUtZ2NzJyxcbiAgICBbbmFtZSQ0XTogJ2ZpcmUtZ2NzLWNvbXBhdCcsXG4gICAgW25hbWUkM106ICdmaXJlLWZzdCcsXG4gICAgW25hbWUkMV06ICdmaXJlLWZzdC1jb21wYXQnLFxuICAgIFtuYW1lJDJdOiAnZmlyZS12ZXJ0ZXgnLFxuICAgICdmaXJlLWpzJzogJ2ZpcmUtanMnLCAvLyBQbGF0Zm9ybSBpZGVudGlmaWVyIGZvciBKUyBTREsuXG4gICAgW25hbWVdOiAnZmlyZS1qcy1hbGwnXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgX2FwcHMgPSBuZXcgTWFwKCk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBfc2VydmVyQXBwcyA9IG5ldyBNYXAoKTtcbi8qKlxuICogUmVnaXN0ZXJlZCBjb21wb25lbnRzLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgX2NvbXBvbmVudHMgPSBuZXcgTWFwKCk7XG4vKipcbiAqIEBwYXJhbSBjb21wb25lbnQgLSB0aGUgY29tcG9uZW50IGJlaW5nIGFkZGVkIHRvIHRoaXMgYXBwJ3MgY29udGFpbmVyXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIF9hZGRDb21wb25lbnQoYXBwLCBjb21wb25lbnQpIHtcbiAgICB0cnkge1xuICAgICAgICBhcHAuY29udGFpbmVyLmFkZENvbXBvbmVudChjb21wb25lbnQpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoYENvbXBvbmVudCAke2NvbXBvbmVudC5uYW1lfSBmYWlsZWQgdG8gcmVnaXN0ZXIgd2l0aCBGaXJlYmFzZUFwcCAke2FwcC5uYW1lfWAsIGUpO1xuICAgIH1cbn1cbi8qKlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBfYWRkT3JPdmVyd3JpdGVDb21wb25lbnQoYXBwLCBjb21wb25lbnQpIHtcbiAgICBhcHAuY29udGFpbmVyLmFkZE9yT3ZlcndyaXRlQ29tcG9uZW50KGNvbXBvbmVudCk7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gY29tcG9uZW50IC0gdGhlIGNvbXBvbmVudCB0byByZWdpc3RlclxuICogQHJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGNvbXBvbmVudCBpcyByZWdpc3RlcmVkIHN1Y2Nlc3NmdWxseVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBfcmVnaXN0ZXJDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5uYW1lO1xuICAgIGlmIChfY29tcG9uZW50cy5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBUaGVyZSB3ZXJlIG11bHRpcGxlIGF0dGVtcHRzIHRvIHJlZ2lzdGVyIGNvbXBvbmVudCAke2NvbXBvbmVudE5hbWV9LmApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF9jb21wb25lbnRzLnNldChjb21wb25lbnROYW1lLCBjb21wb25lbnQpO1xuICAgIC8vIGFkZCB0aGUgY29tcG9uZW50IHRvIGV4aXN0aW5nIGFwcCBpbnN0YW5jZXNcbiAgICBmb3IgKGNvbnN0IGFwcCBvZiBfYXBwcy52YWx1ZXMoKSkge1xuICAgICAgICBfYWRkQ29tcG9uZW50KGFwcCwgY29tcG9uZW50KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBzZXJ2ZXJBcHAgb2YgX3NlcnZlckFwcHMudmFsdWVzKCkpIHtcbiAgICAgICAgX2FkZENvbXBvbmVudChzZXJ2ZXJBcHAsIGNvbXBvbmVudCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIGFwcCAtIEZpcmViYXNlQXBwIGluc3RhbmNlXG4gKiBAcGFyYW0gbmFtZSAtIHNlcnZpY2UgbmFtZVxuICpcbiAqIEByZXR1cm5zIHRoZSBwcm92aWRlciBmb3IgdGhlIHNlcnZpY2Ugd2l0aCB0aGUgbWF0Y2hpbmcgbmFtZVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBfZ2V0UHJvdmlkZXIoYXBwLCBuYW1lKSB7XG4gICAgY29uc3QgaGVhcnRiZWF0Q29udHJvbGxlciA9IGFwcC5jb250YWluZXJcbiAgICAgICAgLmdldFByb3ZpZGVyKCdoZWFydGJlYXQnKVxuICAgICAgICAuZ2V0SW1tZWRpYXRlKHsgb3B0aW9uYWw6IHRydWUgfSk7XG4gICAgaWYgKGhlYXJ0YmVhdENvbnRyb2xsZXIpIHtcbiAgICAgICAgdm9pZCBoZWFydGJlYXRDb250cm9sbGVyLnRyaWdnZXJIZWFydGJlYXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGFwcC5jb250YWluZXIuZ2V0UHJvdmlkZXIobmFtZSk7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gYXBwIC0gRmlyZWJhc2VBcHAgaW5zdGFuY2VcbiAqIEBwYXJhbSBuYW1lIC0gc2VydmljZSBuYW1lXG4gKiBAcGFyYW0gaW5zdGFuY2VJZGVudGlmaWVyIC0gc2VydmljZSBpbnN0YW5jZSBpZGVudGlmaWVyIGluIGNhc2UgdGhlIHNlcnZpY2Ugc3VwcG9ydHMgbXVsdGlwbGUgaW5zdGFuY2VzXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIF9yZW1vdmVTZXJ2aWNlSW5zdGFuY2UoYXBwLCBuYW1lLCBpbnN0YW5jZUlkZW50aWZpZXIgPSBERUZBVUxUX0VOVFJZX05BTUUpIHtcbiAgICBfZ2V0UHJvdmlkZXIoYXBwLCBuYW1lKS5jbGVhckluc3RhbmNlKGluc3RhbmNlSWRlbnRpZmllcik7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gb2JqIC0gYW4gb2JqZWN0IG9mIHR5cGUgRmlyZWJhc2VBcHAgb3IgRmlyZWJhc2VPcHRpb25zLlxuICpcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGUgb2JqZWN0IGlzIG9mIHR5cGUgRmlyZWJhc2VBcHAuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIF9pc0ZpcmViYXNlQXBwKG9iaikge1xuICAgIHJldHVybiBvYmoub3B0aW9ucyAhPT0gdW5kZWZpbmVkO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIG9iaiAtIGFuIG9iamVjdCBvZiB0eXBlIEZpcmViYXNlQXBwLlxuICpcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIG9iamVjdCBpcyBvZiB0eXBlIEZpcmViYXNlU2VydmVyQXBwSW1wbC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gX2lzRmlyZWJhc2VTZXJ2ZXJBcHAob2JqKSB7XG4gICAgcmV0dXJuIG9iai5zZXR0aW5ncyAhPT0gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBUZXN0IG9ubHlcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gX2NsZWFyQ29tcG9uZW50cygpIHtcbiAgICBfY29tcG9uZW50cy5jbGVhcigpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgRVJST1JTID0ge1xuICAgIFtcIm5vLWFwcFwiIC8qIEFwcEVycm9yLk5PX0FQUCAqL106IFwiTm8gRmlyZWJhc2UgQXBwICd7JGFwcE5hbWV9JyBoYXMgYmVlbiBjcmVhdGVkIC0gXCIgK1xuICAgICAgICAnY2FsbCBpbml0aWFsaXplQXBwKCkgZmlyc3QnLFxuICAgIFtcImJhZC1hcHAtbmFtZVwiIC8qIEFwcEVycm9yLkJBRF9BUFBfTkFNRSAqL106IFwiSWxsZWdhbCBBcHAgbmFtZTogJ3skYXBwTmFtZX0nXCIsXG4gICAgW1wiZHVwbGljYXRlLWFwcFwiIC8qIEFwcEVycm9yLkRVUExJQ0FURV9BUFAgKi9dOiBcIkZpcmViYXNlIEFwcCBuYW1lZCAneyRhcHBOYW1lfScgYWxyZWFkeSBleGlzdHMgd2l0aCBkaWZmZXJlbnQgb3B0aW9ucyBvciBjb25maWdcIixcbiAgICBbXCJhcHAtZGVsZXRlZFwiIC8qIEFwcEVycm9yLkFQUF9ERUxFVEVEICovXTogXCJGaXJlYmFzZSBBcHAgbmFtZWQgJ3skYXBwTmFtZX0nIGFscmVhZHkgZGVsZXRlZFwiLFxuICAgIFtcInNlcnZlci1hcHAtZGVsZXRlZFwiIC8qIEFwcEVycm9yLlNFUlZFUl9BUFBfREVMRVRFRCAqL106ICdGaXJlYmFzZSBTZXJ2ZXIgQXBwIGhhcyBiZWVuIGRlbGV0ZWQnLFxuICAgIFtcIm5vLW9wdGlvbnNcIiAvKiBBcHBFcnJvci5OT19PUFRJT05TICovXTogJ05lZWQgdG8gcHJvdmlkZSBvcHRpb25zLCB3aGVuIG5vdCBiZWluZyBkZXBsb3llZCB0byBob3N0aW5nIHZpYSBzb3VyY2UuJyxcbiAgICBbXCJpbnZhbGlkLWFwcC1hcmd1bWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfQVBQX0FSR1VNRU5UICovXTogJ2ZpcmViYXNlLnskYXBwTmFtZX0oKSB0YWtlcyBlaXRoZXIgbm8gYXJndW1lbnQgb3IgYSAnICtcbiAgICAgICAgJ0ZpcmViYXNlIEFwcCBpbnN0YW5jZS4nLFxuICAgIFtcImludmFsaWQtbG9nLWFyZ3VtZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9MT0dfQVJHVU1FTlQgKi9dOiAnRmlyc3QgYXJndW1lbnQgdG8gYG9uTG9nYCBtdXN0IGJlIG51bGwgb3IgYSBmdW5jdGlvbi4nLFxuICAgIFtcImlkYi1vcGVuXCIgLyogQXBwRXJyb3IuSURCX09QRU4gKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gb3BlbmluZyBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxuICAgIFtcImlkYi1nZXRcIiAvKiBBcHBFcnJvci5JREJfR0VUICovXTogJ0Vycm9yIHRocm93biB3aGVuIHJlYWRpbmcgZnJvbSBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxuICAgIFtcImlkYi1zZXRcIiAvKiBBcHBFcnJvci5JREJfV1JJVEUgKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gd3JpdGluZyB0byBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxuICAgIFtcImlkYi1kZWxldGVcIiAvKiBBcHBFcnJvci5JREJfREVMRVRFICovXTogJ0Vycm9yIHRocm93biB3aGVuIGRlbGV0aW5nIGZyb20gSW5kZXhlZERCLiBPcmlnaW5hbCBlcnJvcjogeyRvcmlnaW5hbEVycm9yTWVzc2FnZX0uJyxcbiAgICBbXCJmaW5hbGl6YXRpb24tcmVnaXN0cnktbm90LXN1cHBvcnRlZFwiIC8qIEFwcEVycm9yLkZJTkFMSVpBVElPTl9SRUdJU1RSWV9OT1RfU1VQUE9SVEVEICovXTogJ0ZpcmViYXNlU2VydmVyQXBwIGRlbGV0ZU9uRGVyZWYgZmllbGQgZGVmaW5lZCBidXQgdGhlIEpTIHJ1bnRpbWUgZG9lcyBub3Qgc3VwcG9ydCBGaW5hbGl6YXRpb25SZWdpc3RyeS4nLFxuICAgIFtcImludmFsaWQtc2VydmVyLWFwcC1lbnZpcm9ubWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfU0VSVkVSX0FQUF9FTlZJUk9OTUVOVCAqL106ICdGaXJlYmFzZVNlcnZlckFwcCBpcyBub3QgZm9yIHVzZSBpbiBicm93c2VyIGVudmlyb25tZW50cy4nXG59O1xuY29uc3QgRVJST1JfRkFDVE9SWSA9IG5ldyBFcnJvckZhY3RvcnkoJ2FwcCcsICdGaXJlYmFzZScsIEVSUk9SUyk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBGaXJlYmFzZUFwcEltcGwge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNvbmZpZywgY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuX2lzRGVsZXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyk7XG4gICAgICAgIHRoaXMuX25hbWUgPSBjb25maWcubmFtZTtcbiAgICAgICAgdGhpcy5fYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID1cbiAgICAgICAgICAgIGNvbmZpZy5hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQ7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2FwcCcsICgpID0+IHRoaXMsIFwiUFVCTElDXCIgLyogQ29tcG9uZW50VHlwZS5QVUJMSUMgKi8pKTtcbiAgICB9XG4gICAgZ2V0IGF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCgpIHtcbiAgICAgICAgdGhpcy5jaGVja0Rlc3Ryb3llZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkO1xuICAgIH1cbiAgICBzZXQgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkKHZhbCkge1xuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XG4gICAgICAgIHRoaXMuX2F1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCA9IHZhbDtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICAgIH1cbiAgICBnZXQgY29uZmlnKCkge1xuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25maWc7XG4gICAgfVxuICAgIGdldCBjb250YWluZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gICAgfVxuICAgIGdldCBpc0RlbGV0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RlbGV0ZWQ7XG4gICAgfVxuICAgIHNldCBpc0RlbGV0ZWQodmFsKSB7XG4gICAgICAgIHRoaXMuX2lzRGVsZXRlZCA9IHZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIHRocm93IGFuIEVycm9yIGlmIHRoZSBBcHAgaGFzIGFscmVhZHkgYmVlbiBkZWxldGVkIC1cbiAgICAgKiB1c2UgYmVmb3JlIHBlcmZvcm1pbmcgQVBJIGFjdGlvbnMgb24gdGhlIEFwcC5cbiAgICAgKi9cbiAgICBjaGVja0Rlc3Ryb3llZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEZWxldGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImFwcC1kZWxldGVkXCIgLyogQXBwRXJyb3IuQVBQX0RFTEVURUQgKi8sIHsgYXBwTmFtZTogdGhpcy5fbmFtZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIEZpcmViYXNlU2VydmVyQXBwSW1wbCBleHRlbmRzIEZpcmViYXNlQXBwSW1wbCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgc2VydmVyQ29uZmlnLCBuYW1lLCBjb250YWluZXIpIHtcbiAgICAgICAgLy8gQnVpbGQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzIGZvciB0aGUgRmlyZWJhc2VBcHBJbXBsIGJhc2UgY2xhc3MuXG4gICAgICAgIGNvbnN0IGF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCA9IHNlcnZlckNvbmZpZy5hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBzZXJ2ZXJDb25maWcuYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkXG4gICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICAvLyBDcmVhdGUgdGhlIEZpcmViYXNlQXBwU2V0dGluZ3Mgb2JqZWN0IGZvciB0aGUgRmlyZWJhc2VBcHBJbXAgY29uc3RydWN0b3IuXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWRcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXBpS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIENvbnN0cnVjdCB0aGUgcGFyZW50IEZpcmViYXNlQXBwSW1wIG9iamVjdC5cbiAgICAgICAgICAgIHN1cGVyKG9wdGlvbnMsIGNvbmZpZywgY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGFwcEltcGwgPSBvcHRpb25zO1xuICAgICAgICAgICAgc3VwZXIoYXBwSW1wbC5vcHRpb25zLCBjb25maWcsIGNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm93IGNvbnN0cnVjdCB0aGUgZGF0YSBmb3IgdGhlIEZpcmViYXNlU2VydmVyQXBwSW1wbC5cbiAgICAgICAgdGhpcy5fc2VydmVyQ29uZmlnID0gT2JqZWN0LmFzc2lnbih7IGF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCB9LCBzZXJ2ZXJDb25maWcpO1xuICAgICAgICB0aGlzLl9maW5hbGl6YXRpb25SZWdpc3RyeSA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLl9maW5hbGl6YXRpb25SZWdpc3RyeSA9IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvbWF0aWNDbGVhbnVwKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZWZDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuaW5jUmVmQ291bnQodGhpcy5fc2VydmVyQ29uZmlnLnJlbGVhc2VPbkRlcmVmKTtcbiAgICAgICAgLy8gRG8gbm90IHJldGFpbiBhIGhhcmQgcmVmZXJlbmNlIHRvIHRoZSBkcmVmIG9iamVjdCwgb3RoZXJ3aXNlIHRoZSBGaW5hbGl6YXRpb25SZWdpc3RyeVxuICAgICAgICAvLyB3aWxsIG5ldmVyIHRyaWdnZXIuXG4gICAgICAgIHRoaXMuX3NlcnZlckNvbmZpZy5yZWxlYXNlT25EZXJlZiA9IHVuZGVmaW5lZDtcbiAgICAgICAgc2VydmVyQ29uZmlnLnJlbGVhc2VPbkRlcmVmID0gdW5kZWZpbmVkO1xuICAgICAgICByZWdpc3RlclZlcnNpb24obmFtZSRxLCB2ZXJzaW9uJDEsICdzZXJ2ZXJhcHAnKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgcmVmQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZDb3VudDtcbiAgICB9XG4gICAgLy8gSW5jcmVtZW50IHRoZSByZWZlcmVuY2UgY291bnQgb2YgdGhpcyBzZXJ2ZXIgYXBwLiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQsIHJlZ2lzdGVyIGl0XG4gICAgLy8gd2l0aCB0aGUgZmluYWxpemF0aW9uIHJlZ2lzdHJ5LlxuICAgIGluY1JlZkNvdW50KG9iaikge1xuICAgICAgICBpZiAodGhpcy5pc0RlbGV0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZWZDb3VudCsrO1xuICAgICAgICBpZiAob2JqICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fZmluYWxpemF0aW9uUmVnaXN0cnkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbmFsaXphdGlvblJlZ2lzdHJ5LnJlZ2lzdGVyKG9iaiwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRGVjcmVtZW50IHRoZSByZWZlcmVuY2UgY291bnQuXG4gICAgZGVjUmVmQ291bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGVsZXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0tdGhpcy5fcmVmQ291bnQ7XG4gICAgfVxuICAgIC8vIEludm9rZWQgYnkgdGhlIEZpbmFsaXphdGlvblJlZ2lzdHJ5IGNhbGxiYWNrIHRvIG5vdGUgdGhhdCB0aGlzIGFwcCBzaG91bGQgZ28gdGhyb3VnaCBpdHNcbiAgICAvLyByZWZlcmVuY2UgY291bnRzIGFuZCBkZWxldGUgaXRzZWxmIGlmIG5vIHJlZmVyZW5jZSBjb3VudCByZW1haW4uIFRoZSBjb29yZGluYXRpbmcgbG9naWMgdGhhdFxuICAgIC8vIGhhbmRsZXMgdGhpcyBpcyBpbiBkZWxldGVBcHAoLi4uKS5cbiAgICBhdXRvbWF0aWNDbGVhbnVwKCkge1xuICAgICAgICB2b2lkIGRlbGV0ZUFwcCh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHNldHRpbmdzKCkge1xuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXJ2ZXJDb25maWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCB0aHJvdyBhbiBFcnJvciBpZiB0aGUgQXBwIGhhcyBhbHJlYWR5IGJlZW4gZGVsZXRlZCAtXG4gICAgICogdXNlIGJlZm9yZSBwZXJmb3JtaW5nIEFQSSBhY3Rpb25zIG9uIHRoZSBBcHAuXG4gICAgICovXG4gICAgY2hlY2tEZXN0cm95ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGVsZXRlZCkge1xuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJzZXJ2ZXItYXBwLWRlbGV0ZWRcIiAvKiBBcHBFcnJvci5TRVJWRVJfQVBQX0RFTEVURUQgKi8pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaGUgY3VycmVudCBTREsgdmVyc2lvbi5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IFNES19WRVJTSU9OID0gdmVyc2lvbjtcbmZ1bmN0aW9uIGluaXRpYWxpemVBcHAoX29wdGlvbnMsIHJhd0NvbmZpZyA9IHt9KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBfb3B0aW9ucztcbiAgICBpZiAodHlwZW9mIHJhd0NvbmZpZyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHJhd0NvbmZpZztcbiAgICAgICAgcmF3Q29uZmlnID0geyBuYW1lIH07XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oeyBuYW1lOiBERUZBVUxUX0VOVFJZX05BTUUsIGF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZDogZmFsc2UgfSwgcmF3Q29uZmlnKTtcbiAgICBjb25zdCBuYW1lID0gY29uZmlnLm5hbWU7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCAhbmFtZSkge1xuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImJhZC1hcHAtbmFtZVwiIC8qIEFwcEVycm9yLkJBRF9BUFBfTkFNRSAqLywge1xuICAgICAgICAgICAgYXBwTmFtZTogU3RyaW5nKG5hbWUpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0gZ2V0RGVmYXVsdEFwcENvbmZpZygpKTtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJuby1vcHRpb25zXCIgLyogQXBwRXJyb3IuTk9fT1BUSU9OUyAqLyk7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nQXBwID0gX2FwcHMuZ2V0KG5hbWUpO1xuICAgIGlmIChleGlzdGluZ0FwcCkge1xuICAgICAgICAvLyByZXR1cm4gdGhlIGV4aXN0aW5nIGFwcCBpZiBvcHRpb25zIGFuZCBjb25maWcgZGVlcCBlcXVhbCB0aGUgb25lcyBpbiB0aGUgZXhpc3RpbmcgYXBwLlxuICAgICAgICBpZiAoZGVlcEVxdWFsKG9wdGlvbnMsIGV4aXN0aW5nQXBwLm9wdGlvbnMpICYmXG4gICAgICAgICAgICBkZWVwRXF1YWwoY29uZmlnLCBleGlzdGluZ0FwcC5jb25maWcpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdBcHA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImR1cGxpY2F0ZS1hcHBcIiAvKiBBcHBFcnJvci5EVVBMSUNBVEVfQVBQICovLCB7IGFwcE5hbWU6IG5hbWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY29udGFpbmVyID0gbmV3IENvbXBvbmVudENvbnRhaW5lcihuYW1lKTtcbiAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiBfY29tcG9uZW50cy52YWx1ZXMoKSkge1xuICAgICAgICBjb250YWluZXIuYWRkQ29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgfVxuICAgIGNvbnN0IG5ld0FwcCA9IG5ldyBGaXJlYmFzZUFwcEltcGwob3B0aW9ucywgY29uZmlnLCBjb250YWluZXIpO1xuICAgIF9hcHBzLnNldChuYW1lLCBuZXdBcHApO1xuICAgIHJldHVybiBuZXdBcHA7XG59XG5mdW5jdGlvbiBpbml0aWFsaXplU2VydmVyQXBwKF9vcHRpb25zLCBfc2VydmVyQXBwQ29uZmlnKSB7XG4gICAgaWYgKGlzQnJvd3NlcigpICYmICFpc1dlYldvcmtlcigpKSB7XG4gICAgICAgIC8vIEZpcmViYXNlU2VydmVyQXBwIGlzbid0IGRlc2lnbmVkIHRvIGJlIHJ1biBpbiBicm93c2Vycy5cbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJpbnZhbGlkLXNlcnZlci1hcHAtZW52aXJvbm1lbnRcIiAvKiBBcHBFcnJvci5JTlZBTElEX1NFUlZFUl9BUFBfRU5WSVJPTk1FTlQgKi8pO1xuICAgIH1cbiAgICBpZiAoX3NlcnZlckFwcENvbmZpZy5hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBfc2VydmVyQXBwQ29uZmlnLmF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBsZXQgYXBwT3B0aW9ucztcbiAgICBpZiAoX2lzRmlyZWJhc2VBcHAoX29wdGlvbnMpKSB7XG4gICAgICAgIGFwcE9wdGlvbnMgPSBfb3B0aW9ucy5vcHRpb25zO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXBwT3B0aW9ucyA9IF9vcHRpb25zO1xuICAgIH1cbiAgICAvLyBCdWlsZCBhbiBhcHAgbmFtZSBiYXNlZCBvbiBhIGhhc2ggb2YgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICBjb25zdCBuYW1lT2JqID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBfc2VydmVyQXBwQ29uZmlnKSwgYXBwT3B0aW9ucyk7XG4gICAgLy8gSG93ZXZlciwgRG8gbm90IG1hbmdsZSB0aGUgbmFtZSBiYXNlZCBvbiByZWxlYXNlT25EZXJlZiwgc2luY2UgaXQgd2lsbCB2YXJ5IGJldHdlZW4gdGhlXG4gICAgLy8gY29uc3RydWN0aW9uIG9mIEZpcmViYXNlU2VydmVyQXBwIGluc3RhbmNlcy4gRm9yIGV4YW1wbGUsIGlmIHRoZSBvYmplY3QgaXMgdGhlIHJlcXVlc3QgaGVhZGVycy5cbiAgICBpZiAobmFtZU9iai5yZWxlYXNlT25EZXJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlbGV0ZSBuYW1lT2JqLnJlbGVhc2VPbkRlcmVmO1xuICAgIH1cbiAgICBjb25zdCBoYXNoQ29kZSA9IChzKSA9PiB7XG4gICAgICAgIHJldHVybiBbLi4uc10ucmVkdWNlKChoYXNoLCBjKSA9PiAoTWF0aC5pbXVsKDMxLCBoYXNoKSArIGMuY2hhckNvZGVBdCgwKSkgfCAwLCAwKTtcbiAgICB9O1xuICAgIGlmIChfc2VydmVyQXBwQ29uZmlnLnJlbGVhc2VPbkRlcmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiZmluYWxpemF0aW9uLXJlZ2lzdHJ5LW5vdC1zdXBwb3J0ZWRcIiAvKiBBcHBFcnJvci5GSU5BTElaQVRJT05fUkVHSVNUUllfTk9UX1NVUFBPUlRFRCAqLywge30pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5hbWVTdHJpbmcgPSAnJyArIGhhc2hDb2RlKEpTT04uc3RyaW5naWZ5KG5hbWVPYmopKTtcbiAgICBjb25zdCBleGlzdGluZ0FwcCA9IF9zZXJ2ZXJBcHBzLmdldChuYW1lU3RyaW5nKTtcbiAgICBpZiAoZXhpc3RpbmdBcHApIHtcbiAgICAgICAgZXhpc3RpbmdBcHAuaW5jUmVmQ291bnQoX3NlcnZlckFwcENvbmZpZy5yZWxlYXNlT25EZXJlZik7XG4gICAgICAgIHJldHVybiBleGlzdGluZ0FwcDtcbiAgICB9XG4gICAgY29uc3QgY29udGFpbmVyID0gbmV3IENvbXBvbmVudENvbnRhaW5lcihuYW1lU3RyaW5nKTtcbiAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiBfY29tcG9uZW50cy52YWx1ZXMoKSkge1xuICAgICAgICBjb250YWluZXIuYWRkQ29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgfVxuICAgIGNvbnN0IG5ld0FwcCA9IG5ldyBGaXJlYmFzZVNlcnZlckFwcEltcGwoYXBwT3B0aW9ucywgX3NlcnZlckFwcENvbmZpZywgbmFtZVN0cmluZywgY29udGFpbmVyKTtcbiAgICBfc2VydmVyQXBwcy5zZXQobmFtZVN0cmluZywgbmV3QXBwKTtcbiAgICByZXR1cm4gbmV3QXBwO1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgYSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gaW5zdGFuY2UuXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMsIHRoZSBkZWZhdWx0IGFwcCBpcyByZXR1cm5lZC4gV2hlbiBhbiBhcHAgbmFtZVxuICogaXMgcHJvdmlkZWQsIHRoZSBhcHAgY29ycmVzcG9uZGluZyB0byB0aGF0IG5hbWUgaXMgcmV0dXJuZWQuXG4gKlxuICogQW4gZXhjZXB0aW9uIGlzIHRocm93biBpZiB0aGUgYXBwIGJlaW5nIHJldHJpZXZlZCBoYXMgbm90IHlldCBiZWVuXG4gKiBpbml0aWFsaXplZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gUmV0dXJuIHRoZSBkZWZhdWx0IGFwcFxuICogY29uc3QgYXBwID0gZ2V0QXBwKCk7XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gUmV0dXJuIGEgbmFtZWQgYXBwXG4gKiBjb25zdCBvdGhlckFwcCA9IGdldEFwcChcIm90aGVyQXBwXCIpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIG5hbWUgLSBPcHRpb25hbCBuYW1lIG9mIHRoZSBhcHAgdG8gcmV0dXJuLiBJZiBubyBuYW1lIGlzXG4gKiAgIHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBpcyBgXCJbREVGQVVMVF1cImAuXG4gKlxuICogQHJldHVybnMgVGhlIGFwcCBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm92aWRlZCBhcHAgbmFtZS5cbiAqICAgSWYgbm8gYXBwIG5hbWUgaXMgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IGFwcCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGdldEFwcChuYW1lID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XG4gICAgY29uc3QgYXBwID0gX2FwcHMuZ2V0KG5hbWUpO1xuICAgIGlmICghYXBwICYmIG5hbWUgPT09IERFRkFVTFRfRU5UUllfTkFNRSAmJiBnZXREZWZhdWx0QXBwQ29uZmlnKCkpIHtcbiAgICAgICAgcmV0dXJuIGluaXRpYWxpemVBcHAoKTtcbiAgICB9XG4gICAgaWYgKCFhcHApIHtcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJuby1hcHBcIiAvKiBBcHBFcnJvci5OT19BUFAgKi8sIHsgYXBwTmFtZTogbmFtZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFwcDtcbn1cbi8qKlxuICogQSAocmVhZC1vbmx5KSBhcnJheSBvZiBhbGwgaW5pdGlhbGl6ZWQgYXBwcy5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZ2V0QXBwcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShfYXBwcy52YWx1ZXMoKSk7XG59XG4vKipcbiAqIFJlbmRlcnMgdGhpcyBhcHAgdW51c2FibGUgYW5kIGZyZWVzIHRoZSByZXNvdXJjZXMgb2YgYWxsIGFzc29jaWF0ZWRcbiAqIHNlcnZpY2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBkZWxldGVBcHAoYXBwKVxuICogICAudGhlbihmdW5jdGlvbigpIHtcbiAqICAgICBjb25zb2xlLmxvZyhcIkFwcCBkZWxldGVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAqICAgfSlcbiAqICAgLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gKiAgICAgY29uc29sZS5sb2coXCJFcnJvciBkZWxldGluZyBhcHA6XCIsIGVycm9yKTtcbiAqICAgfSk7XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUFwcChhcHApIHtcbiAgICBsZXQgY2xlYW51cFByb3ZpZGVycyA9IGZhbHNlO1xuICAgIGNvbnN0IG5hbWUgPSBhcHAubmFtZTtcbiAgICBpZiAoX2FwcHMuaGFzKG5hbWUpKSB7XG4gICAgICAgIGNsZWFudXBQcm92aWRlcnMgPSB0cnVlO1xuICAgICAgICBfYXBwcy5kZWxldGUobmFtZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKF9zZXJ2ZXJBcHBzLmhhcyhuYW1lKSkge1xuICAgICAgICBjb25zdCBmaXJlYmFzZVNlcnZlckFwcCA9IGFwcDtcbiAgICAgICAgaWYgKGZpcmViYXNlU2VydmVyQXBwLmRlY1JlZkNvdW50KCkgPD0gMCkge1xuICAgICAgICAgICAgX3NlcnZlckFwcHMuZGVsZXRlKG5hbWUpO1xuICAgICAgICAgICAgY2xlYW51cFByb3ZpZGVycyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNsZWFudXBQcm92aWRlcnMpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoYXBwLmNvbnRhaW5lclxuICAgICAgICAgICAgLmdldFByb3ZpZGVycygpXG4gICAgICAgICAgICAubWFwKHByb3ZpZGVyID0+IHByb3ZpZGVyLmRlbGV0ZSgpKSk7XG4gICAgICAgIGFwcC5pc0RlbGV0ZWQgPSB0cnVlO1xuICAgIH1cbn1cbi8qKlxuICogUmVnaXN0ZXJzIGEgbGlicmFyeSdzIG5hbWUgYW5kIHZlcnNpb24gZm9yIHBsYXRmb3JtIGxvZ2dpbmcgcHVycG9zZXMuXG4gKiBAcGFyYW0gbGlicmFyeSAtIE5hbWUgb2YgMXAgb3IgM3AgbGlicmFyeSAoZS5nLiBmaXJlc3RvcmUsIGFuZ3VsYXJmaXJlKVxuICogQHBhcmFtIHZlcnNpb24gLSBDdXJyZW50IHZlcnNpb24gb2YgdGhhdCBsaWJyYXJ5LlxuICogQHBhcmFtIHZhcmlhbnQgLSBCdW5kbGUgdmFyaWFudCwgZS5nLiwgbm9kZSwgcm4sIGV0Yy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyVmVyc2lvbihsaWJyYXJ5S2V5T3JOYW1lLCB2ZXJzaW9uLCB2YXJpYW50KSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIFRPRE86IFdlIGNhbiB1c2UgdGhpcyBjaGVjayB0byB3aGl0ZWxpc3Qgc3RyaW5ncyB3aGVuL2lmIHdlIHNldCB1cFxuICAgIC8vIGEgZ29vZCB3aGl0ZWxpc3Qgc3lzdGVtLlxuICAgIGxldCBsaWJyYXJ5ID0gKF9hID0gUExBVEZPUk1fTE9HX1NUUklOR1tsaWJyYXJ5S2V5T3JOYW1lXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbGlicmFyeUtleU9yTmFtZTtcbiAgICBpZiAodmFyaWFudCkge1xuICAgICAgICBsaWJyYXJ5ICs9IGAtJHt2YXJpYW50fWA7XG4gICAgfVxuICAgIGNvbnN0IGxpYnJhcnlNaXNtYXRjaCA9IGxpYnJhcnkubWF0Y2goL1xcc3xcXC8vKTtcbiAgICBjb25zdCB2ZXJzaW9uTWlzbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKC9cXHN8XFwvLyk7XG4gICAgaWYgKGxpYnJhcnlNaXNtYXRjaCB8fCB2ZXJzaW9uTWlzbWF0Y2gpIHtcbiAgICAgICAgY29uc3Qgd2FybmluZyA9IFtcbiAgICAgICAgICAgIGBVbmFibGUgdG8gcmVnaXN0ZXIgbGlicmFyeSBcIiR7bGlicmFyeX1cIiB3aXRoIHZlcnNpb24gXCIke3ZlcnNpb259XCI6YFxuICAgICAgICBdO1xuICAgICAgICBpZiAobGlicmFyeU1pc21hdGNoKSB7XG4gICAgICAgICAgICB3YXJuaW5nLnB1c2goYGxpYnJhcnkgbmFtZSBcIiR7bGlicmFyeX1cIiBjb250YWlucyBpbGxlZ2FsIGNoYXJhY3RlcnMgKHdoaXRlc3BhY2Ugb3IgXCIvXCIpYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpYnJhcnlNaXNtYXRjaCAmJiB2ZXJzaW9uTWlzbWF0Y2gpIHtcbiAgICAgICAgICAgIHdhcm5pbmcucHVzaCgnYW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZlcnNpb25NaXNtYXRjaCkge1xuICAgICAgICAgICAgd2FybmluZy5wdXNoKGB2ZXJzaW9uIG5hbWUgXCIke3ZlcnNpb259XCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzICh3aGl0ZXNwYWNlIG9yIFwiL1wiKWApO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci53YXJuKHdhcm5pbmcuam9pbignICcpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfcmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudChgJHtsaWJyYXJ5fS12ZXJzaW9uYCwgKCkgPT4gKHsgbGlicmFyeSwgdmVyc2lvbiB9KSwgXCJWRVJTSU9OXCIgLyogQ29tcG9uZW50VHlwZS5WRVJTSU9OICovKSk7XG59XG4vKipcbiAqIFNldHMgbG9nIGhhbmRsZXIgZm9yIGFsbCBGaXJlYmFzZSBTREtzLlxuICogQHBhcmFtIGxvZ0NhbGxiYWNrIC0gQW4gb3B0aW9uYWwgY3VzdG9tIGxvZyBoYW5kbGVyIHRoYXQgZXhlY3V0ZXMgdXNlciBjb2RlIHdoZW5ldmVyXG4gKiB0aGUgRmlyZWJhc2UgU0RLIG1ha2VzIGEgbG9nZ2luZyBjYWxsLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gb25Mb2cobG9nQ2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBpZiAobG9nQ2FsbGJhY2sgIT09IG51bGwgJiYgdHlwZW9mIGxvZ0NhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaW52YWxpZC1sb2ctYXJndW1lbnRcIiAvKiBBcHBFcnJvci5JTlZBTElEX0xPR19BUkdVTUVOVCAqLyk7XG4gICAgfVxuICAgIHNldFVzZXJMb2dIYW5kbGVyKGxvZ0NhbGxiYWNrLCBvcHRpb25zKTtcbn1cbi8qKlxuICogU2V0cyBsb2cgbGV2ZWwgZm9yIGFsbCBGaXJlYmFzZSBTREtzLlxuICpcbiAqIEFsbCBvZiB0aGUgbG9nIHR5cGVzIGFib3ZlIHRoZSBjdXJyZW50IGxvZyBsZXZlbCBhcmUgY2FwdHVyZWQgKGkuZS4gaWZcbiAqIHlvdSBzZXQgdGhlIGxvZyBsZXZlbCB0byBgaW5mb2AsIGVycm9ycyBhcmUgbG9nZ2VkLCBidXQgYGRlYnVnYCBhbmRcbiAqIGB2ZXJib3NlYCBsb2dzIGFyZSBub3QpLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobG9nTGV2ZWwpIHtcbiAgICBzZXRMb2dMZXZlbCQxKGxvZ0xldmVsKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IERCX05BTUUgPSAnZmlyZWJhc2UtaGVhcnRiZWF0LWRhdGFiYXNlJztcbmNvbnN0IERCX1ZFUlNJT04gPSAxO1xuY29uc3QgU1RPUkVfTkFNRSA9ICdmaXJlYmFzZS1oZWFydGJlYXQtc3RvcmUnO1xubGV0IGRiUHJvbWlzZSA9IG51bGw7XG5mdW5jdGlvbiBnZXREYlByb21pc2UoKSB7XG4gICAgaWYgKCFkYlByb21pc2UpIHtcbiAgICAgICAgZGJQcm9taXNlID0gb3BlbkRCKERCX05BTUUsIERCX1ZFUlNJT04sIHtcbiAgICAgICAgICAgIHVwZ3JhZGU6IChkYiwgb2xkVmVyc2lvbikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHVzZSAnYnJlYWsnIGluIHRoaXMgc3dpdGNoIHN0YXRlbWVudCwgdGhlIGZhbGwtdGhyb3VnaFxuICAgICAgICAgICAgICAgIC8vIGJlaGF2aW9yIGlzIHdoYXQgd2Ugd2FudCwgYmVjYXVzZSBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgdmVyc2lvbnMgYmV0d2VlblxuICAgICAgICAgICAgICAgIC8vIHRoZSBvbGQgdmVyc2lvbiBhbmQgdGhlIGN1cnJlbnQgdmVyc2lvbiwgd2Ugd2FudCBBTEwgdGhlIG1pZ3JhdGlvbnNcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhvc2UgdmVyc2lvbnMgdG8gcnVuLCBub3Qgb25seSB0aGUgbGFzdCBvbmUuXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlZmF1bHQtY2FzZVxuICAgICAgICAgICAgICAgIHN3aXRjaCAob2xkVmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKFNUT1JFX05BTUUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkvaU9TIGJyb3dzZXJzIHRocm93IG9jY2FzaW9uYWwgZXhjZXB0aW9ucyBvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRiLmNyZWF0ZU9iamVjdFN0b3JlKCkgdGhhdCBtYXkgYmUgYSBidWcuIEF2b2lkIGJsb2NraW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlc3Qgb2YgdGhlIGFwcCBmdW5jdGlvbmFsaXR5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJpZGItb3BlblwiIC8qIEFwcEVycm9yLklEQl9PUEVOICovLCB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFcnJvck1lc3NhZ2U6IGUubWVzc2FnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGJQcm9taXNlO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVhZEhlYXJ0YmVhdHNGcm9tSW5kZXhlZERCKGFwcCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGJQcm9taXNlKCk7XG4gICAgICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oU1RPUkVfTkFNRSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHR4Lm9iamVjdFN0b3JlKFNUT1JFX05BTUUpLmdldChjb21wdXRlS2V5KGFwcCkpO1xuICAgICAgICAvLyBXZSBhbHJlYWR5IGhhdmUgdGhlIHZhbHVlIGJ1dCB0eC5kb25lIGNhbiB0aHJvdyxcbiAgICAgICAgLy8gc28gd2UgbmVlZCB0byBhd2FpdCBpdCBoZXJlIHRvIGNhdGNoIGVycm9yc1xuICAgICAgICBhd2FpdCB0eC5kb25lO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGUubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpZGJHZXRFcnJvciA9IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaWRiLWdldFwiIC8qIEFwcEVycm9yLklEQl9HRVQgKi8sIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yTWVzc2FnZTogZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLm1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oaWRiR2V0RXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiB3cml0ZUhlYXJ0YmVhdHNUb0luZGV4ZWREQihhcHAsIGhlYXJ0YmVhdE9iamVjdCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGJQcm9taXNlKCk7XG4gICAgICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oU1RPUkVfTkFNRSwgJ3JlYWR3cml0ZScpO1xuICAgICAgICBjb25zdCBvYmplY3RTdG9yZSA9IHR4Lm9iamVjdFN0b3JlKFNUT1JFX05BTUUpO1xuICAgICAgICBhd2FpdCBvYmplY3RTdG9yZS5wdXQoaGVhcnRiZWF0T2JqZWN0LCBjb21wdXRlS2V5KGFwcCkpO1xuICAgICAgICBhd2FpdCB0eC5kb25lO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGUubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpZGJHZXRFcnJvciA9IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaWRiLXNldFwiIC8qIEFwcEVycm9yLklEQl9XUklURSAqLywge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3JNZXNzYWdlOiBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsb2dnZXIud2FybihpZGJHZXRFcnJvci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVLZXkoYXBwKSB7XG4gICAgcmV0dXJuIGAke2FwcC5uYW1lfSEke2FwcC5vcHRpb25zLmFwcElkfWA7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBNQVhfSEVBREVSX0JZVEVTID0gMTAyNDtcbi8vIDMwIGRheXNcbmNvbnN0IFNUT1JFRF9IRUFSVEJFQVRfUkVURU5USU9OX01BWF9NSUxMSVMgPSAzMCAqIDI0ICogNjAgKiA2MCAqIDEwMDA7XG5jbGFzcyBIZWFydGJlYXRTZXJ2aWNlSW1wbCB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW4tbWVtb3J5IGNhY2hlIGZvciBoZWFydGJlYXRzLCB1c2VkIGJ5IGdldEhlYXJ0YmVhdHNIZWFkZXIoKSB0byBnZW5lcmF0ZVxuICAgICAgICAgKiB0aGUgaGVhZGVyIHN0cmluZy5cbiAgICAgICAgICogU3RvcmVzIG9uZSByZWNvcmQgcGVyIGRhdGUuIFRoaXMgd2lsbCBiZSBjb25zb2xpZGF0ZWQgaW50byB0aGUgc3RhbmRhcmRcbiAgICAgICAgICogZm9ybWF0IG9mIG9uZSByZWNvcmQgcGVyIHVzZXIgYWdlbnQgc3RyaW5nIGJlZm9yZSBiZWluZyBzZW50IGFzIGEgaGVhZGVyLlxuICAgICAgICAgKiBQb3B1bGF0ZWQgZnJvbSBpbmRleGVkREIgd2hlbiB0aGUgY29udHJvbGxlciBpcyBpbnN0YW50aWF0ZWQgYW5kIHNob3VsZFxuICAgICAgICAgKiBiZSBrZXB0IGluIHN5bmMgd2l0aCBpbmRleGVkREIuXG4gICAgICAgICAqIExlYXZlIHB1YmxpYyBmb3IgZWFzaWVyIHRlc3RpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPSBudWxsO1xuICAgICAgICBjb25zdCBhcHAgPSB0aGlzLmNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwJykuZ2V0SW1tZWRpYXRlKCk7XG4gICAgICAgIHRoaXMuX3N0b3JhZ2UgPSBuZXcgSGVhcnRiZWF0U3RvcmFnZUltcGwoYXBwKTtcbiAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlUHJvbWlzZSA9IHRoaXMuX3N0b3JhZ2UucmVhZCgpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9IHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdG8gcmVwb3J0IGEgaGVhcnRiZWF0LiBUaGUgZnVuY3Rpb24gd2lsbCBnZW5lcmF0ZVxuICAgICAqIGEgSGVhcnRiZWF0c0J5VXNlckFnZW50IG9iamVjdCwgdXBkYXRlIGhlYXJ0YmVhdHNDYWNoZSwgYW5kIHBlcnNpc3QgaXRcbiAgICAgKiB0byBJbmRleGVkREIuXG4gICAgICogTm90ZSB0aGF0IHdlIG9ubHkgc3RvcmUgb25lIGhlYXJ0YmVhdCBwZXIgZGF5LiBTbyBpZiBhIGhlYXJ0YmVhdCBmb3IgdG9kYXkgaXNcbiAgICAgKiBhbHJlYWR5IGxvZ2dlZCwgc3Vic2VxdWVudCBjYWxscyB0byB0aGlzIGZ1bmN0aW9uIGluIHRoZSBzYW1lIGRheSB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICovXG4gICAgYXN5bmMgdHJpZ2dlckhlYXJ0YmVhdCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBsYXRmb3JtTG9nZ2VyID0gdGhpcy5jb250YWluZXJcbiAgICAgICAgICAgICAgICAuZ2V0UHJvdmlkZXIoJ3BsYXRmb3JtLWxvZ2dlcicpXG4gICAgICAgICAgICAgICAgLmdldEltbWVkaWF0ZSgpO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgXCJGaXJlYmFzZSB1c2VyIGFnZW50XCIgc3RyaW5nIGZyb20gdGhlIHBsYXRmb3JtIGxvZ2dlclxuICAgICAgICAgICAgLy8gc2VydmljZSwgbm90IHRoZSBicm93c2VyIHVzZXIgYWdlbnQuXG4gICAgICAgICAgICBjb25zdCBhZ2VudCA9IHBsYXRmb3JtTG9nZ2VyLmdldFBsYXRmb3JtSW5mb1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgZGF0ZSA9IGdldFVUQ0RhdGVTdHJpbmcoKTtcbiAgICAgICAgICAgIGlmICgoKF9hID0gdGhpcy5faGVhcnRiZWF0c0NhY2hlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVhcnRiZWF0cykgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9IGF3YWl0IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZVByb21pc2U7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZmFpbGVkIHRvIGNvbnN0cnVjdCBhIGhlYXJ0YmVhdHMgY2FjaGUsIHRoZW4gcmV0dXJuIGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgICAgIGlmICgoKF9iID0gdGhpcy5faGVhcnRiZWF0c0NhY2hlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGVhcnRiZWF0cykgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG8gbm90IHN0b3JlIGEgaGVhcnRiZWF0IGlmIG9uZSBpcyBhbHJlYWR5IHN0b3JlZCBmb3IgdGhpcyBkYXlcbiAgICAgICAgICAgIC8vIG9yIGlmIGEgaGVhZGVyIGhhcyBhbHJlYWR5IGJlZW4gc2VudCB0b2RheS5cbiAgICAgICAgICAgIGlmICh0aGlzLl9oZWFydGJlYXRzQ2FjaGUubGFzdFNlbnRIZWFydGJlYXREYXRlID09PSBkYXRlIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMuc29tZShzaW5nbGVEYXRlSGVhcnRiZWF0ID0+IHNpbmdsZURhdGVIZWFydGJlYXQuZGF0ZSA9PT0gZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBlbnRyeSBmb3IgdGhpcyBkYXRlLiBDcmVhdGUgb25lLlxuICAgICAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzLnB1c2goeyBkYXRlLCBhZ2VudCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSBlbnRyaWVzIG9sZGVyIHRoYW4gMzAgZGF5cy5cbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzID1cbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5maWx0ZXIoc2luZ2xlRGF0ZUhlYXJ0YmVhdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhiVGltZXN0YW1wID0gbmV3IERhdGUoc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub3cgLSBoYlRpbWVzdGFtcCA8PSBTVE9SRURfSEVBUlRCRUFUX1JFVEVOVElPTl9NQVhfTUlMTElTO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2Uub3ZlcndyaXRlKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgd2hpY2ggY2FuIGJlIGF0dGFjaGVkIHRvIHRoZSBoZWFydGJlYXQtc3BlY2lmaWMgaGVhZGVyIGRpcmVjdGx5LlxuICAgICAqIEl0IGFsc28gY2xlYXJzIGFsbCBoZWFydGJlYXRzIGZyb20gbWVtb3J5IGFzIHdlbGwgYXMgaW4gSW5kZXhlZERCLlxuICAgICAqXG4gICAgICogTk9URTogQ29uc3VtaW5nIHByb2R1Y3QgU0RLcyBzaG91bGQgbm90IHNlbmQgdGhlIGhlYWRlciBpZiB0aGlzIG1ldGhvZFxuICAgICAqIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEhlYXJ0YmVhdHNIZWFkZXIoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9oZWFydGJlYXRzQ2FjaGVQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgaXQncyBzdGlsbCBudWxsIG9yIHRoZSBhcnJheSBpcyBlbXB0eSwgdGhlcmUgaXMgbm8gZGF0YSB0byBzZW5kLlxuICAgICAgICAgICAgaWYgKCgoX2EgPSB0aGlzLl9oZWFydGJlYXRzQ2FjaGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWFydGJlYXRzKSA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0ZSA9IGdldFVUQ0RhdGVTdHJpbmcoKTtcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgYXMgbWFueSBoZWFydGJlYXRzIGZyb20gdGhlIGNhY2hlIGFzIHdpbGwgZml0IHVuZGVyIHRoZSBzaXplIGxpbWl0LlxuICAgICAgICAgICAgY29uc3QgeyBoZWFydGJlYXRzVG9TZW5kLCB1bnNlbnRFbnRyaWVzIH0gPSBleHRyYWN0SGVhcnRiZWF0c0ZvckhlYWRlcih0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cyk7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJTdHJpbmcgPSBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyhKU09OLnN0cmluZ2lmeSh7IHZlcnNpb246IDIsIGhlYXJ0YmVhdHM6IGhlYXJ0YmVhdHNUb1NlbmQgfSkpO1xuICAgICAgICAgICAgLy8gU3RvcmUgbGFzdCBzZW50IGRhdGUgdG8gcHJldmVudCBhbm90aGVyIGJlaW5nIGxvZ2dlZC9zZW50IGZvciB0aGUgc2FtZSBkYXkuXG4gICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUubGFzdFNlbnRIZWFydGJlYXREYXRlID0gZGF0ZTtcbiAgICAgICAgICAgIGlmICh1bnNlbnRFbnRyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSBhbnkgdW5zZW50IGVudHJpZXMgaWYgdGhleSBleGlzdC5cbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cyA9IHVuc2VudEVudHJpZXM7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzZWVtcyBtb3JlIGxpa2VseSB0aGFuIGVtcHR5aW5nIHRoZSBhcnJheSAoYmVsb3cpIHRvIGxlYWQgdG8gc29tZSBvZGQgc3RhdGVcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgY2FjaGUgaXNuJ3QgZW1wdHkgYW5kIHRoaXMgd2lsbCBiZSBjYWxsZWQgYWdhaW4gb24gdGhlIG5leHQgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAvLyBhbmQgaXMgcHJvYmFibHkgc2FmZXN0IGlmIHdlIGF3YWl0IGl0LlxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3N0b3JhZ2Uub3ZlcndyaXRlKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cyA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdCB3YWl0IGZvciB0aGlzLCB0byByZWR1Y2UgbGF0ZW5jeS5cbiAgICAgICAgICAgICAgICB2b2lkIHRoaXMuX3N0b3JhZ2Uub3ZlcndyaXRlKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGVhZGVyU3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihlKTtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFVUQ0RhdGVTdHJpbmcoKSB7XG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgIC8vIFJldHVybnMgZGF0ZSBmb3JtYXQgJ1lZWVktTU0tREQnXG4gICAgcmV0dXJuIHRvZGF5LnRvSVNPU3RyaW5nKCkuc3Vic3RyaW5nKDAsIDEwKTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RIZWFydGJlYXRzRm9ySGVhZGVyKGhlYXJ0YmVhdHNDYWNoZSwgbWF4U2l6ZSA9IE1BWF9IRUFERVJfQllURVMpIHtcbiAgICAvLyBIZWFydGJlYXRzIGdyb3VwZWQgYnkgdXNlciBhZ2VudCBpbiB0aGUgc3RhbmRhcmQgZm9ybWF0IHRvIGJlIHNlbnQgaW5cbiAgICAvLyB0aGUgaGVhZGVyLlxuICAgIGNvbnN0IGhlYXJ0YmVhdHNUb1NlbmQgPSBbXTtcbiAgICAvLyBTaW5nbGUgZGF0ZSBmb3JtYXQgaGVhcnRiZWF0cyB0aGF0IGFyZSBub3Qgc2VudC5cbiAgICBsZXQgdW5zZW50RW50cmllcyA9IGhlYXJ0YmVhdHNDYWNoZS5zbGljZSgpO1xuICAgIGZvciAoY29uc3Qgc2luZ2xlRGF0ZUhlYXJ0YmVhdCBvZiBoZWFydGJlYXRzQ2FjaGUpIHtcbiAgICAgICAgLy8gTG9vayBmb3IgYW4gZXhpc3RpbmcgZW50cnkgd2l0aCB0aGUgc2FtZSB1c2VyIGFnZW50LlxuICAgICAgICBjb25zdCBoZWFydGJlYXRFbnRyeSA9IGhlYXJ0YmVhdHNUb1NlbmQuZmluZChoYiA9PiBoYi5hZ2VudCA9PT0gc2luZ2xlRGF0ZUhlYXJ0YmVhdC5hZ2VudCk7XG4gICAgICAgIGlmICghaGVhcnRiZWF0RW50cnkpIHtcbiAgICAgICAgICAgIC8vIElmIG5vIGVudHJ5IGZvciB0aGlzIHVzZXIgYWdlbnQgZXhpc3RzLCBjcmVhdGUgb25lLlxuICAgICAgICAgICAgaGVhcnRiZWF0c1RvU2VuZC5wdXNoKHtcbiAgICAgICAgICAgICAgICBhZ2VudDogc2luZ2xlRGF0ZUhlYXJ0YmVhdC5hZ2VudCxcbiAgICAgICAgICAgICAgICBkYXRlczogW3NpbmdsZURhdGVIZWFydGJlYXQuZGF0ZV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNvdW50Qnl0ZXMoaGVhcnRiZWF0c1RvU2VuZCkgPiBtYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGhlYWRlciB3b3VsZCBleGNlZWQgbWF4IHNpemUsIHJlbW92ZSB0aGUgYWRkZWQgaGVhcnRiZWF0XG4gICAgICAgICAgICAgICAgLy8gZW50cnkgYW5kIHN0b3AgYWRkaW5nIHRvIHRoZSBoZWFkZXIuXG4gICAgICAgICAgICAgICAgaGVhcnRiZWF0c1RvU2VuZC5wb3AoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhlYXJ0YmVhdEVudHJ5LmRhdGVzLnB1c2goc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBoZWFkZXIgd291bGQgZXhjZWVkIG1heCBzaXplLCByZW1vdmUgdGhlIGFkZGVkIGRhdGVcbiAgICAgICAgICAgIC8vIGFuZCBzdG9wIGFkZGluZyB0byB0aGUgaGVhZGVyLlxuICAgICAgICAgICAgaWYgKGNvdW50Qnl0ZXMoaGVhcnRiZWF0c1RvU2VuZCkgPiBtYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgaGVhcnRiZWF0RW50cnkuZGF0ZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUG9wIHVuc2VudCBlbnRyeSBmcm9tIHF1ZXVlLiAoU2tpcHBlZCBpZiBhZGRpbmcgdGhlIGVudHJ5IGV4Y2VlZGVkXG4gICAgICAgIC8vIHF1b3RhIGFuZCB0aGUgbG9vcCBicmVha3MgZWFybHkuKVxuICAgICAgICB1bnNlbnRFbnRyaWVzID0gdW5zZW50RW50cmllcy5zbGljZSgxKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGVhcnRiZWF0c1RvU2VuZCxcbiAgICAgICAgdW5zZW50RW50cmllc1xuICAgIH07XG59XG5jbGFzcyBIZWFydGJlYXRTdG9yYWdlSW1wbCB7XG4gICAgY29uc3RydWN0b3IoYXBwKSB7XG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xuICAgICAgICB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlID0gdGhpcy5ydW5JbmRleGVkREJFbnZpcm9ubWVudENoZWNrKCk7XG4gICAgfVxuICAgIGFzeW5jIHJ1bkluZGV4ZWREQkVudmlyb25tZW50Q2hlY2soKSB7XG4gICAgICAgIGlmICghaXNJbmRleGVkREJBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUoKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRydWUpXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGFsbCBoZWFydGJlYXRzLlxuICAgICAqL1xuICAgIGFzeW5jIHJlYWQoKSB7XG4gICAgICAgIGNvbnN0IGNhblVzZUluZGV4ZWREQiA9IGF3YWl0IHRoaXMuX2NhblVzZUluZGV4ZWREQlByb21pc2U7XG4gICAgICAgIGlmICghY2FuVXNlSW5kZXhlZERCKSB7XG4gICAgICAgICAgICByZXR1cm4geyBoZWFydGJlYXRzOiBbXSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaWRiSGVhcnRiZWF0T2JqZWN0ID0gYXdhaXQgcmVhZEhlYXJ0YmVhdHNGcm9tSW5kZXhlZERCKHRoaXMuYXBwKTtcbiAgICAgICAgICAgIGlmIChpZGJIZWFydGJlYXRPYmplY3QgPT09IG51bGwgfHwgaWRiSGVhcnRiZWF0T2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpZGJIZWFydGJlYXRPYmplY3QuaGVhcnRiZWF0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZGJIZWFydGJlYXRPYmplY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBoZWFydGJlYXRzOiBbXSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG92ZXJ3cml0ZSB0aGUgc3RvcmFnZSB3aXRoIHRoZSBwcm92aWRlZCBoZWFydGJlYXRzXG4gICAgYXN5bmMgb3ZlcndyaXRlKGhlYXJ0YmVhdHNPYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjYW5Vc2VJbmRleGVkREIgPSBhd2FpdCB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlO1xuICAgICAgICBpZiAoIWNhblVzZUluZGV4ZWREQikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0ID0gYXdhaXQgdGhpcy5yZWFkKCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVIZWFydGJlYXRzVG9JbmRleGVkREIodGhpcy5hcHAsIHtcbiAgICAgICAgICAgICAgICBsYXN0U2VudEhlYXJ0YmVhdERhdGU6IChfYSA9IGhlYXJ0YmVhdHNPYmplY3QubGFzdFNlbnRIZWFydGJlYXREYXRlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBleGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QubGFzdFNlbnRIZWFydGJlYXREYXRlLFxuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdHM6IGhlYXJ0YmVhdHNPYmplY3QuaGVhcnRiZWF0c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWRkIGhlYXJ0YmVhdHNcbiAgICBhc3luYyBhZGQoaGVhcnRiZWF0c09iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNhblVzZUluZGV4ZWREQiA9IGF3YWl0IHRoaXMuX2NhblVzZUluZGV4ZWREQlByb21pc2U7XG4gICAgICAgIGlmICghY2FuVXNlSW5kZXhlZERCKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QgPSBhd2FpdCB0aGlzLnJlYWQoKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZUhlYXJ0YmVhdHNUb0luZGV4ZWREQih0aGlzLmFwcCwge1xuICAgICAgICAgICAgICAgIGxhc3RTZW50SGVhcnRiZWF0RGF0ZTogKF9hID0gaGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUsXG4gICAgICAgICAgICAgICAgaGVhcnRiZWF0czogW1xuICAgICAgICAgICAgICAgICAgICAuLi5leGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QuaGVhcnRiZWF0cyxcbiAgICAgICAgICAgICAgICAgICAgLi4uaGVhcnRiZWF0c09iamVjdC5oZWFydGJlYXRzXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIENhbGN1bGF0ZSBieXRlcyBvZiBhIEhlYXJ0YmVhdHNCeVVzZXJBZ2VudCBhcnJheSBhZnRlciBiZWluZyB3cmFwcGVkXG4gKiBpbiBhIHBsYXRmb3JtIGxvZ2dpbmcgaGVhZGVyIEpTT04gb2JqZWN0LCBzdHJpbmdpZmllZCwgYW5kIGNvbnZlcnRlZFxuICogdG8gYmFzZSA2NC5cbiAqL1xuZnVuY3Rpb24gY291bnRCeXRlcyhoZWFydGJlYXRzQ2FjaGUpIHtcbiAgICAvLyBiYXNlNjQgaGFzIGEgcmVzdHJpY3RlZCBzZXQgb2YgY2hhcmFjdGVycywgYWxsIG9mIHdoaWNoIHNob3VsZCBiZSAxIGJ5dGUuXG4gICAgcmV0dXJuIGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nKFxuICAgIC8vIGhlYXJ0YmVhdHNDYWNoZSB3cmFwcGVyIHByb3BlcnRpZXNcbiAgICBKU09OLnN0cmluZ2lmeSh7IHZlcnNpb246IDIsIGhlYXJ0YmVhdHM6IGhlYXJ0YmVhdHNDYWNoZSB9KSkubGVuZ3RoO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJDb3JlQ29tcG9uZW50cyh2YXJpYW50KSB7XG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ3BsYXRmb3JtLWxvZ2dlcicsIGNvbnRhaW5lciA9PiBuZXcgUGxhdGZvcm1Mb2dnZXJTZXJ2aWNlSW1wbChjb250YWluZXIpLCBcIlBSSVZBVEVcIiAvKiBDb21wb25lbnRUeXBlLlBSSVZBVEUgKi8pKTtcbiAgICBfcmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudCgnaGVhcnRiZWF0JywgY29udGFpbmVyID0+IG5ldyBIZWFydGJlYXRTZXJ2aWNlSW1wbChjb250YWluZXIpLCBcIlBSSVZBVEVcIiAvKiBDb21wb25lbnRUeXBlLlBSSVZBVEUgKi8pKTtcbiAgICAvLyBSZWdpc3RlciBgYXBwYCBwYWNrYWdlLlxuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lJHEsIHZlcnNpb24kMSwgdmFyaWFudCk7XG4gICAgLy8gQlVJTERfVEFSR0VUIHdpbGwgYmUgcmVwbGFjZWQgYnkgdmFsdWVzIGxpa2UgZXNtMjAxNywgY2pzMjAxNywgZXRjIGR1cmluZyB0aGUgY29tcGlsYXRpb25cbiAgICByZWdpc3RlclZlcnNpb24obmFtZSRxLCB2ZXJzaW9uJDEsICdlc20yMDE3Jyk7XG4gICAgLy8gUmVnaXN0ZXIgcGxhdGZvcm0gU0RLIGlkZW50aWZpZXIgKG5vIHZlcnNpb24pLlxuICAgIHJlZ2lzdGVyVmVyc2lvbignZmlyZS1qcycsICcnKTtcbn1cblxuLyoqXG4gKiBGaXJlYmFzZSBBcHBcbiAqXG4gKiBAcmVtYXJrcyBUaGlzIHBhY2thZ2UgY29vcmRpbmF0ZXMgdGhlIGNvbW11bmljYXRpb24gYmV0d2VlbiB0aGUgZGlmZmVyZW50IEZpcmViYXNlIGNvbXBvbmVudHNcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5yZWdpc3RlckNvcmVDb21wb25lbnRzKCcnKTtcblxuZXhwb3J0IHsgU0RLX1ZFUlNJT04sIERFRkFVTFRfRU5UUllfTkFNRSBhcyBfREVGQVVMVF9FTlRSWV9OQU1FLCBfYWRkQ29tcG9uZW50LCBfYWRkT3JPdmVyd3JpdGVDb21wb25lbnQsIF9hcHBzLCBfY2xlYXJDb21wb25lbnRzLCBfY29tcG9uZW50cywgX2dldFByb3ZpZGVyLCBfaXNGaXJlYmFzZUFwcCwgX2lzRmlyZWJhc2VTZXJ2ZXJBcHAsIF9yZWdpc3RlckNvbXBvbmVudCwgX3JlbW92ZVNlcnZpY2VJbnN0YW5jZSwgX3NlcnZlckFwcHMsIGRlbGV0ZUFwcCwgZ2V0QXBwLCBnZXRBcHBzLCBpbml0aWFsaXplQXBwLCBpbml0aWFsaXplU2VydmVyQXBwLCBvbkxvZywgcmVnaXN0ZXJWZXJzaW9uLCBzZXRMb2dMZXZlbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtMjAxNy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js":
/*!********************************************************************!*\
  !*** ./node_modules/@firebase/component/dist/esm/index.esm2017.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Component: () => (/* binding */ Component),\n/* harmony export */   ComponentContainer: () => (/* binding */ ComponentContainer),\n/* harmony export */   Provider: () => (/* binding */ Provider)\n/* harmony export */ });\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n\n\n/**\n * Component for service name T, e.g. `auth`, `auth-internal`\n */\nclass Component {\n    /**\n     *\n     * @param name The public service name, e.g. app, auth, firestore, database\n     * @param instanceFactory Service factory responsible for creating the public interface\n     * @param type whether the service provided by the component is public or private\n     */\n    constructor(name, instanceFactory, type) {\n        this.name = name;\n        this.instanceFactory = instanceFactory;\n        this.type = type;\n        this.multipleInstances = false;\n        /**\n         * Properties to be added to the service namespace\n         */\n        this.serviceProps = {};\n        this.instantiationMode = \"LAZY\" /* InstantiationMode.LAZY */;\n        this.onInstanceCreated = null;\n    }\n    setInstantiationMode(mode) {\n        this.instantiationMode = mode;\n        return this;\n    }\n    setMultipleInstances(multipleInstances) {\n        this.multipleInstances = multipleInstances;\n        return this;\n    }\n    setServiceProps(props) {\n        this.serviceProps = props;\n        return this;\n    }\n    setInstanceCreatedCallback(callback) {\n        this.onInstanceCreated = callback;\n        return this;\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\n * NameServiceMapping[T] is an alias for the type of the instance\n */\nclass Provider {\n    constructor(name, container) {\n        this.name = name;\n        this.container = container;\n        this.component = null;\n        this.instances = new Map();\n        this.instancesDeferred = new Map();\n        this.instancesOptions = new Map();\n        this.onInitCallbacks = new Map();\n    }\n    /**\n     * @param identifier A provider can provide multiple instances of a service\n     * if this.component.multipleInstances is true.\n     */\n    get(identifier) {\n        // if multipleInstances is not supported, use the default name\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n        if (!this.instancesDeferred.has(normalizedIdentifier)) {\n            const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n            this.instancesDeferred.set(normalizedIdentifier, deferred);\n            if (this.isInitialized(normalizedIdentifier) ||\n                this.shouldAutoInitialize()) {\n                // initialize the service if it can be auto-initialized\n                try {\n                    const instance = this.getOrInitializeService({\n                        instanceIdentifier: normalizedIdentifier\n                    });\n                    if (instance) {\n                        deferred.resolve(instance);\n                    }\n                }\n                catch (e) {\n                    // when the instance factory throws an exception during get(), it should not cause\n                    // a fatal error. We just return the unresolved promise in this case.\n                }\n            }\n        }\n        return this.instancesDeferred.get(normalizedIdentifier).promise;\n    }\n    getImmediate(options) {\n        var _a;\n        // if multipleInstances is not supported, use the default name\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\n        const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\n        if (this.isInitialized(normalizedIdentifier) ||\n            this.shouldAutoInitialize()) {\n            try {\n                return this.getOrInitializeService({\n                    instanceIdentifier: normalizedIdentifier\n                });\n            }\n            catch (e) {\n                if (optional) {\n                    return null;\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        else {\n            // In case a component is not initialized and should/cannot be auto-initialized at the moment, return null if the optional flag is set, or throw\n            if (optional) {\n                return null;\n            }\n            else {\n                throw Error(`Service ${this.name} is not available`);\n            }\n        }\n    }\n    getComponent() {\n        return this.component;\n    }\n    setComponent(component) {\n        if (component.name !== this.name) {\n            throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);\n        }\n        if (this.component) {\n            throw Error(`Component for ${this.name} has already been provided`);\n        }\n        this.component = component;\n        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\n        if (!this.shouldAutoInitialize()) {\n            return;\n        }\n        // if the service is eager, initialize the default instance\n        if (isComponentEager(component)) {\n            try {\n                this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });\n            }\n            catch (e) {\n                // when the instance factory for an eager Component throws an exception during the eager\n                // initialization, it should not cause a fatal error.\n                // TODO: Investigate if we need to make it configurable, because some component may want to cause\n                // a fatal error in this case?\n            }\n        }\n        // Create service instances for the pending promises and resolve them\n        // NOTE: if this.multipleInstances is false, only the default instance will be created\n        // and all promises with resolve with it regardless of the identifier.\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\n            const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n            try {\n                // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\n                const instance = this.getOrInitializeService({\n                    instanceIdentifier: normalizedIdentifier\n                });\n                instanceDeferred.resolve(instance);\n            }\n            catch (e) {\n                // when the instance factory throws an exception, it should not cause\n                // a fatal error. We just leave the promise unresolved.\n            }\n        }\n    }\n    clearInstance(identifier = DEFAULT_ENTRY_NAME) {\n        this.instancesDeferred.delete(identifier);\n        this.instancesOptions.delete(identifier);\n        this.instances.delete(identifier);\n    }\n    // app.delete() will call this method on every provider to delete the services\n    // TODO: should we mark the provider as deleted?\n    async delete() {\n        const services = Array.from(this.instances.values());\n        await Promise.all([\n            ...services\n                .filter(service => 'INTERNAL' in service) // legacy services\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                .map(service => service.INTERNAL.delete()),\n            ...services\n                .filter(service => '_delete' in service) // modularized services\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                .map(service => service._delete())\n        ]);\n    }\n    isComponentSet() {\n        return this.component != null;\n    }\n    isInitialized(identifier = DEFAULT_ENTRY_NAME) {\n        return this.instances.has(identifier);\n    }\n    getOptions(identifier = DEFAULT_ENTRY_NAME) {\n        return this.instancesOptions.get(identifier) || {};\n    }\n    initialize(opts = {}) {\n        const { options = {} } = opts;\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\n        if (this.isInitialized(normalizedIdentifier)) {\n            throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);\n        }\n        if (!this.isComponentSet()) {\n            throw Error(`Component ${this.name} has not been registered yet`);\n        }\n        const instance = this.getOrInitializeService({\n            instanceIdentifier: normalizedIdentifier,\n            options\n        });\n        // resolve any pending promise waiting for the service instance\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\n            const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n            if (normalizedIdentifier === normalizedDeferredIdentifier) {\n                instanceDeferred.resolve(instance);\n            }\n        }\n        return instance;\n    }\n    /**\n     *\n     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\n     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\n     *\n     * @param identifier An optional instance identifier\n     * @returns a function to unregister the callback\n     */\n    onInit(callback, identifier) {\n        var _a;\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n        const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();\n        existingCallbacks.add(callback);\n        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\n        const existingInstance = this.instances.get(normalizedIdentifier);\n        if (existingInstance) {\n            callback(existingInstance, normalizedIdentifier);\n        }\n        return () => {\n            existingCallbacks.delete(callback);\n        };\n    }\n    /**\n     * Invoke onInit callbacks synchronously\n     * @param instance the service instance`\n     */\n    invokeOnInitCallbacks(instance, identifier) {\n        const callbacks = this.onInitCallbacks.get(identifier);\n        if (!callbacks) {\n            return;\n        }\n        for (const callback of callbacks) {\n            try {\n                callback(instance, identifier);\n            }\n            catch (_a) {\n                // ignore errors in the onInit callback\n            }\n        }\n    }\n    getOrInitializeService({ instanceIdentifier, options = {} }) {\n        let instance = this.instances.get(instanceIdentifier);\n        if (!instance && this.component) {\n            instance = this.component.instanceFactory(this.container, {\n                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\n                options\n            });\n            this.instances.set(instanceIdentifier, instance);\n            this.instancesOptions.set(instanceIdentifier, options);\n            /**\n             * Invoke onInit listeners.\n             * Note this.component.onInstanceCreated is different, which is used by the component creator,\n             * while onInit listeners are registered by consumers of the provider.\n             */\n            this.invokeOnInitCallbacks(instance, instanceIdentifier);\n            /**\n             * Order is important\n             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\n             * makes `isInitialized()` return true.\n             */\n            if (this.component.onInstanceCreated) {\n                try {\n                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\n                }\n                catch (_a) {\n                    // ignore errors in the onInstanceCreatedCallback\n                }\n            }\n        }\n        return instance || null;\n    }\n    normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {\n        if (this.component) {\n            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\n        }\n        else {\n            return identifier; // assume multiple instances are supported before the component is provided.\n        }\n    }\n    shouldAutoInitialize() {\n        return (!!this.component &&\n            this.component.instantiationMode !== \"EXPLICIT\" /* InstantiationMode.EXPLICIT */);\n    }\n}\n// undefined should be passed to the service factory for the default instance\nfunction normalizeIdentifierForFactory(identifier) {\n    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\n}\nfunction isComponentEager(component) {\n    return component.instantiationMode === \"EAGER\" /* InstantiationMode.EAGER */;\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\n */\nclass ComponentContainer {\n    constructor(name) {\n        this.name = name;\n        this.providers = new Map();\n    }\n    /**\n     *\n     * @param component Component being added\n     * @param overwrite When a component with the same name has already been registered,\n     * if overwrite is true: overwrite the existing component with the new component and create a new\n     * provider with the new component. It can be useful in tests where you want to use different mocks\n     * for different tests.\n     * if overwrite is false: throw an exception\n     */\n    addComponent(component) {\n        const provider = this.getProvider(component.name);\n        if (provider.isComponentSet()) {\n            throw new Error(`Component ${component.name} has already been registered with ${this.name}`);\n        }\n        provider.setComponent(component);\n    }\n    addOrOverwriteComponent(component) {\n        const provider = this.getProvider(component.name);\n        if (provider.isComponentSet()) {\n            // delete the existing provider from the container, so we can register the new component\n            this.providers.delete(component.name);\n        }\n        this.addComponent(component);\n    }\n    /**\n     * getProvider provides a type safe interface where it can only be called with a field name\n     * present in NameServiceMapping interface.\n     *\n     * Firebase SDKs providing services should extend NameServiceMapping interface to register\n     * themselves.\n     */\n    getProvider(name) {\n        if (this.providers.has(name)) {\n            return this.providers.get(name);\n        }\n        // create a Provider for a service that hasn't registered with Firebase\n        const provider = new Provider(name, this);\n        this.providers.set(name, provider);\n        return provider;\n    }\n    getProviders() {\n        return Array.from(this.providers.values());\n    }\n}\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2NvbXBvbmVudC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0RBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQixlQUFlLFVBQVU7QUFDMUY7QUFDQTtBQUNBLHlDQUF5QyxXQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3Q0FBd0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0EsMkJBQTJCLFVBQVUsR0FBRyxxQkFBcUI7QUFDN0Q7QUFDQTtBQUNBLHFDQUFxQyxXQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtDQUFrQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnQkFBZ0IsbUNBQW1DLFVBQVU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1EO0FBQ25EIiwic291cmNlcyI6WyIvVXNlcnMvdnRwYXRlbDA3L1BhdGVsQ01QMjMzRmluYWxQcm9qZWN0L25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvY29tcG9uZW50L2Rpc3QvZXNtL2luZGV4LmVzbTIwMTcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVmZXJyZWQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5cbi8qKlxuICogQ29tcG9uZW50IGZvciBzZXJ2aWNlIG5hbWUgVCwgZS5nLiBgYXV0aGAsIGBhdXRoLWludGVybmFsYFxuICovXG5jbGFzcyBDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIHB1YmxpYyBzZXJ2aWNlIG5hbWUsIGUuZy4gYXBwLCBhdXRoLCBmaXJlc3RvcmUsIGRhdGFiYXNlXG4gICAgICogQHBhcmFtIGluc3RhbmNlRmFjdG9yeSBTZXJ2aWNlIGZhY3RvcnkgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoZSBwdWJsaWMgaW50ZXJmYWNlXG4gICAgICogQHBhcmFtIHR5cGUgd2hldGhlciB0aGUgc2VydmljZSBwcm92aWRlZCBieSB0aGUgY29tcG9uZW50IGlzIHB1YmxpYyBvciBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgaW5zdGFuY2VGYWN0b3J5LCB0eXBlKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VGYWN0b3J5ID0gaW5zdGFuY2VGYWN0b3J5O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLm11bHRpcGxlSW5zdGFuY2VzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIHRvIGJlIGFkZGVkIHRvIHRoZSBzZXJ2aWNlIG5hbWVzcGFjZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXJ2aWNlUHJvcHMgPSB7fTtcbiAgICAgICAgdGhpcy5pbnN0YW50aWF0aW9uTW9kZSA9IFwiTEFaWVwiIC8qIEluc3RhbnRpYXRpb25Nb2RlLkxBWlkgKi87XG4gICAgICAgIHRoaXMub25JbnN0YW5jZUNyZWF0ZWQgPSBudWxsO1xuICAgIH1cbiAgICBzZXRJbnN0YW50aWF0aW9uTW9kZShtb2RlKSB7XG4gICAgICAgIHRoaXMuaW5zdGFudGlhdGlvbk1vZGUgPSBtb2RlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0TXVsdGlwbGVJbnN0YW5jZXMobXVsdGlwbGVJbnN0YW5jZXMpIHtcbiAgICAgICAgdGhpcy5tdWx0aXBsZUluc3RhbmNlcyA9IG11bHRpcGxlSW5zdGFuY2VzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0U2VydmljZVByb3BzKHByb3BzKSB7XG4gICAgICAgIHRoaXMuc2VydmljZVByb3BzID0gcHJvcHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRJbnN0YW5jZUNyZWF0ZWRDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm9uSW5zdGFuY2VDcmVhdGVkID0gY2FsbGJhY2s7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IERFRkFVTFRfRU5UUllfTkFNRSA9ICdbREVGQVVMVF0nO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBQcm92aWRlciBmb3IgaW5zdGFuY2UgZm9yIHNlcnZpY2UgbmFtZSBULCBlLmcuICdhdXRoJywgJ2F1dGgtaW50ZXJuYWwnXG4gKiBOYW1lU2VydmljZU1hcHBpbmdbVF0gaXMgYW4gYWxpYXMgZm9yIHRoZSB0eXBlIG9mIHRoZSBpbnN0YW5jZVxuICovXG5jbGFzcyBQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmluc3RhbmNlc0RlZmVycmVkID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmluc3RhbmNlc09wdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMub25Jbml0Q2FsbGJhY2tzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gaWRlbnRpZmllciBBIHByb3ZpZGVyIGNhbiBwcm92aWRlIG11bHRpcGxlIGluc3RhbmNlcyBvZiBhIHNlcnZpY2VcbiAgICAgKiBpZiB0aGlzLmNvbXBvbmVudC5tdWx0aXBsZUluc3RhbmNlcyBpcyB0cnVlLlxuICAgICAqL1xuICAgIGdldChpZGVudGlmaWVyKSB7XG4gICAgICAgIC8vIGlmIG11bHRpcGxlSW5zdGFuY2VzIGlzIG5vdCBzdXBwb3J0ZWQsIHVzZSB0aGUgZGVmYXVsdCBuYW1lXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICAgIGlmICghdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5oYXMobm9ybWFsaXplZElkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5zZXQobm9ybWFsaXplZElkZW50aWZpZXIsIGRlZmVycmVkKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQobm9ybWFsaXplZElkZW50aWZpZXIpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zaG91bGRBdXRvSW5pdGlhbGl6ZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgc2VydmljZSBpZiBpdCBjYW4gYmUgYXV0by1pbml0aWFsaXplZFxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgaW5zdGFuY2UgZmFjdG9yeSB0aHJvd3MgYW4gZXhjZXB0aW9uIGR1cmluZyBnZXQoKSwgaXQgc2hvdWxkIG5vdCBjYXVzZVxuICAgICAgICAgICAgICAgICAgICAvLyBhIGZhdGFsIGVycm9yLiBXZSBqdXN0IHJldHVybiB0aGUgdW5yZXNvbHZlZCBwcm9taXNlIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuZ2V0KG5vcm1hbGl6ZWRJZGVudGlmaWVyKS5wcm9taXNlO1xuICAgIH1cbiAgICBnZXRJbW1lZGlhdGUob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIGlmIG11bHRpcGxlSW5zdGFuY2VzIGlzIG5vdCBzdXBwb3J0ZWQsIHVzZSB0aGUgZGVmYXVsdCBuYW1lXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlkZW50aWZpZXIpO1xuICAgICAgICBjb25zdCBvcHRpb25hbCA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vcHRpb25hbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQobm9ybWFsaXplZElkZW50aWZpZXIpIHx8XG4gICAgICAgICAgICB0aGlzLnNob3VsZEF1dG9Jbml0aWFsaXplKCkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJbiBjYXNlIGEgY29tcG9uZW50IGlzIG5vdCBpbml0aWFsaXplZCBhbmQgc2hvdWxkL2Nhbm5vdCBiZSBhdXRvLWluaXRpYWxpemVkIGF0IHRoZSBtb21lbnQsIHJldHVybiBudWxsIGlmIHRoZSBvcHRpb25hbCBmbGFnIGlzIHNldCwgb3IgdGhyb3dcbiAgICAgICAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFNlcnZpY2UgJHt0aGlzLm5hbWV9IGlzIG5vdCBhdmFpbGFibGVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDb21wb25lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudDtcbiAgICB9XG4gICAgc2V0Q29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoY29tcG9uZW50Lm5hbWUgIT09IHRoaXMubmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYE1pc21hdGNoaW5nIENvbXBvbmVudCAke2NvbXBvbmVudC5uYW1lfSBmb3IgUHJvdmlkZXIgJHt0aGlzLm5hbWV9LmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYENvbXBvbmVudCBmb3IgJHt0aGlzLm5hbWV9IGhhcyBhbHJlYWR5IGJlZW4gcHJvdmlkZWRgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgLy8gcmV0dXJuIGVhcmx5IHdpdGhvdXQgYXR0ZW1wdGluZyB0byBpbml0aWFsaXplIHRoZSBjb21wb25lbnQgaWYgdGhlIGNvbXBvbmVudCByZXF1aXJlcyBleHBsaWNpdCBpbml0aWFsaXphdGlvbiAoY2FsbGluZyBgUHJvdmlkZXIuaW5pdGlhbGl6ZSgpYClcbiAgICAgICAgaWYgKCF0aGlzLnNob3VsZEF1dG9Jbml0aWFsaXplKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgc2VydmljZSBpcyBlYWdlciwgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZVxuICAgICAgICBpZiAoaXNDb21wb25lbnRFYWdlcihjb21wb25lbnQpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7IGluc3RhbmNlSWRlbnRpZmllcjogREVGQVVMVF9FTlRSWV9OQU1FIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBpbnN0YW5jZSBmYWN0b3J5IGZvciBhbiBlYWdlciBDb21wb25lbnQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBkdXJpbmcgdGhlIGVhZ2VyXG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6YXRpb24sIGl0IHNob3VsZCBub3QgY2F1c2UgYSBmYXRhbCBlcnJvci5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBJbnZlc3RpZ2F0ZSBpZiB3ZSBuZWVkIHRvIG1ha2UgaXQgY29uZmlndXJhYmxlLCBiZWNhdXNlIHNvbWUgY29tcG9uZW50IG1heSB3YW50IHRvIGNhdXNlXG4gICAgICAgICAgICAgICAgLy8gYSBmYXRhbCBlcnJvciBpbiB0aGlzIGNhc2U/XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIHNlcnZpY2UgaW5zdGFuY2VzIGZvciB0aGUgcGVuZGluZyBwcm9taXNlcyBhbmQgcmVzb2x2ZSB0aGVtXG4gICAgICAgIC8vIE5PVEU6IGlmIHRoaXMubXVsdGlwbGVJbnN0YW5jZXMgaXMgZmFsc2UsIG9ubHkgdGhlIGRlZmF1bHQgaW5zdGFuY2Ugd2lsbCBiZSBjcmVhdGVkXG4gICAgICAgIC8vIGFuZCBhbGwgcHJvbWlzZXMgd2l0aCByZXNvbHZlIHdpdGggaXQgcmVnYXJkbGVzcyBvZiB0aGUgaWRlbnRpZmllci5cbiAgICAgICAgZm9yIChjb25zdCBbaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZURlZmVycmVkXSBvZiB0aGlzLmluc3RhbmNlc0RlZmVycmVkLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpbnN0YW5jZUlkZW50aWZpZXIpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBgZ2V0T3JJbml0aWFsaXplU2VydmljZSgpYCBzaG91bGQgYWx3YXlzIHJldHVybiBhIHZhbGlkIGluc3RhbmNlIHNpbmNlIGEgY29tcG9uZW50IGlzIGd1YXJhbnRlZWQuIHVzZSAhIHRvIG1ha2UgdHlwZXNjcmlwdCBoYXBweS5cbiAgICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZURlZmVycmVkLnJlc29sdmUoaW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBpbnN0YW5jZSBmYWN0b3J5IHRocm93cyBhbiBleGNlcHRpb24sIGl0IHNob3VsZCBub3QgY2F1c2VcbiAgICAgICAgICAgICAgICAvLyBhIGZhdGFsIGVycm9yLiBXZSBqdXN0IGxlYXZlIHRoZSBwcm9taXNlIHVucmVzb2x2ZWQuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJJbnN0YW5jZShpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuZGVsZXRlKGlkZW50aWZpZXIpO1xuICAgICAgICB0aGlzLmluc3RhbmNlc09wdGlvbnMuZGVsZXRlKGlkZW50aWZpZXIpO1xuICAgICAgICB0aGlzLmluc3RhbmNlcy5kZWxldGUoaWRlbnRpZmllcik7XG4gICAgfVxuICAgIC8vIGFwcC5kZWxldGUoKSB3aWxsIGNhbGwgdGhpcyBtZXRob2Qgb24gZXZlcnkgcHJvdmlkZXIgdG8gZGVsZXRlIHRoZSBzZXJ2aWNlc1xuICAgIC8vIFRPRE86IHNob3VsZCB3ZSBtYXJrIHRoZSBwcm92aWRlciBhcyBkZWxldGVkP1xuICAgIGFzeW5jIGRlbGV0ZSgpIHtcbiAgICAgICAgY29uc3Qgc2VydmljZXMgPSBBcnJheS5mcm9tKHRoaXMuaW5zdGFuY2VzLnZhbHVlcygpKTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgLi4uc2VydmljZXNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKHNlcnZpY2UgPT4gJ0lOVEVSTkFMJyBpbiBzZXJ2aWNlKSAvLyBsZWdhY3kgc2VydmljZXNcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIC5tYXAoc2VydmljZSA9PiBzZXJ2aWNlLklOVEVSTkFMLmRlbGV0ZSgpKSxcbiAgICAgICAgICAgIC4uLnNlcnZpY2VzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihzZXJ2aWNlID0+ICdfZGVsZXRlJyBpbiBzZXJ2aWNlKSAvLyBtb2R1bGFyaXplZCBzZXJ2aWNlc1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgLm1hcChzZXJ2aWNlID0+IHNlcnZpY2UuX2RlbGV0ZSgpKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgaXNDb21wb25lbnRTZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudCAhPSBudWxsO1xuICAgIH1cbiAgICBpc0luaXRpYWxpemVkKGlkZW50aWZpZXIgPSBERUZBVUxUX0VOVFJZX05BTUUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VzLmhhcyhpZGVudGlmaWVyKTtcbiAgICB9XG4gICAgZ2V0T3B0aW9ucyhpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlc09wdGlvbnMuZ2V0KGlkZW50aWZpZXIpIHx8IHt9O1xuICAgIH1cbiAgICBpbml0aWFsaXplKG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMgPSB7fSB9ID0gb3B0cztcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihvcHRzLmluc3RhbmNlSWRlbnRpZmllcik7XG4gICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQobm9ybWFsaXplZElkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgJHt0aGlzLm5hbWV9KCR7bm9ybWFsaXplZElkZW50aWZpZXJ9KSBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzQ29tcG9uZW50U2V0KCkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBDb21wb25lbnQgJHt0aGlzLm5hbWV9IGhhcyBub3QgYmVlbiByZWdpc3RlcmVkIHlldGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcbiAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXIsXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICAvLyByZXNvbHZlIGFueSBwZW5kaW5nIHByb21pc2Ugd2FpdGluZyBmb3IgdGhlIHNlcnZpY2UgaW5zdGFuY2VcbiAgICAgICAgZm9yIChjb25zdCBbaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZURlZmVycmVkXSBvZiB0aGlzLmluc3RhbmNlc0RlZmVycmVkLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZERlZmVycmVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKGluc3RhbmNlSWRlbnRpZmllcik7XG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZElkZW50aWZpZXIgPT09IG5vcm1hbGl6ZWREZWZlcnJlZElkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZURlZmVycmVkLnJlc29sdmUoaW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkICBhZnRlciB0aGUgcHJvdmlkZXIgaGFzIGJlZW4gaW5pdGlhbGl6ZWQgYnkgY2FsbGluZyBwcm92aWRlci5pbml0aWFsaXplKCkuXG4gICAgICogVGhlIGZ1bmN0aW9uIGlzIGludm9rZWQgU1lOQ0hST05PVVNMWSwgc28gaXQgc2hvdWxkIG5vdCBleGVjdXRlIGFueSBsb25ncnVubmluZyB0YXNrcyBpbiBvcmRlciB0byBub3QgYmxvY2sgdGhlIHByb2dyYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWRlbnRpZmllciBBbiBvcHRpb25hbCBpbnN0YW5jZSBpZGVudGlmaWVyXG4gICAgICogQHJldHVybnMgYSBmdW5jdGlvbiB0byB1bnJlZ2lzdGVyIHRoZSBjYWxsYmFja1xuICAgICAqL1xuICAgIG9uSW5pdChjYWxsYmFjaywgaWRlbnRpZmllcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQ2FsbGJhY2tzID0gKF9hID0gdGhpcy5vbkluaXRDYWxsYmFja3MuZ2V0KG5vcm1hbGl6ZWRJZGVudGlmaWVyKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFNldCgpO1xuICAgICAgICBleGlzdGluZ0NhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuICAgICAgICB0aGlzLm9uSW5pdENhbGxiYWNrcy5zZXQobm9ybWFsaXplZElkZW50aWZpZXIsIGV4aXN0aW5nQ2FsbGJhY2tzKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdJbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2VzLmdldChub3JtYWxpemVkSWRlbnRpZmllcik7XG4gICAgICAgIGlmIChleGlzdGluZ0luc3RhbmNlKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhleGlzdGluZ0luc3RhbmNlLCBub3JtYWxpemVkSWRlbnRpZmllcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGV4aXN0aW5nQ2FsbGJhY2tzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZSBvbkluaXQgY2FsbGJhY2tzIHN5bmNocm9ub3VzbHlcbiAgICAgKiBAcGFyYW0gaW5zdGFuY2UgdGhlIHNlcnZpY2UgaW5zdGFuY2VgXG4gICAgICovXG4gICAgaW52b2tlT25Jbml0Q2FsbGJhY2tzKGluc3RhbmNlLCBpZGVudGlmaWVyKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMub25Jbml0Q2FsbGJhY2tzLmdldChpZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIGNhbGxiYWNrcykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhpbnN0YW5jZSwgaWRlbnRpZmllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGluIHRoZSBvbkluaXQgY2FsbGJhY2tcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRPckluaXRpYWxpemVTZXJ2aWNlKHsgaW5zdGFuY2VJZGVudGlmaWVyLCBvcHRpb25zID0ge30gfSkge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlcy5nZXQoaW5zdGFuY2VJZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKCFpbnN0YW5jZSAmJiB0aGlzLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgaW5zdGFuY2UgPSB0aGlzLmNvbXBvbmVudC5pbnN0YW5jZUZhY3RvcnkodGhpcy5jb250YWluZXIsIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZUlkZW50aWZpZXJGb3JGYWN0b3J5KGluc3RhbmNlSWRlbnRpZmllciksXG4gICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlcy5zZXQoaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlc09wdGlvbnMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgb3B0aW9ucyk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEludm9rZSBvbkluaXQgbGlzdGVuZXJzLlxuICAgICAgICAgICAgICogTm90ZSB0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCBpcyBkaWZmZXJlbnQsIHdoaWNoIGlzIHVzZWQgYnkgdGhlIGNvbXBvbmVudCBjcmVhdG9yLFxuICAgICAgICAgICAgICogd2hpbGUgb25Jbml0IGxpc3RlbmVycyBhcmUgcmVnaXN0ZXJlZCBieSBjb25zdW1lcnMgb2YgdGhlIHByb3ZpZGVyLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmludm9rZU9uSW5pdENhbGxiYWNrcyhpbnN0YW5jZSwgaW5zdGFuY2VJZGVudGlmaWVyKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogT3JkZXIgaXMgaW1wb3J0YW50XG4gICAgICAgICAgICAgKiBvbkluc3RhbmNlQ3JlYXRlZCgpIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgdGhpcy5pbnN0YW5jZXMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2UpOyB3aGljaFxuICAgICAgICAgICAgICogbWFrZXMgYGlzSW5pdGlhbGl6ZWQoKWAgcmV0dXJuIHRydWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50Lm9uSW5zdGFuY2VDcmVhdGVkKHRoaXMuY29udGFpbmVyLCBpbnN0YW5jZUlkZW50aWZpZXIsIGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBlcnJvcnMgaW4gdGhlIG9uSW5zdGFuY2VDcmVhdGVkQ2FsbGJhY2tcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlIHx8IG51bGw7XG4gICAgfVxuICAgIG5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50Lm11bHRpcGxlSW5zdGFuY2VzID8gaWRlbnRpZmllciA6IERFRkFVTFRfRU5UUllfTkFNRTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpZGVudGlmaWVyOyAvLyBhc3N1bWUgbXVsdGlwbGUgaW5zdGFuY2VzIGFyZSBzdXBwb3J0ZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgcHJvdmlkZWQuXG4gICAgICAgIH1cbiAgICB9XG4gICAgc2hvdWxkQXV0b0luaXRpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiAoISF0aGlzLmNvbXBvbmVudCAmJlxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuaW5zdGFudGlhdGlvbk1vZGUgIT09IFwiRVhQTElDSVRcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5FWFBMSUNJVCAqLyk7XG4gICAgfVxufVxuLy8gdW5kZWZpbmVkIHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIHNlcnZpY2UgZmFjdG9yeSBmb3IgdGhlIGRlZmF1bHQgaW5zdGFuY2VcbmZ1bmN0aW9uIG5vcm1hbGl6ZUlkZW50aWZpZXJGb3JGYWN0b3J5KGlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gaWRlbnRpZmllciA9PT0gREVGQVVMVF9FTlRSWV9OQU1FID8gdW5kZWZpbmVkIDogaWRlbnRpZmllcjtcbn1cbmZ1bmN0aW9uIGlzQ29tcG9uZW50RWFnZXIoY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudC5pbnN0YW50aWF0aW9uTW9kZSA9PT0gXCJFQUdFUlwiIC8qIEluc3RhbnRpYXRpb25Nb2RlLkVBR0VSICovO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBDb21wb25lbnRDb250YWluZXIgdGhhdCBwcm92aWRlcyBQcm92aWRlcnMgZm9yIHNlcnZpY2UgbmFtZSBULCBlLmcuIGBhdXRoYCwgYGF1dGgtaW50ZXJuYWxgXG4gKi9cbmNsYXNzIENvbXBvbmVudENvbnRhaW5lciB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnByb3ZpZGVycyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29tcG9uZW50IENvbXBvbmVudCBiZWluZyBhZGRlZFxuICAgICAqIEBwYXJhbSBvdmVyd3JpdGUgV2hlbiBhIGNvbXBvbmVudCB3aXRoIHRoZSBzYW1lIG5hbWUgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkLFxuICAgICAqIGlmIG92ZXJ3cml0ZSBpcyB0cnVlOiBvdmVyd3JpdGUgdGhlIGV4aXN0aW5nIGNvbXBvbmVudCB3aXRoIHRoZSBuZXcgY29tcG9uZW50IGFuZCBjcmVhdGUgYSBuZXdcbiAgICAgKiBwcm92aWRlciB3aXRoIHRoZSBuZXcgY29tcG9uZW50LiBJdCBjYW4gYmUgdXNlZnVsIGluIHRlc3RzIHdoZXJlIHlvdSB3YW50IHRvIHVzZSBkaWZmZXJlbnQgbW9ja3NcbiAgICAgKiBmb3IgZGlmZmVyZW50IHRlc3RzLlxuICAgICAqIGlmIG92ZXJ3cml0ZSBpcyBmYWxzZTogdGhyb3cgYW4gZXhjZXB0aW9uXG4gICAgICovXG4gICAgYWRkQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIoY29tcG9uZW50Lm5hbWUpO1xuICAgICAgICBpZiAocHJvdmlkZXIuaXNDb21wb25lbnRTZXQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21wb25lbnQgJHtjb21wb25lbnQubmFtZX0gaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIHdpdGggJHt0aGlzLm5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvdmlkZXIuc2V0Q29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgfVxuICAgIGFkZE9yT3ZlcndyaXRlQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIoY29tcG9uZW50Lm5hbWUpO1xuICAgICAgICBpZiAocHJvdmlkZXIuaXNDb21wb25lbnRTZXQoKSkge1xuICAgICAgICAgICAgLy8gZGVsZXRlIHRoZSBleGlzdGluZyBwcm92aWRlciBmcm9tIHRoZSBjb250YWluZXIsIHNvIHdlIGNhbiByZWdpc3RlciB0aGUgbmV3IGNvbXBvbmVudFxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcnMuZGVsZXRlKGNvbXBvbmVudC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChjb21wb25lbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRQcm92aWRlciBwcm92aWRlcyBhIHR5cGUgc2FmZSBpbnRlcmZhY2Ugd2hlcmUgaXQgY2FuIG9ubHkgYmUgY2FsbGVkIHdpdGggYSBmaWVsZCBuYW1lXG4gICAgICogcHJlc2VudCBpbiBOYW1lU2VydmljZU1hcHBpbmcgaW50ZXJmYWNlLlxuICAgICAqXG4gICAgICogRmlyZWJhc2UgU0RLcyBwcm92aWRpbmcgc2VydmljZXMgc2hvdWxkIGV4dGVuZCBOYW1lU2VydmljZU1hcHBpbmcgaW50ZXJmYWNlIHRvIHJlZ2lzdGVyXG4gICAgICogdGhlbXNlbHZlcy5cbiAgICAgKi9cbiAgICBnZXRQcm92aWRlcihuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3ZpZGVycy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVycy5nZXQobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3JlYXRlIGEgUHJvdmlkZXIgZm9yIGEgc2VydmljZSB0aGF0IGhhc24ndCByZWdpc3RlcmVkIHdpdGggRmlyZWJhc2VcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIobmFtZSwgdGhpcyk7XG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuYW1lLCBwcm92aWRlcik7XG4gICAgICAgIHJldHVybiBwcm92aWRlcjtcbiAgICB9XG4gICAgZ2V0UHJvdmlkZXJzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnByb3ZpZGVycy52YWx1ZXMoKSk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBDb21wb25lbnQsIENvbXBvbmVudENvbnRhaW5lciwgUHJvdmlkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbTIwMTcuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/firestore/dist/index.node.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@firebase/firestore/dist/index.node.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractUserDataWriter: () => (/* binding */ AbstractUserDataWriter),\n/* harmony export */   AggregateField: () => (/* binding */ AggregateField),\n/* harmony export */   AggregateQuerySnapshot: () => (/* binding */ AggregateQuerySnapshot),\n/* harmony export */   Bytes: () => (/* binding */ Bytes),\n/* harmony export */   CACHE_SIZE_UNLIMITED: () => (/* binding */ CACHE_SIZE_UNLIMITED),\n/* harmony export */   CollectionReference: () => (/* binding */ CollectionReference),\n/* harmony export */   DocumentReference: () => (/* binding */ DocumentReference),\n/* harmony export */   DocumentSnapshot: () => (/* binding */ DocumentSnapshot),\n/* harmony export */   FieldPath: () => (/* binding */ FieldPath),\n/* harmony export */   FieldValue: () => (/* binding */ FieldValue),\n/* harmony export */   Firestore: () => (/* binding */ Firestore),\n/* harmony export */   FirestoreError: () => (/* binding */ FirestoreError),\n/* harmony export */   GeoPoint: () => (/* binding */ GeoPoint),\n/* harmony export */   LoadBundleTask: () => (/* binding */ LoadBundleTask),\n/* harmony export */   PersistentCacheIndexManager: () => (/* binding */ PersistentCacheIndexManager),\n/* harmony export */   Query: () => (/* binding */ Query),\n/* harmony export */   QueryCompositeFilterConstraint: () => (/* binding */ QueryCompositeFilterConstraint),\n/* harmony export */   QueryConstraint: () => (/* binding */ QueryConstraint),\n/* harmony export */   QueryDocumentSnapshot: () => (/* binding */ QueryDocumentSnapshot),\n/* harmony export */   QueryEndAtConstraint: () => (/* binding */ QueryEndAtConstraint),\n/* harmony export */   QueryFieldFilterConstraint: () => (/* binding */ QueryFieldFilterConstraint),\n/* harmony export */   QueryLimitConstraint: () => (/* binding */ QueryLimitConstraint),\n/* harmony export */   QueryOrderByConstraint: () => (/* binding */ QueryOrderByConstraint),\n/* harmony export */   QuerySnapshot: () => (/* binding */ QuerySnapshot),\n/* harmony export */   QueryStartAtConstraint: () => (/* binding */ QueryStartAtConstraint),\n/* harmony export */   SnapshotMetadata: () => (/* binding */ SnapshotMetadata),\n/* harmony export */   Timestamp: () => (/* binding */ Timestamp),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   VectorValue: () => (/* binding */ VectorValue),\n/* harmony export */   WriteBatch: () => (/* binding */ WriteBatch),\n/* harmony export */   _AutoId: () => (/* binding */ AutoId),\n/* harmony export */   _ByteString: () => (/* binding */ ByteString),\n/* harmony export */   _DatabaseId: () => (/* binding */ DatabaseId),\n/* harmony export */   _DocumentKey: () => (/* binding */ DocumentKey),\n/* harmony export */   _EmptyAppCheckTokenProvider: () => (/* binding */ EmptyAppCheckTokenProvider),\n/* harmony export */   _EmptyAuthCredentialsProvider: () => (/* binding */ EmptyAuthCredentialsProvider),\n/* harmony export */   _FieldPath: () => (/* binding */ FieldPath$1),\n/* harmony export */   _TestingHooks: () => (/* binding */ TestingHooks),\n/* harmony export */   _cast: () => (/* binding */ cast),\n/* harmony export */   _debugAssert: () => (/* binding */ debugAssert),\n/* harmony export */   _internalAggregationQueryToProtoRunAggregationQueryRequest: () => (/* binding */ _internalAggregationQueryToProtoRunAggregationQueryRequest),\n/* harmony export */   _internalQueryToProtoQueryTarget: () => (/* binding */ _internalQueryToProtoQueryTarget),\n/* harmony export */   _isBase64Available: () => (/* binding */ isBase64Available),\n/* harmony export */   _logWarn: () => (/* binding */ logWarn),\n/* harmony export */   _validateIsNotUsedTogether: () => (/* binding */ validateIsNotUsedTogether),\n/* harmony export */   addDoc: () => (/* binding */ addDoc),\n/* harmony export */   aggregateFieldEqual: () => (/* binding */ aggregateFieldEqual),\n/* harmony export */   aggregateQuerySnapshotEqual: () => (/* binding */ aggregateQuerySnapshotEqual),\n/* harmony export */   and: () => (/* binding */ and),\n/* harmony export */   arrayRemove: () => (/* binding */ arrayRemove),\n/* harmony export */   arrayUnion: () => (/* binding */ arrayUnion),\n/* harmony export */   average: () => (/* binding */ average),\n/* harmony export */   clearIndexedDbPersistence: () => (/* binding */ clearIndexedDbPersistence),\n/* harmony export */   collection: () => (/* binding */ collection),\n/* harmony export */   collectionGroup: () => (/* binding */ collectionGroup),\n/* harmony export */   connectFirestoreEmulator: () => (/* binding */ connectFirestoreEmulator),\n/* harmony export */   count: () => (/* binding */ count),\n/* harmony export */   deleteAllPersistentCacheIndexes: () => (/* binding */ deleteAllPersistentCacheIndexes),\n/* harmony export */   deleteDoc: () => (/* binding */ deleteDoc),\n/* harmony export */   deleteField: () => (/* binding */ deleteField),\n/* harmony export */   disableNetwork: () => (/* binding */ disableNetwork),\n/* harmony export */   disablePersistentCacheIndexAutoCreation: () => (/* binding */ disablePersistentCacheIndexAutoCreation),\n/* harmony export */   doc: () => (/* binding */ doc),\n/* harmony export */   documentId: () => (/* binding */ documentId),\n/* harmony export */   enableIndexedDbPersistence: () => (/* binding */ enableIndexedDbPersistence),\n/* harmony export */   enableMultiTabIndexedDbPersistence: () => (/* binding */ enableMultiTabIndexedDbPersistence),\n/* harmony export */   enableNetwork: () => (/* binding */ enableNetwork),\n/* harmony export */   enablePersistentCacheIndexAutoCreation: () => (/* binding */ enablePersistentCacheIndexAutoCreation),\n/* harmony export */   endAt: () => (/* binding */ endAt),\n/* harmony export */   endBefore: () => (/* binding */ endBefore),\n/* harmony export */   ensureFirestoreConfigured: () => (/* binding */ ensureFirestoreConfigured),\n/* harmony export */   executeWrite: () => (/* binding */ executeWrite),\n/* harmony export */   getAggregateFromServer: () => (/* binding */ getAggregateFromServer),\n/* harmony export */   getCountFromServer: () => (/* binding */ getCountFromServer),\n/* harmony export */   getDoc: () => (/* binding */ getDoc),\n/* harmony export */   getDocFromCache: () => (/* binding */ getDocFromCache),\n/* harmony export */   getDocFromServer: () => (/* binding */ getDocFromServer),\n/* harmony export */   getDocs: () => (/* binding */ getDocs),\n/* harmony export */   getDocsFromCache: () => (/* binding */ getDocsFromCache),\n/* harmony export */   getDocsFromServer: () => (/* binding */ getDocsFromServer),\n/* harmony export */   getFirestore: () => (/* binding */ getFirestore),\n/* harmony export */   getPersistentCacheIndexManager: () => (/* binding */ getPersistentCacheIndexManager),\n/* harmony export */   increment: () => (/* binding */ increment),\n/* harmony export */   initializeFirestore: () => (/* binding */ initializeFirestore),\n/* harmony export */   limit: () => (/* binding */ limit),\n/* harmony export */   limitToLast: () => (/* binding */ limitToLast),\n/* harmony export */   loadBundle: () => (/* binding */ loadBundle),\n/* harmony export */   memoryEagerGarbageCollector: () => (/* binding */ memoryEagerGarbageCollector),\n/* harmony export */   memoryLocalCache: () => (/* binding */ memoryLocalCache),\n/* harmony export */   memoryLruGarbageCollector: () => (/* binding */ memoryLruGarbageCollector),\n/* harmony export */   namedQuery: () => (/* binding */ namedQuery),\n/* harmony export */   onSnapshot: () => (/* binding */ onSnapshot),\n/* harmony export */   onSnapshotsInSync: () => (/* binding */ onSnapshotsInSync),\n/* harmony export */   or: () => (/* binding */ or),\n/* harmony export */   orderBy: () => (/* binding */ orderBy),\n/* harmony export */   persistentLocalCache: () => (/* binding */ persistentLocalCache),\n/* harmony export */   persistentMultipleTabManager: () => (/* binding */ persistentMultipleTabManager),\n/* harmony export */   persistentSingleTabManager: () => (/* binding */ persistentSingleTabManager),\n/* harmony export */   query: () => (/* binding */ query),\n/* harmony export */   queryEqual: () => (/* binding */ queryEqual),\n/* harmony export */   refEqual: () => (/* binding */ refEqual),\n/* harmony export */   runTransaction: () => (/* binding */ runTransaction),\n/* harmony export */   serverTimestamp: () => (/* binding */ serverTimestamp),\n/* harmony export */   setDoc: () => (/* binding */ setDoc),\n/* harmony export */   setIndexConfiguration: () => (/* binding */ setIndexConfiguration),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   snapshotEqual: () => (/* binding */ snapshotEqual),\n/* harmony export */   startAfter: () => (/* binding */ startAfter),\n/* harmony export */   startAt: () => (/* binding */ startAt),\n/* harmony export */   sum: () => (/* binding */ sum),\n/* harmony export */   terminate: () => (/* binding */ terminate),\n/* harmony export */   updateDoc: () => (/* binding */ updateDoc),\n/* harmony export */   vector: () => (/* binding */ vector),\n/* harmony export */   waitForPendingWrites: () => (/* binding */ waitForPendingWrites),\n/* harmony export */   where: () => (/* binding */ where),\n/* harmony export */   writeBatch: () => (/* binding */ writeBatch)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @firebase/webchannel-wrapper/bloom-blob */ \"(ssr)/./node_modules/@firebase/webchannel-wrapper/dist/bloom-blob/esm/bloom_blob_es2018.js\");\n/* harmony import */ var _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @grpc/grpc-js */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/index.js\");\n/* harmony import */ var _grpc_proto_loader__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @grpc/proto-loader */ \"(ssr)/./node_modules/@grpc/proto-loader/build/src/index.js\");\n\n\n\n\n\n\n\n\n\n\nconst name = \"@firebase/firestore\";\nconst version$1 = \"4.7.5\";\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Simple wrapper around a nullable UID. Mostly exists to make code more\n * readable.\n */\nclass User {\n    constructor(uid) {\n        this.uid = uid;\n    }\n    isAuthenticated() {\n        return this.uid != null;\n    }\n    /**\n     * Returns a key representing this user, suitable for inclusion in a\n     * dictionary.\n     */\n    toKey() {\n        if (this.isAuthenticated()) {\n            return 'uid:' + this.uid;\n        }\n        else {\n            return 'anonymous-user';\n        }\n    }\n    isEqual(otherUser) {\n        return otherUser.uid === this.uid;\n    }\n}\n/** A user with a null UID. */\nUser.UNAUTHENTICATED = new User(null);\n// TODO(mikelehen): Look into getting a proper uid-equivalent for\n// non-FirebaseAuth providers.\nUser.GOOGLE_CREDENTIALS = new User('google-credentials-uid');\nUser.FIRST_PARTY = new User('first-party-uid');\nUser.MOCK_USER = new User('mock-user');\n\nconst version = \"11.0.2\";\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nlet SDK_VERSION = version;\nfunction setSDKVersion(version) {\n    SDK_VERSION = version;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Formats an object as a JSON string, suitable for logging. */\nfunction formatJSON(value) {\n    // util.inspect() results in much more readable output than JSON.stringify()\n    return (0,util__WEBPACK_IMPORTED_MODULE_3__.inspect)(value, { depth: 100 });\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst logClient = new _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.Logger('@firebase/firestore');\n// Helper methods are needed because variables can't be exported as read/write\nfunction getLogLevel() {\n    return logClient.logLevel;\n}\n/**\n * Sets the verbosity of Cloud Firestore logs (debug, error, or silent).\n *\n * @param logLevel - The verbosity you set for activity and error logging. Can\n *   be any of the following values:\n *\n *   <ul>\n *     <li>`debug` for the most verbose logging level, primarily for\n *     debugging.</li>\n *     <li>`error` to log errors only.</li>\n *     <li><code>`silent` to turn off logging.</li>\n *   </ul>\n */\nfunction setLogLevel(logLevel) {\n    logClient.setLogLevel(logLevel);\n}\nfunction logDebug(msg, ...obj) {\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\n        const args = obj.map(argToString);\n        logClient.debug(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\n    }\n}\nfunction logError(msg, ...obj) {\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.ERROR) {\n        const args = obj.map(argToString);\n        logClient.error(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\n    }\n}\n/**\n * @internal\n */\nfunction logWarn(msg, ...obj) {\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.WARN) {\n        const args = obj.map(argToString);\n        logClient.warn(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\n    }\n}\n/**\n * Converts an additional log parameter to a string representation.\n */\nfunction argToString(obj) {\n    if (typeof obj === 'string') {\n        return obj;\n    }\n    else {\n        try {\n            return formatJSON(obj);\n        }\n        catch (e) {\n            // Converting to JSON failed, just log the object directly\n            return obj;\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Unconditionally fails, throwing an Error with the given message.\n * Messages are stripped in production builds.\n *\n * Returns `never` and can be used in expressions:\n * @example\n * let futureVar = fail('not implemented yet');\n */\nfunction fail(failure = 'Unexpected state') {\n    // Log the failure in addition to throw an exception, just in case the\n    // exception is swallowed.\n    const message = `FIRESTORE (${SDK_VERSION}) INTERNAL ASSERTION FAILED: ` + failure;\n    logError(message);\n    // NOTE: We don't use FirestoreError here because these are internal failures\n    // that cannot be handled by the user. (Also it would create a circular\n    // dependency between the error and assert modules which doesn't work.)\n    throw new Error(message);\n}\n/**\n * Fails if the given assertion condition is false, throwing an Error with the\n * given message if it did.\n *\n * Messages are stripped in production builds.\n */\nfunction hardAssert(assertion, message) {\n    if (!assertion) {\n        fail();\n    }\n}\n/**\n * Fails if the given assertion condition is false, throwing an Error with the\n * given message if it did.\n *\n * The code of callsites invoking this function are stripped out in production\n * builds. Any side-effects of code within the debugAssert() invocation will not\n * happen in this case.\n *\n * @internal\n */\nfunction debugAssert(assertion, message) {\n    if (!assertion) {\n        fail();\n    }\n}\n/**\n * Casts `obj` to `T`. In non-production builds, verifies that `obj` is an\n * instance of `T` before casting.\n */\nfunction debugCast(obj, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconstructor) {\n    return obj;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst Code = {\n    // Causes are copied from:\n    // https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\n    /** Not an error; returned on success. */\n    OK: 'ok',\n    /** The operation was cancelled (typically by the caller). */\n    CANCELLED: 'cancelled',\n    /** Unknown error or an error from a different error domain. */\n    UNKNOWN: 'unknown',\n    /**\n     * Client specified an invalid argument. Note that this differs from\n     * FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are\n     * problematic regardless of the state of the system (e.g., a malformed file\n     * name).\n     */\n    INVALID_ARGUMENT: 'invalid-argument',\n    /**\n     * Deadline expired before operation could complete. For operations that\n     * change the state of the system, this error may be returned even if the\n     * operation has completed successfully. For example, a successful response\n     * from a server could have been delayed long enough for the deadline to\n     * expire.\n     */\n    DEADLINE_EXCEEDED: 'deadline-exceeded',\n    /** Some requested entity (e.g., file or directory) was not found. */\n    NOT_FOUND: 'not-found',\n    /**\n     * Some entity that we attempted to create (e.g., file or directory) already\n     * exists.\n     */\n    ALREADY_EXISTS: 'already-exists',\n    /**\n     * The caller does not have permission to execute the specified operation.\n     * PERMISSION_DENIED must not be used for rejections caused by exhausting\n     * some resource (use RESOURCE_EXHAUSTED instead for those errors).\n     * PERMISSION_DENIED must not be used if the caller cannot be identified\n     * (use UNAUTHENTICATED instead for those errors).\n     */\n    PERMISSION_DENIED: 'permission-denied',\n    /**\n     * The request does not have valid authentication credentials for the\n     * operation.\n     */\n    UNAUTHENTICATED: 'unauthenticated',\n    /**\n     * Some resource has been exhausted, perhaps a per-user quota, or perhaps the\n     * entire file system is out of space.\n     */\n    RESOURCE_EXHAUSTED: 'resource-exhausted',\n    /**\n     * Operation was rejected because the system is not in a state required for\n     * the operation's execution. For example, directory to be deleted may be\n     * non-empty, an rmdir operation is applied to a non-directory, etc.\n     *\n     * A litmus test that may help a service implementor in deciding\n     * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:\n     *  (a) Use UNAVAILABLE if the client can retry just the failing call.\n     *  (b) Use ABORTED if the client should retry at a higher-level\n     *      (e.g., restarting a read-modify-write sequence).\n     *  (c) Use FAILED_PRECONDITION if the client should not retry until\n     *      the system state has been explicitly fixed. E.g., if an \"rmdir\"\n     *      fails because the directory is non-empty, FAILED_PRECONDITION\n     *      should be returned since the client should not retry unless\n     *      they have first fixed up the directory by deleting files from it.\n     *  (d) Use FAILED_PRECONDITION if the client performs conditional\n     *      REST Get/Update/Delete on a resource and the resource on the\n     *      server does not match the condition. E.g., conflicting\n     *      read-modify-write on the same resource.\n     */\n    FAILED_PRECONDITION: 'failed-precondition',\n    /**\n     * The operation was aborted, typically due to a concurrency issue like\n     * sequencer check failures, transaction aborts, etc.\n     *\n     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n     * and UNAVAILABLE.\n     */\n    ABORTED: 'aborted',\n    /**\n     * Operation was attempted past the valid range. E.g., seeking or reading\n     * past end of file.\n     *\n     * Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed\n     * if the system state changes. For example, a 32-bit file system will\n     * generate INVALID_ARGUMENT if asked to read at an offset that is not in the\n     * range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from\n     * an offset past the current file size.\n     *\n     * There is a fair bit of overlap between FAILED_PRECONDITION and\n     * OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)\n     * when it applies so that callers who are iterating through a space can\n     * easily look for an OUT_OF_RANGE error to detect when they are done.\n     */\n    OUT_OF_RANGE: 'out-of-range',\n    /** Operation is not implemented or not supported/enabled in this service. */\n    UNIMPLEMENTED: 'unimplemented',\n    /**\n     * Internal errors. Means some invariants expected by underlying System has\n     * been broken. If you see one of these errors, Something is very broken.\n     */\n    INTERNAL: 'internal',\n    /**\n     * The service is currently unavailable. This is a most likely a transient\n     * condition and may be corrected by retrying with a backoff.\n     *\n     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n     * and UNAVAILABLE.\n     */\n    UNAVAILABLE: 'unavailable',\n    /** Unrecoverable data loss or corruption. */\n    DATA_LOSS: 'data-loss'\n};\n/** An error returned by a Firestore operation. */\nclass FirestoreError extends _firebase_util__WEBPACK_IMPORTED_MODULE_4__.FirebaseError {\n    /** @hideconstructor */\n    constructor(\n    /**\n     * The backend error code associated with this error.\n     */\n    code, \n    /**\n     * A custom error description.\n     */\n    message) {\n        super(code, message);\n        this.code = code;\n        this.message = message;\n        // HACK: We write a toString property directly because Error is not a real\n        // class and so inheritance does not work correctly. We could alternatively\n        // do the same \"back-door inheritance\" trick that FirebaseError does.\n        this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass OAuthToken {\n    constructor(value, user) {\n        this.user = user;\n        this.type = 'OAuth';\n        this.headers = new Map();\n        this.headers.set('Authorization', `Bearer ${value}`);\n    }\n}\n/**\n * A CredentialsProvider that always yields an empty token.\n * @internal\n */\nclass EmptyAuthCredentialsProvider {\n    getToken() {\n        return Promise.resolve(null);\n    }\n    invalidateToken() { }\n    start(asyncQueue, changeListener) {\n        // Fire with initial user.\n        asyncQueue.enqueueRetryable(() => changeListener(User.UNAUTHENTICATED));\n    }\n    shutdown() { }\n}\n/**\n * A CredentialsProvider that always returns a constant token. Used for\n * emulator token mocking.\n */\nclass EmulatorAuthCredentialsProvider {\n    constructor(token) {\n        this.token = token;\n        /**\n         * Stores the listener registered with setChangeListener()\n         * This isn't actually necessary since the UID never changes, but we use this\n         * to verify the listen contract is adhered to in tests.\n         */\n        this.changeListener = null;\n    }\n    getToken() {\n        return Promise.resolve(this.token);\n    }\n    invalidateToken() { }\n    start(asyncQueue, changeListener) {\n        this.changeListener = changeListener;\n        // Fire with initial user.\n        asyncQueue.enqueueRetryable(() => changeListener(this.token.user));\n    }\n    shutdown() {\n        this.changeListener = null;\n    }\n}\nclass FirebaseAuthCredentialsProvider {\n    constructor(authProvider) {\n        this.authProvider = authProvider;\n        /** Tracks the current User. */\n        this.currentUser = User.UNAUTHENTICATED;\n        /**\n         * Counter used to detect if the token changed while a getToken request was\n         * outstanding.\n         */\n        this.tokenCounter = 0;\n        this.forceRefresh = false;\n        this.auth = null;\n    }\n    start(asyncQueue, changeListener) {\n        hardAssert(this.tokenListener === undefined);\n        let lastTokenId = this.tokenCounter;\n        // A change listener that prevents double-firing for the same token change.\n        const guardedChangeListener = user => {\n            if (this.tokenCounter !== lastTokenId) {\n                lastTokenId = this.tokenCounter;\n                return changeListener(user);\n            }\n            else {\n                return Promise.resolve();\n            }\n        };\n        // A promise that can be waited on to block on the next token change.\n        // This promise is re-created after each change.\n        let nextToken = new Deferred();\n        this.tokenListener = () => {\n            this.tokenCounter++;\n            this.currentUser = this.getUser();\n            nextToken.resolve();\n            nextToken = new Deferred();\n            asyncQueue.enqueueRetryable(() => guardedChangeListener(this.currentUser));\n        };\n        const awaitNextToken = () => {\n            const currentTokenAttempt = nextToken;\n            asyncQueue.enqueueRetryable(async () => {\n                await currentTokenAttempt.promise;\n                await guardedChangeListener(this.currentUser);\n            });\n        };\n        const registerAuth = (auth) => {\n            logDebug('FirebaseAuthCredentialsProvider', 'Auth detected');\n            this.auth = auth;\n            if (this.tokenListener) {\n                this.auth.addAuthTokenListener(this.tokenListener);\n                awaitNextToken();\n            }\n        };\n        this.authProvider.onInit(auth => registerAuth(auth));\n        // Our users can initialize Auth right after Firestore, so we give it\n        // a chance to register itself with the component framework before we\n        // determine whether to start up in unauthenticated mode.\n        setTimeout(() => {\n            if (!this.auth) {\n                const auth = this.authProvider.getImmediate({ optional: true });\n                if (auth) {\n                    registerAuth(auth);\n                }\n                else {\n                    // If auth is still not available, proceed with `null` user\n                    logDebug('FirebaseAuthCredentialsProvider', 'Auth not yet detected');\n                    nextToken.resolve();\n                    nextToken = new Deferred();\n                }\n            }\n        }, 0);\n        awaitNextToken();\n    }\n    getToken() {\n        // Take note of the current value of the tokenCounter so that this method\n        // can fail (with an ABORTED error) if there is a token change while the\n        // request is outstanding.\n        const initialTokenCounter = this.tokenCounter;\n        const forceRefresh = this.forceRefresh;\n        this.forceRefresh = false;\n        if (!this.auth) {\n            return Promise.resolve(null);\n        }\n        return this.auth.getToken(forceRefresh).then(tokenData => {\n            // Cancel the request since the token changed while the request was\n            // outstanding so the response is potentially for a previous user (which\n            // user, we can't be sure).\n            if (this.tokenCounter !== initialTokenCounter) {\n                logDebug('FirebaseAuthCredentialsProvider', 'getToken aborted due to token change.');\n                return this.getToken();\n            }\n            else {\n                if (tokenData) {\n                    hardAssert(typeof tokenData.accessToken === 'string');\n                    return new OAuthToken(tokenData.accessToken, this.currentUser);\n                }\n                else {\n                    return null;\n                }\n            }\n        });\n    }\n    invalidateToken() {\n        this.forceRefresh = true;\n    }\n    shutdown() {\n        if (this.auth && this.tokenListener) {\n            this.auth.removeAuthTokenListener(this.tokenListener);\n        }\n        this.tokenListener = undefined;\n    }\n    // Auth.getUid() can return null even with a user logged in. It is because\n    // getUid() is synchronous, but the auth code populating Uid is asynchronous.\n    // This method should only be called in the AuthTokenListener callback\n    // to guarantee to get the actual user.\n    getUser() {\n        const currentUid = this.auth && this.auth.getUid();\n        hardAssert(currentUid === null || typeof currentUid === 'string');\n        return new User(currentUid);\n    }\n}\n/*\n * FirstPartyToken provides a fresh token each time its value\n * is requested, because if the token is too old, requests will be rejected.\n * Technically this may no longer be necessary since the SDK should gracefully\n * recover from unauthenticated errors (see b/33147818 for context), but it's\n * safer to keep the implementation as-is.\n */\nclass FirstPartyToken {\n    constructor(sessionIndex, iamToken, authTokenFactory) {\n        this.sessionIndex = sessionIndex;\n        this.iamToken = iamToken;\n        this.authTokenFactory = authTokenFactory;\n        this.type = 'FirstParty';\n        this.user = User.FIRST_PARTY;\n        this._headers = new Map();\n    }\n    /**\n     * Gets an authorization token, using a provided factory function, or return\n     * null.\n     */\n    getAuthToken() {\n        if (this.authTokenFactory) {\n            return this.authTokenFactory();\n        }\n        else {\n            return null;\n        }\n    }\n    get headers() {\n        this._headers.set('X-Goog-AuthUser', this.sessionIndex);\n        // Use array notation to prevent minification\n        const authHeaderTokenValue = this.getAuthToken();\n        if (authHeaderTokenValue) {\n            this._headers.set('Authorization', authHeaderTokenValue);\n        }\n        if (this.iamToken) {\n            this._headers.set('X-Goog-Iam-Authorization-Token', this.iamToken);\n        }\n        return this._headers;\n    }\n}\n/*\n * Provides user credentials required for the Firestore JavaScript SDK\n * to authenticate the user, using technique that is only available\n * to applications hosted by Google.\n */\nclass FirstPartyAuthCredentialsProvider {\n    constructor(sessionIndex, iamToken, authTokenFactory) {\n        this.sessionIndex = sessionIndex;\n        this.iamToken = iamToken;\n        this.authTokenFactory = authTokenFactory;\n    }\n    getToken() {\n        return Promise.resolve(new FirstPartyToken(this.sessionIndex, this.iamToken, this.authTokenFactory));\n    }\n    start(asyncQueue, changeListener) {\n        // Fire with initial uid.\n        asyncQueue.enqueueRetryable(() => changeListener(User.FIRST_PARTY));\n    }\n    shutdown() { }\n    invalidateToken() { }\n}\nclass AppCheckToken {\n    constructor(value) {\n        this.value = value;\n        this.type = 'AppCheck';\n        this.headers = new Map();\n        if (value && value.length > 0) {\n            this.headers.set('x-firebase-appcheck', this.value);\n        }\n    }\n}\nclass FirebaseAppCheckTokenProvider {\n    constructor(appCheckProvider) {\n        this.appCheckProvider = appCheckProvider;\n        this.forceRefresh = false;\n        this.appCheck = null;\n        this.latestAppCheckToken = null;\n    }\n    start(asyncQueue, changeListener) {\n        hardAssert(this.tokenListener === undefined);\n        const onTokenChanged = tokenResult => {\n            if (tokenResult.error != null) {\n                logDebug('FirebaseAppCheckTokenProvider', `Error getting App Check token; using placeholder token instead. Error: ${tokenResult.error.message}`);\n            }\n            const tokenUpdated = tokenResult.token !== this.latestAppCheckToken;\n            this.latestAppCheckToken = tokenResult.token;\n            logDebug('FirebaseAppCheckTokenProvider', `Received ${tokenUpdated ? 'new' : 'existing'} token.`);\n            return tokenUpdated\n                ? changeListener(tokenResult.token)\n                : Promise.resolve();\n        };\n        this.tokenListener = (tokenResult) => {\n            asyncQueue.enqueueRetryable(() => onTokenChanged(tokenResult));\n        };\n        const registerAppCheck = (appCheck) => {\n            logDebug('FirebaseAppCheckTokenProvider', 'AppCheck detected');\n            this.appCheck = appCheck;\n            if (this.tokenListener) {\n                this.appCheck.addTokenListener(this.tokenListener);\n            }\n        };\n        this.appCheckProvider.onInit(appCheck => registerAppCheck(appCheck));\n        // Our users can initialize AppCheck after Firestore, so we give it\n        // a chance to register itself with the component framework.\n        setTimeout(() => {\n            if (!this.appCheck) {\n                const appCheck = this.appCheckProvider.getImmediate({ optional: true });\n                if (appCheck) {\n                    registerAppCheck(appCheck);\n                }\n                else {\n                    // If AppCheck is still not available, proceed without it.\n                    logDebug('FirebaseAppCheckTokenProvider', 'AppCheck not yet detected');\n                }\n            }\n        }, 0);\n    }\n    getToken() {\n        const forceRefresh = this.forceRefresh;\n        this.forceRefresh = false;\n        if (!this.appCheck) {\n            return Promise.resolve(null);\n        }\n        return this.appCheck.getToken(forceRefresh).then(tokenResult => {\n            if (tokenResult) {\n                hardAssert(typeof tokenResult.token === 'string');\n                this.latestAppCheckToken = tokenResult.token;\n                return new AppCheckToken(tokenResult.token);\n            }\n            else {\n                return null;\n            }\n        });\n    }\n    invalidateToken() {\n        this.forceRefresh = true;\n    }\n    shutdown() {\n        if (this.appCheck && this.tokenListener) {\n            this.appCheck.removeTokenListener(this.tokenListener);\n        }\n        this.tokenListener = undefined;\n    }\n}\n/**\n * An AppCheck token provider that always yields an empty token.\n * @internal\n */\nclass EmptyAppCheckTokenProvider {\n    getToken() {\n        return Promise.resolve(new AppCheckToken(''));\n    }\n    invalidateToken() { }\n    start(asyncQueue, changeListener) { }\n    shutdown() { }\n}\n/**\n * Builds a CredentialsProvider depending on the type of\n * the credentials passed in.\n */\nfunction makeAuthCredentialsProvider(credentials) {\n    if (!credentials) {\n        return new EmptyAuthCredentialsProvider();\n    }\n    switch (credentials['type']) {\n        case 'firstParty':\n            return new FirstPartyAuthCredentialsProvider(credentials['sessionIndex'] || '0', credentials['iamToken'] || null, credentials['authTokenFactory'] || null);\n        case 'provider':\n            return credentials['client'];\n        default:\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'makeAuthCredentialsProvider failed due to invalid credential type');\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Generates `nBytes` of random bytes.\n *\n * If `nBytes < 0` , an error will be thrown.\n */\nfunction randomBytes(nBytes) {\n    return (0,crypto__WEBPACK_IMPORTED_MODULE_5__.randomBytes)(nBytes);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A utility class for generating unique alphanumeric IDs of a specified length.\n *\n * @internal\n * Exported internally for testing purposes.\n */\nclass AutoId {\n    static newId() {\n        // Alphanumeric characters\n        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n        // The largest byte value that is a multiple of `char.length`.\n        const maxMultiple = Math.floor(256 / chars.length) * chars.length;\n        let autoId = '';\n        const targetLength = 20;\n        while (autoId.length < targetLength) {\n            const bytes = randomBytes(40);\n            for (let i = 0; i < bytes.length; ++i) {\n                // Only accept values that are [0, maxMultiple), this ensures they can\n                // be evenly mapped to indices of `chars` via a modulo operation.\n                if (autoId.length < targetLength && bytes[i] < maxMultiple) {\n                    autoId += chars.charAt(bytes[i] % chars.length);\n                }\n            }\n        }\n        return autoId;\n    }\n}\nfunction primitiveComparator(left, right) {\n    if (left < right) {\n        return -1;\n    }\n    if (left > right) {\n        return 1;\n    }\n    return 0;\n}\n/** Helper to compare arrays using isEqual(). */\nfunction arrayEquals(left, right, comparator) {\n    if (left.length !== right.length) {\n        return false;\n    }\n    return left.every((value, index) => comparator(value, right[index]));\n}\n/**\n * Returns the immediate lexicographically-following string. This is useful to\n * construct an inclusive range for indexeddb iterators.\n */\nfunction immediateSuccessor(s) {\n    // Return the input string, with an additional NUL byte appended.\n    return s + '\\0';\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// The earliest date supported by Firestore timestamps (0001-01-01T00:00:00Z).\nconst MIN_SECONDS = -62135596800;\n// Number of nanoseconds in a millisecond.\nconst MS_TO_NANOS = 1e6;\n/**\n * A `Timestamp` represents a point in time independent of any time zone or\n * calendar, represented as seconds and fractions of seconds at nanosecond\n * resolution in UTC Epoch time.\n *\n * It is encoded using the Proleptic Gregorian Calendar which extends the\n * Gregorian calendar backwards to year one. It is encoded assuming all minutes\n * are 60 seconds long, i.e. leap seconds are \"smeared\" so that no leap second\n * table is needed for interpretation. Range is from 0001-01-01T00:00:00Z to\n * 9999-12-31T23:59:59.999999999Z.\n *\n * For examples and further specifications, refer to the\n * {@link https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto | Timestamp definition}.\n */\nclass Timestamp {\n    /**\n     * Creates a new timestamp with the current date, with millisecond precision.\n     *\n     * @returns a new timestamp representing the current date.\n     */\n    static now() {\n        return Timestamp.fromMillis(Date.now());\n    }\n    /**\n     * Creates a new timestamp from the given date.\n     *\n     * @param date - The date to initialize the `Timestamp` from.\n     * @returns A new `Timestamp` representing the same point in time as the given\n     *     date.\n     */\n    static fromDate(date) {\n        return Timestamp.fromMillis(date.getTime());\n    }\n    /**\n     * Creates a new timestamp from the given number of milliseconds.\n     *\n     * @param milliseconds - Number of milliseconds since Unix epoch\n     *     1970-01-01T00:00:00Z.\n     * @returns A new `Timestamp` representing the same point in time as the given\n     *     number of milliseconds.\n     */\n    static fromMillis(milliseconds) {\n        const seconds = Math.floor(milliseconds / 1000);\n        const nanos = Math.floor((milliseconds - seconds * 1000) * MS_TO_NANOS);\n        return new Timestamp(seconds, nanos);\n    }\n    /**\n     * Creates a new timestamp.\n     *\n     * @param seconds - The number of seconds of UTC time since Unix epoch\n     *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n     *     9999-12-31T23:59:59Z inclusive.\n     * @param nanoseconds - The non-negative fractions of a second at nanosecond\n     *     resolution. Negative second values with fractions must still have\n     *     non-negative nanoseconds values that count forward in time. Must be\n     *     from 0 to 999,999,999 inclusive.\n     */\n    constructor(\n    /**\n     * The number of seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z.\n     */\n    seconds, \n    /**\n     * The fractions of a second at nanosecond resolution.*\n     */\n    nanoseconds) {\n        this.seconds = seconds;\n        this.nanoseconds = nanoseconds;\n        if (nanoseconds < 0) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp nanoseconds out of range: ' + nanoseconds);\n        }\n        if (nanoseconds >= 1e9) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp nanoseconds out of range: ' + nanoseconds);\n        }\n        if (seconds < MIN_SECONDS) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp seconds out of range: ' + seconds);\n        }\n        // This will break in the year 10,000.\n        if (seconds >= 253402300800) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp seconds out of range: ' + seconds);\n        }\n    }\n    /**\n     * Converts a `Timestamp` to a JavaScript `Date` object. This conversion\n     * causes a loss of precision since `Date` objects only support millisecond\n     * precision.\n     *\n     * @returns JavaScript `Date` object representing the same point in time as\n     *     this `Timestamp`, with millisecond precision.\n     */\n    toDate() {\n        return new Date(this.toMillis());\n    }\n    /**\n     * Converts a `Timestamp` to a numeric timestamp (in milliseconds since\n     * epoch). This operation causes a loss of precision.\n     *\n     * @returns The point in time corresponding to this timestamp, represented as\n     *     the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.\n     */\n    toMillis() {\n        return this.seconds * 1000 + this.nanoseconds / MS_TO_NANOS;\n    }\n    _compareTo(other) {\n        if (this.seconds === other.seconds) {\n            return primitiveComparator(this.nanoseconds, other.nanoseconds);\n        }\n        return primitiveComparator(this.seconds, other.seconds);\n    }\n    /**\n     * Returns true if this `Timestamp` is equal to the provided one.\n     *\n     * @param other - The `Timestamp` to compare against.\n     * @returns true if this `Timestamp` is equal to the provided one.\n     */\n    isEqual(other) {\n        return (other.seconds === this.seconds && other.nanoseconds === this.nanoseconds);\n    }\n    /** Returns a textual representation of this `Timestamp`. */\n    toString() {\n        return ('Timestamp(seconds=' +\n            this.seconds +\n            ', nanoseconds=' +\n            this.nanoseconds +\n            ')');\n    }\n    /** Returns a JSON-serializable representation of this `Timestamp`. */\n    toJSON() {\n        return { seconds: this.seconds, nanoseconds: this.nanoseconds };\n    }\n    /**\n     * Converts this object to a primitive string, which allows `Timestamp` objects\n     * to be compared using the `>`, `<=`, `>=` and `>` operators.\n     */\n    valueOf() {\n        // This method returns a string of the form <seconds>.<nanoseconds> where\n        // <seconds> is translated to have a non-negative value and both <seconds>\n        // and <nanoseconds> are left-padded with zeroes to be a consistent length.\n        // Strings with this format then have a lexicographical ordering that matches\n        // the expected ordering. The <seconds> translation is done to avoid having\n        // a leading negative sign (i.e. a leading '-' character) in its string\n        // representation, which would affect its lexicographical ordering.\n        const adjustedSeconds = this.seconds - MIN_SECONDS;\n        // Note: Up to 12 decimal digits are required to represent all valid\n        // 'seconds' values.\n        const formattedSeconds = String(adjustedSeconds).padStart(12, '0');\n        const formattedNanoseconds = String(this.nanoseconds).padStart(9, '0');\n        return formattedSeconds + '.' + formattedNanoseconds;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A version of a document in Firestore. This corresponds to the version\n * timestamp, such as update_time or read_time.\n */\nclass SnapshotVersion {\n    static fromTimestamp(value) {\n        return new SnapshotVersion(value);\n    }\n    static min() {\n        return new SnapshotVersion(new Timestamp(0, 0));\n    }\n    static max() {\n        return new SnapshotVersion(new Timestamp(253402300799, 1e9 - 1));\n    }\n    constructor(timestamp) {\n        this.timestamp = timestamp;\n    }\n    compareTo(other) {\n        return this.timestamp._compareTo(other.timestamp);\n    }\n    isEqual(other) {\n        return this.timestamp.isEqual(other.timestamp);\n    }\n    /** Returns a number representation of the version for use in spec tests. */\n    toMicroseconds() {\n        // Convert to microseconds.\n        return this.timestamp.seconds * 1e6 + this.timestamp.nanoseconds / 1000;\n    }\n    toString() {\n        return 'SnapshotVersion(' + this.timestamp.toString() + ')';\n    }\n    toTimestamp() {\n        return this.timestamp;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DOCUMENT_KEY_NAME = '__name__';\n/**\n * Path represents an ordered sequence of string segments.\n */\nclass BasePath {\n    constructor(segments, offset, length) {\n        if (offset === undefined) {\n            offset = 0;\n        }\n        else if (offset > segments.length) {\n            fail();\n        }\n        if (length === undefined) {\n            length = segments.length - offset;\n        }\n        else if (length > segments.length - offset) {\n            fail();\n        }\n        this.segments = segments;\n        this.offset = offset;\n        this.len = length;\n    }\n    get length() {\n        return this.len;\n    }\n    isEqual(other) {\n        return BasePath.comparator(this, other) === 0;\n    }\n    child(nameOrPath) {\n        const segments = this.segments.slice(this.offset, this.limit());\n        if (nameOrPath instanceof BasePath) {\n            nameOrPath.forEach(segment => {\n                segments.push(segment);\n            });\n        }\n        else {\n            segments.push(nameOrPath);\n        }\n        return this.construct(segments);\n    }\n    /** The index of one past the last segment of the path. */\n    limit() {\n        return this.offset + this.length;\n    }\n    popFirst(size) {\n        size = size === undefined ? 1 : size;\n        return this.construct(this.segments, this.offset + size, this.length - size);\n    }\n    popLast() {\n        return this.construct(this.segments, this.offset, this.length - 1);\n    }\n    firstSegment() {\n        return this.segments[this.offset];\n    }\n    lastSegment() {\n        return this.get(this.length - 1);\n    }\n    get(index) {\n        return this.segments[this.offset + index];\n    }\n    isEmpty() {\n        return this.length === 0;\n    }\n    isPrefixOf(other) {\n        if (other.length < this.length) {\n            return false;\n        }\n        for (let i = 0; i < this.length; i++) {\n            if (this.get(i) !== other.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isImmediateParentOf(potentialChild) {\n        if (this.length + 1 !== potentialChild.length) {\n            return false;\n        }\n        for (let i = 0; i < this.length; i++) {\n            if (this.get(i) !== potentialChild.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    forEach(fn) {\n        for (let i = this.offset, end = this.limit(); i < end; i++) {\n            fn(this.segments[i]);\n        }\n    }\n    toArray() {\n        return this.segments.slice(this.offset, this.limit());\n    }\n    static comparator(p1, p2) {\n        const len = Math.min(p1.length, p2.length);\n        for (let i = 0; i < len; i++) {\n            const left = p1.get(i);\n            const right = p2.get(i);\n            if (left < right) {\n                return -1;\n            }\n            if (left > right) {\n                return 1;\n            }\n        }\n        if (p1.length < p2.length) {\n            return -1;\n        }\n        if (p1.length > p2.length) {\n            return 1;\n        }\n        return 0;\n    }\n}\n/**\n * A slash-separated path for navigating resources (documents and collections)\n * within Firestore.\n *\n * @internal\n */\nclass ResourcePath extends BasePath {\n    construct(segments, offset, length) {\n        return new ResourcePath(segments, offset, length);\n    }\n    canonicalString() {\n        // NOTE: The client is ignorant of any path segments containing escape\n        // sequences (e.g. __id123__) and just passes them through raw (they exist\n        // for legacy reasons and should not be used frequently).\n        return this.toArray().join('/');\n    }\n    toString() {\n        return this.canonicalString();\n    }\n    /**\n     * Returns a string representation of this path\n     * where each path segment has been encoded with\n     * `encodeURIComponent`.\n     */\n    toUriEncodedString() {\n        return this.toArray().map(encodeURIComponent).join('/');\n    }\n    /**\n     * Creates a resource path from the given slash-delimited string. If multiple\n     * arguments are provided, all components are combined. Leading and trailing\n     * slashes from all components are ignored.\n     */\n    static fromString(...pathComponents) {\n        // NOTE: The client is ignorant of any path segments containing escape\n        // sequences (e.g. __id123__) and just passes them through raw (they exist\n        // for legacy reasons and should not be used frequently).\n        const segments = [];\n        for (const path of pathComponents) {\n            if (path.indexOf('//') >= 0) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid segment (${path}). Paths must not contain // in them.`);\n            }\n            // Strip leading and trailing slashed.\n            segments.push(...path.split('/').filter(segment => segment.length > 0));\n        }\n        return new ResourcePath(segments);\n    }\n    static emptyPath() {\n        return new ResourcePath([]);\n    }\n}\nconst identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;\n/**\n * A dot-separated path for navigating sub-objects within a document.\n * @internal\n */\nclass FieldPath$1 extends BasePath {\n    construct(segments, offset, length) {\n        return new FieldPath$1(segments, offset, length);\n    }\n    /**\n     * Returns true if the string could be used as a segment in a field path\n     * without escaping.\n     */\n    static isValidIdentifier(segment) {\n        return identifierRegExp.test(segment);\n    }\n    canonicalString() {\n        return this.toArray()\n            .map(str => {\n            str = str.replace(/\\\\/g, '\\\\\\\\').replace(/`/g, '\\\\`');\n            if (!FieldPath$1.isValidIdentifier(str)) {\n                str = '`' + str + '`';\n            }\n            return str;\n        })\n            .join('.');\n    }\n    toString() {\n        return this.canonicalString();\n    }\n    /**\n     * Returns true if this field references the key of a document.\n     */\n    isKeyField() {\n        return this.length === 1 && this.get(0) === DOCUMENT_KEY_NAME;\n    }\n    /**\n     * The field designating the key of a document.\n     */\n    static keyField() {\n        return new FieldPath$1([DOCUMENT_KEY_NAME]);\n    }\n    /**\n     * Parses a field string from the given server-formatted string.\n     *\n     * - Splitting the empty string is not allowed (for now at least).\n     * - Empty segments within the string (e.g. if there are two consecutive\n     *   separators) are not allowed.\n     *\n     * TODO(b/37244157): we should make this more strict. Right now, it allows\n     * non-identifier path components, even if they aren't escaped.\n     */\n    static fromServerFormat(path) {\n        const segments = [];\n        let current = '';\n        let i = 0;\n        const addCurrentSegment = () => {\n            if (current.length === 0) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid field path (${path}). Paths must not be empty, begin ` +\n                    `with '.', end with '.', or contain '..'`);\n            }\n            segments.push(current);\n            current = '';\n        };\n        let inBackticks = false;\n        while (i < path.length) {\n            const c = path[i];\n            if (c === '\\\\') {\n                if (i + 1 === path.length) {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has trailing escape character: ' + path);\n                }\n                const next = path[i + 1];\n                if (!(next === '\\\\' || next === '.' || next === '`')) {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has invalid escape sequence: ' + path);\n                }\n                current += next;\n                i += 2;\n            }\n            else if (c === '`') {\n                inBackticks = !inBackticks;\n                i++;\n            }\n            else if (c === '.' && !inBackticks) {\n                addCurrentSegment();\n                i++;\n            }\n            else {\n                current += c;\n                i++;\n            }\n        }\n        addCurrentSegment();\n        if (inBackticks) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Unterminated ` in path: ' + path);\n        }\n        return new FieldPath$1(segments);\n    }\n    static emptyPath() {\n        return new FieldPath$1([]);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @internal\n */\nclass DocumentKey {\n    constructor(path) {\n        this.path = path;\n    }\n    static fromPath(path) {\n        return new DocumentKey(ResourcePath.fromString(path));\n    }\n    static fromName(name) {\n        return new DocumentKey(ResourcePath.fromString(name).popFirst(5));\n    }\n    static empty() {\n        return new DocumentKey(ResourcePath.emptyPath());\n    }\n    get collectionGroup() {\n        return this.path.popLast().lastSegment();\n    }\n    /** Returns true if the document is in the specified collectionId. */\n    hasCollectionId(collectionId) {\n        return (this.path.length >= 2 &&\n            this.path.get(this.path.length - 2) === collectionId);\n    }\n    /** Returns the collection group (i.e. the name of the parent collection) for this key. */\n    getCollectionGroup() {\n        return this.path.get(this.path.length - 2);\n    }\n    /** Returns the fully qualified path to the parent collection. */\n    getCollectionPath() {\n        return this.path.popLast();\n    }\n    isEqual(other) {\n        return (other !== null && ResourcePath.comparator(this.path, other.path) === 0);\n    }\n    toString() {\n        return this.path.toString();\n    }\n    static comparator(k1, k2) {\n        return ResourcePath.comparator(k1.path, k2.path);\n    }\n    static isDocumentKey(path) {\n        return path.length % 2 === 0;\n    }\n    /**\n     * Creates and returns a new document key with the given segments.\n     *\n     * @param segments - The segments of the path to the document\n     * @returns A new instance of DocumentKey\n     */\n    static fromSegments(segments) {\n        return new DocumentKey(new ResourcePath(segments.slice()));\n    }\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The initial mutation batch id for each index. Gets updated during index\n * backfill.\n */\nconst INITIAL_LARGEST_BATCH_ID = -1;\n/**\n * The initial sequence number for each index. Gets updated during index\n * backfill.\n */\nconst INITIAL_SEQUENCE_NUMBER = 0;\n/**\n * An index definition for field indexes in Firestore.\n *\n * Every index is associated with a collection. The definition contains a list\n * of fields and their index kind (which can be `ASCENDING`, `DESCENDING` or\n * `CONTAINS` for ArrayContains/ArrayContainsAny queries).\n *\n * Unlike the backend, the SDK does not differentiate between collection or\n * collection group-scoped indices. Every index can be used for both single\n * collection and collection group queries.\n */\nclass FieldIndex {\n    constructor(\n    /**\n     * The index ID. Returns -1 if the index ID is not available (e.g. the index\n     * has not yet been persisted).\n     */\n    indexId, \n    /** The collection ID this index applies to. */\n    collectionGroup, \n    /** The field segments for this index. */\n    fields, \n    /** Shows how up-to-date the index is for the current user. */\n    indexState) {\n        this.indexId = indexId;\n        this.collectionGroup = collectionGroup;\n        this.fields = fields;\n        this.indexState = indexState;\n    }\n}\n/** An ID for an index that has not yet been added to persistence.  */\nFieldIndex.UNKNOWN_ID = -1;\n/** Returns the ArrayContains/ArrayContainsAny segment for this index. */\nfunction fieldIndexGetArraySegment(fieldIndex) {\n    return fieldIndex.fields.find(s => s.kind === 2 /* IndexKind.CONTAINS */);\n}\n/** Returns all directional (ascending/descending) segments for this index. */\nfunction fieldIndexGetDirectionalSegments(fieldIndex) {\n    return fieldIndex.fields.filter(s => s.kind !== 2 /* IndexKind.CONTAINS */);\n}\n/**\n * Returns the order of the document key component for the given index.\n *\n * PORTING NOTE: This is only used in the Web IndexedDb implementation.\n */\nfunction fieldIndexGetKeyOrder(fieldIndex) {\n    const directionalSegments = fieldIndexGetDirectionalSegments(fieldIndex);\n    return directionalSegments.length === 0\n        ? 0 /* IndexKind.ASCENDING */\n        : directionalSegments[directionalSegments.length - 1].kind;\n}\n/**\n * Compares indexes by collection group and segments. Ignores update time and\n * index ID.\n */\nfunction fieldIndexSemanticComparator(left, right) {\n    let cmp = primitiveComparator(left.collectionGroup, right.collectionGroup);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    for (let i = 0; i < Math.min(left.fields.length, right.fields.length); ++i) {\n        cmp = indexSegmentComparator(left.fields[i], right.fields[i]);\n        if (cmp !== 0) {\n            return cmp;\n        }\n    }\n    return primitiveComparator(left.fields.length, right.fields.length);\n}\n/** Returns a debug representation of the field index */\nfunction fieldIndexToString(fieldIndex) {\n    return `id=${fieldIndex.indexId}|cg=${fieldIndex.collectionGroup}|f=${fieldIndex.fields.map(f => `${f.fieldPath}:${f.kind}`).join(',')}`;\n}\n/** An index component consisting of field path and index type.  */\nclass IndexSegment {\n    constructor(\n    /** The field path of the component. */\n    fieldPath, \n    /** The fields sorting order. */\n    kind) {\n        this.fieldPath = fieldPath;\n        this.kind = kind;\n    }\n}\nfunction indexSegmentComparator(left, right) {\n    const cmp = FieldPath$1.comparator(left.fieldPath, right.fieldPath);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return primitiveComparator(left.kind, right.kind);\n}\n/**\n * Stores the \"high water mark\" that indicates how updated the Index is for the\n * current user.\n */\nclass IndexState {\n    constructor(\n    /**\n     * Indicates when the index was last updated (relative to other indexes).\n     */\n    sequenceNumber, \n    /** The the latest indexed read time, document and batch id. */\n    offset) {\n        this.sequenceNumber = sequenceNumber;\n        this.offset = offset;\n    }\n    /** The state of an index that has not yet been backfilled. */\n    static empty() {\n        return new IndexState(INITIAL_SEQUENCE_NUMBER, IndexOffset.min());\n    }\n}\n/**\n * Creates an offset that matches all documents with a read time higher than\n * `readTime`.\n */\nfunction newIndexOffsetSuccessorFromReadTime(readTime, largestBatchId) {\n    // We want to create an offset that matches all documents with a read time\n    // greater than the provided read time. To do so, we technically need to\n    // create an offset for `(readTime, MAX_DOCUMENT_KEY)`. While we could use\n    // Unicode codepoints to generate MAX_DOCUMENT_KEY, it is much easier to use\n    // `(readTime + 1, DocumentKey.empty())` since `> DocumentKey.empty()` matches\n    // all valid document IDs.\n    const successorSeconds = readTime.toTimestamp().seconds;\n    const successorNanos = readTime.toTimestamp().nanoseconds + 1;\n    const successor = SnapshotVersion.fromTimestamp(successorNanos === 1e9\n        ? new Timestamp(successorSeconds + 1, 0)\n        : new Timestamp(successorSeconds, successorNanos));\n    return new IndexOffset(successor, DocumentKey.empty(), largestBatchId);\n}\n/** Creates a new offset based on the provided document. */\nfunction newIndexOffsetFromDocument(document) {\n    return new IndexOffset(document.readTime, document.key, INITIAL_LARGEST_BATCH_ID);\n}\n/**\n * Stores the latest read time, document and batch ID that were processed for an\n * index.\n */\nclass IndexOffset {\n    constructor(\n    /**\n     * The latest read time version that has been indexed by Firestore for this\n     * field index.\n     */\n    readTime, \n    /**\n     * The key of the last document that was indexed for this query. Use\n     * `DocumentKey.empty()` if no document has been indexed.\n     */\n    documentKey, \n    /*\n     * The largest mutation batch id that's been processed by Firestore.\n     */\n    largestBatchId) {\n        this.readTime = readTime;\n        this.documentKey = documentKey;\n        this.largestBatchId = largestBatchId;\n    }\n    /** Returns an offset that sorts before all regular offsets. */\n    static min() {\n        return new IndexOffset(SnapshotVersion.min(), DocumentKey.empty(), INITIAL_LARGEST_BATCH_ID);\n    }\n    /** Returns an offset that sorts after all regular offsets. */\n    static max() {\n        return new IndexOffset(SnapshotVersion.max(), DocumentKey.empty(), INITIAL_LARGEST_BATCH_ID);\n    }\n}\nfunction indexOffsetComparator(left, right) {\n    let cmp = left.readTime.compareTo(right.readTime);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = DocumentKey.comparator(left.documentKey, right.documentKey);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return primitiveComparator(left.largestBatchId, right.largestBatchId);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst PRIMARY_LEASE_LOST_ERROR_MSG = 'The current tab is not in the required state to perform this operation. ' +\n    'It might be necessary to refresh the browser tab.';\n/**\n * A base class representing a persistence transaction, encapsulating both the\n * transaction's sequence numbers as well as a list of onCommitted listeners.\n *\n * When you call Persistence.runTransaction(), it will create a transaction and\n * pass it to your callback. You then pass it to any method that operates\n * on persistence.\n */\nclass PersistenceTransaction {\n    constructor() {\n        this.onCommittedListeners = [];\n    }\n    addOnCommittedListener(listener) {\n        this.onCommittedListeners.push(listener);\n    }\n    raiseOnCommittedEvent() {\n        this.onCommittedListeners.forEach(listener => listener());\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Verifies the error thrown by a LocalStore operation. If a LocalStore\n * operation fails because the primary lease has been taken by another client,\n * we ignore the error (the persistence layer will immediately call\n * `applyPrimaryLease` to propagate the primary state change). All other errors\n * are re-thrown.\n *\n * @param err - An error returned by a LocalStore operation.\n * @returns A Promise that resolves after we recovered, or the original error.\n */\nasync function ignoreIfPrimaryLeaseLoss(err) {\n    if (err.code === Code.FAILED_PRECONDITION &&\n        err.message === PRIMARY_LEASE_LOST_ERROR_MSG) {\n        logDebug('LocalStore', 'Unexpectedly lost primary lease');\n    }\n    else {\n        throw err;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * PersistencePromise is essentially a re-implementation of Promise except\n * it has a .next() method instead of .then() and .next() and .catch() callbacks\n * are executed synchronously when a PersistencePromise resolves rather than\n * asynchronously (Promise implementations use setImmediate() or similar).\n *\n * This is necessary to interoperate with IndexedDB which will automatically\n * commit transactions if control is returned to the event loop without\n * synchronously initiating another operation on the transaction.\n *\n * NOTE: .then() and .catch() only allow a single consumer, unlike normal\n * Promises.\n */\nclass PersistencePromise {\n    constructor(callback) {\n        // NOTE: next/catchCallback will always point to our own wrapper functions,\n        // not the user's raw next() or catch() callbacks.\n        this.nextCallback = null;\n        this.catchCallback = null;\n        // When the operation resolves, we'll set result or error and mark isDone.\n        this.result = undefined;\n        this.error = undefined;\n        this.isDone = false;\n        // Set to true when .then() or .catch() are called and prevents additional\n        // chaining.\n        this.callbackAttached = false;\n        callback(value => {\n            this.isDone = true;\n            this.result = value;\n            if (this.nextCallback) {\n                // value should be defined unless T is Void, but we can't express\n                // that in the type system.\n                this.nextCallback(value);\n            }\n        }, error => {\n            this.isDone = true;\n            this.error = error;\n            if (this.catchCallback) {\n                this.catchCallback(error);\n            }\n        });\n    }\n    catch(fn) {\n        return this.next(undefined, fn);\n    }\n    next(nextFn, catchFn) {\n        if (this.callbackAttached) {\n            fail();\n        }\n        this.callbackAttached = true;\n        if (this.isDone) {\n            if (!this.error) {\n                return this.wrapSuccess(nextFn, this.result);\n            }\n            else {\n                return this.wrapFailure(catchFn, this.error);\n            }\n        }\n        else {\n            return new PersistencePromise((resolve, reject) => {\n                this.nextCallback = (value) => {\n                    this.wrapSuccess(nextFn, value).next(resolve, reject);\n                };\n                this.catchCallback = (error) => {\n                    this.wrapFailure(catchFn, error).next(resolve, reject);\n                };\n            });\n        }\n    }\n    toPromise() {\n        return new Promise((resolve, reject) => {\n            this.next(resolve, reject);\n        });\n    }\n    wrapUserFunction(fn) {\n        try {\n            const result = fn();\n            if (result instanceof PersistencePromise) {\n                return result;\n            }\n            else {\n                return PersistencePromise.resolve(result);\n            }\n        }\n        catch (e) {\n            return PersistencePromise.reject(e);\n        }\n    }\n    wrapSuccess(nextFn, value) {\n        if (nextFn) {\n            return this.wrapUserFunction(() => nextFn(value));\n        }\n        else {\n            // If there's no nextFn, then R must be the same as T\n            return PersistencePromise.resolve(value);\n        }\n    }\n    wrapFailure(catchFn, error) {\n        if (catchFn) {\n            return this.wrapUserFunction(() => catchFn(error));\n        }\n        else {\n            return PersistencePromise.reject(error);\n        }\n    }\n    static resolve(result) {\n        return new PersistencePromise((resolve, reject) => {\n            resolve(result);\n        });\n    }\n    static reject(error) {\n        return new PersistencePromise((resolve, reject) => {\n            reject(error);\n        });\n    }\n    static waitFor(\n    // Accept all Promise types in waitFor().\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    all) {\n        return new PersistencePromise((resolve, reject) => {\n            let expectedCount = 0;\n            let resolvedCount = 0;\n            let done = false;\n            all.forEach(element => {\n                ++expectedCount;\n                element.next(() => {\n                    ++resolvedCount;\n                    if (done && resolvedCount === expectedCount) {\n                        resolve();\n                    }\n                }, err => reject(err));\n            });\n            done = true;\n            if (resolvedCount === expectedCount) {\n                resolve();\n            }\n        });\n    }\n    /**\n     * Given an array of predicate functions that asynchronously evaluate to a\n     * boolean, implements a short-circuiting `or` between the results. Predicates\n     * will be evaluated until one of them returns `true`, then stop. The final\n     * result will be whether any of them returned `true`.\n     */\n    static or(predicates) {\n        let p = PersistencePromise.resolve(false);\n        for (const predicate of predicates) {\n            p = p.next(isTrue => {\n                if (isTrue) {\n                    return PersistencePromise.resolve(isTrue);\n                }\n                else {\n                    return predicate();\n                }\n            });\n        }\n        return p;\n    }\n    static forEach(collection, f) {\n        const promises = [];\n        collection.forEach((r, s) => {\n            promises.push(f.call(this, r, s));\n        });\n        return this.waitFor(promises);\n    }\n    /**\n     * Concurrently map all array elements through asynchronous function.\n     */\n    static mapArray(array, f) {\n        return new PersistencePromise((resolve, reject) => {\n            const expectedCount = array.length;\n            const results = new Array(expectedCount);\n            let resolvedCount = 0;\n            for (let i = 0; i < expectedCount; i++) {\n                const current = i;\n                f(array[current]).next(result => {\n                    results[current] = result;\n                    ++resolvedCount;\n                    if (resolvedCount === expectedCount) {\n                        resolve(results);\n                    }\n                }, err => reject(err));\n            }\n        });\n    }\n    /**\n     * An alternative to recursive PersistencePromise calls, that avoids\n     * potential memory problems from unbounded chains of promises.\n     *\n     * The `action` will be called repeatedly while `condition` is true.\n     */\n    static doWhile(condition, action) {\n        return new PersistencePromise((resolve, reject) => {\n            const process = () => {\n                if (condition() === true) {\n                    action().next(() => {\n                        process();\n                    }, reject);\n                }\n                else {\n                    resolve();\n                }\n            };\n            process();\n        });\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// References to `window` are guarded by SimpleDb.isAvailable()\n/* eslint-disable no-restricted-globals */\nconst LOG_TAG$i = 'SimpleDb';\n/**\n * The maximum number of retry attempts for an IndexedDb transaction that fails\n * with a DOMException.\n */\nconst TRANSACTION_RETRY_COUNT = 3;\n/**\n * Wraps an IDBTransaction and exposes a store() method to get a handle to a\n * specific object store.\n */\nclass SimpleDbTransaction {\n    static open(db, action, mode, objectStoreNames) {\n        try {\n            return new SimpleDbTransaction(action, db.transaction(objectStoreNames, mode));\n        }\n        catch (e) {\n            throw new IndexedDbTransactionError(action, e);\n        }\n    }\n    constructor(action, transaction) {\n        this.action = action;\n        this.transaction = transaction;\n        this.aborted = false;\n        /**\n         * A `Promise` that resolves with the result of the IndexedDb transaction.\n         */\n        this.completionDeferred = new Deferred();\n        this.transaction.oncomplete = () => {\n            this.completionDeferred.resolve();\n        };\n        this.transaction.onabort = () => {\n            if (transaction.error) {\n                this.completionDeferred.reject(new IndexedDbTransactionError(action, transaction.error));\n            }\n            else {\n                this.completionDeferred.resolve();\n            }\n        };\n        this.transaction.onerror = (event) => {\n            const error = checkForAndReportiOSError(event.target.error);\n            this.completionDeferred.reject(new IndexedDbTransactionError(action, error));\n        };\n    }\n    get completionPromise() {\n        return this.completionDeferred.promise;\n    }\n    abort(error) {\n        if (error) {\n            this.completionDeferred.reject(error);\n        }\n        if (!this.aborted) {\n            logDebug(LOG_TAG$i, 'Aborting transaction:', error ? error.message : 'Client-initiated abort');\n            this.aborted = true;\n            this.transaction.abort();\n        }\n    }\n    maybeCommit() {\n        // If the browser supports V3 IndexedDB, we invoke commit() explicitly to\n        // speed up index DB processing if the event loop remains blocks.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const maybeV3IndexedDb = this.transaction;\n        if (!this.aborted && typeof maybeV3IndexedDb.commit === 'function') {\n            maybeV3IndexedDb.commit();\n        }\n    }\n    /**\n     * Returns a SimpleDbStore<KeyType, ValueType> for the specified store. All\n     * operations performed on the SimpleDbStore happen within the context of this\n     * transaction and it cannot be used anymore once the transaction is\n     * completed.\n     *\n     * Note that we can't actually enforce that the KeyType and ValueType are\n     * correct, but they allow type safety through the rest of the consuming code.\n     */\n    store(storeName) {\n        const store = this.transaction.objectStore(storeName);\n        return new SimpleDbStore(store);\n    }\n}\n/**\n * Provides a wrapper around IndexedDb with a simplified interface that uses\n * Promise-like return values to chain operations. Real promises cannot be used\n * since .then() continuations are executed asynchronously (e.g. via\n * .setImmediate), which would cause IndexedDB to end the transaction.\n * See PersistencePromise for more details.\n */\nclass SimpleDb {\n    /** Deletes the specified database. */\n    static delete(name) {\n        logDebug(LOG_TAG$i, 'Removing database:', name);\n        return wrapRequest(window.indexedDB.deleteDatabase(name)).toPromise();\n    }\n    /** Returns true if IndexedDB is available in the current environment. */\n    static isAvailable() {\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isIndexedDBAvailable)()) {\n            return false;\n        }\n        if (SimpleDb.isMockPersistence()) {\n            return true;\n        }\n        // We extensively use indexed array values and compound keys,\n        // which IE and Edge do not support. However, they still have indexedDB\n        // defined on the window, so we need to check for them here and make sure\n        // to return that persistence is not enabled for those browsers.\n        // For tracking support of this feature, see here:\n        // https://developer.microsoft.com/en-us/microsoft-edge/platform/status/indexeddbarraysandmultientrysupport/\n        // Check the UA string to find out the browser.\n        const ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getUA)();\n        // IE 10\n        // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';\n        // IE 11\n        // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';\n        // Edge\n        // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML,\n        // like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';\n        // iOS Safari: Disable for users running iOS version < 10.\n        const iOSVersion = SimpleDb.getIOSVersion(ua);\n        const isUnsupportedIOS = 0 < iOSVersion && iOSVersion < 10;\n        // Android browser: Disable for users running version < 4.5.\n        const androidVersion = getAndroidVersion(ua);\n        const isUnsupportedAndroid = 0 < androidVersion && androidVersion < 4.5;\n        if (ua.indexOf('MSIE ') > 0 ||\n            ua.indexOf('Trident/') > 0 ||\n            ua.indexOf('Edge/') > 0 ||\n            isUnsupportedIOS ||\n            isUnsupportedAndroid) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n    /**\n     * Returns true if the backing IndexedDB store is the Node IndexedDBShim\n     * (see https://github.com/axemclion/IndexedDBShim).\n     */\n    static isMockPersistence() {\n        var _a;\n        return (typeof process !== 'undefined' &&\n            ((_a = process.env) === null || _a === void 0 ? void 0 : _a.USE_MOCK_PERSISTENCE) === 'YES');\n    }\n    /** Helper to get a typed SimpleDbStore from a transaction. */\n    static getStore(txn, store) {\n        return txn.store(store);\n    }\n    // visible for testing\n    /** Parse User Agent to determine iOS version. Returns -1 if not found. */\n    static getIOSVersion(ua) {\n        const iOSVersionRegex = ua.match(/i(?:phone|pad|pod) os ([\\d_]+)/i);\n        const version = iOSVersionRegex\n            ? iOSVersionRegex[1].split('_').slice(0, 2).join('.')\n            : '-1';\n        return Number(version);\n    }\n    /*\n     * Creates a new SimpleDb wrapper for IndexedDb database `name`.\n     *\n     * Note that `version` must not be a downgrade. IndexedDB does not support\n     * downgrading the schema version. We currently do not support any way to do\n     * versioning outside of IndexedDB's versioning mechanism, as only\n     * version-upgrade transactions are allowed to do things like create\n     * objectstores.\n     */\n    constructor(name, version, schemaConverter) {\n        this.name = name;\n        this.version = version;\n        this.schemaConverter = schemaConverter;\n        const iOSVersion = SimpleDb.getIOSVersion((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getUA)());\n        // NOTE: According to https://bugs.webkit.org/show_bug.cgi?id=197050, the\n        // bug we're checking for should exist in iOS >= 12.2 and < 13, but for\n        // whatever reason it's much harder to hit after 12.2 so we only proactively\n        // log on 12.2.\n        if (iOSVersion === 12.2) {\n            logError('Firestore persistence suffers from a bug in iOS 12.2 ' +\n                'Safari that may cause your app to stop working. See ' +\n                'https://stackoverflow.com/q/56496296/110915 for details ' +\n                'and a potential workaround.');\n        }\n    }\n    /**\n     * Opens the specified database, creating or upgrading it if necessary.\n     */\n    async ensureDb(action) {\n        if (!this.db) {\n            logDebug(LOG_TAG$i, 'Opening database:', this.name);\n            this.db = await new Promise((resolve, reject) => {\n                // TODO(mikelehen): Investigate browser compatibility.\n                // https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB\n                // suggests IE9 and older WebKit browsers handle upgrade\n                // differently. They expect setVersion, as described here:\n                // https://developer.mozilla.org/en-US/docs/Web/API/IDBVersionChangeRequest/setVersion\n                const request = indexedDB.open(this.name, this.version);\n                request.onsuccess = (event) => {\n                    const db = event.target.result;\n                    resolve(db);\n                };\n                request.onblocked = () => {\n                    reject(new IndexedDbTransactionError(action, 'Cannot upgrade IndexedDB schema while another tab is open. ' +\n                        'Close all tabs that access Firestore and reload this page to proceed.'));\n                };\n                request.onerror = (event) => {\n                    const error = event.target.error;\n                    if (error.name === 'VersionError') {\n                        reject(new FirestoreError(Code.FAILED_PRECONDITION, 'A newer version of the Firestore SDK was previously used and so the persisted ' +\n                            'data is not compatible with the version of the SDK you are now using. The SDK ' +\n                            'will operate with persistence disabled. If you need persistence, please ' +\n                            're-upgrade to a newer version of the SDK or else clear the persisted IndexedDB ' +\n                            'data for your app to start fresh.'));\n                    }\n                    else if (error.name === 'InvalidStateError') {\n                        reject(new FirestoreError(Code.FAILED_PRECONDITION, 'Unable to open an IndexedDB connection. This could be due to running in a ' +\n                            'private browsing session on a browser whose private browsing sessions do not ' +\n                            'support IndexedDB: ' +\n                            error));\n                    }\n                    else {\n                        reject(new IndexedDbTransactionError(action, error));\n                    }\n                };\n                request.onupgradeneeded = (event) => {\n                    logDebug(LOG_TAG$i, 'Database \"' + this.name + '\" requires upgrade from version:', event.oldVersion);\n                    const db = event.target.result;\n                    this.schemaConverter\n                        .createOrUpgrade(db, request.transaction, event.oldVersion, this.version)\n                        .next(() => {\n                        logDebug(LOG_TAG$i, 'Database upgrade to version ' + this.version + ' complete');\n                    });\n                };\n            });\n        }\n        if (this.versionchangelistener) {\n            this.db.onversionchange = event => this.versionchangelistener(event);\n        }\n        return this.db;\n    }\n    setVersionChangeListener(versionChangeListener) {\n        this.versionchangelistener = versionChangeListener;\n        if (this.db) {\n            this.db.onversionchange = (event) => {\n                return versionChangeListener(event);\n            };\n        }\n    }\n    async runTransaction(action, mode, objectStores, transactionFn) {\n        const readonly = mode === 'readonly';\n        let attemptNumber = 0;\n        while (true) {\n            ++attemptNumber;\n            try {\n                this.db = await this.ensureDb(action);\n                const transaction = SimpleDbTransaction.open(this.db, action, readonly ? 'readonly' : 'readwrite', objectStores);\n                const transactionFnResult = transactionFn(transaction)\n                    .next(result => {\n                    transaction.maybeCommit();\n                    return result;\n                })\n                    .catch(error => {\n                    // Abort the transaction if there was an error.\n                    transaction.abort(error);\n                    // We cannot actually recover, and calling `abort()` will cause the transaction's\n                    // completion promise to be rejected. This in turn means that we won't use\n                    // `transactionFnResult` below. We return a rejection here so that we don't add the\n                    // possibility of returning `void` to the type of `transactionFnResult`.\n                    return PersistencePromise.reject(error);\n                })\n                    .toPromise();\n                // As noted above, errors are propagated by aborting the transaction. So\n                // we swallow any error here to avoid the browser logging it as unhandled.\n                transactionFnResult.catch(() => { });\n                // Wait for the transaction to complete (i.e. IndexedDb's onsuccess event to\n                // fire), but still return the original transactionFnResult back to the\n                // caller.\n                await transaction.completionPromise;\n                return transactionFnResult;\n            }\n            catch (e) {\n                const error = e;\n                // TODO(schmidt-sebastian): We could probably be smarter about this and\n                // not retry exceptions that are likely unrecoverable (such as quota\n                // exceeded errors).\n                // Note: We cannot use an instanceof check for FirestoreException, since the\n                // exception is wrapped in a generic error by our async/await handling.\n                const retryable = error.name !== 'FirebaseError' &&\n                    attemptNumber < TRANSACTION_RETRY_COUNT;\n                logDebug(LOG_TAG$i, 'Transaction failed with error:', error.message, 'Retrying:', retryable);\n                this.close();\n                if (!retryable) {\n                    return Promise.reject(error);\n                }\n            }\n        }\n    }\n    close() {\n        if (this.db) {\n            this.db.close();\n        }\n        this.db = undefined;\n    }\n}\n/** Parse User Agent to determine Android version. Returns -1 if not found. */\nfunction getAndroidVersion(ua) {\n    const androidVersionRegex = ua.match(/Android ([\\d.]+)/i);\n    const version = androidVersionRegex\n        ? androidVersionRegex[1].split('.').slice(0, 2).join('.')\n        : '-1';\n    return Number(version);\n}\n/**\n * A controller for iterating over a key range or index. It allows an iterate\n * callback to delete the currently-referenced object, or jump to a new key\n * within the key range or index.\n */\nclass IterationController {\n    constructor(dbCursor) {\n        this.dbCursor = dbCursor;\n        this.shouldStop = false;\n        this.nextKey = null;\n    }\n    get isDone() {\n        return this.shouldStop;\n    }\n    get skipToKey() {\n        return this.nextKey;\n    }\n    set cursor(value) {\n        this.dbCursor = value;\n    }\n    /**\n     * This function can be called to stop iteration at any point.\n     */\n    done() {\n        this.shouldStop = true;\n    }\n    /**\n     * This function can be called to skip to that next key, which could be\n     * an index or a primary key.\n     */\n    skip(key) {\n        this.nextKey = key;\n    }\n    /**\n     * Delete the current cursor value from the object store.\n     *\n     * NOTE: You CANNOT do this with a keysOnly query.\n     */\n    delete() {\n        return wrapRequest(this.dbCursor.delete());\n    }\n}\n/** An error that wraps exceptions that thrown during IndexedDB execution. */\nclass IndexedDbTransactionError extends FirestoreError {\n    constructor(actionName, cause) {\n        super(Code.UNAVAILABLE, `IndexedDB transaction '${actionName}' failed: ${cause}`);\n        this.name = 'IndexedDbTransactionError';\n    }\n}\n/** Verifies whether `e` is an IndexedDbTransactionError. */\nfunction isIndexedDbTransactionError(e) {\n    // Use name equality, as instanceof checks on errors don't work with errors\n    // that wrap other errors.\n    return e.name === 'IndexedDbTransactionError';\n}\n/**\n * A wrapper around an IDBObjectStore providing an API that:\n *\n * 1) Has generic KeyType / ValueType parameters to provide strongly-typed\n * methods for acting against the object store.\n * 2) Deals with IndexedDB's onsuccess / onerror event callbacks, making every\n * method return a PersistencePromise instead.\n * 3) Provides a higher-level API to avoid needing to do excessive wrapping of\n * intermediate IndexedDB types (IDBCursorWithValue, etc.)\n */\nclass SimpleDbStore {\n    constructor(store) {\n        this.store = store;\n    }\n    put(keyOrValue, value) {\n        let request;\n        if (value !== undefined) {\n            logDebug(LOG_TAG$i, 'PUT', this.store.name, keyOrValue, value);\n            request = this.store.put(value, keyOrValue);\n        }\n        else {\n            logDebug(LOG_TAG$i, 'PUT', this.store.name, '<auto-key>', keyOrValue);\n            request = this.store.put(keyOrValue);\n        }\n        return wrapRequest(request);\n    }\n    /**\n     * Adds a new value into an Object Store and returns the new key. Similar to\n     * IndexedDb's `add()`, this method will fail on primary key collisions.\n     *\n     * @param value - The object to write.\n     * @returns The key of the value to add.\n     */\n    add(value) {\n        logDebug(LOG_TAG$i, 'ADD', this.store.name, value, value);\n        const request = this.store.add(value);\n        return wrapRequest(request);\n    }\n    /**\n     * Gets the object with the specified key from the specified store, or null\n     * if no object exists with the specified key.\n     *\n     * @key The key of the object to get.\n     * @returns The object with the specified key or null if no object exists.\n     */\n    get(key) {\n        const request = this.store.get(key);\n        // We're doing an unsafe cast to ValueType.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return wrapRequest(request).next(result => {\n            // Normalize nonexistence to null.\n            if (result === undefined) {\n                result = null;\n            }\n            logDebug(LOG_TAG$i, 'GET', this.store.name, key, result);\n            return result;\n        });\n    }\n    delete(key) {\n        logDebug(LOG_TAG$i, 'DELETE', this.store.name, key);\n        const request = this.store.delete(key);\n        return wrapRequest(request);\n    }\n    /**\n     * If we ever need more of the count variants, we can add overloads. For now,\n     * all we need is to count everything in a store.\n     *\n     * Returns the number of rows in the store.\n     */\n    count() {\n        logDebug(LOG_TAG$i, 'COUNT', this.store.name);\n        const request = this.store.count();\n        return wrapRequest(request);\n    }\n    loadAll(indexOrRange, range) {\n        const iterateOptions = this.options(indexOrRange, range);\n        // Use `getAll()` if the browser supports IndexedDB v3, as it is roughly\n        // 20% faster.\n        const store = iterateOptions.index\n            ? this.store.index(iterateOptions.index)\n            : this.store;\n        if (typeof store.getAll === 'function') {\n            const request = store.getAll(iterateOptions.range);\n            return new PersistencePromise((resolve, reject) => {\n                request.onerror = (event) => {\n                    reject(event.target.error);\n                };\n                request.onsuccess = (event) => {\n                    resolve(event.target.result);\n                };\n            });\n        }\n        else {\n            const cursor = this.cursor(iterateOptions);\n            const results = [];\n            return this.iterateCursor(cursor, (key, value) => {\n                results.push(value);\n            }).next(() => {\n                return results;\n            });\n        }\n    }\n    /**\n     * Loads the first `count` elements from the provided index range. Loads all\n     * elements if no limit is provided.\n     */\n    loadFirst(range, count) {\n        const request = this.store.getAll(range, count === null ? undefined : count);\n        return new PersistencePromise((resolve, reject) => {\n            request.onerror = (event) => {\n                reject(event.target.error);\n            };\n            request.onsuccess = (event) => {\n                resolve(event.target.result);\n            };\n        });\n    }\n    deleteAll(indexOrRange, range) {\n        logDebug(LOG_TAG$i, 'DELETE ALL', this.store.name);\n        const options = this.options(indexOrRange, range);\n        options.keysOnly = false;\n        const cursor = this.cursor(options);\n        return this.iterateCursor(cursor, (key, value, control) => {\n            // NOTE: Calling delete() on a cursor is documented as more efficient than\n            // calling delete() on an object store with a single key\n            // (https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/delete),\n            // however, this requires us *not* to use a keysOnly cursor\n            // (https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/delete). We\n            // may want to compare the performance of each method.\n            return control.delete();\n        });\n    }\n    iterate(optionsOrCallback, callback) {\n        let options;\n        if (!callback) {\n            options = {};\n            callback = optionsOrCallback;\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        const cursor = this.cursor(options);\n        return this.iterateCursor(cursor, callback);\n    }\n    /**\n     * Iterates over a store, but waits for the given callback to complete for\n     * each entry before iterating the next entry. This allows the callback to do\n     * asynchronous work to determine if this iteration should continue.\n     *\n     * The provided callback should return `true` to continue iteration, and\n     * `false` otherwise.\n     */\n    iterateSerial(callback) {\n        const cursorRequest = this.cursor({});\n        return new PersistencePromise((resolve, reject) => {\n            cursorRequest.onerror = (event) => {\n                const error = checkForAndReportiOSError(event.target.error);\n                reject(error);\n            };\n            cursorRequest.onsuccess = (event) => {\n                const cursor = event.target.result;\n                if (!cursor) {\n                    resolve();\n                    return;\n                }\n                callback(cursor.primaryKey, cursor.value).next(shouldContinue => {\n                    if (shouldContinue) {\n                        cursor.continue();\n                    }\n                    else {\n                        resolve();\n                    }\n                });\n            };\n        });\n    }\n    iterateCursor(cursorRequest, fn) {\n        const results = [];\n        return new PersistencePromise((resolve, reject) => {\n            cursorRequest.onerror = (event) => {\n                reject(event.target.error);\n            };\n            cursorRequest.onsuccess = (event) => {\n                const cursor = event.target.result;\n                if (!cursor) {\n                    resolve();\n                    return;\n                }\n                const controller = new IterationController(cursor);\n                const userResult = fn(cursor.primaryKey, cursor.value, controller);\n                if (userResult instanceof PersistencePromise) {\n                    const userPromise = userResult.catch(err => {\n                        controller.done();\n                        return PersistencePromise.reject(err);\n                    });\n                    results.push(userPromise);\n                }\n                if (controller.isDone) {\n                    resolve();\n                }\n                else if (controller.skipToKey === null) {\n                    cursor.continue();\n                }\n                else {\n                    cursor.continue(controller.skipToKey);\n                }\n            };\n        }).next(() => PersistencePromise.waitFor(results));\n    }\n    options(indexOrRange, range) {\n        let indexName = undefined;\n        if (indexOrRange !== undefined) {\n            if (typeof indexOrRange === 'string') {\n                indexName = indexOrRange;\n            }\n            else {\n                range = indexOrRange;\n            }\n        }\n        return { index: indexName, range };\n    }\n    cursor(options) {\n        let direction = 'next';\n        if (options.reverse) {\n            direction = 'prev';\n        }\n        if (options.index) {\n            const index = this.store.index(options.index);\n            if (options.keysOnly) {\n                return index.openKeyCursor(options.range, direction);\n            }\n            else {\n                return index.openCursor(options.range, direction);\n            }\n        }\n        else {\n            return this.store.openCursor(options.range, direction);\n        }\n    }\n}\n/**\n * Wraps an IDBRequest in a PersistencePromise, using the onsuccess / onerror\n * handlers to resolve / reject the PersistencePromise as appropriate.\n */\nfunction wrapRequest(request) {\n    return new PersistencePromise((resolve, reject) => {\n        request.onsuccess = (event) => {\n            const result = event.target.result;\n            resolve(result);\n        };\n        request.onerror = (event) => {\n            const error = checkForAndReportiOSError(event.target.error);\n            reject(error);\n        };\n    });\n}\n// Guard so we only report the error once.\nlet reportedIOSError = false;\nfunction checkForAndReportiOSError(error) {\n    const iOSVersion = SimpleDb.getIOSVersion((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getUA)());\n    if (iOSVersion >= 12.2 && iOSVersion < 13) {\n        const IOS_ERROR = 'An internal error was encountered in the Indexed Database server';\n        if (error.message.indexOf(IOS_ERROR) >= 0) {\n            // Wrap error in a more descriptive one.\n            const newError = new FirestoreError('internal', `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${IOS_ERROR}'. This is likely ` +\n                `due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 ` +\n                `for details and a potential workaround.`);\n            if (!reportedIOSError) {\n                reportedIOSError = true;\n                // Throw a global exception outside of this promise chain, for the user to\n                // potentially catch.\n                setTimeout(() => {\n                    throw newError;\n                }, 0);\n            }\n            return newError;\n        }\n    }\n    return error;\n}\n\nconst LOG_TAG$h = 'IndexBackfiller';\n/** How long we wait to try running index backfill after SDK initialization. */\nconst INITIAL_BACKFILL_DELAY_MS = 15 * 1000;\n/** Minimum amount of time between backfill checks, after the first one. */\nconst REGULAR_BACKFILL_DELAY_MS = 60 * 1000;\n/** The maximum number of documents to process each time backfill() is called. */\nconst MAX_DOCUMENTS_TO_PROCESS = 50;\n/** This class is responsible for the scheduling of Index Backfiller. */\nclass IndexBackfillerScheduler {\n    constructor(asyncQueue, backfiller) {\n        this.asyncQueue = asyncQueue;\n        this.backfiller = backfiller;\n        this.task = null;\n    }\n    start() {\n        this.schedule(INITIAL_BACKFILL_DELAY_MS);\n    }\n    stop() {\n        if (this.task) {\n            this.task.cancel();\n            this.task = null;\n        }\n    }\n    get started() {\n        return this.task !== null;\n    }\n    schedule(delay) {\n        logDebug(LOG_TAG$h, `Scheduled in ${delay}ms`);\n        this.task = this.asyncQueue.enqueueAfterDelay(\"index_backfill\" /* TimerId.IndexBackfill */, delay, async () => {\n            this.task = null;\n            try {\n                const documentsProcessed = await this.backfiller.backfill();\n                logDebug(LOG_TAG$h, `Documents written: ${documentsProcessed}`);\n            }\n            catch (e) {\n                if (isIndexedDbTransactionError(e)) {\n                    logDebug(LOG_TAG$h, 'Ignoring IndexedDB error during index backfill: ', e);\n                }\n                else {\n                    await ignoreIfPrimaryLeaseLoss(e);\n                }\n            }\n            await this.schedule(REGULAR_BACKFILL_DELAY_MS);\n        });\n    }\n}\n/** Implements the steps for backfilling indexes. */\nclass IndexBackfiller {\n    constructor(\n    /**\n     * LocalStore provides access to IndexManager and LocalDocumentView.\n     * These properties will update when the user changes. Consequently,\n     * making a local copy of IndexManager and LocalDocumentView will require\n     * updates over time. The simpler solution is to rely on LocalStore to have\n     * an up-to-date references to IndexManager and LocalDocumentStore.\n     */\n    localStore, persistence) {\n        this.localStore = localStore;\n        this.persistence = persistence;\n    }\n    async backfill(maxDocumentsToProcess = MAX_DOCUMENTS_TO_PROCESS) {\n        return this.persistence.runTransaction('Backfill Indexes', 'readwrite-primary', txn => this.writeIndexEntries(txn, maxDocumentsToProcess));\n    }\n    /** Writes index entries until the cap is reached. Returns the number of documents processed. */\n    writeIndexEntries(transaction, maxDocumentsToProcess) {\n        const processedCollectionGroups = new Set();\n        let documentsRemaining = maxDocumentsToProcess;\n        let continueLoop = true;\n        return PersistencePromise.doWhile(() => continueLoop === true && documentsRemaining > 0, () => {\n            return this.localStore.indexManager\n                .getNextCollectionGroupToUpdate(transaction)\n                .next((collectionGroup) => {\n                if (collectionGroup === null ||\n                    processedCollectionGroups.has(collectionGroup)) {\n                    continueLoop = false;\n                }\n                else {\n                    logDebug(LOG_TAG$h, `Processing collection: ${collectionGroup}`);\n                    return this.writeEntriesForCollectionGroup(transaction, collectionGroup, documentsRemaining).next(documentsProcessed => {\n                        documentsRemaining -= documentsProcessed;\n                        processedCollectionGroups.add(collectionGroup);\n                    });\n                }\n            });\n        }).next(() => maxDocumentsToProcess - documentsRemaining);\n    }\n    /**\n     * Writes entries for the provided collection group. Returns the number of documents processed.\n     */\n    writeEntriesForCollectionGroup(transaction, collectionGroup, documentsRemainingUnderCap) {\n        // Use the earliest offset of all field indexes to query the local cache.\n        return this.localStore.indexManager\n            .getMinOffsetFromCollectionGroup(transaction, collectionGroup)\n            .next(existingOffset => this.localStore.localDocuments\n            .getNextDocuments(transaction, collectionGroup, existingOffset, documentsRemainingUnderCap)\n            .next(nextBatch => {\n            const docs = nextBatch.changes;\n            return this.localStore.indexManager\n                .updateIndexEntries(transaction, docs)\n                .next(() => this.getNewOffset(existingOffset, nextBatch))\n                .next(newOffset => {\n                logDebug(LOG_TAG$h, `Updating offset: ${newOffset}`);\n                return this.localStore.indexManager.updateCollectionGroup(transaction, collectionGroup, newOffset);\n            })\n                .next(() => docs.size);\n        }));\n    }\n    /** Returns the next offset based on the provided documents. */\n    getNewOffset(existingOffset, lookupResult) {\n        let maxOffset = existingOffset;\n        lookupResult.changes.forEach((key, document) => {\n            const newOffset = newIndexOffsetFromDocument(document);\n            if (indexOffsetComparator(newOffset, maxOffset) > 0) {\n                maxOffset = newOffset;\n            }\n        });\n        return new IndexOffset(maxOffset.readTime, maxOffset.documentKey, Math.max(lookupResult.batchId, existingOffset.largestBatchId));\n    }\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * `ListenSequence` is a monotonic sequence. It is initialized with a minimum value to\n * exceed. All subsequent calls to next will return increasing values. If provided with a\n * `SequenceNumberSyncer`, it will additionally bump its next value when told of a new value, as\n * well as write out sequence numbers that it produces via `next()`.\n */\nclass ListenSequence {\n    constructor(previousValue, sequenceNumberSyncer) {\n        this.previousValue = previousValue;\n        if (sequenceNumberSyncer) {\n            sequenceNumberSyncer.sequenceNumberHandler = sequenceNumber => this.setPreviousValue(sequenceNumber);\n            this.writeNewSequenceNumber = sequenceNumber => sequenceNumberSyncer.writeSequenceNumber(sequenceNumber);\n        }\n    }\n    setPreviousValue(externalPreviousValue) {\n        this.previousValue = Math.max(externalPreviousValue, this.previousValue);\n        return this.previousValue;\n    }\n    next() {\n        const nextValue = ++this.previousValue;\n        if (this.writeNewSequenceNumber) {\n            this.writeNewSequenceNumber(nextValue);\n        }\n        return nextValue;\n    }\n}\nListenSequence.INVALID = -1;\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst escapeChar = '\\u0001';\nconst encodedSeparatorChar = '\\u0001';\nconst encodedNul = '\\u0010';\nconst encodedEscape = '\\u0011';\n/**\n * Encodes a resource path into a IndexedDb-compatible string form.\n */\nfunction encodeResourcePath(path) {\n    let result = '';\n    for (let i = 0; i < path.length; i++) {\n        if (result.length > 0) {\n            result = encodeSeparator(result);\n        }\n        result = encodeSegment(path.get(i), result);\n    }\n    return encodeSeparator(result);\n}\n/** Encodes a single segment of a resource path into the given result */\nfunction encodeSegment(segment, resultBuf) {\n    let result = resultBuf;\n    const length = segment.length;\n    for (let i = 0; i < length; i++) {\n        const c = segment.charAt(i);\n        switch (c) {\n            case '\\0':\n                result += escapeChar + encodedNul;\n                break;\n            case escapeChar:\n                result += escapeChar + encodedEscape;\n                break;\n            default:\n                result += c;\n        }\n    }\n    return result;\n}\n/** Encodes a path separator into the given result */\nfunction encodeSeparator(result) {\n    return result + escapeChar + encodedSeparatorChar;\n}\n/**\n * Decodes the given IndexedDb-compatible string form of a resource path into\n * a ResourcePath instance. Note that this method is not suitable for use with\n * decoding resource names from the server; those are One Platform format\n * strings.\n */\nfunction decodeResourcePath(path) {\n    // Event the empty path must encode as a path of at least length 2. A path\n    // with exactly 2 must be the empty path.\n    const length = path.length;\n    hardAssert(length >= 2);\n    if (length === 2) {\n        hardAssert(path.charAt(0) === escapeChar && path.charAt(1) === encodedSeparatorChar);\n        return ResourcePath.emptyPath();\n    }\n    // Escape characters cannot exist past the second-to-last position in the\n    // source value.\n    const lastReasonableEscapeIndex = length - 2;\n    const segments = [];\n    let segmentBuilder = '';\n    for (let start = 0; start < length;) {\n        // The last two characters of a valid encoded path must be a separator, so\n        // there must be an end to this segment.\n        const end = path.indexOf(escapeChar, start);\n        if (end < 0 || end > lastReasonableEscapeIndex) {\n            fail();\n        }\n        const next = path.charAt(end + 1);\n        switch (next) {\n            case encodedSeparatorChar:\n                const currentPiece = path.substring(start, end);\n                let segment;\n                if (segmentBuilder.length === 0) {\n                    // Avoid copying for the common case of a segment that excludes \\0\n                    // and \\001\n                    segment = currentPiece;\n                }\n                else {\n                    segmentBuilder += currentPiece;\n                    segment = segmentBuilder;\n                    segmentBuilder = '';\n                }\n                segments.push(segment);\n                break;\n            case encodedNul:\n                segmentBuilder += path.substring(start, end);\n                segmentBuilder += '\\0';\n                break;\n            case encodedEscape:\n                // The escape character can be used in the output to encode itself.\n                segmentBuilder += path.substring(start, end + 1);\n                break;\n            default:\n                fail();\n        }\n        start = end + 2;\n    }\n    return new ResourcePath(segments);\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DbRemoteDocumentStore$1 = 'remoteDocuments';\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Name of the IndexedDb object store.\n *\n * Note that the name 'owner' is chosen to ensure backwards compatibility with\n * older clients that only supported single locked access to the persistence\n * layer.\n */\nconst DbPrimaryClientStore = 'owner';\n/**\n * The key string used for the single object that exists in the\n * DbPrimaryClient store.\n */\nconst DbPrimaryClientKey = 'owner';\n/** Name of the IndexedDb object store.  */\nconst DbMutationQueueStore = 'mutationQueues';\n/** Keys are automatically assigned via the userId property. */\nconst DbMutationQueueKeyPath = 'userId';\n/** Name of the IndexedDb object store.  */\nconst DbMutationBatchStore = 'mutations';\n/** Keys are automatically assigned via the userId, batchId properties. */\nconst DbMutationBatchKeyPath = 'batchId';\n/** The index name for lookup of mutations by user. */\nconst DbMutationBatchUserMutationsIndex = 'userMutationsIndex';\n/** The user mutations index is keyed by [userId, batchId] pairs. */\nconst DbMutationBatchUserMutationsKeyPath = ['userId', 'batchId'];\n/**\n * Creates a [userId] key for use in the DbDocumentMutations index to iterate\n * over all of a user's document mutations.\n */\nfunction newDbDocumentMutationPrefixForUser(userId) {\n    return [userId];\n}\n/**\n * Creates a [userId, encodedPath] key for use in the DbDocumentMutations\n * index to iterate over all at document mutations for a given path or lower.\n */\nfunction newDbDocumentMutationPrefixForPath(userId, path) {\n    return [userId, encodeResourcePath(path)];\n}\n/**\n * Creates a full index key of [userId, encodedPath, batchId] for inserting\n * and deleting into the DbDocumentMutations index.\n */\nfunction newDbDocumentMutationKey(userId, path, batchId) {\n    return [userId, encodeResourcePath(path), batchId];\n}\n/**\n * Because we store all the useful information for this store in the key,\n * there is no useful information to store as the value. The raw (unencoded)\n * path cannot be stored because IndexedDb doesn't store prototype\n * information.\n */\nconst DbDocumentMutationPlaceholder = {};\nconst DbDocumentMutationStore = 'documentMutations';\nconst DbRemoteDocumentStore = 'remoteDocumentsV14';\n/**\n * The primary key of the remote documents store, which allows for efficient\n * access by collection path and read time.\n */\nconst DbRemoteDocumentKeyPath = [\n    'prefixPath',\n    'collectionGroup',\n    'readTime',\n    'documentId'\n];\n/** An index that provides access to documents by key. */\nconst DbRemoteDocumentDocumentKeyIndex = 'documentKeyIndex';\nconst DbRemoteDocumentDocumentKeyIndexPath = [\n    'prefixPath',\n    'collectionGroup',\n    'documentId'\n];\n/**\n * An index that provides access to documents by collection group and read\n * time.\n *\n * This index is used by the index backfiller.\n */\nconst DbRemoteDocumentCollectionGroupIndex = 'collectionGroupIndex';\nconst DbRemoteDocumentCollectionGroupIndexPath = [\n    'collectionGroup',\n    'readTime',\n    'prefixPath',\n    'documentId'\n];\nconst DbRemoteDocumentGlobalStore = 'remoteDocumentGlobal';\nconst DbRemoteDocumentGlobalKey = 'remoteDocumentGlobalKey';\nconst DbTargetStore = 'targets';\n/** Keys are automatically assigned via the targetId property. */\nconst DbTargetKeyPath = 'targetId';\n/** The name of the queryTargets index. */\nconst DbTargetQueryTargetsIndexName = 'queryTargetsIndex';\n/**\n * The index of all canonicalIds to the targets that they match. This is not\n * a unique mapping because canonicalId does not promise a unique name for all\n * possible queries, so we append the targetId to make the mapping unique.\n */\nconst DbTargetQueryTargetsKeyPath = ['canonicalId', 'targetId'];\n/** Name of the IndexedDb object store.  */\nconst DbTargetDocumentStore = 'targetDocuments';\n/** Keys are automatically assigned via the targetId, path properties. */\nconst DbTargetDocumentKeyPath = ['targetId', 'path'];\n/** The index name for the reverse index. */\nconst DbTargetDocumentDocumentTargetsIndex = 'documentTargetsIndex';\n/** We also need to create the reverse index for these properties. */\nconst DbTargetDocumentDocumentTargetsKeyPath = ['path', 'targetId'];\n/**\n * The key string used for the single object that exists in the\n * DbTargetGlobal store.\n */\nconst DbTargetGlobalKey = 'targetGlobalKey';\nconst DbTargetGlobalStore = 'targetGlobal';\n/** Name of the IndexedDb object store. */\nconst DbCollectionParentStore = 'collectionParents';\n/** Keys are automatically assigned via the collectionId, parent properties. */\nconst DbCollectionParentKeyPath = ['collectionId', 'parent'];\n/** Name of the IndexedDb object store. */\nconst DbClientMetadataStore = 'clientMetadata';\n/** Keys are automatically assigned via the clientId properties. */\nconst DbClientMetadataKeyPath = 'clientId';\n/** Name of the IndexedDb object store. */\nconst DbBundleStore = 'bundles';\nconst DbBundleKeyPath = 'bundleId';\n/** Name of the IndexedDb object store. */\nconst DbNamedQueryStore = 'namedQueries';\nconst DbNamedQueryKeyPath = 'name';\n/** Name of the IndexedDb object store. */\nconst DbIndexConfigurationStore = 'indexConfiguration';\nconst DbIndexConfigurationKeyPath = 'indexId';\n/**\n * An index that provides access to the index configurations by collection\n * group.\n *\n * PORTING NOTE: iOS and Android maintain this index in-memory, but this is\n * not possible here as the Web client supports concurrent access to\n * persistence via multi-tab.\n */\nconst DbIndexConfigurationCollectionGroupIndex = 'collectionGroupIndex';\nconst DbIndexConfigurationCollectionGroupIndexPath = 'collectionGroup';\n/** Name of the IndexedDb object store. */\nconst DbIndexStateStore = 'indexState';\nconst DbIndexStateKeyPath = ['indexId', 'uid'];\n/**\n * An index that provides access to documents in a collection sorted by last\n * update time. Used by the backfiller.\n *\n * PORTING NOTE: iOS and Android maintain this index in-memory, but this is\n * not possible here as the Web client supports concurrent access to\n * persistence via multi-tab.\n */\nconst DbIndexStateSequenceNumberIndex = 'sequenceNumberIndex';\nconst DbIndexStateSequenceNumberIndexPath = ['uid', 'sequenceNumber'];\n/** Name of the IndexedDb object store. */\nconst DbIndexEntryStore = 'indexEntries';\nconst DbIndexEntryKeyPath = [\n    'indexId',\n    'uid',\n    'arrayValue',\n    'directionalValue',\n    'orderedDocumentKey',\n    'documentKey'\n];\nconst DbIndexEntryDocumentKeyIndex = 'documentKeyIndex';\nconst DbIndexEntryDocumentKeyIndexPath = [\n    'indexId',\n    'uid',\n    'orderedDocumentKey'\n];\n/** Name of the IndexedDb object store. */\nconst DbDocumentOverlayStore = 'documentOverlays';\nconst DbDocumentOverlayKeyPath = [\n    'userId',\n    'collectionPath',\n    'documentId'\n];\nconst DbDocumentOverlayCollectionPathOverlayIndex = 'collectionPathOverlayIndex';\nconst DbDocumentOverlayCollectionPathOverlayIndexPath = [\n    'userId',\n    'collectionPath',\n    'largestBatchId'\n];\nconst DbDocumentOverlayCollectionGroupOverlayIndex = 'collectionGroupOverlayIndex';\nconst DbDocumentOverlayCollectionGroupOverlayIndexPath = [\n    'userId',\n    'collectionGroup',\n    'largestBatchId'\n];\n/** Name of the IndexedDb object store. */\nconst DbGlobalsStore = 'globals';\nconst DbGlobalsKeyPath = 'name';\n// Visible for testing\nconst V1_STORES = [\n    DbMutationQueueStore,\n    DbMutationBatchStore,\n    DbDocumentMutationStore,\n    DbRemoteDocumentStore$1,\n    DbTargetStore,\n    DbPrimaryClientStore,\n    DbTargetGlobalStore,\n    DbTargetDocumentStore\n];\n// Visible for testing\nconst V3_STORES = V1_STORES;\n// Note: DbRemoteDocumentChanges is no longer used and dropped with v9.\nconst V4_STORES = [...V3_STORES, DbClientMetadataStore];\nconst V6_STORES = [...V4_STORES, DbRemoteDocumentGlobalStore];\nconst V8_STORES = [...V6_STORES, DbCollectionParentStore];\nconst V11_STORES = [...V8_STORES, DbBundleStore, DbNamedQueryStore];\nconst V12_STORES = [...V11_STORES, DbDocumentOverlayStore];\nconst V13_STORES = [\n    DbMutationQueueStore,\n    DbMutationBatchStore,\n    DbDocumentMutationStore,\n    DbRemoteDocumentStore,\n    DbTargetStore,\n    DbPrimaryClientStore,\n    DbTargetGlobalStore,\n    DbTargetDocumentStore,\n    DbClientMetadataStore,\n    DbRemoteDocumentGlobalStore,\n    DbCollectionParentStore,\n    DbBundleStore,\n    DbNamedQueryStore,\n    DbDocumentOverlayStore\n];\nconst V14_STORES = V13_STORES;\nconst V15_STORES = [\n    ...V14_STORES,\n    DbIndexConfigurationStore,\n    DbIndexStateStore,\n    DbIndexEntryStore\n];\nconst V16_STORES = V15_STORES;\nconst V17_STORES = [...V15_STORES, DbGlobalsStore];\n/** Returns the object stores for the provided schema. */\nfunction getObjectStores(schemaVersion) {\n    if (schemaVersion === 17) {\n        return V17_STORES;\n    }\n    else if (schemaVersion === 16) {\n        return V16_STORES;\n    }\n    else if (schemaVersion === 15) {\n        return V15_STORES;\n    }\n    else if (schemaVersion === 14) {\n        return V14_STORES;\n    }\n    else if (schemaVersion === 13) {\n        return V13_STORES;\n    }\n    else if (schemaVersion === 12) {\n        return V12_STORES;\n    }\n    else if (schemaVersion === 11) {\n        return V11_STORES;\n    }\n    else {\n        fail();\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass IndexedDbTransaction extends PersistenceTransaction {\n    constructor(simpleDbTransaction, currentSequenceNumber) {\n        super();\n        this.simpleDbTransaction = simpleDbTransaction;\n        this.currentSequenceNumber = currentSequenceNumber;\n    }\n}\nfunction getStore(txn, store) {\n    const indexedDbTransaction = debugCast(txn);\n    return SimpleDb.getStore(indexedDbTransaction.simpleDbTransaction, store);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction objectSize(obj) {\n    let count = 0;\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            count++;\n        }\n    }\n    return count;\n}\nfunction forEach(obj, fn) {\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            fn(key, obj[key]);\n        }\n    }\n}\nfunction mapToArray(obj, fn) {\n    const result = [];\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            result.push(fn(obj[key], key, obj));\n        }\n    }\n    return result;\n}\nfunction isEmpty(obj) {\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// An immutable sorted map implementation, based on a Left-leaning Red-Black\n// tree.\nclass SortedMap {\n    constructor(comparator, root) {\n        this.comparator = comparator;\n        this.root = root ? root : LLRBNode.EMPTY;\n    }\n    // Returns a copy of the map, with the specified key/value added or replaced.\n    insert(key, value) {\n        return new SortedMap(this.comparator, this.root\n            .insert(key, value, this.comparator)\n            .copy(null, null, LLRBNode.BLACK, null, null));\n    }\n    // Returns a copy of the map, with the specified key removed.\n    remove(key) {\n        return new SortedMap(this.comparator, this.root\n            .remove(key, this.comparator)\n            .copy(null, null, LLRBNode.BLACK, null, null));\n    }\n    // Returns the value of the node with the given key, or null.\n    get(key) {\n        let node = this.root;\n        while (!node.isEmpty()) {\n            const cmp = this.comparator(key, node.key);\n            if (cmp === 0) {\n                return node.value;\n            }\n            else if (cmp < 0) {\n                node = node.left;\n            }\n            else if (cmp > 0) {\n                node = node.right;\n            }\n        }\n        return null;\n    }\n    // Returns the index of the element in this sorted map, or -1 if it doesn't\n    // exist.\n    indexOf(key) {\n        // Number of nodes that were pruned when descending right\n        let prunedNodes = 0;\n        let node = this.root;\n        while (!node.isEmpty()) {\n            const cmp = this.comparator(key, node.key);\n            if (cmp === 0) {\n                return prunedNodes + node.left.size;\n            }\n            else if (cmp < 0) {\n                node = node.left;\n            }\n            else {\n                // Count all nodes left of the node plus the node itself\n                prunedNodes += node.left.size + 1;\n                node = node.right;\n            }\n        }\n        // Node not found\n        return -1;\n    }\n    isEmpty() {\n        return this.root.isEmpty();\n    }\n    // Returns the total number of nodes in the map.\n    get size() {\n        return this.root.size;\n    }\n    // Returns the minimum key in the map.\n    minKey() {\n        return this.root.minKey();\n    }\n    // Returns the maximum key in the map.\n    maxKey() {\n        return this.root.maxKey();\n    }\n    // Traverses the map in key order and calls the specified action function\n    // for each key/value pair. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    inorderTraversal(action) {\n        return this.root.inorderTraversal(action);\n    }\n    forEach(fn) {\n        this.inorderTraversal((k, v) => {\n            fn(k, v);\n            return false;\n        });\n    }\n    toString() {\n        const descriptions = [];\n        this.inorderTraversal((k, v) => {\n            descriptions.push(`${k}:${v}`);\n            return false;\n        });\n        return `{${descriptions.join(', ')}}`;\n    }\n    // Traverses the map in reverse key order and calls the specified action\n    // function for each key/value pair. If action returns true, traversal is\n    // aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    reverseTraversal(action) {\n        return this.root.reverseTraversal(action);\n    }\n    // Returns an iterator over the SortedMap.\n    getIterator() {\n        return new SortedMapIterator(this.root, null, this.comparator, false);\n    }\n    getIteratorFrom(key) {\n        return new SortedMapIterator(this.root, key, this.comparator, false);\n    }\n    getReverseIterator() {\n        return new SortedMapIterator(this.root, null, this.comparator, true);\n    }\n    getReverseIteratorFrom(key) {\n        return new SortedMapIterator(this.root, key, this.comparator, true);\n    }\n} // end SortedMap\n// An iterator over an LLRBNode.\nclass SortedMapIterator {\n    constructor(node, startKey, comparator, isReverse) {\n        this.isReverse = isReverse;\n        this.nodeStack = [];\n        let cmp = 1;\n        while (!node.isEmpty()) {\n            cmp = startKey ? comparator(node.key, startKey) : 1;\n            // flip the comparison if we're going in reverse\n            if (startKey && isReverse) {\n                cmp *= -1;\n            }\n            if (cmp < 0) {\n                // This node is less than our start key. ignore it\n                if (this.isReverse) {\n                    node = node.left;\n                }\n                else {\n                    node = node.right;\n                }\n            }\n            else if (cmp === 0) {\n                // This node is exactly equal to our start key. Push it on the stack,\n                // but stop iterating;\n                this.nodeStack.push(node);\n                break;\n            }\n            else {\n                // This node is greater than our start key, add it to the stack and move\n                // to the next one\n                this.nodeStack.push(node);\n                if (this.isReverse) {\n                    node = node.right;\n                }\n                else {\n                    node = node.left;\n                }\n            }\n        }\n    }\n    getNext() {\n        let node = this.nodeStack.pop();\n        const result = { key: node.key, value: node.value };\n        if (this.isReverse) {\n            node = node.left;\n            while (!node.isEmpty()) {\n                this.nodeStack.push(node);\n                node = node.right;\n            }\n        }\n        else {\n            node = node.right;\n            while (!node.isEmpty()) {\n                this.nodeStack.push(node);\n                node = node.left;\n            }\n        }\n        return result;\n    }\n    hasNext() {\n        return this.nodeStack.length > 0;\n    }\n    peek() {\n        if (this.nodeStack.length === 0) {\n            return null;\n        }\n        const node = this.nodeStack[this.nodeStack.length - 1];\n        return { key: node.key, value: node.value };\n    }\n} // end SortedMapIterator\n// Represents a node in a Left-leaning Red-Black tree.\nclass LLRBNode {\n    constructor(key, value, color, left, right) {\n        this.key = key;\n        this.value = value;\n        this.color = color != null ? color : LLRBNode.RED;\n        this.left = left != null ? left : LLRBNode.EMPTY;\n        this.right = right != null ? right : LLRBNode.EMPTY;\n        this.size = this.left.size + 1 + this.right.size;\n    }\n    // Returns a copy of the current node, optionally replacing pieces of it.\n    copy(key, value, color, left, right) {\n        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);\n    }\n    isEmpty() {\n        return false;\n    }\n    // Traverses the tree in key order and calls the specified action function\n    // for each node. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    inorderTraversal(action) {\n        return (this.left.inorderTraversal(action) ||\n            action(this.key, this.value) ||\n            this.right.inorderTraversal(action));\n    }\n    // Traverses the tree in reverse key order and calls the specified action\n    // function for each node. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    reverseTraversal(action) {\n        return (this.right.reverseTraversal(action) ||\n            action(this.key, this.value) ||\n            this.left.reverseTraversal(action));\n    }\n    // Returns the minimum node in the tree.\n    min() {\n        if (this.left.isEmpty()) {\n            return this;\n        }\n        else {\n            return this.left.min();\n        }\n    }\n    // Returns the maximum key in the tree.\n    minKey() {\n        return this.min().key;\n    }\n    // Returns the maximum key in the tree.\n    maxKey() {\n        if (this.right.isEmpty()) {\n            return this.key;\n        }\n        else {\n            return this.right.maxKey();\n        }\n    }\n    // Returns new tree, with the key/value added.\n    insert(key, value, comparator) {\n        let n = this;\n        const cmp = comparator(key, n.key);\n        if (cmp < 0) {\n            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\n        }\n        else if (cmp === 0) {\n            n = n.copy(null, value, null, null, null);\n        }\n        else {\n            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));\n        }\n        return n.fixUp();\n    }\n    removeMin() {\n        if (this.left.isEmpty()) {\n            return LLRBNode.EMPTY;\n        }\n        let n = this;\n        if (!n.left.isRed() && !n.left.left.isRed()) {\n            n = n.moveRedLeft();\n        }\n        n = n.copy(null, null, null, n.left.removeMin(), null);\n        return n.fixUp();\n    }\n    // Returns new tree, with the specified item removed.\n    remove(key, comparator) {\n        let smallest;\n        let n = this;\n        if (comparator(key, n.key) < 0) {\n            if (!n.left.isEmpty() && !n.left.isRed() && !n.left.left.isRed()) {\n                n = n.moveRedLeft();\n            }\n            n = n.copy(null, null, null, n.left.remove(key, comparator), null);\n        }\n        else {\n            if (n.left.isRed()) {\n                n = n.rotateRight();\n            }\n            if (!n.right.isEmpty() && !n.right.isRed() && !n.right.left.isRed()) {\n                n = n.moveRedRight();\n            }\n            if (comparator(key, n.key) === 0) {\n                if (n.right.isEmpty()) {\n                    return LLRBNode.EMPTY;\n                }\n                else {\n                    smallest = n.right.min();\n                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin());\n                }\n            }\n            n = n.copy(null, null, null, null, n.right.remove(key, comparator));\n        }\n        return n.fixUp();\n    }\n    isRed() {\n        return this.color;\n    }\n    // Returns new tree after performing any needed rotations.\n    fixUp() {\n        let n = this;\n        if (n.right.isRed() && !n.left.isRed()) {\n            n = n.rotateLeft();\n        }\n        if (n.left.isRed() && n.left.left.isRed()) {\n            n = n.rotateRight();\n        }\n        if (n.left.isRed() && n.right.isRed()) {\n            n = n.colorFlip();\n        }\n        return n;\n    }\n    moveRedLeft() {\n        let n = this.colorFlip();\n        if (n.right.left.isRed()) {\n            n = n.copy(null, null, null, null, n.right.rotateRight());\n            n = n.rotateLeft();\n            n = n.colorFlip();\n        }\n        return n;\n    }\n    moveRedRight() {\n        let n = this.colorFlip();\n        if (n.left.left.isRed()) {\n            n = n.rotateRight();\n            n = n.colorFlip();\n        }\n        return n;\n    }\n    rotateLeft() {\n        const nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\n        return this.right.copy(null, null, this.color, nl, null);\n    }\n    rotateRight() {\n        const nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\n        return this.left.copy(null, null, this.color, null, nr);\n    }\n    colorFlip() {\n        const left = this.left.copy(null, null, !this.left.color, null, null);\n        const right = this.right.copy(null, null, !this.right.color, null, null);\n        return this.copy(null, null, !this.color, left, right);\n    }\n    // For testing.\n    checkMaxDepth() {\n        const blackDepth = this.check();\n        if (Math.pow(2.0, blackDepth) <= this.size + 1) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    // In a balanced RB tree, the black-depth (number of black nodes) from root to\n    // leaves is equal on both sides.  This function verifies that or asserts.\n    check() {\n        if (this.isRed() && this.left.isRed()) {\n            throw fail();\n        }\n        if (this.right.isRed()) {\n            throw fail();\n        }\n        const blackDepth = this.left.check();\n        if (blackDepth !== this.right.check()) {\n            throw fail();\n        }\n        else {\n            return blackDepth + (this.isRed() ? 0 : 1);\n        }\n    }\n} // end LLRBNode\n// Empty node is shared between all LLRB trees.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nLLRBNode.EMPTY = null;\nLLRBNode.RED = true;\nLLRBNode.BLACK = false;\n// Represents an empty node (a leaf node in the Red-Black Tree).\nclass LLRBEmptyNode {\n    constructor() {\n        this.size = 0;\n    }\n    get key() {\n        throw fail();\n    }\n    get value() {\n        throw fail();\n    }\n    get color() {\n        throw fail();\n    }\n    get left() {\n        throw fail();\n    }\n    get right() {\n        throw fail();\n    }\n    // Returns a copy of the current node.\n    copy(key, value, color, left, right) {\n        return this;\n    }\n    // Returns a copy of the tree, with the specified key/value added.\n    insert(key, value, comparator) {\n        return new LLRBNode(key, value);\n    }\n    // Returns a copy of the tree, with the specified key removed.\n    remove(key, comparator) {\n        return this;\n    }\n    isEmpty() {\n        return true;\n    }\n    inorderTraversal(action) {\n        return false;\n    }\n    reverseTraversal(action) {\n        return false;\n    }\n    minKey() {\n        return null;\n    }\n    maxKey() {\n        return null;\n    }\n    isRed() {\n        return false;\n    }\n    // For testing.\n    checkMaxDepth() {\n        return true;\n    }\n    check() {\n        return 0;\n    }\n} // end LLRBEmptyNode\nLLRBNode.EMPTY = new LLRBEmptyNode();\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * SortedSet is an immutable (copy-on-write) collection that holds elements\n * in order specified by the provided comparator.\n *\n * NOTE: if provided comparator returns 0 for two elements, we consider them to\n * be equal!\n */\nclass SortedSet {\n    constructor(comparator) {\n        this.comparator = comparator;\n        this.data = new SortedMap(this.comparator);\n    }\n    has(elem) {\n        return this.data.get(elem) !== null;\n    }\n    first() {\n        return this.data.minKey();\n    }\n    last() {\n        return this.data.maxKey();\n    }\n    get size() {\n        return this.data.size;\n    }\n    indexOf(elem) {\n        return this.data.indexOf(elem);\n    }\n    /** Iterates elements in order defined by \"comparator\" */\n    forEach(cb) {\n        this.data.inorderTraversal((k, v) => {\n            cb(k);\n            return false;\n        });\n    }\n    /** Iterates over `elem`s such that: range[0] &lt;= elem &lt; range[1]. */\n    forEachInRange(range, cb) {\n        const iter = this.data.getIteratorFrom(range[0]);\n        while (iter.hasNext()) {\n            const elem = iter.getNext();\n            if (this.comparator(elem.key, range[1]) >= 0) {\n                return;\n            }\n            cb(elem.key);\n        }\n    }\n    /**\n     * Iterates over `elem`s such that: start &lt;= elem until false is returned.\n     */\n    forEachWhile(cb, start) {\n        let iter;\n        if (start !== undefined) {\n            iter = this.data.getIteratorFrom(start);\n        }\n        else {\n            iter = this.data.getIterator();\n        }\n        while (iter.hasNext()) {\n            const elem = iter.getNext();\n            const result = cb(elem.key);\n            if (!result) {\n                return;\n            }\n        }\n    }\n    /** Finds the least element greater than or equal to `elem`. */\n    firstAfterOrEqual(elem) {\n        const iter = this.data.getIteratorFrom(elem);\n        return iter.hasNext() ? iter.getNext().key : null;\n    }\n    getIterator() {\n        return new SortedSetIterator(this.data.getIterator());\n    }\n    getIteratorFrom(key) {\n        return new SortedSetIterator(this.data.getIteratorFrom(key));\n    }\n    /** Inserts or updates an element */\n    add(elem) {\n        return this.copy(this.data.remove(elem).insert(elem, true));\n    }\n    /** Deletes an element */\n    delete(elem) {\n        if (!this.has(elem)) {\n            return this;\n        }\n        return this.copy(this.data.remove(elem));\n    }\n    isEmpty() {\n        return this.data.isEmpty();\n    }\n    unionWith(other) {\n        let result = this;\n        // Make sure `result` always refers to the larger one of the two sets.\n        if (result.size < other.size) {\n            result = other;\n            other = this;\n        }\n        other.forEach(elem => {\n            result = result.add(elem);\n        });\n        return result;\n    }\n    isEqual(other) {\n        if (!(other instanceof SortedSet)) {\n            return false;\n        }\n        if (this.size !== other.size) {\n            return false;\n        }\n        const thisIt = this.data.getIterator();\n        const otherIt = other.data.getIterator();\n        while (thisIt.hasNext()) {\n            const thisElem = thisIt.getNext().key;\n            const otherElem = otherIt.getNext().key;\n            if (this.comparator(thisElem, otherElem) !== 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    toArray() {\n        const res = [];\n        this.forEach(targetId => {\n            res.push(targetId);\n        });\n        return res;\n    }\n    toString() {\n        const result = [];\n        this.forEach(elem => result.push(elem));\n        return 'SortedSet(' + result.toString() + ')';\n    }\n    copy(data) {\n        const result = new SortedSet(this.comparator);\n        result.data = data;\n        return result;\n    }\n}\nclass SortedSetIterator {\n    constructor(iter) {\n        this.iter = iter;\n    }\n    getNext() {\n        return this.iter.getNext().key;\n    }\n    hasNext() {\n        return this.iter.hasNext();\n    }\n}\n/**\n * Compares two sorted sets for equality using their natural ordering. The\n * method computes the intersection and invokes `onAdd` for every element that\n * is in `after` but not `before`. `onRemove` is invoked for every element in\n * `before` but missing from `after`.\n *\n * The method creates a copy of both `before` and `after` and runs in O(n log\n * n), where n is the size of the two lists.\n *\n * @param before - The elements that exist in the original set.\n * @param after - The elements to diff against the original set.\n * @param comparator - The comparator for the elements in before and after.\n * @param onAdd - A function to invoke for every element that is part of `\n * after` but not `before`.\n * @param onRemove - A function to invoke for every element that is part of\n * `before` but not `after`.\n */\nfunction diffSortedSets(before, after, comparator, onAdd, onRemove) {\n    const beforeIt = before.getIterator();\n    const afterIt = after.getIterator();\n    let beforeValue = advanceIterator(beforeIt);\n    let afterValue = advanceIterator(afterIt);\n    // Walk through the two sets at the same time, using the ordering defined by\n    // `comparator`.\n    while (beforeValue || afterValue) {\n        let added = false;\n        let removed = false;\n        if (beforeValue && afterValue) {\n            const cmp = comparator(beforeValue, afterValue);\n            if (cmp < 0) {\n                // The element was removed if the next element in our ordered\n                // walkthrough is only in `before`.\n                removed = true;\n            }\n            else if (cmp > 0) {\n                // The element was added if the next element in our ordered walkthrough\n                // is only in `after`.\n                added = true;\n            }\n        }\n        else if (beforeValue != null) {\n            removed = true;\n        }\n        else {\n            added = true;\n        }\n        if (added) {\n            onAdd(afterValue);\n            afterValue = advanceIterator(afterIt);\n        }\n        else if (removed) {\n            onRemove(beforeValue);\n            beforeValue = advanceIterator(beforeIt);\n        }\n        else {\n            beforeValue = advanceIterator(beforeIt);\n            afterValue = advanceIterator(afterIt);\n        }\n    }\n}\n/**\n * Returns the next element from the iterator or `undefined` if none available.\n */\nfunction advanceIterator(it) {\n    return it.hasNext() ? it.getNext() : undefined;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provides a set of fields that can be used to partially patch a document.\n * FieldMask is used in conjunction with ObjectValue.\n * Examples:\n *   foo - Overwrites foo entirely with the provided value. If foo is not\n *         present in the companion ObjectValue, the field is deleted.\n *   foo.bar - Overwrites only the field bar of the object foo.\n *             If foo is not an object, foo is replaced with an object\n *             containing foo\n */\nclass FieldMask {\n    constructor(fields) {\n        this.fields = fields;\n        // TODO(dimond): validation of FieldMask\n        // Sort the field mask to support `FieldMask.isEqual()` and assert below.\n        fields.sort(FieldPath$1.comparator);\n    }\n    static empty() {\n        return new FieldMask([]);\n    }\n    /**\n     * Returns a new FieldMask object that is the result of adding all the given\n     * fields paths to this field mask.\n     */\n    unionWith(extraFields) {\n        let mergedMaskSet = new SortedSet(FieldPath$1.comparator);\n        for (const fieldPath of this.fields) {\n            mergedMaskSet = mergedMaskSet.add(fieldPath);\n        }\n        for (const fieldPath of extraFields) {\n            mergedMaskSet = mergedMaskSet.add(fieldPath);\n        }\n        return new FieldMask(mergedMaskSet.toArray());\n    }\n    /**\n     * Verifies that `fieldPath` is included by at least one field in this field\n     * mask.\n     *\n     * This is an O(n) operation, where `n` is the size of the field mask.\n     */\n    covers(fieldPath) {\n        for (const fieldMaskPath of this.fields) {\n            if (fieldMaskPath.isPrefixOf(fieldPath)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isEqual(other) {\n        return arrayEquals(this.fields, other.fields, (l, r) => l.isEqual(r));\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Converts a Base64 encoded string to a binary string. */\nfunction decodeBase64(encoded) {\n    // Note: We used to validate the base64 string here via a regular expression.\n    // This was removed to improve the performance of indexing.\n    return Buffer.from(encoded, 'base64').toString('binary');\n}\n/** Converts a binary string to a Base64 encoded string. */\nfunction encodeBase64(raw) {\n    return Buffer.from(raw, 'binary').toString('base64');\n}\n/** True if and only if the Base64 conversion functions are available. */\nfunction isBase64Available() {\n    return true;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Immutable class that represents a \"proto\" byte string.\n *\n * Proto byte strings can either be Base64-encoded strings or Uint8Arrays when\n * sent on the wire. This class abstracts away this differentiation by holding\n * the proto byte string in a common class that must be converted into a string\n * before being sent as a proto.\n * @internal\n */\nclass ByteString {\n    constructor(binaryString) {\n        this.binaryString = binaryString;\n    }\n    static fromBase64String(base64) {\n        const binaryString = decodeBase64(base64);\n        return new ByteString(binaryString);\n    }\n    static fromUint8Array(array) {\n        // TODO(indexing); Remove the copy of the byte string here as this method\n        // is frequently called during indexing.\n        const binaryString = binaryStringFromUint8Array(array);\n        return new ByteString(binaryString);\n    }\n    [Symbol.iterator]() {\n        let i = 0;\n        return {\n            next: () => {\n                if (i < this.binaryString.length) {\n                    return { value: this.binaryString.charCodeAt(i++), done: false };\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n    }\n    toBase64() {\n        return encodeBase64(this.binaryString);\n    }\n    toUint8Array() {\n        return uint8ArrayFromBinaryString(this.binaryString);\n    }\n    approximateByteSize() {\n        return this.binaryString.length * 2;\n    }\n    compareTo(other) {\n        return primitiveComparator(this.binaryString, other.binaryString);\n    }\n    isEqual(other) {\n        return this.binaryString === other.binaryString;\n    }\n}\nByteString.EMPTY_BYTE_STRING = new ByteString('');\n/**\n * Helper function to convert an Uint8array to a binary string.\n */\nfunction binaryStringFromUint8Array(array) {\n    let binaryString = '';\n    for (let i = 0; i < array.length; ++i) {\n        binaryString += String.fromCharCode(array[i]);\n    }\n    return binaryString;\n}\n/**\n * Helper function to convert a binary string to an Uint8Array.\n */\nfunction uint8ArrayFromBinaryString(binaryString) {\n    const buffer = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n        buffer[i] = binaryString.charCodeAt(i);\n    }\n    return buffer;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// A RegExp matching ISO 8601 UTC timestamps with optional fraction.\nconst ISO_TIMESTAMP_REG_EXP = new RegExp(/^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(?:\\.(\\d+))?Z$/);\n/**\n * Converts the possible Proto values for a timestamp value into a \"seconds and\n * nanos\" representation.\n */\nfunction normalizeTimestamp(date) {\n    hardAssert(!!date);\n    // The json interface (for the browser) will return an iso timestamp string,\n    // while the proto js library (for node) will return a\n    // google.protobuf.Timestamp instance.\n    if (typeof date === 'string') {\n        // The date string can have higher precision (nanos) than the Date class\n        // (millis), so we do some custom parsing here.\n        // Parse the nanos right out of the string.\n        let nanos = 0;\n        const fraction = ISO_TIMESTAMP_REG_EXP.exec(date);\n        hardAssert(!!fraction);\n        if (fraction[1]) {\n            // Pad the fraction out to 9 digits (nanos).\n            let nanoStr = fraction[1];\n            nanoStr = (nanoStr + '000000000').substr(0, 9);\n            nanos = Number(nanoStr);\n        }\n        // Parse the date to get the seconds.\n        const parsedDate = new Date(date);\n        const seconds = Math.floor(parsedDate.getTime() / 1000);\n        return { seconds, nanos };\n    }\n    else {\n        // TODO(b/37282237): Use strings for Proto3 timestamps\n        // assert(!this.options.useProto3Json,\n        //   'The timestamp instance format requires Proto JS.');\n        const seconds = normalizeNumber(date.seconds);\n        const nanos = normalizeNumber(date.nanos);\n        return { seconds, nanos };\n    }\n}\n/**\n * Converts the possible Proto types for numbers into a JavaScript number.\n * Returns 0 if the value is not numeric.\n */\nfunction normalizeNumber(value) {\n    // TODO(bjornick): Handle int64 greater than 53 bits.\n    if (typeof value === 'number') {\n        return value;\n    }\n    else if (typeof value === 'string') {\n        return Number(value);\n    }\n    else {\n        return 0;\n    }\n}\n/** Converts the possible Proto types for Blobs into a ByteString. */\nfunction normalizeByteString(blob) {\n    if (typeof blob === 'string') {\n        return ByteString.fromBase64String(blob);\n    }\n    else {\n        return ByteString.fromUint8Array(blob);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a locally-applied ServerTimestamp.\n *\n * Server Timestamps are backed by MapValues that contain an internal field\n * `__type__` with a value of `server_timestamp`. The previous value and local\n * write time are stored in its `__previous_value__` and `__local_write_time__`\n * fields respectively.\n *\n * Notes:\n * - ServerTimestampValue instances are created as the result of applying a\n *   transform. They can only exist in the local view of a document. Therefore\n *   they do not need to be parsed or serialized.\n * - When evaluated locally (e.g. for snapshot.data()), they by default\n *   evaluate to `null`. This behavior can be configured by passing custom\n *   FieldValueOptions to value().\n * - With respect to other ServerTimestampValues, they sort by their\n *   localWriteTime.\n */\nconst SERVER_TIMESTAMP_SENTINEL = 'server_timestamp';\nconst TYPE_KEY$1 = '__type__';\nconst PREVIOUS_VALUE_KEY = '__previous_value__';\nconst LOCAL_WRITE_TIME_KEY = '__local_write_time__';\nfunction isServerTimestamp(value) {\n    var _a, _b;\n    const type = (_b = (((_a = value === null || value === void 0 ? void 0 : value.mapValue) === null || _a === void 0 ? void 0 : _a.fields) || {})[TYPE_KEY$1]) === null || _b === void 0 ? void 0 : _b.stringValue;\n    return type === SERVER_TIMESTAMP_SENTINEL;\n}\n/**\n * Creates a new ServerTimestamp proto value (using the internal format).\n */\nfunction serverTimestamp$1(localWriteTime, previousValue) {\n    const mapValue = {\n        fields: {\n            [TYPE_KEY$1]: {\n                stringValue: SERVER_TIMESTAMP_SENTINEL\n            },\n            [LOCAL_WRITE_TIME_KEY]: {\n                timestampValue: {\n                    seconds: localWriteTime.seconds,\n                    nanos: localWriteTime.nanoseconds\n                }\n            }\n        }\n    };\n    // We should avoid storing deeply nested server timestamp map values\n    // because we never use the intermediate \"previous values\".\n    // For example:\n    // previous: 42L, add: t1, result: t1 -> 42L\n    // previous: t1,  add: t2, result: t2 -> 42L (NOT t2 -> t1 -> 42L)\n    // previous: t2,  add: t3, result: t3 -> 42L (NOT t3 -> t2 -> t1 -> 42L)\n    // `getPreviousValue` recursively traverses server timestamps to find the\n    // least recent Value.\n    if (previousValue && isServerTimestamp(previousValue)) {\n        previousValue = getPreviousValue(previousValue);\n    }\n    if (previousValue) {\n        mapValue.fields[PREVIOUS_VALUE_KEY] = previousValue;\n    }\n    return { mapValue };\n}\n/**\n * Returns the value of the field before this ServerTimestamp was set.\n *\n * Preserving the previous values allows the user to display the last resoled\n * value until the backend responds with the timestamp.\n */\nfunction getPreviousValue(value) {\n    const previousValue = value.mapValue.fields[PREVIOUS_VALUE_KEY];\n    if (isServerTimestamp(previousValue)) {\n        return getPreviousValue(previousValue);\n    }\n    return previousValue;\n}\n/**\n * Returns the local time at which this timestamp was first set.\n */\nfunction getLocalWriteTime(value) {\n    const localWriteTime = normalizeTimestamp(value.mapValue.fields[LOCAL_WRITE_TIME_KEY].timestampValue);\n    return new Timestamp(localWriteTime.seconds, localWriteTime.nanos);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass DatabaseInfo {\n    /**\n     * Constructs a DatabaseInfo using the provided host, databaseId and\n     * persistenceKey.\n     *\n     * @param databaseId - The database to use.\n     * @param appId - The Firebase App Id.\n     * @param persistenceKey - A unique identifier for this Firestore's local\n     * storage (used in conjunction with the databaseId).\n     * @param host - The Firestore backend host to connect to.\n     * @param ssl - Whether to use SSL when connecting.\n     * @param forceLongPolling - Whether to use the forceLongPolling option\n     * when using WebChannel as the network transport.\n     * @param autoDetectLongPolling - Whether to use the detectBufferingProxy\n     * option when using WebChannel as the network transport.\n     * @param longPollingOptions Options that configure long-polling.\n     * @param useFetchStreams Whether to use the Fetch API instead of\n     * XMLHTTPRequest\n     */\n    constructor(databaseId, appId, persistenceKey, host, ssl, forceLongPolling, autoDetectLongPolling, longPollingOptions, useFetchStreams) {\n        this.databaseId = databaseId;\n        this.appId = appId;\n        this.persistenceKey = persistenceKey;\n        this.host = host;\n        this.ssl = ssl;\n        this.forceLongPolling = forceLongPolling;\n        this.autoDetectLongPolling = autoDetectLongPolling;\n        this.longPollingOptions = longPollingOptions;\n        this.useFetchStreams = useFetchStreams;\n    }\n}\n/** The default database name for a project. */\nconst DEFAULT_DATABASE_NAME = '(default)';\n/**\n * Represents the database ID a Firestore client is associated with.\n * @internal\n */\nclass DatabaseId {\n    constructor(projectId, database) {\n        this.projectId = projectId;\n        this.database = database ? database : DEFAULT_DATABASE_NAME;\n    }\n    static empty() {\n        return new DatabaseId('', '');\n    }\n    get isDefaultDatabase() {\n        return this.database === DEFAULT_DATABASE_NAME;\n    }\n    isEqual(other) {\n        return (other instanceof DatabaseId &&\n            other.projectId === this.projectId &&\n            other.database === this.database);\n    }\n}\nfunction databaseIdFromApp(app, database) {\n    if (!Object.prototype.hasOwnProperty.apply(app.options, ['projectId'])) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, '\"projectId\" not provided in firebase.initializeApp.');\n    }\n    return new DatabaseId(app.options.projectId, database);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Sentinel value that sorts before any Mutation Batch ID. */\nconst BATCHID_UNKNOWN = -1;\n/**\n * Returns whether a variable is either undefined or null.\n */\nfunction isNullOrUndefined(value) {\n    return value === null || value === undefined;\n}\n/** Returns whether the value represents -0. */\nfunction isNegativeZero(value) {\n    // Detect if the value is -0.0. Based on polyfill from\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n    return value === 0 && 1 / value === 1 / -0;\n}\n/**\n * Returns whether a value is an integer and in the safe integer range\n * @param value - The value to test for being an integer and in the safe range\n */\nfunction isSafeInteger(value) {\n    return (typeof value === 'number' &&\n        Number.isInteger(value) &&\n        !isNegativeZero(value) &&\n        value <= Number.MAX_SAFE_INTEGER &&\n        value >= Number.MIN_SAFE_INTEGER);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst TYPE_KEY = '__type__';\nconst MAX_VALUE_TYPE = '__max__';\nconst MAX_VALUE = {\n    mapValue: {\n        fields: {\n            '__type__': { stringValue: MAX_VALUE_TYPE }\n        }\n    }\n};\nconst VECTOR_VALUE_SENTINEL = '__vector__';\nconst VECTOR_MAP_VECTORS_KEY = 'value';\nconst MIN_VALUE = {\n    nullValue: 'NULL_VALUE'\n};\n/** Extracts the backend's type order for the provided value. */\nfunction typeOrder(value) {\n    if ('nullValue' in value) {\n        return 0 /* TypeOrder.NullValue */;\n    }\n    else if ('booleanValue' in value) {\n        return 1 /* TypeOrder.BooleanValue */;\n    }\n    else if ('integerValue' in value || 'doubleValue' in value) {\n        return 2 /* TypeOrder.NumberValue */;\n    }\n    else if ('timestampValue' in value) {\n        return 3 /* TypeOrder.TimestampValue */;\n    }\n    else if ('stringValue' in value) {\n        return 5 /* TypeOrder.StringValue */;\n    }\n    else if ('bytesValue' in value) {\n        return 6 /* TypeOrder.BlobValue */;\n    }\n    else if ('referenceValue' in value) {\n        return 7 /* TypeOrder.RefValue */;\n    }\n    else if ('geoPointValue' in value) {\n        return 8 /* TypeOrder.GeoPointValue */;\n    }\n    else if ('arrayValue' in value) {\n        return 9 /* TypeOrder.ArrayValue */;\n    }\n    else if ('mapValue' in value) {\n        if (isServerTimestamp(value)) {\n            return 4 /* TypeOrder.ServerTimestampValue */;\n        }\n        else if (isMaxValue(value)) {\n            return 9007199254740991 /* TypeOrder.MaxValue */;\n        }\n        else if (isVectorValue(value)) {\n            return 10 /* TypeOrder.VectorValue */;\n        }\n        return 11 /* TypeOrder.ObjectValue */;\n    }\n    else {\n        return fail();\n    }\n}\n/** Tests `left` and `right` for equality based on the backend semantics. */\nfunction valueEquals(left, right) {\n    if (left === right) {\n        return true;\n    }\n    const leftType = typeOrder(left);\n    const rightType = typeOrder(right);\n    if (leftType !== rightType) {\n        return false;\n    }\n    switch (leftType) {\n        case 0 /* TypeOrder.NullValue */:\n            return true;\n        case 1 /* TypeOrder.BooleanValue */:\n            return left.booleanValue === right.booleanValue;\n        case 4 /* TypeOrder.ServerTimestampValue */:\n            return getLocalWriteTime(left).isEqual(getLocalWriteTime(right));\n        case 3 /* TypeOrder.TimestampValue */:\n            return timestampEquals(left, right);\n        case 5 /* TypeOrder.StringValue */:\n            return left.stringValue === right.stringValue;\n        case 6 /* TypeOrder.BlobValue */:\n            return blobEquals(left, right);\n        case 7 /* TypeOrder.RefValue */:\n            return left.referenceValue === right.referenceValue;\n        case 8 /* TypeOrder.GeoPointValue */:\n            return geoPointEquals(left, right);\n        case 2 /* TypeOrder.NumberValue */:\n            return numberEquals(left, right);\n        case 9 /* TypeOrder.ArrayValue */:\n            return arrayEquals(left.arrayValue.values || [], right.arrayValue.values || [], valueEquals);\n        case 10 /* TypeOrder.VectorValue */:\n        case 11 /* TypeOrder.ObjectValue */:\n            return objectEquals(left, right);\n        case 9007199254740991 /* TypeOrder.MaxValue */:\n            return true;\n        default:\n            return fail();\n    }\n}\nfunction timestampEquals(left, right) {\n    if (typeof left.timestampValue === 'string' &&\n        typeof right.timestampValue === 'string' &&\n        left.timestampValue.length === right.timestampValue.length) {\n        // Use string equality for ISO 8601 timestamps\n        return left.timestampValue === right.timestampValue;\n    }\n    const leftTimestamp = normalizeTimestamp(left.timestampValue);\n    const rightTimestamp = normalizeTimestamp(right.timestampValue);\n    return (leftTimestamp.seconds === rightTimestamp.seconds &&\n        leftTimestamp.nanos === rightTimestamp.nanos);\n}\nfunction geoPointEquals(left, right) {\n    return (normalizeNumber(left.geoPointValue.latitude) ===\n        normalizeNumber(right.geoPointValue.latitude) &&\n        normalizeNumber(left.geoPointValue.longitude) ===\n            normalizeNumber(right.geoPointValue.longitude));\n}\nfunction blobEquals(left, right) {\n    return normalizeByteString(left.bytesValue).isEqual(normalizeByteString(right.bytesValue));\n}\nfunction numberEquals(left, right) {\n    if ('integerValue' in left && 'integerValue' in right) {\n        return (normalizeNumber(left.integerValue) === normalizeNumber(right.integerValue));\n    }\n    else if ('doubleValue' in left && 'doubleValue' in right) {\n        const n1 = normalizeNumber(left.doubleValue);\n        const n2 = normalizeNumber(right.doubleValue);\n        if (n1 === n2) {\n            return isNegativeZero(n1) === isNegativeZero(n2);\n        }\n        else {\n            return isNaN(n1) && isNaN(n2);\n        }\n    }\n    return false;\n}\nfunction objectEquals(left, right) {\n    const leftMap = left.mapValue.fields || {};\n    const rightMap = right.mapValue.fields || {};\n    if (objectSize(leftMap) !== objectSize(rightMap)) {\n        return false;\n    }\n    for (const key in leftMap) {\n        if (leftMap.hasOwnProperty(key)) {\n            if (rightMap[key] === undefined ||\n                !valueEquals(leftMap[key], rightMap[key])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n/** Returns true if the ArrayValue contains the specified element. */\nfunction arrayValueContains(haystack, needle) {\n    return ((haystack.values || []).find(v => valueEquals(v, needle)) !== undefined);\n}\nfunction valueCompare(left, right) {\n    if (left === right) {\n        return 0;\n    }\n    const leftType = typeOrder(left);\n    const rightType = typeOrder(right);\n    if (leftType !== rightType) {\n        return primitiveComparator(leftType, rightType);\n    }\n    switch (leftType) {\n        case 0 /* TypeOrder.NullValue */:\n        case 9007199254740991 /* TypeOrder.MaxValue */:\n            return 0;\n        case 1 /* TypeOrder.BooleanValue */:\n            return primitiveComparator(left.booleanValue, right.booleanValue);\n        case 2 /* TypeOrder.NumberValue */:\n            return compareNumbers(left, right);\n        case 3 /* TypeOrder.TimestampValue */:\n            return compareTimestamps(left.timestampValue, right.timestampValue);\n        case 4 /* TypeOrder.ServerTimestampValue */:\n            return compareTimestamps(getLocalWriteTime(left), getLocalWriteTime(right));\n        case 5 /* TypeOrder.StringValue */:\n            return primitiveComparator(left.stringValue, right.stringValue);\n        case 6 /* TypeOrder.BlobValue */:\n            return compareBlobs(left.bytesValue, right.bytesValue);\n        case 7 /* TypeOrder.RefValue */:\n            return compareReferences(left.referenceValue, right.referenceValue);\n        case 8 /* TypeOrder.GeoPointValue */:\n            return compareGeoPoints(left.geoPointValue, right.geoPointValue);\n        case 9 /* TypeOrder.ArrayValue */:\n            return compareArrays(left.arrayValue, right.arrayValue);\n        case 10 /* TypeOrder.VectorValue */:\n            return compareVectors(left.mapValue, right.mapValue);\n        case 11 /* TypeOrder.ObjectValue */:\n            return compareMaps(left.mapValue, right.mapValue);\n        default:\n            throw fail();\n    }\n}\nfunction compareNumbers(left, right) {\n    const leftNumber = normalizeNumber(left.integerValue || left.doubleValue);\n    const rightNumber = normalizeNumber(right.integerValue || right.doubleValue);\n    if (leftNumber < rightNumber) {\n        return -1;\n    }\n    else if (leftNumber > rightNumber) {\n        return 1;\n    }\n    else if (leftNumber === rightNumber) {\n        return 0;\n    }\n    else {\n        // one or both are NaN.\n        if (isNaN(leftNumber)) {\n            return isNaN(rightNumber) ? 0 : -1;\n        }\n        else {\n            return 1;\n        }\n    }\n}\nfunction compareTimestamps(left, right) {\n    if (typeof left === 'string' &&\n        typeof right === 'string' &&\n        left.length === right.length) {\n        return primitiveComparator(left, right);\n    }\n    const leftTimestamp = normalizeTimestamp(left);\n    const rightTimestamp = normalizeTimestamp(right);\n    const comparison = primitiveComparator(leftTimestamp.seconds, rightTimestamp.seconds);\n    if (comparison !== 0) {\n        return comparison;\n    }\n    return primitiveComparator(leftTimestamp.nanos, rightTimestamp.nanos);\n}\nfunction compareReferences(leftPath, rightPath) {\n    const leftSegments = leftPath.split('/');\n    const rightSegments = rightPath.split('/');\n    for (let i = 0; i < leftSegments.length && i < rightSegments.length; i++) {\n        const comparison = primitiveComparator(leftSegments[i], rightSegments[i]);\n        if (comparison !== 0) {\n            return comparison;\n        }\n    }\n    return primitiveComparator(leftSegments.length, rightSegments.length);\n}\nfunction compareGeoPoints(left, right) {\n    const comparison = primitiveComparator(normalizeNumber(left.latitude), normalizeNumber(right.latitude));\n    if (comparison !== 0) {\n        return comparison;\n    }\n    return primitiveComparator(normalizeNumber(left.longitude), normalizeNumber(right.longitude));\n}\nfunction compareBlobs(left, right) {\n    const leftBytes = normalizeByteString(left);\n    const rightBytes = normalizeByteString(right);\n    return leftBytes.compareTo(rightBytes);\n}\nfunction compareArrays(left, right) {\n    const leftArray = left.values || [];\n    const rightArray = right.values || [];\n    for (let i = 0; i < leftArray.length && i < rightArray.length; ++i) {\n        const compare = valueCompare(leftArray[i], rightArray[i]);\n        if (compare) {\n            return compare;\n        }\n    }\n    return primitiveComparator(leftArray.length, rightArray.length);\n}\nfunction compareVectors(left, right) {\n    var _a, _b, _c, _d;\n    const leftMap = left.fields || {};\n    const rightMap = right.fields || {};\n    // The vector is a map, but only vector value is compared.\n    const leftArrayValue = (_a = leftMap[VECTOR_MAP_VECTORS_KEY]) === null || _a === void 0 ? void 0 : _a.arrayValue;\n    const rightArrayValue = (_b = rightMap[VECTOR_MAP_VECTORS_KEY]) === null || _b === void 0 ? void 0 : _b.arrayValue;\n    const lengthCompare = primitiveComparator(((_c = leftArrayValue === null || leftArrayValue === void 0 ? void 0 : leftArrayValue.values) === null || _c === void 0 ? void 0 : _c.length) || 0, ((_d = rightArrayValue === null || rightArrayValue === void 0 ? void 0 : rightArrayValue.values) === null || _d === void 0 ? void 0 : _d.length) || 0);\n    if (lengthCompare !== 0) {\n        return lengthCompare;\n    }\n    return compareArrays(leftArrayValue, rightArrayValue);\n}\nfunction compareMaps(left, right) {\n    if (left === MAX_VALUE.mapValue && right === MAX_VALUE.mapValue) {\n        return 0;\n    }\n    else if (left === MAX_VALUE.mapValue) {\n        return 1;\n    }\n    else if (right === MAX_VALUE.mapValue) {\n        return -1;\n    }\n    const leftMap = left.fields || {};\n    const leftKeys = Object.keys(leftMap);\n    const rightMap = right.fields || {};\n    const rightKeys = Object.keys(rightMap);\n    // Even though MapValues are likely sorted correctly based on their insertion\n    // order (e.g. when received from the backend), local modifications can bring\n    // elements out of order. We need to re-sort the elements to ensure that\n    // canonical IDs are independent of insertion order.\n    leftKeys.sort();\n    rightKeys.sort();\n    for (let i = 0; i < leftKeys.length && i < rightKeys.length; ++i) {\n        const keyCompare = primitiveComparator(leftKeys[i], rightKeys[i]);\n        if (keyCompare !== 0) {\n            return keyCompare;\n        }\n        const compare = valueCompare(leftMap[leftKeys[i]], rightMap[rightKeys[i]]);\n        if (compare !== 0) {\n            return compare;\n        }\n    }\n    return primitiveComparator(leftKeys.length, rightKeys.length);\n}\n/**\n * Generates the canonical ID for the provided field value (as used in Target\n * serialization).\n */\nfunction canonicalId(value) {\n    return canonifyValue(value);\n}\nfunction canonifyValue(value) {\n    if ('nullValue' in value) {\n        return 'null';\n    }\n    else if ('booleanValue' in value) {\n        return '' + value.booleanValue;\n    }\n    else if ('integerValue' in value) {\n        return '' + value.integerValue;\n    }\n    else if ('doubleValue' in value) {\n        return '' + value.doubleValue;\n    }\n    else if ('timestampValue' in value) {\n        return canonifyTimestamp(value.timestampValue);\n    }\n    else if ('stringValue' in value) {\n        return value.stringValue;\n    }\n    else if ('bytesValue' in value) {\n        return canonifyByteString(value.bytesValue);\n    }\n    else if ('referenceValue' in value) {\n        return canonifyReference(value.referenceValue);\n    }\n    else if ('geoPointValue' in value) {\n        return canonifyGeoPoint(value.geoPointValue);\n    }\n    else if ('arrayValue' in value) {\n        return canonifyArray(value.arrayValue);\n    }\n    else if ('mapValue' in value) {\n        return canonifyMap(value.mapValue);\n    }\n    else {\n        return fail();\n    }\n}\nfunction canonifyByteString(byteString) {\n    return normalizeByteString(byteString).toBase64();\n}\nfunction canonifyTimestamp(timestamp) {\n    const normalizedTimestamp = normalizeTimestamp(timestamp);\n    return `time(${normalizedTimestamp.seconds},${normalizedTimestamp.nanos})`;\n}\nfunction canonifyGeoPoint(geoPoint) {\n    return `geo(${geoPoint.latitude},${geoPoint.longitude})`;\n}\nfunction canonifyReference(referenceValue) {\n    return DocumentKey.fromName(referenceValue).toString();\n}\nfunction canonifyMap(mapValue) {\n    // Iteration order in JavaScript is not guaranteed. To ensure that we generate\n    // matching canonical IDs for identical maps, we need to sort the keys.\n    const sortedKeys = Object.keys(mapValue.fields || {}).sort();\n    let result = '{';\n    let first = true;\n    for (const key of sortedKeys) {\n        if (!first) {\n            result += ',';\n        }\n        else {\n            first = false;\n        }\n        result += `${key}:${canonifyValue(mapValue.fields[key])}`;\n    }\n    return result + '}';\n}\nfunction canonifyArray(arrayValue) {\n    let result = '[';\n    let first = true;\n    for (const value of arrayValue.values || []) {\n        if (!first) {\n            result += ',';\n        }\n        else {\n            first = false;\n        }\n        result += canonifyValue(value);\n    }\n    return result + ']';\n}\n/**\n * Returns an approximate (and wildly inaccurate) in-memory size for the field\n * value.\n *\n * The memory size takes into account only the actual user data as it resides\n * in memory and ignores object overhead.\n */\nfunction estimateByteSize(value) {\n    switch (typeOrder(value)) {\n        case 0 /* TypeOrder.NullValue */:\n            return 4;\n        case 1 /* TypeOrder.BooleanValue */:\n            return 4;\n        case 2 /* TypeOrder.NumberValue */:\n            return 8;\n        case 3 /* TypeOrder.TimestampValue */:\n            // Timestamps are made up of two distinct numbers (seconds + nanoseconds)\n            return 16;\n        case 4 /* TypeOrder.ServerTimestampValue */:\n            const previousValue = getPreviousValue(value);\n            return previousValue ? 16 + estimateByteSize(previousValue) : 16;\n        case 5 /* TypeOrder.StringValue */:\n            // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures:\n            // \"JavaScript's String type is [...] a set of elements of 16-bit unsigned\n            // integer values\"\n            return value.stringValue.length * 2;\n        case 6 /* TypeOrder.BlobValue */:\n            return normalizeByteString(value.bytesValue).approximateByteSize();\n        case 7 /* TypeOrder.RefValue */:\n            return value.referenceValue.length;\n        case 8 /* TypeOrder.GeoPointValue */:\n            // GeoPoints are made up of two distinct numbers (latitude + longitude)\n            return 16;\n        case 9 /* TypeOrder.ArrayValue */:\n            return estimateArrayByteSize(value.arrayValue);\n        case 10 /* TypeOrder.VectorValue */:\n        case 11 /* TypeOrder.ObjectValue */:\n            return estimateMapByteSize(value.mapValue);\n        default:\n            throw fail();\n    }\n}\nfunction estimateMapByteSize(mapValue) {\n    let size = 0;\n    forEach(mapValue.fields, (key, val) => {\n        size += key.length + estimateByteSize(val);\n    });\n    return size;\n}\nfunction estimateArrayByteSize(arrayValue) {\n    return (arrayValue.values || []).reduce((previousSize, value) => previousSize + estimateByteSize(value), 0);\n}\n/** Returns a reference value for the provided database and key. */\nfunction refValue(databaseId, key) {\n    return {\n        referenceValue: `projects/${databaseId.projectId}/databases/${databaseId.database}/documents/${key.path.canonicalString()}`\n    };\n}\n/** Returns true if `value` is an IntegerValue . */\nfunction isInteger(value) {\n    return !!value && 'integerValue' in value;\n}\n/** Returns true if `value` is a DoubleValue. */\nfunction isDouble(value) {\n    return !!value && 'doubleValue' in value;\n}\n/** Returns true if `value` is either an IntegerValue or a DoubleValue. */\nfunction isNumber(value) {\n    return isInteger(value) || isDouble(value);\n}\n/** Returns true if `value` is an ArrayValue. */\nfunction isArray(value) {\n    return !!value && 'arrayValue' in value;\n}\n/** Returns true if `value` is a NullValue. */\nfunction isNullValue(value) {\n    return !!value && 'nullValue' in value;\n}\n/** Returns true if `value` is NaN. */\nfunction isNanValue(value) {\n    return !!value && 'doubleValue' in value && isNaN(Number(value.doubleValue));\n}\n/** Returns true if `value` is a MapValue. */\nfunction isMapValue(value) {\n    return !!value && 'mapValue' in value;\n}\n/** Returns true if `value` is a VetorValue. */\nfunction isVectorValue(value) {\n    var _a, _b;\n    const type = (_b = (((_a = value === null || value === void 0 ? void 0 : value.mapValue) === null || _a === void 0 ? void 0 : _a.fields) || {})[TYPE_KEY]) === null || _b === void 0 ? void 0 : _b.stringValue;\n    return type === VECTOR_VALUE_SENTINEL;\n}\n/** Creates a deep copy of `source`. */\nfunction deepClone(source) {\n    if (source.geoPointValue) {\n        return { geoPointValue: Object.assign({}, source.geoPointValue) };\n    }\n    else if (source.timestampValue &&\n        typeof source.timestampValue === 'object') {\n        return { timestampValue: Object.assign({}, source.timestampValue) };\n    }\n    else if (source.mapValue) {\n        const target = { mapValue: { fields: {} } };\n        forEach(source.mapValue.fields, (key, val) => (target.mapValue.fields[key] = deepClone(val)));\n        return target;\n    }\n    else if (source.arrayValue) {\n        const target = { arrayValue: { values: [] } };\n        for (let i = 0; i < (source.arrayValue.values || []).length; ++i) {\n            target.arrayValue.values[i] = deepClone(source.arrayValue.values[i]);\n        }\n        return target;\n    }\n    else {\n        return Object.assign({}, source);\n    }\n}\n/** Returns true if the Value represents the canonical {@link #MAX_VALUE} . */\nfunction isMaxValue(value) {\n    return ((((value.mapValue || {}).fields || {})['__type__'] || {}).stringValue ===\n        MAX_VALUE_TYPE);\n}\nconst MIN_VECTOR_VALUE = {\n    mapValue: {\n        fields: {\n            [TYPE_KEY]: { stringValue: VECTOR_VALUE_SENTINEL },\n            [VECTOR_MAP_VECTORS_KEY]: {\n                arrayValue: {}\n            }\n        }\n    }\n};\n/** Returns the lowest value for the given value type (inclusive). */\nfunction valuesGetLowerBound(value) {\n    if ('nullValue' in value) {\n        return MIN_VALUE;\n    }\n    else if ('booleanValue' in value) {\n        return { booleanValue: false };\n    }\n    else if ('integerValue' in value || 'doubleValue' in value) {\n        return { doubleValue: NaN };\n    }\n    else if ('timestampValue' in value) {\n        return { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } };\n    }\n    else if ('stringValue' in value) {\n        return { stringValue: '' };\n    }\n    else if ('bytesValue' in value) {\n        return { bytesValue: '' };\n    }\n    else if ('referenceValue' in value) {\n        return refValue(DatabaseId.empty(), DocumentKey.empty());\n    }\n    else if ('geoPointValue' in value) {\n        return { geoPointValue: { latitude: -90, longitude: -180 } };\n    }\n    else if ('arrayValue' in value) {\n        return { arrayValue: {} };\n    }\n    else if ('mapValue' in value) {\n        if (isVectorValue(value)) {\n            return MIN_VECTOR_VALUE;\n        }\n        return { mapValue: {} };\n    }\n    else {\n        return fail();\n    }\n}\n/** Returns the largest value for the given value type (exclusive). */\nfunction valuesGetUpperBound(value) {\n    if ('nullValue' in value) {\n        return { booleanValue: false };\n    }\n    else if ('booleanValue' in value) {\n        return { doubleValue: NaN };\n    }\n    else if ('integerValue' in value || 'doubleValue' in value) {\n        return { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } };\n    }\n    else if ('timestampValue' in value) {\n        return { stringValue: '' };\n    }\n    else if ('stringValue' in value) {\n        return { bytesValue: '' };\n    }\n    else if ('bytesValue' in value) {\n        return refValue(DatabaseId.empty(), DocumentKey.empty());\n    }\n    else if ('referenceValue' in value) {\n        return { geoPointValue: { latitude: -90, longitude: -180 } };\n    }\n    else if ('geoPointValue' in value) {\n        return { arrayValue: {} };\n    }\n    else if ('arrayValue' in value) {\n        return MIN_VECTOR_VALUE;\n    }\n    else if ('mapValue' in value) {\n        if (isVectorValue(value)) {\n            return { mapValue: {} };\n        }\n        return MAX_VALUE;\n    }\n    else {\n        return fail();\n    }\n}\nfunction lowerBoundCompare(left, right) {\n    const cmp = valueCompare(left.value, right.value);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    if (left.inclusive && !right.inclusive) {\n        return -1;\n    }\n    else if (!left.inclusive && right.inclusive) {\n        return 1;\n    }\n    return 0;\n}\nfunction upperBoundCompare(left, right) {\n    const cmp = valueCompare(left.value, right.value);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    if (left.inclusive && !right.inclusive) {\n        return 1;\n    }\n    else if (!left.inclusive && right.inclusive) {\n        return -1;\n    }\n    return 0;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An ObjectValue represents a MapValue in the Firestore Proto and offers the\n * ability to add and remove fields (via the ObjectValueBuilder).\n */\nclass ObjectValue {\n    constructor(value) {\n        this.value = value;\n    }\n    static empty() {\n        return new ObjectValue({ mapValue: {} });\n    }\n    /**\n     * Returns the value at the given path or null.\n     *\n     * @param path - the path to search\n     * @returns The value at the path or null if the path is not set.\n     */\n    field(path) {\n        if (path.isEmpty()) {\n            return this.value;\n        }\n        else {\n            let currentLevel = this.value;\n            for (let i = 0; i < path.length - 1; ++i) {\n                currentLevel = (currentLevel.mapValue.fields || {})[path.get(i)];\n                if (!isMapValue(currentLevel)) {\n                    return null;\n                }\n            }\n            currentLevel = (currentLevel.mapValue.fields || {})[path.lastSegment()];\n            return currentLevel || null;\n        }\n    }\n    /**\n     * Sets the field to the provided value.\n     *\n     * @param path - The field path to set.\n     * @param value - The value to set.\n     */\n    set(path, value) {\n        const fieldsMap = this.getFieldsMap(path.popLast());\n        fieldsMap[path.lastSegment()] = deepClone(value);\n    }\n    /**\n     * Sets the provided fields to the provided values.\n     *\n     * @param data - A map of fields to values (or null for deletes).\n     */\n    setAll(data) {\n        let parent = FieldPath$1.emptyPath();\n        let upserts = {};\n        let deletes = [];\n        data.forEach((value, path) => {\n            if (!parent.isImmediateParentOf(path)) {\n                // Insert the accumulated changes at this parent location\n                const fieldsMap = this.getFieldsMap(parent);\n                this.applyChanges(fieldsMap, upserts, deletes);\n                upserts = {};\n                deletes = [];\n                parent = path.popLast();\n            }\n            if (value) {\n                upserts[path.lastSegment()] = deepClone(value);\n            }\n            else {\n                deletes.push(path.lastSegment());\n            }\n        });\n        const fieldsMap = this.getFieldsMap(parent);\n        this.applyChanges(fieldsMap, upserts, deletes);\n    }\n    /**\n     * Removes the field at the specified path. If there is no field at the\n     * specified path, nothing is changed.\n     *\n     * @param path - The field path to remove.\n     */\n    delete(path) {\n        const nestedValue = this.field(path.popLast());\n        if (isMapValue(nestedValue) && nestedValue.mapValue.fields) {\n            delete nestedValue.mapValue.fields[path.lastSegment()];\n        }\n    }\n    isEqual(other) {\n        return valueEquals(this.value, other.value);\n    }\n    /**\n     * Returns the map that contains the leaf element of `path`. If the parent\n     * entry does not yet exist, or if it is not a map, a new map will be created.\n     */\n    getFieldsMap(path) {\n        let current = this.value;\n        if (!current.mapValue.fields) {\n            current.mapValue = { fields: {} };\n        }\n        for (let i = 0; i < path.length; ++i) {\n            let next = current.mapValue.fields[path.get(i)];\n            if (!isMapValue(next) || !next.mapValue.fields) {\n                next = { mapValue: { fields: {} } };\n                current.mapValue.fields[path.get(i)] = next;\n            }\n            current = next;\n        }\n        return current.mapValue.fields;\n    }\n    /**\n     * Modifies `fieldsMap` by adding, replacing or deleting the specified\n     * entries.\n     */\n    applyChanges(fieldsMap, inserts, deletes) {\n        forEach(inserts, (key, val) => (fieldsMap[key] = val));\n        for (const field of deletes) {\n            delete fieldsMap[field];\n        }\n    }\n    clone() {\n        return new ObjectValue(deepClone(this.value));\n    }\n}\n/**\n * Returns a FieldMask built from all fields in a MapValue.\n */\nfunction extractFieldMask(value) {\n    const fields = [];\n    forEach(value.fields, (key, value) => {\n        const currentPath = new FieldPath$1([key]);\n        if (isMapValue(value)) {\n            const nestedMask = extractFieldMask(value.mapValue);\n            const nestedFields = nestedMask.fields;\n            if (nestedFields.length === 0) {\n                // Preserve the empty map by adding it to the FieldMask.\n                fields.push(currentPath);\n            }\n            else {\n                // For nested and non-empty ObjectValues, add the FieldPath of the\n                // leaf nodes.\n                for (const nestedPath of nestedFields) {\n                    fields.push(currentPath.child(nestedPath));\n                }\n            }\n        }\n        else {\n            // For nested and non-empty ObjectValues, add the FieldPath of the leaf\n            // nodes.\n            fields.push(currentPath);\n        }\n    });\n    return new FieldMask(fields);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a document in Firestore with a key, version, data and whether it\n * has local mutations applied to it.\n *\n * Documents can transition between states via `convertToFoundDocument()`,\n * `convertToNoDocument()` and `convertToUnknownDocument()`. If a document does\n * not transition to one of these states even after all mutations have been\n * applied, `isValidDocument()` returns false and the document should be removed\n * from all views.\n */\nclass MutableDocument {\n    constructor(key, documentType, version, readTime, createTime, data, documentState) {\n        this.key = key;\n        this.documentType = documentType;\n        this.version = version;\n        this.readTime = readTime;\n        this.createTime = createTime;\n        this.data = data;\n        this.documentState = documentState;\n    }\n    /**\n     * Creates a document with no known version or data, but which can serve as\n     * base document for mutations.\n     */\n    static newInvalidDocument(documentKey) {\n        return new MutableDocument(documentKey, 0 /* DocumentType.INVALID */, \n        /* version */ SnapshotVersion.min(), \n        /* readTime */ SnapshotVersion.min(), \n        /* createTime */ SnapshotVersion.min(), ObjectValue.empty(), 0 /* DocumentState.SYNCED */);\n    }\n    /**\n     * Creates a new document that is known to exist with the given data at the\n     * given version.\n     */\n    static newFoundDocument(documentKey, version, createTime, value) {\n        return new MutableDocument(documentKey, 1 /* DocumentType.FOUND_DOCUMENT */, \n        /* version */ version, \n        /* readTime */ SnapshotVersion.min(), \n        /* createTime */ createTime, value, 0 /* DocumentState.SYNCED */);\n    }\n    /** Creates a new document that is known to not exist at the given version. */\n    static newNoDocument(documentKey, version) {\n        return new MutableDocument(documentKey, 2 /* DocumentType.NO_DOCUMENT */, \n        /* version */ version, \n        /* readTime */ SnapshotVersion.min(), \n        /* createTime */ SnapshotVersion.min(), ObjectValue.empty(), 0 /* DocumentState.SYNCED */);\n    }\n    /**\n     * Creates a new document that is known to exist at the given version but\n     * whose data is not known (e.g. a document that was updated without a known\n     * base document).\n     */\n    static newUnknownDocument(documentKey, version) {\n        return new MutableDocument(documentKey, 3 /* DocumentType.UNKNOWN_DOCUMENT */, \n        /* version */ version, \n        /* readTime */ SnapshotVersion.min(), \n        /* createTime */ SnapshotVersion.min(), ObjectValue.empty(), 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */);\n    }\n    /**\n     * Changes the document type to indicate that it exists and that its version\n     * and data are known.\n     */\n    convertToFoundDocument(version, value) {\n        // If a document is switching state from being an invalid or deleted\n        // document to a valid (FOUND_DOCUMENT) document, either due to receiving an\n        // update from Watch or due to applying a local set mutation on top\n        // of a deleted document, our best guess about its createTime would be the\n        // version at which the document transitioned to a FOUND_DOCUMENT.\n        if (this.createTime.isEqual(SnapshotVersion.min()) &&\n            (this.documentType === 2 /* DocumentType.NO_DOCUMENT */ ||\n                this.documentType === 0 /* DocumentType.INVALID */)) {\n            this.createTime = version;\n        }\n        this.version = version;\n        this.documentType = 1 /* DocumentType.FOUND_DOCUMENT */;\n        this.data = value;\n        this.documentState = 0 /* DocumentState.SYNCED */;\n        return this;\n    }\n    /**\n     * Changes the document type to indicate that it doesn't exist at the given\n     * version.\n     */\n    convertToNoDocument(version) {\n        this.version = version;\n        this.documentType = 2 /* DocumentType.NO_DOCUMENT */;\n        this.data = ObjectValue.empty();\n        this.documentState = 0 /* DocumentState.SYNCED */;\n        return this;\n    }\n    /**\n     * Changes the document type to indicate that it exists at a given version but\n     * that its data is not known (e.g. a document that was updated without a known\n     * base document).\n     */\n    convertToUnknownDocument(version) {\n        this.version = version;\n        this.documentType = 3 /* DocumentType.UNKNOWN_DOCUMENT */;\n        this.data = ObjectValue.empty();\n        this.documentState = 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */;\n        return this;\n    }\n    setHasCommittedMutations() {\n        this.documentState = 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */;\n        return this;\n    }\n    setHasLocalMutations() {\n        this.documentState = 1 /* DocumentState.HAS_LOCAL_MUTATIONS */;\n        this.version = SnapshotVersion.min();\n        return this;\n    }\n    setReadTime(readTime) {\n        this.readTime = readTime;\n        return this;\n    }\n    get hasLocalMutations() {\n        return this.documentState === 1 /* DocumentState.HAS_LOCAL_MUTATIONS */;\n    }\n    get hasCommittedMutations() {\n        return this.documentState === 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */;\n    }\n    get hasPendingWrites() {\n        return this.hasLocalMutations || this.hasCommittedMutations;\n    }\n    isValidDocument() {\n        return this.documentType !== 0 /* DocumentType.INVALID */;\n    }\n    isFoundDocument() {\n        return this.documentType === 1 /* DocumentType.FOUND_DOCUMENT */;\n    }\n    isNoDocument() {\n        return this.documentType === 2 /* DocumentType.NO_DOCUMENT */;\n    }\n    isUnknownDocument() {\n        return this.documentType === 3 /* DocumentType.UNKNOWN_DOCUMENT */;\n    }\n    isEqual(other) {\n        return (other instanceof MutableDocument &&\n            this.key.isEqual(other.key) &&\n            this.version.isEqual(other.version) &&\n            this.documentType === other.documentType &&\n            this.documentState === other.documentState &&\n            this.data.isEqual(other.data));\n    }\n    mutableCopy() {\n        return new MutableDocument(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState);\n    }\n    toString() {\n        return (`Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, ` +\n            `{createTime: ${this.createTime}}), ` +\n            `{documentType: ${this.documentType}}), ` +\n            `{documentState: ${this.documentState}})`);\n    }\n}\n/**\n * Compares the value for field `field` in the provided documents. Throws if\n * the field does not exist in both documents.\n */\nfunction compareDocumentsByField(field, d1, d2) {\n    const v1 = d1.data.field(field);\n    const v2 = d2.data.field(field);\n    if (v1 !== null && v2 !== null) {\n        return valueCompare(v1, v2);\n    }\n    else {\n        return fail();\n    }\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a bound of a query.\n *\n * The bound is specified with the given components representing a position and\n * whether it's just before or just after the position (relative to whatever the\n * query order is).\n *\n * The position represents a logical index position for a query. It's a prefix\n * of values for the (potentially implicit) order by clauses of a query.\n *\n * Bound provides a function to determine whether a document comes before or\n * after a bound. This is influenced by whether the position is just before or\n * just after the provided values.\n */\nclass Bound {\n    constructor(position, inclusive) {\n        this.position = position;\n        this.inclusive = inclusive;\n    }\n}\nfunction boundCompareToDocument(bound, orderBy, doc) {\n    let comparison = 0;\n    for (let i = 0; i < bound.position.length; i++) {\n        const orderByComponent = orderBy[i];\n        const component = bound.position[i];\n        if (orderByComponent.field.isKeyField()) {\n            comparison = DocumentKey.comparator(DocumentKey.fromName(component.referenceValue), doc.key);\n        }\n        else {\n            const docValue = doc.data.field(orderByComponent.field);\n            comparison = valueCompare(component, docValue);\n        }\n        if (orderByComponent.dir === \"desc\" /* Direction.DESCENDING */) {\n            comparison = comparison * -1;\n        }\n        if (comparison !== 0) {\n            break;\n        }\n    }\n    return comparison;\n}\n/**\n * Returns true if a document sorts after a bound using the provided sort\n * order.\n */\nfunction boundSortsAfterDocument(bound, orderBy, doc) {\n    const comparison = boundCompareToDocument(bound, orderBy, doc);\n    return bound.inclusive ? comparison >= 0 : comparison > 0;\n}\n/**\n * Returns true if a document sorts before a bound using the provided sort\n * order.\n */\nfunction boundSortsBeforeDocument(bound, orderBy, doc) {\n    const comparison = boundCompareToDocument(bound, orderBy, doc);\n    return bound.inclusive ? comparison <= 0 : comparison < 0;\n}\nfunction boundEquals(left, right) {\n    if (left === null) {\n        return right === null;\n    }\n    else if (right === null) {\n        return false;\n    }\n    if (left.inclusive !== right.inclusive ||\n        left.position.length !== right.position.length) {\n        return false;\n    }\n    for (let i = 0; i < left.position.length; i++) {\n        const leftPosition = left.position[i];\n        const rightPosition = right.position[i];\n        if (!valueEquals(leftPosition, rightPosition)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An ordering on a field, in some Direction. Direction defaults to ASCENDING.\n */\nclass OrderBy {\n    constructor(field, dir = \"asc\" /* Direction.ASCENDING */) {\n        this.field = field;\n        this.dir = dir;\n    }\n}\nfunction canonifyOrderBy(orderBy) {\n    // TODO(b/29183165): Make this collision robust.\n    return orderBy.field.canonicalString() + orderBy.dir;\n}\nfunction stringifyOrderBy(orderBy) {\n    return `${orderBy.field.canonicalString()} (${orderBy.dir})`;\n}\nfunction orderByEquals(left, right) {\n    return left.dir === right.dir && left.field.isEqual(right.field);\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass Filter {\n}\nclass FieldFilter extends Filter {\n    constructor(field, op, value) {\n        super();\n        this.field = field;\n        this.op = op;\n        this.value = value;\n    }\n    /**\n     * Creates a filter based on the provided arguments.\n     */\n    static create(field, op, value) {\n        if (field.isKeyField()) {\n            if (op === \"in\" /* Operator.IN */ || op === \"not-in\" /* Operator.NOT_IN */) {\n                return this.createKeyFieldInFilter(field, op, value);\n            }\n            else {\n                return new KeyFieldFilter(field, op, value);\n            }\n        }\n        else if (op === \"array-contains\" /* Operator.ARRAY_CONTAINS */) {\n            return new ArrayContainsFilter(field, value);\n        }\n        else if (op === \"in\" /* Operator.IN */) {\n            return new InFilter(field, value);\n        }\n        else if (op === \"not-in\" /* Operator.NOT_IN */) {\n            return new NotInFilter(field, value);\n        }\n        else if (op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */) {\n            return new ArrayContainsAnyFilter(field, value);\n        }\n        else {\n            return new FieldFilter(field, op, value);\n        }\n    }\n    static createKeyFieldInFilter(field, op, value) {\n        return op === \"in\" /* Operator.IN */\n            ? new KeyFieldInFilter(field, value)\n            : new KeyFieldNotInFilter(field, value);\n    }\n    matches(doc) {\n        const other = doc.data.field(this.field);\n        // Types do not have to match in NOT_EQUAL filters.\n        if (this.op === \"!=\" /* Operator.NOT_EQUAL */) {\n            return (other !== null &&\n                this.matchesComparison(valueCompare(other, this.value)));\n        }\n        // Only compare types with matching backend order (such as double and int).\n        return (other !== null &&\n            typeOrder(this.value) === typeOrder(other) &&\n            this.matchesComparison(valueCompare(other, this.value)));\n    }\n    matchesComparison(comparison) {\n        switch (this.op) {\n            case \"<\" /* Operator.LESS_THAN */:\n                return comparison < 0;\n            case \"<=\" /* Operator.LESS_THAN_OR_EQUAL */:\n                return comparison <= 0;\n            case \"==\" /* Operator.EQUAL */:\n                return comparison === 0;\n            case \"!=\" /* Operator.NOT_EQUAL */:\n                return comparison !== 0;\n            case \">\" /* Operator.GREATER_THAN */:\n                return comparison > 0;\n            case \">=\" /* Operator.GREATER_THAN_OR_EQUAL */:\n                return comparison >= 0;\n            default:\n                return fail();\n        }\n    }\n    isInequality() {\n        return ([\n            \"<\" /* Operator.LESS_THAN */,\n            \"<=\" /* Operator.LESS_THAN_OR_EQUAL */,\n            \">\" /* Operator.GREATER_THAN */,\n            \">=\" /* Operator.GREATER_THAN_OR_EQUAL */,\n            \"!=\" /* Operator.NOT_EQUAL */,\n            \"not-in\" /* Operator.NOT_IN */\n        ].indexOf(this.op) >= 0);\n    }\n    getFlattenedFilters() {\n        return [this];\n    }\n    getFilters() {\n        return [this];\n    }\n}\nclass CompositeFilter extends Filter {\n    constructor(filters, op) {\n        super();\n        this.filters = filters;\n        this.op = op;\n        this.memoizedFlattenedFilters = null;\n    }\n    /**\n     * Creates a filter based on the provided arguments.\n     */\n    static create(filters, op) {\n        return new CompositeFilter(filters, op);\n    }\n    matches(doc) {\n        if (compositeFilterIsConjunction(this)) {\n            // For conjunctions, all filters must match, so return false if any filter doesn't match.\n            return this.filters.find(filter => !filter.matches(doc)) === undefined;\n        }\n        else {\n            // For disjunctions, at least one filter should match.\n            return this.filters.find(filter => filter.matches(doc)) !== undefined;\n        }\n    }\n    getFlattenedFilters() {\n        if (this.memoizedFlattenedFilters !== null) {\n            return this.memoizedFlattenedFilters;\n        }\n        this.memoizedFlattenedFilters = this.filters.reduce((result, subfilter) => {\n            return result.concat(subfilter.getFlattenedFilters());\n        }, []);\n        return this.memoizedFlattenedFilters;\n    }\n    // Returns a mutable copy of `this.filters`\n    getFilters() {\n        return Object.assign([], this.filters);\n    }\n}\nfunction compositeFilterIsConjunction(compositeFilter) {\n    return compositeFilter.op === \"and\" /* CompositeOperator.AND */;\n}\nfunction compositeFilterIsDisjunction(compositeFilter) {\n    return compositeFilter.op === \"or\" /* CompositeOperator.OR */;\n}\n/**\n * Returns true if this filter is a conjunction of field filters only. Returns false otherwise.\n */\nfunction compositeFilterIsFlatConjunction(compositeFilter) {\n    return (compositeFilterIsFlat(compositeFilter) &&\n        compositeFilterIsConjunction(compositeFilter));\n}\n/**\n * Returns true if this filter does not contain any composite filters. Returns false otherwise.\n */\nfunction compositeFilterIsFlat(compositeFilter) {\n    for (const filter of compositeFilter.filters) {\n        if (filter instanceof CompositeFilter) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction canonifyFilter(filter) {\n    if (filter instanceof FieldFilter) {\n        // TODO(b/29183165): Technically, this won't be unique if two values have\n        // the same description, such as the int 3 and the string \"3\". So we should\n        // add the types in here somehow, too.\n        return (filter.field.canonicalString() +\n            filter.op.toString() +\n            canonicalId(filter.value));\n    }\n    else if (compositeFilterIsFlatConjunction(filter)) {\n        // Older SDK versions use an implicit AND operation between their filters.\n        // In the new SDK versions, the developer may use an explicit AND filter.\n        // To stay consistent with the old usages, we add a special case to ensure\n        // the canonical ID for these two are the same. For example:\n        // `col.whereEquals(\"a\", 1).whereEquals(\"b\", 2)` should have the same\n        // canonical ID as `col.where(and(equals(\"a\",1), equals(\"b\",2)))`.\n        return filter.filters.map(filter => canonifyFilter(filter)).join(',');\n    }\n    else {\n        // filter instanceof CompositeFilter\n        const canonicalIdsString = filter.filters\n            .map(filter => canonifyFilter(filter))\n            .join(',');\n        return `${filter.op}(${canonicalIdsString})`;\n    }\n}\nfunction filterEquals(f1, f2) {\n    if (f1 instanceof FieldFilter) {\n        return fieldFilterEquals(f1, f2);\n    }\n    else if (f1 instanceof CompositeFilter) {\n        return compositeFilterEquals(f1, f2);\n    }\n    else {\n        fail();\n    }\n}\nfunction fieldFilterEquals(f1, f2) {\n    return (f2 instanceof FieldFilter &&\n        f1.op === f2.op &&\n        f1.field.isEqual(f2.field) &&\n        valueEquals(f1.value, f2.value));\n}\nfunction compositeFilterEquals(f1, f2) {\n    if (f2 instanceof CompositeFilter &&\n        f1.op === f2.op &&\n        f1.filters.length === f2.filters.length) {\n        const subFiltersMatch = f1.filters.reduce((result, f1Filter, index) => result && filterEquals(f1Filter, f2.filters[index]), true);\n        return subFiltersMatch;\n    }\n    return false;\n}\n/**\n * Returns a new composite filter that contains all filter from\n * `compositeFilter` plus all the given filters in `otherFilters`.\n */\nfunction compositeFilterWithAddedFilters(compositeFilter, otherFilters) {\n    const mergedFilters = compositeFilter.filters.concat(otherFilters);\n    return CompositeFilter.create(mergedFilters, compositeFilter.op);\n}\n/** Returns a debug description for `filter`. */\nfunction stringifyFilter(filter) {\n    if (filter instanceof FieldFilter) {\n        return stringifyFieldFilter(filter);\n    }\n    else if (filter instanceof CompositeFilter) {\n        return stringifyCompositeFilter(filter);\n    }\n    else {\n        return 'Filter';\n    }\n}\nfunction stringifyCompositeFilter(filter) {\n    return (filter.op.toString() +\n        ` {` +\n        filter.getFilters().map(stringifyFilter).join(' ,') +\n        '}');\n}\nfunction stringifyFieldFilter(filter) {\n    return `${filter.field.canonicalString()} ${filter.op} ${canonicalId(filter.value)}`;\n}\n/** Filter that matches on key fields (i.e. '__name__'). */\nclass KeyFieldFilter extends FieldFilter {\n    constructor(field, op, value) {\n        super(field, op, value);\n        this.key = DocumentKey.fromName(value.referenceValue);\n    }\n    matches(doc) {\n        const comparison = DocumentKey.comparator(doc.key, this.key);\n        return this.matchesComparison(comparison);\n    }\n}\n/** Filter that matches on key fields within an array. */\nclass KeyFieldInFilter extends FieldFilter {\n    constructor(field, value) {\n        super(field, \"in\" /* Operator.IN */, value);\n        this.keys = extractDocumentKeysFromArrayValue(\"in\" /* Operator.IN */, value);\n    }\n    matches(doc) {\n        return this.keys.some(key => key.isEqual(doc.key));\n    }\n}\n/** Filter that matches on key fields not present within an array. */\nclass KeyFieldNotInFilter extends FieldFilter {\n    constructor(field, value) {\n        super(field, \"not-in\" /* Operator.NOT_IN */, value);\n        this.keys = extractDocumentKeysFromArrayValue(\"not-in\" /* Operator.NOT_IN */, value);\n    }\n    matches(doc) {\n        return !this.keys.some(key => key.isEqual(doc.key));\n    }\n}\nfunction extractDocumentKeysFromArrayValue(op, value) {\n    var _a;\n    return (((_a = value.arrayValue) === null || _a === void 0 ? void 0 : _a.values) || []).map(v => {\n        return DocumentKey.fromName(v.referenceValue);\n    });\n}\n/** A Filter that implements the array-contains operator. */\nclass ArrayContainsFilter extends FieldFilter {\n    constructor(field, value) {\n        super(field, \"array-contains\" /* Operator.ARRAY_CONTAINS */, value);\n    }\n    matches(doc) {\n        const other = doc.data.field(this.field);\n        return isArray(other) && arrayValueContains(other.arrayValue, this.value);\n    }\n}\n/** A Filter that implements the IN operator. */\nclass InFilter extends FieldFilter {\n    constructor(field, value) {\n        super(field, \"in\" /* Operator.IN */, value);\n    }\n    matches(doc) {\n        const other = doc.data.field(this.field);\n        return other !== null && arrayValueContains(this.value.arrayValue, other);\n    }\n}\n/** A Filter that implements the not-in operator. */\nclass NotInFilter extends FieldFilter {\n    constructor(field, value) {\n        super(field, \"not-in\" /* Operator.NOT_IN */, value);\n    }\n    matches(doc) {\n        if (arrayValueContains(this.value.arrayValue, { nullValue: 'NULL_VALUE' })) {\n            return false;\n        }\n        const other = doc.data.field(this.field);\n        return other !== null && !arrayValueContains(this.value.arrayValue, other);\n    }\n}\n/** A Filter that implements the array-contains-any operator. */\nclass ArrayContainsAnyFilter extends FieldFilter {\n    constructor(field, value) {\n        super(field, \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */, value);\n    }\n    matches(doc) {\n        const other = doc.data.field(this.field);\n        if (!isArray(other) || !other.arrayValue.values) {\n            return false;\n        }\n        return other.arrayValue.values.some(val => arrayValueContains(this.value.arrayValue, val));\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Visible for testing\nclass TargetImpl {\n    constructor(path, collectionGroup = null, orderBy = [], filters = [], limit = null, startAt = null, endAt = null) {\n        this.path = path;\n        this.collectionGroup = collectionGroup;\n        this.orderBy = orderBy;\n        this.filters = filters;\n        this.limit = limit;\n        this.startAt = startAt;\n        this.endAt = endAt;\n        this.memoizedCanonicalId = null;\n    }\n}\n/**\n * Initializes a Target with a path and optional additional query constraints.\n * Path must currently be empty if this is a collection group query.\n *\n * NOTE: you should always construct `Target` from `Query.toTarget` instead of\n * using this factory method, because `Query` provides an implicit `orderBy`\n * property.\n */\nfunction newTarget(path, collectionGroup = null, orderBy = [], filters = [], limit = null, startAt = null, endAt = null) {\n    return new TargetImpl(path, collectionGroup, orderBy, filters, limit, startAt, endAt);\n}\nfunction canonifyTarget(target) {\n    const targetImpl = debugCast(target);\n    if (targetImpl.memoizedCanonicalId === null) {\n        let str = targetImpl.path.canonicalString();\n        if (targetImpl.collectionGroup !== null) {\n            str += '|cg:' + targetImpl.collectionGroup;\n        }\n        str += '|f:';\n        str += targetImpl.filters.map(f => canonifyFilter(f)).join(',');\n        str += '|ob:';\n        str += targetImpl.orderBy.map(o => canonifyOrderBy(o)).join(',');\n        if (!isNullOrUndefined(targetImpl.limit)) {\n            str += '|l:';\n            str += targetImpl.limit;\n        }\n        if (targetImpl.startAt) {\n            str += '|lb:';\n            str += targetImpl.startAt.inclusive ? 'b:' : 'a:';\n            str += targetImpl.startAt.position.map(p => canonicalId(p)).join(',');\n        }\n        if (targetImpl.endAt) {\n            str += '|ub:';\n            str += targetImpl.endAt.inclusive ? 'a:' : 'b:';\n            str += targetImpl.endAt.position.map(p => canonicalId(p)).join(',');\n        }\n        targetImpl.memoizedCanonicalId = str;\n    }\n    return targetImpl.memoizedCanonicalId;\n}\nfunction stringifyTarget(target) {\n    let str = target.path.canonicalString();\n    if (target.collectionGroup !== null) {\n        str += ' collectionGroup=' + target.collectionGroup;\n    }\n    if (target.filters.length > 0) {\n        str += `, filters: [${target.filters\n            .map(f => stringifyFilter(f))\n            .join(', ')}]`;\n    }\n    if (!isNullOrUndefined(target.limit)) {\n        str += ', limit: ' + target.limit;\n    }\n    if (target.orderBy.length > 0) {\n        str += `, orderBy: [${target.orderBy\n            .map(o => stringifyOrderBy(o))\n            .join(', ')}]`;\n    }\n    if (target.startAt) {\n        str += ', startAt: ';\n        str += target.startAt.inclusive ? 'b:' : 'a:';\n        str += target.startAt.position.map(p => canonicalId(p)).join(',');\n    }\n    if (target.endAt) {\n        str += ', endAt: ';\n        str += target.endAt.inclusive ? 'a:' : 'b:';\n        str += target.endAt.position.map(p => canonicalId(p)).join(',');\n    }\n    return `Target(${str})`;\n}\nfunction targetEquals(left, right) {\n    if (left.limit !== right.limit) {\n        return false;\n    }\n    if (left.orderBy.length !== right.orderBy.length) {\n        return false;\n    }\n    for (let i = 0; i < left.orderBy.length; i++) {\n        if (!orderByEquals(left.orderBy[i], right.orderBy[i])) {\n            return false;\n        }\n    }\n    if (left.filters.length !== right.filters.length) {\n        return false;\n    }\n    for (let i = 0; i < left.filters.length; i++) {\n        if (!filterEquals(left.filters[i], right.filters[i])) {\n            return false;\n        }\n    }\n    if (left.collectionGroup !== right.collectionGroup) {\n        return false;\n    }\n    if (!left.path.isEqual(right.path)) {\n        return false;\n    }\n    if (!boundEquals(left.startAt, right.startAt)) {\n        return false;\n    }\n    return boundEquals(left.endAt, right.endAt);\n}\nfunction targetIsDocumentTarget(target) {\n    return (DocumentKey.isDocumentKey(target.path) &&\n        target.collectionGroup === null &&\n        target.filters.length === 0);\n}\n/** Returns the field filters that target the given field path. */\nfunction targetGetFieldFiltersForPath(target, path) {\n    return target.filters.filter(f => f instanceof FieldFilter && f.field.isEqual(path));\n}\n/**\n * Returns the values that are used in ARRAY_CONTAINS or ARRAY_CONTAINS_ANY\n * filters. Returns `null` if there are no such filters.\n */\nfunction targetGetArrayValues(target, fieldIndex) {\n    const segment = fieldIndexGetArraySegment(fieldIndex);\n    if (segment === undefined) {\n        return null;\n    }\n    for (const fieldFilter of targetGetFieldFiltersForPath(target, segment.fieldPath)) {\n        switch (fieldFilter.op) {\n            case \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */:\n                return fieldFilter.value.arrayValue.values || [];\n            case \"array-contains\" /* Operator.ARRAY_CONTAINS */:\n                return [fieldFilter.value];\n            // Remaining filters are not array filters.\n        }\n    }\n    return null;\n}\n/**\n * Returns the list of values that are used in != or NOT_IN filters. Returns\n * `null` if there are no such filters.\n */\nfunction targetGetNotInValues(target, fieldIndex) {\n    const values = new Map();\n    for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\n        for (const fieldFilter of targetGetFieldFiltersForPath(target, segment.fieldPath)) {\n            switch (fieldFilter.op) {\n                case \"==\" /* Operator.EQUAL */:\n                case \"in\" /* Operator.IN */:\n                    // Encode equality prefix, which is encoded in the index value before\n                    // the inequality (e.g. `a == 'a' && b != 'b'` is encoded to\n                    // `value != 'ab'`).\n                    values.set(segment.fieldPath.canonicalString(), fieldFilter.value);\n                    break;\n                case \"not-in\" /* Operator.NOT_IN */:\n                case \"!=\" /* Operator.NOT_EQUAL */:\n                    // NotIn/NotEqual is always a suffix. There cannot be any remaining\n                    // segments and hence we can return early here.\n                    values.set(segment.fieldPath.canonicalString(), fieldFilter.value);\n                    return Array.from(values.values());\n                // Remaining filters cannot be used as notIn bounds.\n            }\n        }\n    }\n    return null;\n}\n/**\n * Returns a lower bound of field values that can be used as a starting point to\n * scan the index defined by `fieldIndex`. Returns `MIN_VALUE` if no lower bound\n * exists.\n */\nfunction targetGetLowerBound(target, fieldIndex) {\n    const values = [];\n    let inclusive = true;\n    // For each segment, retrieve a lower bound if there is a suitable filter or\n    // startAt.\n    for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\n        const segmentBound = segment.kind === 0 /* IndexKind.ASCENDING */\n            ? targetGetAscendingBound(target, segment.fieldPath, target.startAt)\n            : targetGetDescendingBound(target, segment.fieldPath, target.startAt);\n        values.push(segmentBound.value);\n        inclusive && (inclusive = segmentBound.inclusive);\n    }\n    return new Bound(values, inclusive);\n}\n/**\n * Returns an upper bound of field values that can be used as an ending point\n * when scanning the index defined by `fieldIndex`. Returns `MAX_VALUE` if no\n * upper bound exists.\n */\nfunction targetGetUpperBound(target, fieldIndex) {\n    const values = [];\n    let inclusive = true;\n    // For each segment, retrieve an upper bound if there is a suitable filter or\n    // endAt.\n    for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\n        const segmentBound = segment.kind === 0 /* IndexKind.ASCENDING */\n            ? targetGetDescendingBound(target, segment.fieldPath, target.endAt)\n            : targetGetAscendingBound(target, segment.fieldPath, target.endAt);\n        values.push(segmentBound.value);\n        inclusive && (inclusive = segmentBound.inclusive);\n    }\n    return new Bound(values, inclusive);\n}\n/**\n * Returns the value to use as the lower bound for ascending index segment at\n * the provided `fieldPath` (or the upper bound for an descending segment).\n */\nfunction targetGetAscendingBound(target, fieldPath, bound) {\n    let value = MIN_VALUE;\n    let inclusive = true;\n    // Process all filters to find a value for the current field segment\n    for (const fieldFilter of targetGetFieldFiltersForPath(target, fieldPath)) {\n        let filterValue = MIN_VALUE;\n        let filterInclusive = true;\n        switch (fieldFilter.op) {\n            case \"<\" /* Operator.LESS_THAN */:\n            case \"<=\" /* Operator.LESS_THAN_OR_EQUAL */:\n                filterValue = valuesGetLowerBound(fieldFilter.value);\n                break;\n            case \"==\" /* Operator.EQUAL */:\n            case \"in\" /* Operator.IN */:\n            case \">=\" /* Operator.GREATER_THAN_OR_EQUAL */:\n                filterValue = fieldFilter.value;\n                break;\n            case \">\" /* Operator.GREATER_THAN */:\n                filterValue = fieldFilter.value;\n                filterInclusive = false;\n                break;\n            case \"!=\" /* Operator.NOT_EQUAL */:\n            case \"not-in\" /* Operator.NOT_IN */:\n                filterValue = MIN_VALUE;\n                break;\n            // Remaining filters cannot be used as lower bounds.\n        }\n        if (lowerBoundCompare({ value, inclusive }, { value: filterValue, inclusive: filterInclusive }) < 0) {\n            value = filterValue;\n            inclusive = filterInclusive;\n        }\n    }\n    // If there is an additional bound, compare the values against the existing\n    // range to see if we can narrow the scope.\n    if (bound !== null) {\n        for (let i = 0; i < target.orderBy.length; ++i) {\n            const orderBy = target.orderBy[i];\n            if (orderBy.field.isEqual(fieldPath)) {\n                const cursorValue = bound.position[i];\n                if (lowerBoundCompare({ value, inclusive }, { value: cursorValue, inclusive: bound.inclusive }) < 0) {\n                    value = cursorValue;\n                    inclusive = bound.inclusive;\n                }\n                break;\n            }\n        }\n    }\n    return { value, inclusive };\n}\n/**\n * Returns the value to use as the upper bound for ascending index segment at\n * the provided `fieldPath` (or the lower bound for a descending segment).\n */\nfunction targetGetDescendingBound(target, fieldPath, bound) {\n    let value = MAX_VALUE;\n    let inclusive = true;\n    // Process all filters to find a value for the current field segment\n    for (const fieldFilter of targetGetFieldFiltersForPath(target, fieldPath)) {\n        let filterValue = MAX_VALUE;\n        let filterInclusive = true;\n        switch (fieldFilter.op) {\n            case \">=\" /* Operator.GREATER_THAN_OR_EQUAL */:\n            case \">\" /* Operator.GREATER_THAN */:\n                filterValue = valuesGetUpperBound(fieldFilter.value);\n                filterInclusive = false;\n                break;\n            case \"==\" /* Operator.EQUAL */:\n            case \"in\" /* Operator.IN */:\n            case \"<=\" /* Operator.LESS_THAN_OR_EQUAL */:\n                filterValue = fieldFilter.value;\n                break;\n            case \"<\" /* Operator.LESS_THAN */:\n                filterValue = fieldFilter.value;\n                filterInclusive = false;\n                break;\n            case \"!=\" /* Operator.NOT_EQUAL */:\n            case \"not-in\" /* Operator.NOT_IN */:\n                filterValue = MAX_VALUE;\n                break;\n            // Remaining filters cannot be used as upper bounds.\n        }\n        if (upperBoundCompare({ value, inclusive }, { value: filterValue, inclusive: filterInclusive }) > 0) {\n            value = filterValue;\n            inclusive = filterInclusive;\n        }\n    }\n    // If there is an additional bound, compare the values against the existing\n    // range to see if we can narrow the scope.\n    if (bound !== null) {\n        for (let i = 0; i < target.orderBy.length; ++i) {\n            const orderBy = target.orderBy[i];\n            if (orderBy.field.isEqual(fieldPath)) {\n                const cursorValue = bound.position[i];\n                if (upperBoundCompare({ value, inclusive }, { value: cursorValue, inclusive: bound.inclusive }) > 0) {\n                    value = cursorValue;\n                    inclusive = bound.inclusive;\n                }\n                break;\n            }\n        }\n    }\n    return { value, inclusive };\n}\n/** Returns the number of segments of a perfect index for this target. */\nfunction targetGetSegmentCount(target) {\n    let fields = new SortedSet(FieldPath$1.comparator);\n    let hasArraySegment = false;\n    for (const filter of target.filters) {\n        for (const subFilter of filter.getFlattenedFilters()) {\n            // __name__ is not an explicit segment of any index, so we don't need to\n            // count it.\n            if (subFilter.field.isKeyField()) {\n                continue;\n            }\n            // ARRAY_CONTAINS or ARRAY_CONTAINS_ANY filters must be counted separately.\n            // For instance, it is possible to have an index for \"a ARRAY a ASC\". Even\n            // though these are on the same field, they should be counted as two\n            // separate segments in an index.\n            if (subFilter.op === \"array-contains\" /* Operator.ARRAY_CONTAINS */ ||\n                subFilter.op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */) {\n                hasArraySegment = true;\n            }\n            else {\n                fields = fields.add(subFilter.field);\n            }\n        }\n    }\n    for (const orderBy of target.orderBy) {\n        // __name__ is not an explicit segment of any index, so we don't need to\n        // count it.\n        if (!orderBy.field.isKeyField()) {\n            fields = fields.add(orderBy.field);\n        }\n    }\n    return fields.size + (hasArraySegment ? 1 : 0);\n}\nfunction targetHasLimit(target) {\n    return target.limit !== null;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Query encapsulates all the query attributes we support in the SDK. It can\n * be run against the LocalStore, as well as be converted to a `Target` to\n * query the RemoteStore results.\n *\n * Visible for testing.\n */\nclass QueryImpl {\n    /**\n     * Initializes a Query with a path and optional additional query constraints.\n     * Path must currently be empty if this is a collection group query.\n     */\n    constructor(path, collectionGroup = null, explicitOrderBy = [], filters = [], limit = null, limitType = \"F\" /* LimitType.First */, startAt = null, endAt = null) {\n        this.path = path;\n        this.collectionGroup = collectionGroup;\n        this.explicitOrderBy = explicitOrderBy;\n        this.filters = filters;\n        this.limit = limit;\n        this.limitType = limitType;\n        this.startAt = startAt;\n        this.endAt = endAt;\n        this.memoizedNormalizedOrderBy = null;\n        // The corresponding `Target` of this `Query` instance, for use with\n        // non-aggregate queries.\n        this.memoizedTarget = null;\n        // The corresponding `Target` of this `Query` instance, for use with\n        // aggregate queries. Unlike targets for non-aggregate queries,\n        // aggregate query targets do not contain normalized order-bys, they only\n        // contain explicit order-bys.\n        this.memoizedAggregateTarget = null;\n        if (this.startAt) ;\n        if (this.endAt) ;\n    }\n}\n/** Creates a new Query instance with the options provided. */\nfunction newQuery(path, collectionGroup, explicitOrderBy, filters, limit, limitType, startAt, endAt) {\n    return new QueryImpl(path, collectionGroup, explicitOrderBy, filters, limit, limitType, startAt, endAt);\n}\n/** Creates a new Query for a query that matches all documents at `path` */\nfunction newQueryForPath(path) {\n    return new QueryImpl(path);\n}\n/**\n * Helper to convert a collection group query into a collection query at a\n * specific path. This is used when executing collection group queries, since\n * we have to split the query into a set of collection queries at multiple\n * paths.\n */\nfunction asCollectionQueryAtPath(query, path) {\n    return new QueryImpl(path, \n    /*collectionGroup=*/ null, query.explicitOrderBy.slice(), query.filters.slice(), query.limit, query.limitType, query.startAt, query.endAt);\n}\n/**\n * Returns true if this query does not specify any query constraints that\n * could remove results.\n */\nfunction queryMatchesAllDocuments(query) {\n    return (query.filters.length === 0 &&\n        query.limit === null &&\n        query.startAt == null &&\n        query.endAt == null &&\n        (query.explicitOrderBy.length === 0 ||\n            (query.explicitOrderBy.length === 1 &&\n                query.explicitOrderBy[0].field.isKeyField())));\n}\n// Returns the sorted set of inequality filter fields used in this query.\nfunction getInequalityFilterFields(query) {\n    let result = new SortedSet(FieldPath$1.comparator);\n    query.filters.forEach((filter) => {\n        const subFilters = filter.getFlattenedFilters();\n        subFilters.forEach((filter) => {\n            if (filter.isInequality()) {\n                result = result.add(filter.field);\n            }\n        });\n    });\n    return result;\n}\n/**\n * Creates a new Query for a collection group query that matches all documents\n * within the provided collection group.\n */\nfunction newQueryForCollectionGroup(collectionId) {\n    return new QueryImpl(ResourcePath.emptyPath(), collectionId);\n}\n/**\n * Returns whether the query matches a single document by path (rather than a\n * collection).\n */\nfunction isDocumentQuery$1(query) {\n    return (DocumentKey.isDocumentKey(query.path) &&\n        query.collectionGroup === null &&\n        query.filters.length === 0);\n}\n/**\n * Returns whether the query matches a collection group rather than a specific\n * collection.\n */\nfunction isCollectionGroupQuery(query) {\n    return query.collectionGroup !== null;\n}\n/**\n * Returns the normalized order-by constraint that is used to execute the Query,\n * which can be different from the order-by constraints the user provided (e.g.\n * the SDK and backend always orders by `__name__`). The normalized order-by\n * includes implicit order-bys in addition to the explicit user provided\n * order-bys.\n */\nfunction queryNormalizedOrderBy(query) {\n    const queryImpl = debugCast(query);\n    if (queryImpl.memoizedNormalizedOrderBy === null) {\n        queryImpl.memoizedNormalizedOrderBy = [];\n        const fieldsNormalized = new Set();\n        // Any explicit order by fields should be added as is.\n        for (const orderBy of queryImpl.explicitOrderBy) {\n            queryImpl.memoizedNormalizedOrderBy.push(orderBy);\n            fieldsNormalized.add(orderBy.field.canonicalString());\n        }\n        // The order of the implicit ordering always matches the last explicit order by.\n        const lastDirection = queryImpl.explicitOrderBy.length > 0\n            ? queryImpl.explicitOrderBy[queryImpl.explicitOrderBy.length - 1].dir\n            : \"asc\" /* Direction.ASCENDING */;\n        // Any inequality fields not explicitly ordered should be implicitly ordered in a lexicographical\n        // order. When there are multiple inequality filters on the same field, the field should be added\n        // only once.\n        // Note: `SortedSet<FieldPath>` sorts the key field before other fields. However, we want the key\n        // field to be sorted last.\n        const inequalityFields = getInequalityFilterFields(queryImpl);\n        inequalityFields.forEach(field => {\n            if (!fieldsNormalized.has(field.canonicalString()) &&\n                !field.isKeyField()) {\n                queryImpl.memoizedNormalizedOrderBy.push(new OrderBy(field, lastDirection));\n            }\n        });\n        // Add the document key field to the last if it is not explicitly ordered.\n        if (!fieldsNormalized.has(FieldPath$1.keyField().canonicalString())) {\n            queryImpl.memoizedNormalizedOrderBy.push(new OrderBy(FieldPath$1.keyField(), lastDirection));\n        }\n    }\n    return queryImpl.memoizedNormalizedOrderBy;\n}\n/**\n * Converts this `Query` instance to its corresponding `Target` representation.\n */\nfunction queryToTarget(query) {\n    const queryImpl = debugCast(query);\n    if (!queryImpl.memoizedTarget) {\n        queryImpl.memoizedTarget = _queryToTarget(queryImpl, queryNormalizedOrderBy(query));\n    }\n    return queryImpl.memoizedTarget;\n}\n/**\n * Converts this `Query` instance to its corresponding `Target` representation,\n * for use within an aggregate query. Unlike targets for non-aggregate queries,\n * aggregate query targets do not contain normalized order-bys, they only\n * contain explicit order-bys.\n */\nfunction queryToAggregateTarget(query) {\n    const queryImpl = debugCast(query);\n    if (!queryImpl.memoizedAggregateTarget) {\n        // Do not include implicit order-bys for aggregate queries.\n        queryImpl.memoizedAggregateTarget = _queryToTarget(queryImpl, query.explicitOrderBy);\n    }\n    return queryImpl.memoizedAggregateTarget;\n}\nfunction _queryToTarget(queryImpl, orderBys) {\n    if (queryImpl.limitType === \"F\" /* LimitType.First */) {\n        return newTarget(queryImpl.path, queryImpl.collectionGroup, orderBys, queryImpl.filters, queryImpl.limit, queryImpl.startAt, queryImpl.endAt);\n    }\n    else {\n        // Flip the orderBy directions since we want the last results\n        orderBys = orderBys.map(orderBy => {\n            const dir = orderBy.dir === \"desc\" /* Direction.DESCENDING */\n                ? \"asc\" /* Direction.ASCENDING */\n                : \"desc\" /* Direction.DESCENDING */;\n            return new OrderBy(orderBy.field, dir);\n        });\n        // We need to swap the cursors to match the now-flipped query ordering.\n        const startAt = queryImpl.endAt\n            ? new Bound(queryImpl.endAt.position, queryImpl.endAt.inclusive)\n            : null;\n        const endAt = queryImpl.startAt\n            ? new Bound(queryImpl.startAt.position, queryImpl.startAt.inclusive)\n            : null;\n        // Now return as a LimitType.First query.\n        return newTarget(queryImpl.path, queryImpl.collectionGroup, orderBys, queryImpl.filters, queryImpl.limit, startAt, endAt);\n    }\n}\nfunction queryWithAddedFilter(query, filter) {\n    const newFilters = query.filters.concat([filter]);\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), newFilters, query.limit, query.limitType, query.startAt, query.endAt);\n}\nfunction queryWithAddedOrderBy(query, orderBy) {\n    // TODO(dimond): validate that orderBy does not list the same key twice.\n    const newOrderBy = query.explicitOrderBy.concat([orderBy]);\n    return new QueryImpl(query.path, query.collectionGroup, newOrderBy, query.filters.slice(), query.limit, query.limitType, query.startAt, query.endAt);\n}\nfunction queryWithLimit(query, limit, limitType) {\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), query.filters.slice(), limit, limitType, query.startAt, query.endAt);\n}\nfunction queryWithStartAt(query, bound) {\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), query.filters.slice(), query.limit, query.limitType, bound, query.endAt);\n}\nfunction queryWithEndAt(query, bound) {\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), query.filters.slice(), query.limit, query.limitType, query.startAt, bound);\n}\nfunction queryEquals(left, right) {\n    return (targetEquals(queryToTarget(left), queryToTarget(right)) &&\n        left.limitType === right.limitType);\n}\n// TODO(b/29183165): This is used to get a unique string from a query to, for\n// example, use as a dictionary key, but the implementation is subject to\n// collisions. Make it collision-free.\nfunction canonifyQuery(query) {\n    return `${canonifyTarget(queryToTarget(query))}|lt:${query.limitType}`;\n}\nfunction stringifyQuery(query) {\n    return `Query(target=${stringifyTarget(queryToTarget(query))}; limitType=${query.limitType})`;\n}\n/** Returns whether `doc` matches the constraints of `query`. */\nfunction queryMatches(query, doc) {\n    return (doc.isFoundDocument() &&\n        queryMatchesPathAndCollectionGroup(query, doc) &&\n        queryMatchesOrderBy(query, doc) &&\n        queryMatchesFilters(query, doc) &&\n        queryMatchesBounds(query, doc));\n}\nfunction queryMatchesPathAndCollectionGroup(query, doc) {\n    const docPath = doc.key.path;\n    if (query.collectionGroup !== null) {\n        // NOTE: this.path is currently always empty since we don't expose Collection\n        // Group queries rooted at a document path yet.\n        return (doc.key.hasCollectionId(query.collectionGroup) &&\n            query.path.isPrefixOf(docPath));\n    }\n    else if (DocumentKey.isDocumentKey(query.path)) {\n        // exact match for document queries\n        return query.path.isEqual(docPath);\n    }\n    else {\n        // shallow ancestor queries by default\n        return query.path.isImmediateParentOf(docPath);\n    }\n}\n/**\n * A document must have a value for every ordering clause in order to show up\n * in the results.\n */\nfunction queryMatchesOrderBy(query, doc) {\n    // We must use `queryNormalizedOrderBy()` to get the list of all orderBys (both implicit and explicit).\n    // Note that for OR queries, orderBy applies to all disjunction terms and implicit orderBys must\n    // be taken into account. For example, the query \"a > 1 || b==1\" has an implicit \"orderBy a\" due\n    // to the inequality, and is evaluated as \"a > 1 orderBy a || b==1 orderBy a\".\n    // A document with content of {b:1} matches the filters, but does not match the orderBy because\n    // it's missing the field 'a'.\n    for (const orderBy of queryNormalizedOrderBy(query)) {\n        // order-by key always matches\n        if (!orderBy.field.isKeyField() && doc.data.field(orderBy.field) === null) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction queryMatchesFilters(query, doc) {\n    for (const filter of query.filters) {\n        if (!filter.matches(doc)) {\n            return false;\n        }\n    }\n    return true;\n}\n/** Makes sure a document is within the bounds, if provided. */\nfunction queryMatchesBounds(query, doc) {\n    if (query.startAt &&\n        !boundSortsBeforeDocument(query.startAt, queryNormalizedOrderBy(query), doc)) {\n        return false;\n    }\n    if (query.endAt &&\n        !boundSortsAfterDocument(query.endAt, queryNormalizedOrderBy(query), doc)) {\n        return false;\n    }\n    return true;\n}\n/**\n * Returns the collection group that this query targets.\n *\n * PORTING NOTE: This is only used in the Web SDK to facilitate multi-tab\n * synchronization for query results.\n */\nfunction queryCollectionGroup(query) {\n    return (query.collectionGroup ||\n        (query.path.length % 2 === 1\n            ? query.path.lastSegment()\n            : query.path.get(query.path.length - 2)));\n}\n/**\n * Returns a new comparator function that can be used to compare two documents\n * based on the Query's ordering constraint.\n */\nfunction newQueryComparator(query) {\n    return (d1, d2) => {\n        let comparedOnKeyField = false;\n        for (const orderBy of queryNormalizedOrderBy(query)) {\n            const comp = compareDocs(orderBy, d1, d2);\n            if (comp !== 0) {\n                return comp;\n            }\n            comparedOnKeyField = comparedOnKeyField || orderBy.field.isKeyField();\n        }\n        return 0;\n    };\n}\nfunction compareDocs(orderBy, d1, d2) {\n    const comparison = orderBy.field.isKeyField()\n        ? DocumentKey.comparator(d1.key, d2.key)\n        : compareDocumentsByField(orderBy.field, d1, d2);\n    switch (orderBy.dir) {\n        case \"asc\" /* Direction.ASCENDING */:\n            return comparison;\n        case \"desc\" /* Direction.DESCENDING */:\n            return -1 * comparison;\n        default:\n            return fail();\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A map implementation that uses objects as keys. Objects must have an\n * associated equals function and must be immutable. Entries in the map are\n * stored together with the key being produced from the mapKeyFn. This map\n * automatically handles collisions of keys.\n */\nclass ObjectMap {\n    constructor(mapKeyFn, equalsFn) {\n        this.mapKeyFn = mapKeyFn;\n        this.equalsFn = equalsFn;\n        /**\n         * The inner map for a key/value pair. Due to the possibility of collisions we\n         * keep a list of entries that we do a linear search through to find an actual\n         * match. Note that collisions should be rare, so we still expect near\n         * constant time lookups in practice.\n         */\n        this.inner = {};\n        /** The number of entries stored in the map */\n        this.innerSize = 0;\n    }\n    /** Get a value for this key, or undefined if it does not exist. */\n    get(key) {\n        const id = this.mapKeyFn(key);\n        const matches = this.inner[id];\n        if (matches === undefined) {\n            return undefined;\n        }\n        for (const [otherKey, value] of matches) {\n            if (this.equalsFn(otherKey, key)) {\n                return value;\n            }\n        }\n        return undefined;\n    }\n    has(key) {\n        return this.get(key) !== undefined;\n    }\n    /** Put this key and value in the map. */\n    set(key, value) {\n        const id = this.mapKeyFn(key);\n        const matches = this.inner[id];\n        if (matches === undefined) {\n            this.inner[id] = [[key, value]];\n            this.innerSize++;\n            return;\n        }\n        for (let i = 0; i < matches.length; i++) {\n            if (this.equalsFn(matches[i][0], key)) {\n                // This is updating an existing entry and does not increase `innerSize`.\n                matches[i] = [key, value];\n                return;\n            }\n        }\n        matches.push([key, value]);\n        this.innerSize++;\n    }\n    /**\n     * Remove this key from the map. Returns a boolean if anything was deleted.\n     */\n    delete(key) {\n        const id = this.mapKeyFn(key);\n        const matches = this.inner[id];\n        if (matches === undefined) {\n            return false;\n        }\n        for (let i = 0; i < matches.length; i++) {\n            if (this.equalsFn(matches[i][0], key)) {\n                if (matches.length === 1) {\n                    delete this.inner[id];\n                }\n                else {\n                    matches.splice(i, 1);\n                }\n                this.innerSize--;\n                return true;\n            }\n        }\n        return false;\n    }\n    forEach(fn) {\n        forEach(this.inner, (_, entries) => {\n            for (const [k, v] of entries) {\n                fn(k, v);\n            }\n        });\n    }\n    isEmpty() {\n        return isEmpty(this.inner);\n    }\n    size() {\n        return this.innerSize;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst EMPTY_MUTABLE_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);\nfunction mutableDocumentMap() {\n    return EMPTY_MUTABLE_DOCUMENT_MAP;\n}\nconst EMPTY_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);\nfunction documentMap(...docs) {\n    let map = EMPTY_DOCUMENT_MAP;\n    for (const doc of docs) {\n        map = map.insert(doc.key, doc);\n    }\n    return map;\n}\nfunction newOverlayedDocumentMap() {\n    return newDocumentKeyMap();\n}\nfunction convertOverlayedDocumentMapToDocumentMap(collection) {\n    let documents = EMPTY_DOCUMENT_MAP;\n    collection.forEach((k, v) => (documents = documents.insert(k, v.overlayedDocument)));\n    return documents;\n}\nfunction newOverlayMap() {\n    return newDocumentKeyMap();\n}\nfunction newMutationMap() {\n    return newDocumentKeyMap();\n}\nfunction newDocumentKeyMap() {\n    return new ObjectMap(key => key.toString(), (l, r) => l.isEqual(r));\n}\nconst EMPTY_DOCUMENT_VERSION_MAP = new SortedMap(DocumentKey.comparator);\nfunction documentVersionMap() {\n    return EMPTY_DOCUMENT_VERSION_MAP;\n}\nconst EMPTY_DOCUMENT_KEY_SET = new SortedSet(DocumentKey.comparator);\nfunction documentKeySet(...keys) {\n    let set = EMPTY_DOCUMENT_KEY_SET;\n    for (const key of keys) {\n        set = set.add(key);\n    }\n    return set;\n}\nconst EMPTY_TARGET_ID_SET = new SortedSet(primitiveComparator);\nfunction targetIdSet() {\n    return EMPTY_TARGET_ID_SET;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns an DoubleValue for `value` that is encoded based the serializer's\n * `useProto3Json` setting.\n */\nfunction toDouble(serializer, value) {\n    if (serializer.useProto3Json) {\n        if (isNaN(value)) {\n            return { doubleValue: 'NaN' };\n        }\n        else if (value === Infinity) {\n            return { doubleValue: 'Infinity' };\n        }\n        else if (value === -Infinity) {\n            return { doubleValue: '-Infinity' };\n        }\n    }\n    return { doubleValue: isNegativeZero(value) ? '-0' : value };\n}\n/**\n * Returns an IntegerValue for `value`.\n */\nfunction toInteger(value) {\n    return { integerValue: '' + value };\n}\n/**\n * Returns a value for a number that's appropriate to put into a proto.\n * The return value is an IntegerValue if it can safely represent the value,\n * otherwise a DoubleValue is returned.\n */\nfunction toNumber(serializer, value) {\n    return isSafeInteger(value) ? toInteger(value) : toDouble(serializer, value);\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Used to represent a field transform on a mutation. */\nclass TransformOperation {\n    constructor() {\n        // Make sure that the structural type of `TransformOperation` is unique.\n        // See https://github.com/microsoft/TypeScript/issues/5451\n        this._ = undefined;\n    }\n}\n/**\n * Computes the local transform result against the provided `previousValue`,\n * optionally using the provided localWriteTime.\n */\nfunction applyTransformOperationToLocalView(transform, previousValue, localWriteTime) {\n    if (transform instanceof ServerTimestampTransform) {\n        return serverTimestamp$1(localWriteTime, previousValue);\n    }\n    else if (transform instanceof ArrayUnionTransformOperation) {\n        return applyArrayUnionTransformOperation(transform, previousValue);\n    }\n    else if (transform instanceof ArrayRemoveTransformOperation) {\n        return applyArrayRemoveTransformOperation(transform, previousValue);\n    }\n    else {\n        return applyNumericIncrementTransformOperationToLocalView(transform, previousValue);\n    }\n}\n/**\n * Computes a final transform result after the transform has been acknowledged\n * by the server, potentially using the server-provided transformResult.\n */\nfunction applyTransformOperationToRemoteDocument(transform, previousValue, transformResult) {\n    // The server just sends null as the transform result for array operations,\n    // so we have to calculate a result the same as we do for local\n    // applications.\n    if (transform instanceof ArrayUnionTransformOperation) {\n        return applyArrayUnionTransformOperation(transform, previousValue);\n    }\n    else if (transform instanceof ArrayRemoveTransformOperation) {\n        return applyArrayRemoveTransformOperation(transform, previousValue);\n    }\n    return transformResult;\n}\n/**\n * If this transform operation is not idempotent, returns the base value to\n * persist for this transform. If a base value is returned, the transform\n * operation is always applied to this base value, even if document has\n * already been updated.\n *\n * Base values provide consistent behavior for non-idempotent transforms and\n * allow us to return the same latency-compensated value even if the backend\n * has already applied the transform operation. The base value is null for\n * idempotent transforms, as they can be re-played even if the backend has\n * already applied them.\n *\n * @returns a base value to store along with the mutation, or null for\n * idempotent transforms.\n */\nfunction computeTransformOperationBaseValue(transform, previousValue) {\n    if (transform instanceof NumericIncrementTransformOperation) {\n        return isNumber(previousValue) ? previousValue : { integerValue: 0 };\n    }\n    return null;\n}\nfunction transformOperationEquals(left, right) {\n    if (left instanceof ArrayUnionTransformOperation &&\n        right instanceof ArrayUnionTransformOperation) {\n        return arrayEquals(left.elements, right.elements, valueEquals);\n    }\n    else if (left instanceof ArrayRemoveTransformOperation &&\n        right instanceof ArrayRemoveTransformOperation) {\n        return arrayEquals(left.elements, right.elements, valueEquals);\n    }\n    else if (left instanceof NumericIncrementTransformOperation &&\n        right instanceof NumericIncrementTransformOperation) {\n        return valueEquals(left.operand, right.operand);\n    }\n    return (left instanceof ServerTimestampTransform &&\n        right instanceof ServerTimestampTransform);\n}\n/** Transforms a value into a server-generated timestamp. */\nclass ServerTimestampTransform extends TransformOperation {\n}\n/** Transforms an array value via a union operation. */\nclass ArrayUnionTransformOperation extends TransformOperation {\n    constructor(elements) {\n        super();\n        this.elements = elements;\n    }\n}\nfunction applyArrayUnionTransformOperation(transform, previousValue) {\n    const values = coercedFieldValuesArray(previousValue);\n    for (const toUnion of transform.elements) {\n        if (!values.some(element => valueEquals(element, toUnion))) {\n            values.push(toUnion);\n        }\n    }\n    return { arrayValue: { values } };\n}\n/** Transforms an array value via a remove operation. */\nclass ArrayRemoveTransformOperation extends TransformOperation {\n    constructor(elements) {\n        super();\n        this.elements = elements;\n    }\n}\nfunction applyArrayRemoveTransformOperation(transform, previousValue) {\n    let values = coercedFieldValuesArray(previousValue);\n    for (const toRemove of transform.elements) {\n        values = values.filter(element => !valueEquals(element, toRemove));\n    }\n    return { arrayValue: { values } };\n}\n/**\n * Implements the backend semantics for locally computed NUMERIC_ADD (increment)\n * transforms. Converts all field values to integers or doubles, but unlike the\n * backend does not cap integer values at 2^63. Instead, JavaScript number\n * arithmetic is used and precision loss can occur for values greater than 2^53.\n */\nclass NumericIncrementTransformOperation extends TransformOperation {\n    constructor(serializer, operand) {\n        super();\n        this.serializer = serializer;\n        this.operand = operand;\n    }\n}\nfunction applyNumericIncrementTransformOperationToLocalView(transform, previousValue) {\n    // PORTING NOTE: Since JavaScript's integer arithmetic is limited to 53 bit\n    // precision and resolves overflows by reducing precision, we do not\n    // manually cap overflows at 2^63.\n    const baseValue = computeTransformOperationBaseValue(transform, previousValue);\n    const sum = asNumber(baseValue) + asNumber(transform.operand);\n    if (isInteger(baseValue) && isInteger(transform.operand)) {\n        return toInteger(sum);\n    }\n    else {\n        return toDouble(transform.serializer, sum);\n    }\n}\nfunction asNumber(value) {\n    return normalizeNumber(value.integerValue || value.doubleValue);\n}\nfunction coercedFieldValuesArray(value) {\n    return isArray(value) && value.arrayValue.values\n        ? value.arrayValue.values.slice()\n        : [];\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** A field path and the TransformOperation to perform upon it. */\nclass FieldTransform {\n    constructor(field, transform) {\n        this.field = field;\n        this.transform = transform;\n    }\n}\nfunction fieldTransformEquals(left, right) {\n    return (left.field.isEqual(right.field) &&\n        transformOperationEquals(left.transform, right.transform));\n}\nfunction fieldTransformsAreEqual(left, right) {\n    if (left === undefined && right === undefined) {\n        return true;\n    }\n    if (left && right) {\n        return arrayEquals(left, right, (l, r) => fieldTransformEquals(l, r));\n    }\n    return false;\n}\n/** The result of successfully applying a mutation to the backend. */\nclass MutationResult {\n    constructor(\n    /**\n     * The version at which the mutation was committed:\n     *\n     * - For most operations, this is the updateTime in the WriteResult.\n     * - For deletes, the commitTime of the WriteResponse (because deletes are\n     *   not stored and have no updateTime).\n     *\n     * Note that these versions can be different: No-op writes will not change\n     * the updateTime even though the commitTime advances.\n     */\n    version, \n    /**\n     * The resulting fields returned from the backend after a mutation\n     * containing field transforms has been committed. Contains one FieldValue\n     * for each FieldTransform that was in the mutation.\n     *\n     * Will be empty if the mutation did not contain any field transforms.\n     */\n    transformResults) {\n        this.version = version;\n        this.transformResults = transformResults;\n    }\n}\n/**\n * Encodes a precondition for a mutation. This follows the model that the\n * backend accepts with the special case of an explicit \"empty\" precondition\n * (meaning no precondition).\n */\nclass Precondition {\n    constructor(updateTime, exists) {\n        this.updateTime = updateTime;\n        this.exists = exists;\n    }\n    /** Creates a new empty Precondition. */\n    static none() {\n        return new Precondition();\n    }\n    /** Creates a new Precondition with an exists flag. */\n    static exists(exists) {\n        return new Precondition(undefined, exists);\n    }\n    /** Creates a new Precondition based on a version a document exists at. */\n    static updateTime(version) {\n        return new Precondition(version);\n    }\n    /** Returns whether this Precondition is empty. */\n    get isNone() {\n        return this.updateTime === undefined && this.exists === undefined;\n    }\n    isEqual(other) {\n        return (this.exists === other.exists &&\n            (this.updateTime\n                ? !!other.updateTime && this.updateTime.isEqual(other.updateTime)\n                : !other.updateTime));\n    }\n}\n/** Returns true if the preconditions is valid for the given document. */\nfunction preconditionIsValidForDocument(precondition, document) {\n    if (precondition.updateTime !== undefined) {\n        return (document.isFoundDocument() &&\n            document.version.isEqual(precondition.updateTime));\n    }\n    else if (precondition.exists !== undefined) {\n        return precondition.exists === document.isFoundDocument();\n    }\n    else {\n        return true;\n    }\n}\n/**\n * A mutation describes a self-contained change to a document. Mutations can\n * create, replace, delete, and update subsets of documents.\n *\n * Mutations not only act on the value of the document but also its version.\n *\n * For local mutations (mutations that haven't been committed yet), we preserve\n * the existing version for Set and Patch mutations. For Delete mutations, we\n * reset the version to 0.\n *\n * Here's the expected transition table.\n *\n * MUTATION           APPLIED TO            RESULTS IN\n *\n * SetMutation        Document(v3)          Document(v3)\n * SetMutation        NoDocument(v3)        Document(v0)\n * SetMutation        InvalidDocument(v0)   Document(v0)\n * PatchMutation      Document(v3)          Document(v3)\n * PatchMutation      NoDocument(v3)        NoDocument(v3)\n * PatchMutation      InvalidDocument(v0)   UnknownDocument(v3)\n * DeleteMutation     Document(v3)          NoDocument(v0)\n * DeleteMutation     NoDocument(v3)        NoDocument(v0)\n * DeleteMutation     InvalidDocument(v0)   NoDocument(v0)\n *\n * For acknowledged mutations, we use the updateTime of the WriteResponse as\n * the resulting version for Set and Patch mutations. As deletes have no\n * explicit update time, we use the commitTime of the WriteResponse for\n * Delete mutations.\n *\n * If a mutation is acknowledged by the backend but fails the precondition check\n * locally, we transition to an `UnknownDocument` and rely on Watch to send us\n * the updated version.\n *\n * Field transforms are used only with Patch and Set Mutations. We use the\n * `updateTransforms` message to store transforms, rather than the `transforms`s\n * messages.\n *\n * ## Subclassing Notes\n *\n * Every type of mutation needs to implement its own applyToRemoteDocument() and\n * applyToLocalView() to implement the actual behavior of applying the mutation\n * to some source document (see `setMutationApplyToRemoteDocument()` for an\n * example).\n */\nclass Mutation {\n}\n/**\n * A utility method to calculate a `Mutation` representing the overlay from the\n * final state of the document, and a `FieldMask` representing the fields that\n * are mutated by the local mutations.\n */\nfunction calculateOverlayMutation(doc, mask) {\n    if (!doc.hasLocalMutations || (mask && mask.fields.length === 0)) {\n        return null;\n    }\n    // mask is null when sets or deletes are applied to the current document.\n    if (mask === null) {\n        if (doc.isNoDocument()) {\n            return new DeleteMutation(doc.key, Precondition.none());\n        }\n        else {\n            return new SetMutation(doc.key, doc.data, Precondition.none());\n        }\n    }\n    else {\n        const docValue = doc.data;\n        const patchValue = ObjectValue.empty();\n        let maskSet = new SortedSet(FieldPath$1.comparator);\n        for (let path of mask.fields) {\n            if (!maskSet.has(path)) {\n                let value = docValue.field(path);\n                // If we are deleting a nested field, we take the immediate parent as\n                // the mask used to construct the resulting mutation.\n                // Justification: Nested fields can create parent fields implicitly. If\n                // only a leaf entry is deleted in later mutations, the parent field\n                // should still remain, but we may have lost this information.\n                // Consider mutation (foo.bar 1), then mutation (foo.bar delete()).\n                // This leaves the final result (foo, {}). Despite the fact that `doc`\n                // has the correct result, `foo` is not in `mask`, and the resulting\n                // mutation would miss `foo`.\n                if (value === null && path.length > 1) {\n                    path = path.popLast();\n                    value = docValue.field(path);\n                }\n                if (value === null) {\n                    patchValue.delete(path);\n                }\n                else {\n                    patchValue.set(path, value);\n                }\n                maskSet = maskSet.add(path);\n            }\n        }\n        return new PatchMutation(doc.key, patchValue, new FieldMask(maskSet.toArray()), Precondition.none());\n    }\n}\n/**\n * Applies this mutation to the given document for the purposes of computing a\n * new remote document. If the input document doesn't match the expected state\n * (e.g. it is invalid or outdated), the document type may transition to\n * unknown.\n *\n * @param mutation - The mutation to apply.\n * @param document - The document to mutate. The input document can be an\n *     invalid document if the client has no knowledge of the pre-mutation state\n *     of the document.\n * @param mutationResult - The result of applying the mutation from the backend.\n */\nfunction mutationApplyToRemoteDocument(mutation, document, mutationResult) {\n    if (mutation instanceof SetMutation) {\n        setMutationApplyToRemoteDocument(mutation, document, mutationResult);\n    }\n    else if (mutation instanceof PatchMutation) {\n        patchMutationApplyToRemoteDocument(mutation, document, mutationResult);\n    }\n    else {\n        deleteMutationApplyToRemoteDocument(mutation, document, mutationResult);\n    }\n}\n/**\n * Applies this mutation to the given document for the purposes of computing\n * the new local view of a document. If the input document doesn't match the\n * expected state, the document is not modified.\n *\n * @param mutation - The mutation to apply.\n * @param document - The document to mutate. The input document can be an\n *     invalid document if the client has no knowledge of the pre-mutation state\n *     of the document.\n * @param previousMask - The fields that have been updated before applying this mutation.\n * @param localWriteTime - A timestamp indicating the local write time of the\n *     batch this mutation is a part of.\n * @returns A `FieldMask` representing the fields that are changed by applying this mutation.\n */\nfunction mutationApplyToLocalView(mutation, document, previousMask, localWriteTime) {\n    if (mutation instanceof SetMutation) {\n        return setMutationApplyToLocalView(mutation, document, previousMask, localWriteTime);\n    }\n    else if (mutation instanceof PatchMutation) {\n        return patchMutationApplyToLocalView(mutation, document, previousMask, localWriteTime);\n    }\n    else {\n        return deleteMutationApplyToLocalView(mutation, document, previousMask);\n    }\n}\n/**\n * If this mutation is not idempotent, returns the base value to persist with\n * this mutation. If a base value is returned, the mutation is always applied\n * to this base value, even if document has already been updated.\n *\n * The base value is a sparse object that consists of only the document\n * fields for which this mutation contains a non-idempotent transformation\n * (e.g. a numeric increment). The provided value guarantees consistent\n * behavior for non-idempotent transforms and allow us to return the same\n * latency-compensated value even if the backend has already applied the\n * mutation. The base value is null for idempotent mutations, as they can be\n * re-played even if the backend has already applied them.\n *\n * @returns a base value to store along with the mutation, or null for\n * idempotent mutations.\n */\nfunction mutationExtractBaseValue(mutation, document) {\n    let baseObject = null;\n    for (const fieldTransform of mutation.fieldTransforms) {\n        const existingValue = document.data.field(fieldTransform.field);\n        const coercedValue = computeTransformOperationBaseValue(fieldTransform.transform, existingValue || null);\n        if (coercedValue != null) {\n            if (baseObject === null) {\n                baseObject = ObjectValue.empty();\n            }\n            baseObject.set(fieldTransform.field, coercedValue);\n        }\n    }\n    return baseObject ? baseObject : null;\n}\nfunction mutationEquals(left, right) {\n    if (left.type !== right.type) {\n        return false;\n    }\n    if (!left.key.isEqual(right.key)) {\n        return false;\n    }\n    if (!left.precondition.isEqual(right.precondition)) {\n        return false;\n    }\n    if (!fieldTransformsAreEqual(left.fieldTransforms, right.fieldTransforms)) {\n        return false;\n    }\n    if (left.type === 0 /* MutationType.Set */) {\n        return left.value.isEqual(right.value);\n    }\n    if (left.type === 1 /* MutationType.Patch */) {\n        return (left.data.isEqual(right.data) &&\n            left.fieldMask.isEqual(right.fieldMask));\n    }\n    return true;\n}\n/**\n * A mutation that creates or replaces the document at the given key with the\n * object value contents.\n */\nclass SetMutation extends Mutation {\n    constructor(key, value, precondition, fieldTransforms = []) {\n        super();\n        this.key = key;\n        this.value = value;\n        this.precondition = precondition;\n        this.fieldTransforms = fieldTransforms;\n        this.type = 0 /* MutationType.Set */;\n    }\n    getFieldMask() {\n        return null;\n    }\n}\nfunction setMutationApplyToRemoteDocument(mutation, document, mutationResult) {\n    // Unlike setMutationApplyToLocalView, if we're applying a mutation to a\n    // remote document the server has accepted the mutation so the precondition\n    // must have held.\n    const newData = mutation.value.clone();\n    const transformResults = serverTransformResults(mutation.fieldTransforms, document, mutationResult.transformResults);\n    newData.setAll(transformResults);\n    document\n        .convertToFoundDocument(mutationResult.version, newData)\n        .setHasCommittedMutations();\n}\nfunction setMutationApplyToLocalView(mutation, document, previousMask, localWriteTime) {\n    if (!preconditionIsValidForDocument(mutation.precondition, document)) {\n        // The mutation failed to apply (e.g. a document ID created with add()\n        // caused a name collision).\n        return previousMask;\n    }\n    const newData = mutation.value.clone();\n    const transformResults = localTransformResults(mutation.fieldTransforms, localWriteTime, document);\n    newData.setAll(transformResults);\n    document\n        .convertToFoundDocument(document.version, newData)\n        .setHasLocalMutations();\n    return null; // SetMutation overwrites all fields.\n}\n/**\n * A mutation that modifies fields of the document at the given key with the\n * given values. The values are applied through a field mask:\n *\n *  * When a field is in both the mask and the values, the corresponding field\n *    is updated.\n *  * When a field is in neither the mask nor the values, the corresponding\n *    field is unmodified.\n *  * When a field is in the mask but not in the values, the corresponding field\n *    is deleted.\n *  * When a field is not in the mask but is in the values, the values map is\n *    ignored.\n */\nclass PatchMutation extends Mutation {\n    constructor(key, data, fieldMask, precondition, fieldTransforms = []) {\n        super();\n        this.key = key;\n        this.data = data;\n        this.fieldMask = fieldMask;\n        this.precondition = precondition;\n        this.fieldTransforms = fieldTransforms;\n        this.type = 1 /* MutationType.Patch */;\n    }\n    getFieldMask() {\n        return this.fieldMask;\n    }\n}\nfunction patchMutationApplyToRemoteDocument(mutation, document, mutationResult) {\n    if (!preconditionIsValidForDocument(mutation.precondition, document)) {\n        // Since the mutation was not rejected, we know that the precondition\n        // matched on the backend. We therefore must not have the expected version\n        // of the document in our cache and convert to an UnknownDocument with a\n        // known updateTime.\n        document.convertToUnknownDocument(mutationResult.version);\n        return;\n    }\n    const transformResults = serverTransformResults(mutation.fieldTransforms, document, mutationResult.transformResults);\n    const newData = document.data;\n    newData.setAll(getPatch(mutation));\n    newData.setAll(transformResults);\n    document\n        .convertToFoundDocument(mutationResult.version, newData)\n        .setHasCommittedMutations();\n}\nfunction patchMutationApplyToLocalView(mutation, document, previousMask, localWriteTime) {\n    if (!preconditionIsValidForDocument(mutation.precondition, document)) {\n        return previousMask;\n    }\n    const transformResults = localTransformResults(mutation.fieldTransforms, localWriteTime, document);\n    const newData = document.data;\n    newData.setAll(getPatch(mutation));\n    newData.setAll(transformResults);\n    document\n        .convertToFoundDocument(document.version, newData)\n        .setHasLocalMutations();\n    if (previousMask === null) {\n        return null;\n    }\n    return previousMask\n        .unionWith(mutation.fieldMask.fields)\n        .unionWith(mutation.fieldTransforms.map(transform => transform.field));\n}\n/**\n * Returns a FieldPath/Value map with the content of the PatchMutation.\n */\nfunction getPatch(mutation) {\n    const result = new Map();\n    mutation.fieldMask.fields.forEach(fieldPath => {\n        if (!fieldPath.isEmpty()) {\n            const newValue = mutation.data.field(fieldPath);\n            result.set(fieldPath, newValue);\n        }\n    });\n    return result;\n}\n/**\n * Creates a list of \"transform results\" (a transform result is a field value\n * representing the result of applying a transform) for use after a mutation\n * containing transforms has been acknowledged by the server.\n *\n * @param fieldTransforms - The field transforms to apply the result to.\n * @param mutableDocument - The current state of the document after applying all\n * previous mutations.\n * @param serverTransformResults - The transform results received by the server.\n * @returns The transform results list.\n */\nfunction serverTransformResults(fieldTransforms, mutableDocument, serverTransformResults) {\n    const transformResults = new Map();\n    hardAssert(fieldTransforms.length === serverTransformResults.length);\n    for (let i = 0; i < serverTransformResults.length; i++) {\n        const fieldTransform = fieldTransforms[i];\n        const transform = fieldTransform.transform;\n        const previousValue = mutableDocument.data.field(fieldTransform.field);\n        transformResults.set(fieldTransform.field, applyTransformOperationToRemoteDocument(transform, previousValue, serverTransformResults[i]));\n    }\n    return transformResults;\n}\n/**\n * Creates a list of \"transform results\" (a transform result is a field value\n * representing the result of applying a transform) for use when applying a\n * transform locally.\n *\n * @param fieldTransforms - The field transforms to apply the result to.\n * @param localWriteTime - The local time of the mutation (used to\n *     generate ServerTimestampValues).\n * @param mutableDocument - The document to apply transforms on.\n * @returns The transform results list.\n */\nfunction localTransformResults(fieldTransforms, localWriteTime, mutableDocument) {\n    const transformResults = new Map();\n    for (const fieldTransform of fieldTransforms) {\n        const transform = fieldTransform.transform;\n        const previousValue = mutableDocument.data.field(fieldTransform.field);\n        transformResults.set(fieldTransform.field, applyTransformOperationToLocalView(transform, previousValue, localWriteTime));\n    }\n    return transformResults;\n}\n/** A mutation that deletes the document at the given key. */\nclass DeleteMutation extends Mutation {\n    constructor(key, precondition) {\n        super();\n        this.key = key;\n        this.precondition = precondition;\n        this.type = 2 /* MutationType.Delete */;\n        this.fieldTransforms = [];\n    }\n    getFieldMask() {\n        return null;\n    }\n}\nfunction deleteMutationApplyToRemoteDocument(mutation, document, mutationResult) {\n    // Unlike applyToLocalView, if we're applying a mutation to a remote\n    // document the server has accepted the mutation so the precondition must\n    // have held.\n    document\n        .convertToNoDocument(mutationResult.version)\n        .setHasCommittedMutations();\n}\nfunction deleteMutationApplyToLocalView(mutation, document, previousMask) {\n    if (preconditionIsValidForDocument(mutation.precondition, document)) {\n        document.convertToNoDocument(document.version).setHasLocalMutations();\n        return null;\n    }\n    return previousMask;\n}\n/**\n * A mutation that verifies the existence of the document at the given key with\n * the provided precondition.\n *\n * The `verify` operation is only used in Transactions, and this class serves\n * primarily to facilitate serialization into protos.\n */\nclass VerifyMutation extends Mutation {\n    constructor(key, precondition) {\n        super();\n        this.key = key;\n        this.precondition = precondition;\n        this.type = 3 /* MutationType.Verify */;\n        this.fieldTransforms = [];\n    }\n    getFieldMask() {\n        return null;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A batch of mutations that will be sent as one unit to the backend.\n */\nclass MutationBatch {\n    /**\n     * @param batchId - The unique ID of this mutation batch.\n     * @param localWriteTime - The original write time of this mutation.\n     * @param baseMutations - Mutations that are used to populate the base\n     * values when this mutation is applied locally. This can be used to locally\n     * overwrite values that are persisted in the remote document cache. Base\n     * mutations are never sent to the backend.\n     * @param mutations - The user-provided mutations in this mutation batch.\n     * User-provided mutations are applied both locally and remotely on the\n     * backend.\n     */\n    constructor(batchId, localWriteTime, baseMutations, mutations) {\n        this.batchId = batchId;\n        this.localWriteTime = localWriteTime;\n        this.baseMutations = baseMutations;\n        this.mutations = mutations;\n    }\n    /**\n     * Applies all the mutations in this MutationBatch to the specified document\n     * to compute the state of the remote document\n     *\n     * @param document - The document to apply mutations to.\n     * @param batchResult - The result of applying the MutationBatch to the\n     * backend.\n     */\n    applyToRemoteDocument(document, batchResult) {\n        const mutationResults = batchResult.mutationResults;\n        for (let i = 0; i < this.mutations.length; i++) {\n            const mutation = this.mutations[i];\n            if (mutation.key.isEqual(document.key)) {\n                const mutationResult = mutationResults[i];\n                mutationApplyToRemoteDocument(mutation, document, mutationResult);\n            }\n        }\n    }\n    /**\n     * Computes the local view of a document given all the mutations in this\n     * batch.\n     *\n     * @param document - The document to apply mutations to.\n     * @param mutatedFields - Fields that have been updated before applying this mutation batch.\n     * @returns A `FieldMask` representing all the fields that are mutated.\n     */\n    applyToLocalView(document, mutatedFields) {\n        // First, apply the base state. This allows us to apply non-idempotent\n        // transform against a consistent set of values.\n        for (const mutation of this.baseMutations) {\n            if (mutation.key.isEqual(document.key)) {\n                mutatedFields = mutationApplyToLocalView(mutation, document, mutatedFields, this.localWriteTime);\n            }\n        }\n        // Second, apply all user-provided mutations.\n        for (const mutation of this.mutations) {\n            if (mutation.key.isEqual(document.key)) {\n                mutatedFields = mutationApplyToLocalView(mutation, document, mutatedFields, this.localWriteTime);\n            }\n        }\n        return mutatedFields;\n    }\n    /**\n     * Computes the local view for all provided documents given the mutations in\n     * this batch. Returns a `DocumentKey` to `Mutation` map which can be used to\n     * replace all the mutation applications.\n     */\n    applyToLocalDocumentSet(documentMap, documentsWithoutRemoteVersion) {\n        // TODO(mrschmidt): This implementation is O(n^2). If we apply the mutations\n        // directly (as done in `applyToLocalView()`), we can reduce the complexity\n        // to O(n).\n        const overlays = newMutationMap();\n        this.mutations.forEach(m => {\n            const overlayedDocument = documentMap.get(m.key);\n            // TODO(mutabledocuments): This method should take a MutableDocumentMap\n            // and we should remove this cast.\n            const mutableDocument = overlayedDocument.overlayedDocument;\n            let mutatedFields = this.applyToLocalView(mutableDocument, overlayedDocument.mutatedFields);\n            // Set mutatedFields to null if the document is only from local mutations.\n            // This creates a Set or Delete mutation, instead of trying to create a\n            // patch mutation as the overlay.\n            mutatedFields = documentsWithoutRemoteVersion.has(m.key)\n                ? null\n                : mutatedFields;\n            const overlay = calculateOverlayMutation(mutableDocument, mutatedFields);\n            if (overlay !== null) {\n                overlays.set(m.key, overlay);\n            }\n            if (!mutableDocument.isValidDocument()) {\n                mutableDocument.convertToNoDocument(SnapshotVersion.min());\n            }\n        });\n        return overlays;\n    }\n    keys() {\n        return this.mutations.reduce((keys, m) => keys.add(m.key), documentKeySet());\n    }\n    isEqual(other) {\n        return (this.batchId === other.batchId &&\n            arrayEquals(this.mutations, other.mutations, (l, r) => mutationEquals(l, r)) &&\n            arrayEquals(this.baseMutations, other.baseMutations, (l, r) => mutationEquals(l, r)));\n    }\n}\n/** The result of applying a mutation batch to the backend. */\nclass MutationBatchResult {\n    constructor(batch, commitVersion, mutationResults, \n    /**\n     * A pre-computed mapping from each mutated document to the resulting\n     * version.\n     */\n    docVersions) {\n        this.batch = batch;\n        this.commitVersion = commitVersion;\n        this.mutationResults = mutationResults;\n        this.docVersions = docVersions;\n    }\n    /**\n     * Creates a new MutationBatchResult for the given batch and results. There\n     * must be one result for each mutation in the batch. This static factory\n     * caches a document=&gt;version mapping (docVersions).\n     */\n    static from(batch, commitVersion, results) {\n        hardAssert(batch.mutations.length === results.length);\n        let versionMap = documentVersionMap();\n        const mutations = batch.mutations;\n        for (let i = 0; i < mutations.length; i++) {\n            versionMap = versionMap.insert(mutations[i].key, results[i].version);\n        }\n        return new MutationBatchResult(batch, commitVersion, results, versionMap);\n    }\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Representation of an overlay computed by Firestore.\n *\n * Holds information about a mutation and the largest batch id in Firestore when\n * the mutation was created.\n */\nclass Overlay {\n    constructor(largestBatchId, mutation) {\n        this.largestBatchId = largestBatchId;\n        this.mutation = mutation;\n    }\n    getKey() {\n        return this.mutation.key;\n    }\n    isEqual(other) {\n        return other !== null && this.mutation === other.mutation;\n    }\n    toString() {\n        return `Overlay{\n      largestBatchId: ${this.largestBatchId},\n      mutation: ${this.mutation.toString()}\n    }`;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass ExistenceFilter {\n    constructor(count, unchangedNames) {\n        this.count = count;\n        this.unchangedNames = unchangedNames;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Error Codes describing the different ways GRPC can fail. These are copied\n * directly from GRPC's sources here:\n *\n * https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\n *\n * Important! The names of these identifiers matter because the string forms\n * are used for reverse lookups from the webchannel stream. Do NOT change the\n * names of these identifiers or change this into a const enum.\n */\nvar RpcCode;\n(function (RpcCode) {\n    RpcCode[RpcCode[\"OK\"] = 0] = \"OK\";\n    RpcCode[RpcCode[\"CANCELLED\"] = 1] = \"CANCELLED\";\n    RpcCode[RpcCode[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\n    RpcCode[RpcCode[\"INVALID_ARGUMENT\"] = 3] = \"INVALID_ARGUMENT\";\n    RpcCode[RpcCode[\"DEADLINE_EXCEEDED\"] = 4] = \"DEADLINE_EXCEEDED\";\n    RpcCode[RpcCode[\"NOT_FOUND\"] = 5] = \"NOT_FOUND\";\n    RpcCode[RpcCode[\"ALREADY_EXISTS\"] = 6] = \"ALREADY_EXISTS\";\n    RpcCode[RpcCode[\"PERMISSION_DENIED\"] = 7] = \"PERMISSION_DENIED\";\n    RpcCode[RpcCode[\"UNAUTHENTICATED\"] = 16] = \"UNAUTHENTICATED\";\n    RpcCode[RpcCode[\"RESOURCE_EXHAUSTED\"] = 8] = \"RESOURCE_EXHAUSTED\";\n    RpcCode[RpcCode[\"FAILED_PRECONDITION\"] = 9] = \"FAILED_PRECONDITION\";\n    RpcCode[RpcCode[\"ABORTED\"] = 10] = \"ABORTED\";\n    RpcCode[RpcCode[\"OUT_OF_RANGE\"] = 11] = \"OUT_OF_RANGE\";\n    RpcCode[RpcCode[\"UNIMPLEMENTED\"] = 12] = \"UNIMPLEMENTED\";\n    RpcCode[RpcCode[\"INTERNAL\"] = 13] = \"INTERNAL\";\n    RpcCode[RpcCode[\"UNAVAILABLE\"] = 14] = \"UNAVAILABLE\";\n    RpcCode[RpcCode[\"DATA_LOSS\"] = 15] = \"DATA_LOSS\";\n})(RpcCode || (RpcCode = {}));\n/**\n * Determines whether an error code represents a permanent error when received\n * in response to a non-write operation.\n *\n * See isPermanentWriteError for classifying write errors.\n */\nfunction isPermanentError(code) {\n    switch (code) {\n        case Code.OK:\n            return fail();\n        case Code.CANCELLED:\n        case Code.UNKNOWN:\n        case Code.DEADLINE_EXCEEDED:\n        case Code.RESOURCE_EXHAUSTED:\n        case Code.INTERNAL:\n        case Code.UNAVAILABLE:\n        // Unauthenticated means something went wrong with our token and we need\n        // to retry with new credentials which will happen automatically.\n        case Code.UNAUTHENTICATED:\n            return false;\n        case Code.INVALID_ARGUMENT:\n        case Code.NOT_FOUND:\n        case Code.ALREADY_EXISTS:\n        case Code.PERMISSION_DENIED:\n        case Code.FAILED_PRECONDITION:\n        // Aborted might be retried in some scenarios, but that is dependent on\n        // the context and should handled individually by the calling code.\n        // See https://cloud.google.com/apis/design/errors.\n        case Code.ABORTED:\n        case Code.OUT_OF_RANGE:\n        case Code.UNIMPLEMENTED:\n        case Code.DATA_LOSS:\n            return true;\n        default:\n            return fail();\n    }\n}\n/**\n * Determines whether an error code represents a permanent error when received\n * in response to a write operation.\n *\n * Write operations must be handled specially because as of b/119437764, ABORTED\n * errors on the write stream should be retried too (even though ABORTED errors\n * are not generally retryable).\n *\n * Note that during the initial handshake on the write stream an ABORTED error\n * signals that we should discard our stream token (i.e. it is permanent). This\n * means a handshake error should be classified with isPermanentError, above.\n */\nfunction isPermanentWriteError(code) {\n    return isPermanentError(code) && code !== Code.ABORTED;\n}\n/**\n * Maps an error Code from GRPC status code number, like 0, 1, or 14. These\n * are not the same as HTTP status codes.\n *\n * @returns The Code equivalent to the given GRPC status code. Fails if there\n *     is no match.\n */\nfunction mapCodeFromRpcCode(code) {\n    if (code === undefined) {\n        // This shouldn't normally happen, but in certain error cases (like trying\n        // to send invalid proto messages) we may get an error with no GRPC code.\n        logError('GRPC error has no .code');\n        return Code.UNKNOWN;\n    }\n    switch (code) {\n        case RpcCode.OK:\n            return Code.OK;\n        case RpcCode.CANCELLED:\n            return Code.CANCELLED;\n        case RpcCode.UNKNOWN:\n            return Code.UNKNOWN;\n        case RpcCode.DEADLINE_EXCEEDED:\n            return Code.DEADLINE_EXCEEDED;\n        case RpcCode.RESOURCE_EXHAUSTED:\n            return Code.RESOURCE_EXHAUSTED;\n        case RpcCode.INTERNAL:\n            return Code.INTERNAL;\n        case RpcCode.UNAVAILABLE:\n            return Code.UNAVAILABLE;\n        case RpcCode.UNAUTHENTICATED:\n            return Code.UNAUTHENTICATED;\n        case RpcCode.INVALID_ARGUMENT:\n            return Code.INVALID_ARGUMENT;\n        case RpcCode.NOT_FOUND:\n            return Code.NOT_FOUND;\n        case RpcCode.ALREADY_EXISTS:\n            return Code.ALREADY_EXISTS;\n        case RpcCode.PERMISSION_DENIED:\n            return Code.PERMISSION_DENIED;\n        case RpcCode.FAILED_PRECONDITION:\n            return Code.FAILED_PRECONDITION;\n        case RpcCode.ABORTED:\n            return Code.ABORTED;\n        case RpcCode.OUT_OF_RANGE:\n            return Code.OUT_OF_RANGE;\n        case RpcCode.UNIMPLEMENTED:\n            return Code.UNIMPLEMENTED;\n        case RpcCode.DATA_LOSS:\n            return Code.DATA_LOSS;\n        default:\n            return fail();\n    }\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An error encountered while decoding base64 string.\n */\nclass Base64DecodeError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'Base64DecodeError';\n    }\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The global, singleton instance of TestingHooksSpi.\n *\n * This variable will be `null` in all cases _except_ when running from\n * integration tests that have registered callbacks to be notified of events\n * that happen during the test execution.\n */\nlet testingHooksSpi = null;\n/**\n * Sets the value of the `testingHooksSpi` object.\n * @param instance the instance to set.\n */\nfunction setTestingHooksSpi(instance) {\n    if (testingHooksSpi) {\n        throw new Error('a TestingHooksSpi instance is already set');\n    }\n    testingHooksSpi = instance;\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An instance of the Platform's 'TextEncoder' implementation.\n */\nfunction newTextEncoder() {\n    return new util__WEBPACK_IMPORTED_MODULE_3__.TextEncoder();\n}\n/**\n * An instance of the Platform's 'TextDecoder' implementation.\n */\nfunction newTextDecoder() {\n    return new util__WEBPACK_IMPORTED_MODULE_3__.TextDecoder('utf-8');\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst MAX_64_BIT_UNSIGNED_INTEGER = new _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Integer([0xffffffff, 0xffffffff], 0);\n// Hash a string using md5 hashing algorithm.\nfunction getMd5HashValue(value) {\n    const encodedValue = newTextEncoder().encode(value);\n    const md5 = new _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Md5();\n    md5.update(encodedValue);\n    return new Uint8Array(md5.digest());\n}\n// Interpret the 16 bytes array as two 64-bit unsigned integers, encoded using\n// 2s complement using little endian.\nfunction get64BitUints(Bytes) {\n    const dataView = new DataView(Bytes.buffer);\n    const chunk1 = dataView.getUint32(0, /* littleEndian= */ true);\n    const chunk2 = dataView.getUint32(4, /* littleEndian= */ true);\n    const chunk3 = dataView.getUint32(8, /* littleEndian= */ true);\n    const chunk4 = dataView.getUint32(12, /* littleEndian= */ true);\n    const integer1 = new _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Integer([chunk1, chunk2], 0);\n    const integer2 = new _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Integer([chunk3, chunk4], 0);\n    return [integer1, integer2];\n}\nclass BloomFilter {\n    constructor(bitmap, padding, hashCount) {\n        this.bitmap = bitmap;\n        this.padding = padding;\n        this.hashCount = hashCount;\n        if (padding < 0 || padding >= 8) {\n            throw new BloomFilterError(`Invalid padding: ${padding}`);\n        }\n        if (hashCount < 0) {\n            throw new BloomFilterError(`Invalid hash count: ${hashCount}`);\n        }\n        if (bitmap.length > 0 && this.hashCount === 0) {\n            // Only empty bloom filter can have 0 hash count.\n            throw new BloomFilterError(`Invalid hash count: ${hashCount}`);\n        }\n        if (bitmap.length === 0 && padding !== 0) {\n            // Empty bloom filter should have 0 padding.\n            throw new BloomFilterError(`Invalid padding when bitmap length is 0: ${padding}`);\n        }\n        this.bitCount = bitmap.length * 8 - padding;\n        // Set the bit count in Integer to avoid repetition in mightContain().\n        this.bitCountInInteger = _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Integer.fromNumber(this.bitCount);\n    }\n    // Calculate the ith hash value based on the hashed 64bit integers,\n    // and calculate its corresponding bit index in the bitmap to be checked.\n    getBitIndex(num1, num2, hashIndex) {\n        // Calculate hashed value h(i) = h1 + (i * h2).\n        let hashValue = num1.add(num2.multiply(_firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Integer.fromNumber(hashIndex)));\n        // Wrap if hash value overflow 64bit.\n        if (hashValue.compare(MAX_64_BIT_UNSIGNED_INTEGER) === 1) {\n            hashValue = new _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Integer([hashValue.getBits(0), hashValue.getBits(1)], 0);\n        }\n        return hashValue.modulo(this.bitCountInInteger).toNumber();\n    }\n    // Return whether the bit on the given index in the bitmap is set to 1.\n    isBitSet(index) {\n        // To retrieve bit n, calculate: (bitmap[n / 8] & (0x01 << (n % 8))).\n        const byte = this.bitmap[Math.floor(index / 8)];\n        const offset = index % 8;\n        return (byte & (0x01 << offset)) !== 0;\n    }\n    mightContain(value) {\n        // Empty bitmap should always return false on membership check.\n        if (this.bitCount === 0) {\n            return false;\n        }\n        const md5HashedValue = getMd5HashValue(value);\n        const [hash1, hash2] = get64BitUints(md5HashedValue);\n        for (let i = 0; i < this.hashCount; i++) {\n            const index = this.getBitIndex(hash1, hash2, i);\n            if (!this.isBitSet(index)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /** Create bloom filter for testing purposes only. */\n    static create(bitCount, hashCount, contains) {\n        const padding = bitCount % 8 === 0 ? 0 : 8 - (bitCount % 8);\n        const bitmap = new Uint8Array(Math.ceil(bitCount / 8));\n        const bloomFilter = new BloomFilter(bitmap, padding, hashCount);\n        contains.forEach(item => bloomFilter.insert(item));\n        return bloomFilter;\n    }\n    insert(value) {\n        if (this.bitCount === 0) {\n            return;\n        }\n        const md5HashedValue = getMd5HashValue(value);\n        const [hash1, hash2] = get64BitUints(md5HashedValue);\n        for (let i = 0; i < this.hashCount; i++) {\n            const index = this.getBitIndex(hash1, hash2, i);\n            this.setBit(index);\n        }\n    }\n    setBit(index) {\n        const indexOfByte = Math.floor(index / 8);\n        const offset = index % 8;\n        this.bitmap[indexOfByte] |= 0x01 << offset;\n    }\n}\nclass BloomFilterError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'BloomFilterError';\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An event from the RemoteStore. It is split into targetChanges (changes to the\n * state or the set of documents in our watched targets) and documentUpdates\n * (changes to the actual documents).\n */\nclass RemoteEvent {\n    constructor(\n    /**\n     * The snapshot version this event brings us up to, or MIN if not set.\n     */\n    snapshotVersion, \n    /**\n     * A map from target to changes to the target. See TargetChange.\n     */\n    targetChanges, \n    /**\n     * A map of targets that is known to be inconsistent, and the purpose for\n     * re-listening. Listens for these targets should be re-established without\n     * resume tokens.\n     */\n    targetMismatches, \n    /**\n     * A set of which documents have changed or been deleted, along with the\n     * doc's new values (if not deleted).\n     */\n    documentUpdates, \n    /**\n     * A set of which document updates are due only to limbo resolution targets.\n     */\n    resolvedLimboDocuments) {\n        this.snapshotVersion = snapshotVersion;\n        this.targetChanges = targetChanges;\n        this.targetMismatches = targetMismatches;\n        this.documentUpdates = documentUpdates;\n        this.resolvedLimboDocuments = resolvedLimboDocuments;\n    }\n    /**\n     * HACK: Views require RemoteEvents in order to determine whether the view is\n     * CURRENT, but secondary tabs don't receive remote events. So this method is\n     * used to create a synthesized RemoteEvent that can be used to apply a\n     * CURRENT status change to a View, for queries executed in a different tab.\n     */\n    // PORTING NOTE: Multi-tab only\n    static createSynthesizedRemoteEventForCurrentChange(targetId, current, resumeToken) {\n        const targetChanges = new Map();\n        targetChanges.set(targetId, TargetChange.createSynthesizedTargetChangeForCurrentChange(targetId, current, resumeToken));\n        return new RemoteEvent(SnapshotVersion.min(), targetChanges, new SortedMap(primitiveComparator), mutableDocumentMap(), documentKeySet());\n    }\n}\n/**\n * A TargetChange specifies the set of changes for a specific target as part of\n * a RemoteEvent. These changes track which documents are added, modified or\n * removed, as well as the target's resume token and whether the target is\n * marked CURRENT.\n * The actual changes *to* documents are not part of the TargetChange since\n * documents may be part of multiple targets.\n */\nclass TargetChange {\n    constructor(\n    /**\n     * An opaque, server-assigned token that allows watching a query to be resumed\n     * after disconnecting without retransmitting all the data that matches the\n     * query. The resume token essentially identifies a point in time from which\n     * the server should resume sending results.\n     */\n    resumeToken, \n    /**\n     * The \"current\" (synced) status of this target. Note that \"current\"\n     * has special meaning in the RPC protocol that implies that a target is\n     * both up-to-date and consistent with the rest of the watch stream.\n     */\n    current, \n    /**\n     * The set of documents that were newly assigned to this target as part of\n     * this remote event.\n     */\n    addedDocuments, \n    /**\n     * The set of documents that were already assigned to this target but received\n     * an update during this remote event.\n     */\n    modifiedDocuments, \n    /**\n     * The set of documents that were removed from this target as part of this\n     * remote event.\n     */\n    removedDocuments) {\n        this.resumeToken = resumeToken;\n        this.current = current;\n        this.addedDocuments = addedDocuments;\n        this.modifiedDocuments = modifiedDocuments;\n        this.removedDocuments = removedDocuments;\n    }\n    /**\n     * This method is used to create a synthesized TargetChanges that can be used to\n     * apply a CURRENT status change to a View (for queries executed in a different\n     * tab) or for new queries (to raise snapshots with correct CURRENT status).\n     */\n    static createSynthesizedTargetChangeForCurrentChange(targetId, current, resumeToken) {\n        return new TargetChange(resumeToken, current, documentKeySet(), documentKeySet(), documentKeySet());\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a changed document and a list of target ids to which this change\n * applies.\n *\n * If document has been deleted NoDocument will be provided.\n */\nclass DocumentWatchChange {\n    constructor(\n    /** The new document applies to all of these targets. */\n    updatedTargetIds, \n    /** The new document is removed from all of these targets. */\n    removedTargetIds, \n    /** The key of the document for this change. */\n    key, \n    /**\n     * The new document or NoDocument if it was deleted. Is null if the\n     * document went out of view without the server sending a new document.\n     */\n    newDoc) {\n        this.updatedTargetIds = updatedTargetIds;\n        this.removedTargetIds = removedTargetIds;\n        this.key = key;\n        this.newDoc = newDoc;\n    }\n}\nclass ExistenceFilterChange {\n    constructor(targetId, existenceFilter) {\n        this.targetId = targetId;\n        this.existenceFilter = existenceFilter;\n    }\n}\nclass WatchTargetChange {\n    constructor(\n    /** What kind of change occurred to the watch target. */\n    state, \n    /** The target IDs that were added/removed/set. */\n    targetIds, \n    /**\n     * An opaque, server-assigned token that allows watching a target to be\n     * resumed after disconnecting without retransmitting all the data that\n     * matches the target. The resume token essentially identifies a point in\n     * time from which the server should resume sending results.\n     */\n    resumeToken = ByteString.EMPTY_BYTE_STRING, \n    /** An RPC error indicating why the watch failed. */\n    cause = null) {\n        this.state = state;\n        this.targetIds = targetIds;\n        this.resumeToken = resumeToken;\n        this.cause = cause;\n    }\n}\n/** Tracks the internal state of a Watch target. */\nclass TargetState {\n    constructor() {\n        /**\n         * The number of pending responses (adds or removes) that we are waiting on.\n         * We only consider targets active that have no pending responses.\n         */\n        this.pendingResponses = 0;\n        /**\n         * Keeps track of the document changes since the last raised snapshot.\n         *\n         * These changes are continuously updated as we receive document updates and\n         * always reflect the current set of changes against the last issued snapshot.\n         */\n        this.documentChanges = snapshotChangesMap();\n        /** See public getters for explanations of these fields. */\n        this._resumeToken = ByteString.EMPTY_BYTE_STRING;\n        this._current = false;\n        /**\n         * Whether this target state should be included in the next snapshot. We\n         * initialize to true so that newly-added targets are included in the next\n         * RemoteEvent.\n         */\n        this._hasPendingChanges = true;\n    }\n    /**\n     * Whether this target has been marked 'current'.\n     *\n     * 'Current' has special meaning in the RPC protocol: It implies that the\n     * Watch backend has sent us all changes up to the point at which the target\n     * was added and that the target is consistent with the rest of the watch\n     * stream.\n     */\n    get current() {\n        return this._current;\n    }\n    /** The last resume token sent to us for this target. */\n    get resumeToken() {\n        return this._resumeToken;\n    }\n    /** Whether this target has pending target adds or target removes. */\n    get isPending() {\n        return this.pendingResponses !== 0;\n    }\n    /** Whether we have modified any state that should trigger a snapshot. */\n    get hasPendingChanges() {\n        return this._hasPendingChanges;\n    }\n    /**\n     * Applies the resume token to the TargetChange, but only when it has a new\n     * value. Empty resumeTokens are discarded.\n     */\n    updateResumeToken(resumeToken) {\n        if (resumeToken.approximateByteSize() > 0) {\n            this._hasPendingChanges = true;\n            this._resumeToken = resumeToken;\n        }\n    }\n    /**\n     * Creates a target change from the current set of changes.\n     *\n     * To reset the document changes after raising this snapshot, call\n     * `clearPendingChanges()`.\n     */\n    toTargetChange() {\n        let addedDocuments = documentKeySet();\n        let modifiedDocuments = documentKeySet();\n        let removedDocuments = documentKeySet();\n        this.documentChanges.forEach((key, changeType) => {\n            switch (changeType) {\n                case 0 /* ChangeType.Added */:\n                    addedDocuments = addedDocuments.add(key);\n                    break;\n                case 2 /* ChangeType.Modified */:\n                    modifiedDocuments = modifiedDocuments.add(key);\n                    break;\n                case 1 /* ChangeType.Removed */:\n                    removedDocuments = removedDocuments.add(key);\n                    break;\n                default:\n                    fail();\n            }\n        });\n        return new TargetChange(this._resumeToken, this._current, addedDocuments, modifiedDocuments, removedDocuments);\n    }\n    /**\n     * Resets the document changes and sets `hasPendingChanges` to false.\n     */\n    clearPendingChanges() {\n        this._hasPendingChanges = false;\n        this.documentChanges = snapshotChangesMap();\n    }\n    addDocumentChange(key, changeType) {\n        this._hasPendingChanges = true;\n        this.documentChanges = this.documentChanges.insert(key, changeType);\n    }\n    removeDocumentChange(key) {\n        this._hasPendingChanges = true;\n        this.documentChanges = this.documentChanges.remove(key);\n    }\n    recordPendingTargetRequest() {\n        this.pendingResponses += 1;\n    }\n    recordTargetResponse() {\n        this.pendingResponses -= 1;\n        hardAssert(this.pendingResponses >= 0);\n    }\n    markCurrent() {\n        this._hasPendingChanges = true;\n        this._current = true;\n    }\n}\nconst LOG_TAG$g = 'WatchChangeAggregator';\n/**\n * A helper class to accumulate watch changes into a RemoteEvent.\n */\nclass WatchChangeAggregator {\n    constructor(metadataProvider) {\n        this.metadataProvider = metadataProvider;\n        /** The internal state of all tracked targets. */\n        this.targetStates = new Map();\n        /** Keeps track of the documents to update since the last raised snapshot. */\n        this.pendingDocumentUpdates = mutableDocumentMap();\n        this.pendingDocumentUpdatesByTarget = documentTargetMap();\n        /** A mapping of document keys to their set of target IDs. */\n        this.pendingDocumentTargetMapping = documentTargetMap();\n        /**\n         * A map of targets with existence filter mismatches. These targets are\n         * known to be inconsistent and their listens needs to be re-established by\n         * RemoteStore.\n         */\n        this.pendingTargetResets = new SortedMap(primitiveComparator);\n    }\n    /**\n     * Processes and adds the DocumentWatchChange to the current set of changes.\n     */\n    handleDocumentChange(docChange) {\n        for (const targetId of docChange.updatedTargetIds) {\n            if (docChange.newDoc && docChange.newDoc.isFoundDocument()) {\n                this.addDocumentToTarget(targetId, docChange.newDoc);\n            }\n            else {\n                this.removeDocumentFromTarget(targetId, docChange.key, docChange.newDoc);\n            }\n        }\n        for (const targetId of docChange.removedTargetIds) {\n            this.removeDocumentFromTarget(targetId, docChange.key, docChange.newDoc);\n        }\n    }\n    /** Processes and adds the WatchTargetChange to the current set of changes. */\n    handleTargetChange(targetChange) {\n        this.forEachTarget(targetChange, targetId => {\n            const targetState = this.ensureTargetState(targetId);\n            switch (targetChange.state) {\n                case 0 /* WatchTargetChangeState.NoChange */:\n                    if (this.isActiveTarget(targetId)) {\n                        targetState.updateResumeToken(targetChange.resumeToken);\n                    }\n                    break;\n                case 1 /* WatchTargetChangeState.Added */:\n                    // We need to decrement the number of pending acks needed from watch\n                    // for this targetId.\n                    targetState.recordTargetResponse();\n                    if (!targetState.isPending) {\n                        // We have a freshly added target, so we need to reset any state\n                        // that we had previously. This can happen e.g. when remove and add\n                        // back a target for existence filter mismatches.\n                        targetState.clearPendingChanges();\n                    }\n                    targetState.updateResumeToken(targetChange.resumeToken);\n                    break;\n                case 2 /* WatchTargetChangeState.Removed */:\n                    // We need to keep track of removed targets to we can post-filter and\n                    // remove any target changes.\n                    // We need to decrement the number of pending acks needed from watch\n                    // for this targetId.\n                    targetState.recordTargetResponse();\n                    if (!targetState.isPending) {\n                        this.removeTarget(targetId);\n                    }\n                    break;\n                case 3 /* WatchTargetChangeState.Current */:\n                    if (this.isActiveTarget(targetId)) {\n                        targetState.markCurrent();\n                        targetState.updateResumeToken(targetChange.resumeToken);\n                    }\n                    break;\n                case 4 /* WatchTargetChangeState.Reset */:\n                    if (this.isActiveTarget(targetId)) {\n                        // Reset the target and synthesizes removes for all existing\n                        // documents. The backend will re-add any documents that still\n                        // match the target before it sends the next global snapshot.\n                        this.resetTarget(targetId);\n                        targetState.updateResumeToken(targetChange.resumeToken);\n                    }\n                    break;\n                default:\n                    fail();\n            }\n        });\n    }\n    /**\n     * Iterates over all targetIds that the watch change applies to: either the\n     * targetIds explicitly listed in the change or the targetIds of all currently\n     * active targets.\n     */\n    forEachTarget(targetChange, fn) {\n        if (targetChange.targetIds.length > 0) {\n            targetChange.targetIds.forEach(fn);\n        }\n        else {\n            this.targetStates.forEach((_, targetId) => {\n                if (this.isActiveTarget(targetId)) {\n                    fn(targetId);\n                }\n            });\n        }\n    }\n    /**\n     * Handles existence filters and synthesizes deletes for filter mismatches.\n     * Targets that are invalidated by filter mismatches are added to\n     * `pendingTargetResets`.\n     */\n    handleExistenceFilter(watchChange) {\n        const targetId = watchChange.targetId;\n        const expectedCount = watchChange.existenceFilter.count;\n        const targetData = this.targetDataForActiveTarget(targetId);\n        if (targetData) {\n            const target = targetData.target;\n            if (targetIsDocumentTarget(target)) {\n                if (expectedCount === 0) {\n                    // The existence filter told us the document does not exist. We deduce\n                    // that this document does not exist and apply a deleted document to\n                    // our updates. Without applying this deleted document there might be\n                    // another query that will raise this document as part of a snapshot\n                    // until it is resolved, essentially exposing inconsistency between\n                    // queries.\n                    const key = new DocumentKey(target.path);\n                    this.removeDocumentFromTarget(targetId, key, MutableDocument.newNoDocument(key, SnapshotVersion.min()));\n                }\n                else {\n                    hardAssert(expectedCount === 1);\n                }\n            }\n            else {\n                const currentSize = this.getCurrentDocumentCountForTarget(targetId);\n                // Existence filter mismatch. Mark the documents as being in limbo, and\n                // raise a snapshot with `isFromCache:true`.\n                if (currentSize !== expectedCount) {\n                    // Apply bloom filter to identify and mark removed documents.\n                    const bloomFilter = this.parseBloomFilter(watchChange);\n                    const status = bloomFilter\n                        ? this.applyBloomFilter(bloomFilter, watchChange, currentSize)\n                        : 1 /* BloomFilterApplicationStatus.Skipped */;\n                    if (status !== 0 /* BloomFilterApplicationStatus.Success */) {\n                        // If bloom filter application fails, we reset the mapping and\n                        // trigger re-run of the query.\n                        this.resetTarget(targetId);\n                        const purpose = status === 2 /* BloomFilterApplicationStatus.FalsePositive */\n                            ? \"TargetPurposeExistenceFilterMismatchBloom\" /* TargetPurpose.ExistenceFilterMismatchBloom */\n                            : \"TargetPurposeExistenceFilterMismatch\" /* TargetPurpose.ExistenceFilterMismatch */;\n                        this.pendingTargetResets = this.pendingTargetResets.insert(targetId, purpose);\n                    }\n                    testingHooksSpi === null || testingHooksSpi === void 0 ? void 0 : testingHooksSpi.notifyOnExistenceFilterMismatch(createExistenceFilterMismatchInfoForTestingHooks(currentSize, watchChange.existenceFilter, this.metadataProvider.getDatabaseId(), bloomFilter, status));\n                }\n            }\n        }\n    }\n    /**\n     * Parse the bloom filter from the \"unchanged_names\" field of an existence\n     * filter.\n     */\n    parseBloomFilter(watchChange) {\n        const unchangedNames = watchChange.existenceFilter.unchangedNames;\n        if (!unchangedNames || !unchangedNames.bits) {\n            return null;\n        }\n        const { bits: { bitmap = '', padding = 0 }, hashCount = 0 } = unchangedNames;\n        let normalizedBitmap;\n        try {\n            normalizedBitmap = normalizeByteString(bitmap).toUint8Array();\n        }\n        catch (err) {\n            if (err instanceof Base64DecodeError) {\n                logWarn('Decoding the base64 bloom filter in existence filter failed (' +\n                    err.message +\n                    '); ignoring the bloom filter and falling back to full re-query.');\n                return null;\n            }\n            else {\n                throw err;\n            }\n        }\n        let bloomFilter;\n        try {\n            // BloomFilter throws error if the inputs are invalid.\n            bloomFilter = new BloomFilter(normalizedBitmap, padding, hashCount);\n        }\n        catch (err) {\n            if (err instanceof BloomFilterError) {\n                logWarn('BloomFilter error: ', err);\n            }\n            else {\n                logWarn('Applying bloom filter failed: ', err);\n            }\n            return null;\n        }\n        if (bloomFilter.bitCount === 0) {\n            return null;\n        }\n        return bloomFilter;\n    }\n    /**\n     * Apply bloom filter to remove the deleted documents, and return the\n     * application status.\n     */\n    applyBloomFilter(bloomFilter, watchChange, currentCount) {\n        const expectedCount = watchChange.existenceFilter.count;\n        const removedDocumentCount = this.filterRemovedDocuments(bloomFilter, watchChange.targetId);\n        return expectedCount === currentCount - removedDocumentCount\n            ? 0 /* BloomFilterApplicationStatus.Success */\n            : 2 /* BloomFilterApplicationStatus.FalsePositive */;\n    }\n    /**\n     * Filter out removed documents based on bloom filter membership result and\n     * return number of documents removed.\n     */\n    filterRemovedDocuments(bloomFilter, targetId) {\n        const existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);\n        let removalCount = 0;\n        existingKeys.forEach(key => {\n            const databaseId = this.metadataProvider.getDatabaseId();\n            const documentPath = `projects/${databaseId.projectId}` +\n                `/databases/${databaseId.database}` +\n                `/documents/${key.path.canonicalString()}`;\n            if (!bloomFilter.mightContain(documentPath)) {\n                this.removeDocumentFromTarget(targetId, key, /*updatedDocument=*/ null);\n                removalCount++;\n            }\n        });\n        return removalCount;\n    }\n    /**\n     * Converts the currently accumulated state into a remote event at the\n     * provided snapshot version. Resets the accumulated changes before returning.\n     */\n    createRemoteEvent(snapshotVersion) {\n        const targetChanges = new Map();\n        this.targetStates.forEach((targetState, targetId) => {\n            const targetData = this.targetDataForActiveTarget(targetId);\n            if (targetData) {\n                if (targetState.current && targetIsDocumentTarget(targetData.target)) {\n                    // Document queries for document that don't exist can produce an empty\n                    // result set. To update our local cache, we synthesize a document\n                    // delete if we have not previously received the document for this\n                    // target. This resolves the limbo state of the document, removing it\n                    // from limboDocumentRefs.\n                    //\n                    // TODO(dimond): Ideally we would have an explicit lookup target\n                    // instead resulting in an explicit delete message and we could\n                    // remove this special logic.\n                    const key = new DocumentKey(targetData.target.path);\n                    if (!this.ensureDocumentUpdateByTarget(key).has(targetId) &&\n                        !this.targetContainsDocument(targetId, key)) {\n                        this.removeDocumentFromTarget(targetId, key, MutableDocument.newNoDocument(key, snapshotVersion));\n                    }\n                }\n                if (targetState.hasPendingChanges) {\n                    targetChanges.set(targetId, targetState.toTargetChange());\n                    targetState.clearPendingChanges();\n                }\n            }\n        });\n        let resolvedLimboDocuments = documentKeySet();\n        // We extract the set of limbo-only document updates as the GC logic\n        // special-cases documents that do not appear in the target cache.\n        //\n        // TODO(gsoltis): Expand on this comment once GC is available in the JS\n        // client.\n        this.pendingDocumentTargetMapping.forEach((key, targets) => {\n            let isOnlyLimboTarget = true;\n            targets.forEachWhile(targetId => {\n                const targetData = this.targetDataForActiveTarget(targetId);\n                if (targetData &&\n                    targetData.purpose !== \"TargetPurposeLimboResolution\" /* TargetPurpose.LimboResolution */) {\n                    isOnlyLimboTarget = false;\n                    return false;\n                }\n                return true;\n            });\n            if (isOnlyLimboTarget) {\n                resolvedLimboDocuments = resolvedLimboDocuments.add(key);\n            }\n        });\n        this.pendingDocumentUpdates.forEach((_, doc) => doc.setReadTime(snapshotVersion));\n        const remoteEvent = new RemoteEvent(snapshotVersion, targetChanges, this.pendingTargetResets, this.pendingDocumentUpdates, resolvedLimboDocuments);\n        this.pendingDocumentUpdates = mutableDocumentMap();\n        this.pendingDocumentUpdatesByTarget = documentTargetMap();\n        this.pendingDocumentTargetMapping = documentTargetMap();\n        this.pendingTargetResets = new SortedMap(primitiveComparator);\n        return remoteEvent;\n    }\n    /**\n     * Adds the provided document to the internal list of document updates and\n     * its document key to the given target's mapping.\n     */\n    // Visible for testing.\n    addDocumentToTarget(targetId, document) {\n        if (!this.isActiveTarget(targetId)) {\n            return;\n        }\n        const changeType = this.targetContainsDocument(targetId, document.key)\n            ? 2 /* ChangeType.Modified */\n            : 0 /* ChangeType.Added */;\n        const targetState = this.ensureTargetState(targetId);\n        targetState.addDocumentChange(document.key, changeType);\n        this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(document.key, document);\n        this.pendingDocumentUpdatesByTarget =\n            this.pendingDocumentUpdatesByTarget.insert(document.key, this.ensureDocumentUpdateByTarget(document.key).add(targetId));\n        this.pendingDocumentTargetMapping =\n            this.pendingDocumentTargetMapping.insert(document.key, this.ensureDocumentTargetMapping(document.key).add(targetId));\n    }\n    /**\n     * Removes the provided document from the target mapping. If the\n     * document no longer matches the target, but the document's state is still\n     * known (e.g. we know that the document was deleted or we received the change\n     * that caused the filter mismatch), the new document can be provided\n     * to update the remote document cache.\n     */\n    // Visible for testing.\n    removeDocumentFromTarget(targetId, key, updatedDocument) {\n        if (!this.isActiveTarget(targetId)) {\n            return;\n        }\n        const targetState = this.ensureTargetState(targetId);\n        if (this.targetContainsDocument(targetId, key)) {\n            targetState.addDocumentChange(key, 1 /* ChangeType.Removed */);\n        }\n        else {\n            // The document may have entered and left the target before we raised a\n            // snapshot, so we can just ignore the change.\n            targetState.removeDocumentChange(key);\n        }\n        this.pendingDocumentTargetMapping =\n            this.pendingDocumentTargetMapping.insert(key, this.ensureDocumentTargetMapping(key).delete(targetId));\n        this.pendingDocumentTargetMapping =\n            this.pendingDocumentTargetMapping.insert(key, this.ensureDocumentTargetMapping(key).add(targetId));\n        if (updatedDocument) {\n            this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(key, updatedDocument);\n        }\n    }\n    removeTarget(targetId) {\n        this.targetStates.delete(targetId);\n    }\n    /**\n     * Returns the current count of documents in the target. This includes both\n     * the number of documents that the LocalStore considers to be part of the\n     * target as well as any accumulated changes.\n     */\n    getCurrentDocumentCountForTarget(targetId) {\n        const targetState = this.ensureTargetState(targetId);\n        const targetChange = targetState.toTargetChange();\n        return (this.metadataProvider.getRemoteKeysForTarget(targetId).size +\n            targetChange.addedDocuments.size -\n            targetChange.removedDocuments.size);\n    }\n    /**\n     * Increment the number of acks needed from watch before we can consider the\n     * server to be 'in-sync' with the client's active targets.\n     */\n    recordPendingTargetRequest(targetId) {\n        // For each request we get we need to record we need a response for it.\n        const targetState = this.ensureTargetState(targetId);\n        targetState.recordPendingTargetRequest();\n    }\n    ensureTargetState(targetId) {\n        let result = this.targetStates.get(targetId);\n        if (!result) {\n            result = new TargetState();\n            this.targetStates.set(targetId, result);\n        }\n        return result;\n    }\n    ensureDocumentTargetMapping(key) {\n        let targetMapping = this.pendingDocumentTargetMapping.get(key);\n        if (!targetMapping) {\n            targetMapping = new SortedSet(primitiveComparator);\n            this.pendingDocumentTargetMapping =\n                this.pendingDocumentTargetMapping.insert(key, targetMapping);\n        }\n        return targetMapping;\n    }\n    ensureDocumentUpdateByTarget(key) {\n        let targetMapping = this.pendingDocumentUpdatesByTarget.get(key);\n        if (!targetMapping) {\n            targetMapping = new SortedSet(primitiveComparator);\n            this.pendingDocumentUpdatesByTarget =\n                this.pendingDocumentUpdatesByTarget.insert(key, targetMapping);\n        }\n        return targetMapping;\n    }\n    /**\n     * Verifies that the user is still interested in this target (by calling\n     * `getTargetDataForTarget()`) and that we are not waiting for pending ADDs\n     * from watch.\n     */\n    isActiveTarget(targetId) {\n        const targetActive = this.targetDataForActiveTarget(targetId) !== null;\n        if (!targetActive) {\n            logDebug(LOG_TAG$g, 'Detected inactive target', targetId);\n        }\n        return targetActive;\n    }\n    /**\n     * Returns the TargetData for an active target (i.e. a target that the user\n     * is still interested in that has no outstanding target change requests).\n     */\n    targetDataForActiveTarget(targetId) {\n        const targetState = this.targetStates.get(targetId);\n        return targetState && targetState.isPending\n            ? null\n            : this.metadataProvider.getTargetDataForTarget(targetId);\n    }\n    /**\n     * Resets the state of a Watch target to its initial state (e.g. sets\n     * 'current' to false, clears the resume token and removes its target mapping\n     * from all documents).\n     */\n    resetTarget(targetId) {\n        this.targetStates.set(targetId, new TargetState());\n        // Trigger removal for any documents currently mapped to this target.\n        // These removals will be part of the initial snapshot if Watch does not\n        // resend these documents.\n        const existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);\n        existingKeys.forEach(key => {\n            this.removeDocumentFromTarget(targetId, key, /*updatedDocument=*/ null);\n        });\n    }\n    /**\n     * Returns whether the LocalStore considers the document to be part of the\n     * specified target.\n     */\n    targetContainsDocument(targetId, key) {\n        const existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);\n        return existingKeys.has(key);\n    }\n}\nfunction documentTargetMap() {\n    return new SortedMap(DocumentKey.comparator);\n}\nfunction snapshotChangesMap() {\n    return new SortedMap(DocumentKey.comparator);\n}\nfunction createExistenceFilterMismatchInfoForTestingHooks(localCacheCount, existenceFilter, databaseId, bloomFilter, bloomFilterStatus) {\n    var _a, _b, _c, _d, _e, _f;\n    const result = {\n        localCacheCount,\n        existenceFilterCount: existenceFilter.count,\n        databaseId: databaseId.database,\n        projectId: databaseId.projectId\n    };\n    const unchangedNames = existenceFilter.unchangedNames;\n    if (unchangedNames) {\n        result.bloomFilter = {\n            applied: bloomFilterStatus === 0 /* BloomFilterApplicationStatus.Success */,\n            hashCount: (_a = unchangedNames === null || unchangedNames === void 0 ? void 0 : unchangedNames.hashCount) !== null && _a !== void 0 ? _a : 0,\n            bitmapLength: (_d = (_c = (_b = unchangedNames === null || unchangedNames === void 0 ? void 0 : unchangedNames.bits) === null || _b === void 0 ? void 0 : _b.bitmap) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0,\n            padding: (_f = (_e = unchangedNames === null || unchangedNames === void 0 ? void 0 : unchangedNames.bits) === null || _e === void 0 ? void 0 : _e.padding) !== null && _f !== void 0 ? _f : 0,\n            mightContain: (value) => { var _a; return (_a = bloomFilter === null || bloomFilter === void 0 ? void 0 : bloomFilter.mightContain(value)) !== null && _a !== void 0 ? _a : false; }\n        };\n    }\n    return result;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DIRECTIONS = (() => {\n    const dirs = {};\n    dirs[\"asc\" /* Direction.ASCENDING */] = 'ASCENDING';\n    dirs[\"desc\" /* Direction.DESCENDING */] = 'DESCENDING';\n    return dirs;\n})();\nconst OPERATORS = (() => {\n    const ops = {};\n    ops[\"<\" /* Operator.LESS_THAN */] = 'LESS_THAN';\n    ops[\"<=\" /* Operator.LESS_THAN_OR_EQUAL */] = 'LESS_THAN_OR_EQUAL';\n    ops[\">\" /* Operator.GREATER_THAN */] = 'GREATER_THAN';\n    ops[\">=\" /* Operator.GREATER_THAN_OR_EQUAL */] = 'GREATER_THAN_OR_EQUAL';\n    ops[\"==\" /* Operator.EQUAL */] = 'EQUAL';\n    ops[\"!=\" /* Operator.NOT_EQUAL */] = 'NOT_EQUAL';\n    ops[\"array-contains\" /* Operator.ARRAY_CONTAINS */] = 'ARRAY_CONTAINS';\n    ops[\"in\" /* Operator.IN */] = 'IN';\n    ops[\"not-in\" /* Operator.NOT_IN */] = 'NOT_IN';\n    ops[\"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */] = 'ARRAY_CONTAINS_ANY';\n    return ops;\n})();\nconst COMPOSITE_OPERATORS = (() => {\n    const ops = {};\n    ops[\"and\" /* CompositeOperator.AND */] = 'AND';\n    ops[\"or\" /* CompositeOperator.OR */] = 'OR';\n    return ops;\n})();\nfunction assertPresent(value, description) {\n}\n/**\n * This class generates JsonObject values for the Datastore API suitable for\n * sending to either GRPC stub methods or via the JSON/HTTP REST API.\n *\n * The serializer supports both Protobuf.js and Proto3 JSON formats. By\n * setting `useProto3Json` to true, the serializer will use the Proto3 JSON\n * format.\n *\n * For a description of the Proto3 JSON format check\n * https://developers.google.com/protocol-buffers/docs/proto3#json\n *\n * TODO(klimt): We can remove the databaseId argument if we keep the full\n * resource name in documents.\n */\nclass JsonProtoSerializer {\n    constructor(databaseId, useProto3Json) {\n        this.databaseId = databaseId;\n        this.useProto3Json = useProto3Json;\n    }\n}\nfunction fromRpcStatus(status) {\n    const code = status.code === undefined ? Code.UNKNOWN : mapCodeFromRpcCode(status.code);\n    return new FirestoreError(code, status.message || '');\n}\n/**\n * Returns a value for a number (or null) that's appropriate to put into\n * a google.protobuf.Int32Value proto.\n * DO NOT USE THIS FOR ANYTHING ELSE.\n * This method cheats. It's typed as returning \"number\" because that's what\n * our generated proto interfaces say Int32Value must be. But GRPC actually\n * expects a { value: <number> } struct.\n */\nfunction toInt32Proto(serializer, val) {\n    if (serializer.useProto3Json || isNullOrUndefined(val)) {\n        return val;\n    }\n    else {\n        return { value: val };\n    }\n}\n/**\n * Returns a number (or null) from a google.protobuf.Int32Value proto.\n */\nfunction fromInt32Proto(val) {\n    let result;\n    if (typeof val === 'object') {\n        result = val.value;\n    }\n    else {\n        result = val;\n    }\n    return isNullOrUndefined(result) ? null : result;\n}\n/**\n * Returns a value for a Date that's appropriate to put into a proto.\n */\nfunction toTimestamp(serializer, timestamp) {\n    if (serializer.useProto3Json) {\n        // Serialize to ISO-8601 date format, but with full nano resolution.\n        // Since JS Date has only millis, let's only use it for the seconds and\n        // then manually add the fractions to the end.\n        const jsDateStr = new Date(timestamp.seconds * 1000).toISOString();\n        // Remove .xxx frac part and Z in the end.\n        const strUntilSeconds = jsDateStr.replace(/\\.\\d*/, '').replace('Z', '');\n        // Pad the fraction out to 9 digits (nanos).\n        const nanoStr = ('000000000' + timestamp.nanoseconds).slice(-9);\n        return `${strUntilSeconds}.${nanoStr}Z`;\n    }\n    else {\n        return {\n            seconds: '' + timestamp.seconds,\n            nanos: timestamp.nanoseconds\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        };\n    }\n}\nfunction fromTimestamp(date) {\n    const timestamp = normalizeTimestamp(date);\n    return new Timestamp(timestamp.seconds, timestamp.nanos);\n}\n/**\n * Returns a value for bytes that's appropriate to put in a proto.\n *\n * Visible for testing.\n */\nfunction toBytes(serializer, bytes) {\n    if (serializer.useProto3Json) {\n        return bytes.toBase64();\n    }\n    else {\n        return bytes.toUint8Array();\n    }\n}\n/**\n * Returns a ByteString based on the proto string value.\n */\nfunction fromBytes(serializer, value) {\n    if (serializer.useProto3Json) {\n        hardAssert(value === undefined || typeof value === 'string');\n        return ByteString.fromBase64String(value ? value : '');\n    }\n    else {\n        hardAssert(value === undefined ||\n            // Check if the value is an instance of both Buffer and Uint8Array,\n            // despite the fact that Buffer extends Uint8Array. In some\n            // environments, such as jsdom, the prototype chain of Buffer\n            // does not indicate that it extends Uint8Array.\n            value instanceof Buffer ||\n            value instanceof Uint8Array);\n        return ByteString.fromUint8Array(value ? value : new Uint8Array());\n    }\n}\nfunction toVersion(serializer, version) {\n    return toTimestamp(serializer, version.toTimestamp());\n}\nfunction fromVersion(version) {\n    hardAssert(!!version);\n    return SnapshotVersion.fromTimestamp(fromTimestamp(version));\n}\nfunction toResourceName(databaseId, path) {\n    return toResourcePath(databaseId, path).canonicalString();\n}\nfunction toResourcePath(databaseId, path) {\n    const resourcePath = fullyQualifiedPrefixPath(databaseId).child('documents');\n    return path === undefined ? resourcePath : resourcePath.child(path);\n}\nfunction fromResourceName(name) {\n    const resource = ResourcePath.fromString(name);\n    hardAssert(isValidResourceName(resource));\n    return resource;\n}\nfunction toName(serializer, key) {\n    return toResourceName(serializer.databaseId, key.path);\n}\nfunction fromName(serializer, name) {\n    const resource = fromResourceName(name);\n    if (resource.get(1) !== serializer.databaseId.projectId) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Tried to deserialize key from different project: ' +\n            resource.get(1) +\n            ' vs ' +\n            serializer.databaseId.projectId);\n    }\n    if (resource.get(3) !== serializer.databaseId.database) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Tried to deserialize key from different database: ' +\n            resource.get(3) +\n            ' vs ' +\n            serializer.databaseId.database);\n    }\n    return new DocumentKey(extractLocalPathFromResourceName(resource));\n}\nfunction toQueryPath(serializer, path) {\n    return toResourceName(serializer.databaseId, path);\n}\nfunction fromQueryPath(name) {\n    const resourceName = fromResourceName(name);\n    // In v1beta1 queries for collections at the root did not have a trailing\n    // \"/documents\". In v1 all resource paths contain \"/documents\". Preserve the\n    // ability to read the v1beta1 form for compatibility with queries persisted\n    // in the local target cache.\n    if (resourceName.length === 4) {\n        return ResourcePath.emptyPath();\n    }\n    return extractLocalPathFromResourceName(resourceName);\n}\nfunction getEncodedDatabaseId(serializer) {\n    const path = new ResourcePath([\n        'projects',\n        serializer.databaseId.projectId,\n        'databases',\n        serializer.databaseId.database\n    ]);\n    return path.canonicalString();\n}\nfunction fullyQualifiedPrefixPath(databaseId) {\n    return new ResourcePath([\n        'projects',\n        databaseId.projectId,\n        'databases',\n        databaseId.database\n    ]);\n}\nfunction extractLocalPathFromResourceName(resourceName) {\n    hardAssert(resourceName.length > 4 && resourceName.get(4) === 'documents');\n    return resourceName.popFirst(5);\n}\n/** Creates a Document proto from key and fields (but no create/update time) */\nfunction toMutationDocument(serializer, key, fields) {\n    return {\n        name: toName(serializer, key),\n        fields: fields.value.mapValue.fields\n    };\n}\nfunction toDocument(serializer, document) {\n    return {\n        name: toName(serializer, document.key),\n        fields: document.data.value.mapValue.fields,\n        updateTime: toTimestamp(serializer, document.version.toTimestamp()),\n        createTime: toTimestamp(serializer, document.createTime.toTimestamp())\n    };\n}\nfunction fromDocument(serializer, document, hasCommittedMutations) {\n    const key = fromName(serializer, document.name);\n    const version = fromVersion(document.updateTime);\n    // If we read a document from persistence that is missing createTime, it's due\n    // to older SDK versions not storing this information. In such cases, we'll\n    // set the createTime to zero. This can be removed in the long term.\n    const createTime = document.createTime\n        ? fromVersion(document.createTime)\n        : SnapshotVersion.min();\n    const data = new ObjectValue({ mapValue: { fields: document.fields } });\n    const result = MutableDocument.newFoundDocument(key, version, createTime, data);\n    if (hasCommittedMutations) {\n        result.setHasCommittedMutations();\n    }\n    return hasCommittedMutations ? result.setHasCommittedMutations() : result;\n}\nfunction fromFound(serializer, doc) {\n    hardAssert(!!doc.found);\n    assertPresent(doc.found.name);\n    assertPresent(doc.found.updateTime);\n    const key = fromName(serializer, doc.found.name);\n    const version = fromVersion(doc.found.updateTime);\n    const createTime = doc.found.createTime\n        ? fromVersion(doc.found.createTime)\n        : SnapshotVersion.min();\n    const data = new ObjectValue({ mapValue: { fields: doc.found.fields } });\n    return MutableDocument.newFoundDocument(key, version, createTime, data);\n}\nfunction fromMissing(serializer, result) {\n    hardAssert(!!result.missing);\n    hardAssert(!!result.readTime);\n    const key = fromName(serializer, result.missing);\n    const version = fromVersion(result.readTime);\n    return MutableDocument.newNoDocument(key, version);\n}\nfunction fromBatchGetDocumentsResponse(serializer, result) {\n    if ('found' in result) {\n        return fromFound(serializer, result);\n    }\n    else if ('missing' in result) {\n        return fromMissing(serializer, result);\n    }\n    return fail();\n}\nfunction fromWatchChange(serializer, change) {\n    let watchChange;\n    if ('targetChange' in change) {\n        assertPresent(change.targetChange);\n        // proto3 default value is unset in JSON (undefined), so use 'NO_CHANGE'\n        // if unset\n        const state = fromWatchTargetChangeState(change.targetChange.targetChangeType || 'NO_CHANGE');\n        const targetIds = change.targetChange.targetIds || [];\n        const resumeToken = fromBytes(serializer, change.targetChange.resumeToken);\n        const causeProto = change.targetChange.cause;\n        const cause = causeProto && fromRpcStatus(causeProto);\n        watchChange = new WatchTargetChange(state, targetIds, resumeToken, cause || null);\n    }\n    else if ('documentChange' in change) {\n        assertPresent(change.documentChange);\n        const entityChange = change.documentChange;\n        assertPresent(entityChange.document);\n        assertPresent(entityChange.document.name);\n        assertPresent(entityChange.document.updateTime);\n        const key = fromName(serializer, entityChange.document.name);\n        const version = fromVersion(entityChange.document.updateTime);\n        const createTime = entityChange.document.createTime\n            ? fromVersion(entityChange.document.createTime)\n            : SnapshotVersion.min();\n        const data = new ObjectValue({\n            mapValue: { fields: entityChange.document.fields }\n        });\n        const doc = MutableDocument.newFoundDocument(key, version, createTime, data);\n        const updatedTargetIds = entityChange.targetIds || [];\n        const removedTargetIds = entityChange.removedTargetIds || [];\n        watchChange = new DocumentWatchChange(updatedTargetIds, removedTargetIds, doc.key, doc);\n    }\n    else if ('documentDelete' in change) {\n        assertPresent(change.documentDelete);\n        const docDelete = change.documentDelete;\n        assertPresent(docDelete.document);\n        const key = fromName(serializer, docDelete.document);\n        const version = docDelete.readTime\n            ? fromVersion(docDelete.readTime)\n            : SnapshotVersion.min();\n        const doc = MutableDocument.newNoDocument(key, version);\n        const removedTargetIds = docDelete.removedTargetIds || [];\n        watchChange = new DocumentWatchChange([], removedTargetIds, doc.key, doc);\n    }\n    else if ('documentRemove' in change) {\n        assertPresent(change.documentRemove);\n        const docRemove = change.documentRemove;\n        assertPresent(docRemove.document);\n        const key = fromName(serializer, docRemove.document);\n        const removedTargetIds = docRemove.removedTargetIds || [];\n        watchChange = new DocumentWatchChange([], removedTargetIds, key, null);\n    }\n    else if ('filter' in change) {\n        // TODO(dimond): implement existence filter parsing with strategy.\n        assertPresent(change.filter);\n        const filter = change.filter;\n        assertPresent(filter.targetId);\n        const { count = 0, unchangedNames } = filter;\n        const existenceFilter = new ExistenceFilter(count, unchangedNames);\n        const targetId = filter.targetId;\n        watchChange = new ExistenceFilterChange(targetId, existenceFilter);\n    }\n    else {\n        return fail();\n    }\n    return watchChange;\n}\nfunction fromWatchTargetChangeState(state) {\n    if (state === 'NO_CHANGE') {\n        return 0 /* WatchTargetChangeState.NoChange */;\n    }\n    else if (state === 'ADD') {\n        return 1 /* WatchTargetChangeState.Added */;\n    }\n    else if (state === 'REMOVE') {\n        return 2 /* WatchTargetChangeState.Removed */;\n    }\n    else if (state === 'CURRENT') {\n        return 3 /* WatchTargetChangeState.Current */;\n    }\n    else if (state === 'RESET') {\n        return 4 /* WatchTargetChangeState.Reset */;\n    }\n    else {\n        return fail();\n    }\n}\nfunction versionFromListenResponse(change) {\n    // We have only reached a consistent snapshot for the entire stream if there\n    // is a read_time set and it applies to all targets (i.e. the list of\n    // targets is empty). The backend is guaranteed to send such responses.\n    if (!('targetChange' in change)) {\n        return SnapshotVersion.min();\n    }\n    const targetChange = change.targetChange;\n    if (targetChange.targetIds && targetChange.targetIds.length) {\n        return SnapshotVersion.min();\n    }\n    if (!targetChange.readTime) {\n        return SnapshotVersion.min();\n    }\n    return fromVersion(targetChange.readTime);\n}\nfunction toMutation(serializer, mutation) {\n    let result;\n    if (mutation instanceof SetMutation) {\n        result = {\n            update: toMutationDocument(serializer, mutation.key, mutation.value)\n        };\n    }\n    else if (mutation instanceof DeleteMutation) {\n        result = { delete: toName(serializer, mutation.key) };\n    }\n    else if (mutation instanceof PatchMutation) {\n        result = {\n            update: toMutationDocument(serializer, mutation.key, mutation.data),\n            updateMask: toDocumentMask(mutation.fieldMask)\n        };\n    }\n    else if (mutation instanceof VerifyMutation) {\n        result = {\n            verify: toName(serializer, mutation.key)\n        };\n    }\n    else {\n        return fail();\n    }\n    if (mutation.fieldTransforms.length > 0) {\n        result.updateTransforms = mutation.fieldTransforms.map(transform => toFieldTransform(serializer, transform));\n    }\n    if (!mutation.precondition.isNone) {\n        result.currentDocument = toPrecondition(serializer, mutation.precondition);\n    }\n    return result;\n}\nfunction fromMutation(serializer, proto) {\n    const precondition = proto.currentDocument\n        ? fromPrecondition(proto.currentDocument)\n        : Precondition.none();\n    const fieldTransforms = proto.updateTransforms\n        ? proto.updateTransforms.map(transform => fromFieldTransform(serializer, transform))\n        : [];\n    if (proto.update) {\n        assertPresent(proto.update.name);\n        const key = fromName(serializer, proto.update.name);\n        const value = new ObjectValue({\n            mapValue: { fields: proto.update.fields }\n        });\n        if (proto.updateMask) {\n            const fieldMask = fromDocumentMask(proto.updateMask);\n            return new PatchMutation(key, value, fieldMask, precondition, fieldTransforms);\n        }\n        else {\n            return new SetMutation(key, value, precondition, fieldTransforms);\n        }\n    }\n    else if (proto.delete) {\n        const key = fromName(serializer, proto.delete);\n        return new DeleteMutation(key, precondition);\n    }\n    else if (proto.verify) {\n        const key = fromName(serializer, proto.verify);\n        return new VerifyMutation(key, precondition);\n    }\n    else {\n        return fail();\n    }\n}\nfunction toPrecondition(serializer, precondition) {\n    if (precondition.updateTime !== undefined) {\n        return {\n            updateTime: toVersion(serializer, precondition.updateTime)\n        };\n    }\n    else if (precondition.exists !== undefined) {\n        return { exists: precondition.exists };\n    }\n    else {\n        return fail();\n    }\n}\nfunction fromPrecondition(precondition) {\n    if (precondition.updateTime !== undefined) {\n        return Precondition.updateTime(fromVersion(precondition.updateTime));\n    }\n    else if (precondition.exists !== undefined) {\n        return Precondition.exists(precondition.exists);\n    }\n    else {\n        return Precondition.none();\n    }\n}\nfunction fromWriteResult(proto, commitTime) {\n    // NOTE: Deletes don't have an updateTime.\n    let version = proto.updateTime\n        ? fromVersion(proto.updateTime)\n        : fromVersion(commitTime);\n    if (version.isEqual(SnapshotVersion.min())) {\n        // The Firestore Emulator currently returns an update time of 0 for\n        // deletes of non-existing documents (rather than null). This breaks the\n        // test \"get deleted doc while offline with source=cache\" as NoDocuments\n        // with version 0 are filtered by IndexedDb's RemoteDocumentCache.\n        // TODO(#2149): Remove this when Emulator is fixed\n        version = fromVersion(commitTime);\n    }\n    return new MutationResult(version, proto.transformResults || []);\n}\nfunction fromWriteResults(protos, commitTime) {\n    if (protos && protos.length > 0) {\n        hardAssert(commitTime !== undefined);\n        return protos.map(proto => fromWriteResult(proto, commitTime));\n    }\n    else {\n        return [];\n    }\n}\nfunction toFieldTransform(serializer, fieldTransform) {\n    const transform = fieldTransform.transform;\n    if (transform instanceof ServerTimestampTransform) {\n        return {\n            fieldPath: fieldTransform.field.canonicalString(),\n            setToServerValue: 'REQUEST_TIME'\n        };\n    }\n    else if (transform instanceof ArrayUnionTransformOperation) {\n        return {\n            fieldPath: fieldTransform.field.canonicalString(),\n            appendMissingElements: {\n                values: transform.elements\n            }\n        };\n    }\n    else if (transform instanceof ArrayRemoveTransformOperation) {\n        return {\n            fieldPath: fieldTransform.field.canonicalString(),\n            removeAllFromArray: {\n                values: transform.elements\n            }\n        };\n    }\n    else if (transform instanceof NumericIncrementTransformOperation) {\n        return {\n            fieldPath: fieldTransform.field.canonicalString(),\n            increment: transform.operand\n        };\n    }\n    else {\n        throw fail();\n    }\n}\nfunction fromFieldTransform(serializer, proto) {\n    let transform = null;\n    if ('setToServerValue' in proto) {\n        hardAssert(proto.setToServerValue === 'REQUEST_TIME');\n        transform = new ServerTimestampTransform();\n    }\n    else if ('appendMissingElements' in proto) {\n        const values = proto.appendMissingElements.values || [];\n        transform = new ArrayUnionTransformOperation(values);\n    }\n    else if ('removeAllFromArray' in proto) {\n        const values = proto.removeAllFromArray.values || [];\n        transform = new ArrayRemoveTransformOperation(values);\n    }\n    else if ('increment' in proto) {\n        transform = new NumericIncrementTransformOperation(serializer, proto.increment);\n    }\n    else {\n        fail();\n    }\n    const fieldPath = FieldPath$1.fromServerFormat(proto.fieldPath);\n    return new FieldTransform(fieldPath, transform);\n}\nfunction toDocumentsTarget(serializer, target) {\n    return { documents: [toQueryPath(serializer, target.path)] };\n}\nfunction fromDocumentsTarget(documentsTarget) {\n    const count = documentsTarget.documents.length;\n    hardAssert(count === 1);\n    const name = documentsTarget.documents[0];\n    return queryToTarget(newQueryForPath(fromQueryPath(name)));\n}\nfunction toQueryTarget(serializer, target) {\n    // Dissect the path into parent, collectionId, and optional key filter.\n    const queryTarget = { structuredQuery: {} };\n    const path = target.path;\n    let parent;\n    if (target.collectionGroup !== null) {\n        parent = path;\n        queryTarget.structuredQuery.from = [\n            {\n                collectionId: target.collectionGroup,\n                allDescendants: true\n            }\n        ];\n    }\n    else {\n        parent = path.popLast();\n        queryTarget.structuredQuery.from = [{ collectionId: path.lastSegment() }];\n    }\n    queryTarget.parent = toQueryPath(serializer, parent);\n    const where = toFilters(target.filters);\n    if (where) {\n        queryTarget.structuredQuery.where = where;\n    }\n    const orderBy = toOrder(target.orderBy);\n    if (orderBy) {\n        queryTarget.structuredQuery.orderBy = orderBy;\n    }\n    const limit = toInt32Proto(serializer, target.limit);\n    if (limit !== null) {\n        queryTarget.structuredQuery.limit = limit;\n    }\n    if (target.startAt) {\n        queryTarget.structuredQuery.startAt = toStartAtCursor(target.startAt);\n    }\n    if (target.endAt) {\n        queryTarget.structuredQuery.endAt = toEndAtCursor(target.endAt);\n    }\n    return { queryTarget, parent };\n}\nfunction toRunAggregationQueryRequest(serializer, target, aggregates, skipAliasing) {\n    const { queryTarget, parent } = toQueryTarget(serializer, target);\n    const aliasMap = {};\n    const aggregations = [];\n    let aggregationNum = 0;\n    aggregates.forEach(aggregate => {\n        // Map all client-side aliases to a unique short-form\n        // alias. This avoids issues with client-side aliases that\n        // exceed the 1500-byte string size limit.\n        const serverAlias = skipAliasing\n            ? aggregate.alias\n            : `aggregate_${aggregationNum++}`;\n        aliasMap[serverAlias] = aggregate.alias;\n        if (aggregate.aggregateType === 'count') {\n            aggregations.push({\n                alias: serverAlias,\n                count: {}\n            });\n        }\n        else if (aggregate.aggregateType === 'avg') {\n            aggregations.push({\n                alias: serverAlias,\n                avg: {\n                    field: toFieldPathReference(aggregate.fieldPath)\n                }\n            });\n        }\n        else if (aggregate.aggregateType === 'sum') {\n            aggregations.push({\n                alias: serverAlias,\n                sum: {\n                    field: toFieldPathReference(aggregate.fieldPath)\n                }\n            });\n        }\n    });\n    return {\n        request: {\n            structuredAggregationQuery: {\n                aggregations,\n                structuredQuery: queryTarget.structuredQuery\n            },\n            parent: queryTarget.parent\n        },\n        aliasMap,\n        parent\n    };\n}\nfunction convertQueryTargetToQuery(target) {\n    let path = fromQueryPath(target.parent);\n    const query = target.structuredQuery;\n    const fromCount = query.from ? query.from.length : 0;\n    let collectionGroup = null;\n    if (fromCount > 0) {\n        hardAssert(fromCount === 1);\n        const from = query.from[0];\n        if (from.allDescendants) {\n            collectionGroup = from.collectionId;\n        }\n        else {\n            path = path.child(from.collectionId);\n        }\n    }\n    let filterBy = [];\n    if (query.where) {\n        filterBy = fromFilters(query.where);\n    }\n    let orderBy = [];\n    if (query.orderBy) {\n        orderBy = fromOrder(query.orderBy);\n    }\n    let limit = null;\n    if (query.limit) {\n        limit = fromInt32Proto(query.limit);\n    }\n    let startAt = null;\n    if (query.startAt) {\n        startAt = fromStartAtCursor(query.startAt);\n    }\n    let endAt = null;\n    if (query.endAt) {\n        endAt = fromEndAtCursor(query.endAt);\n    }\n    return newQuery(path, collectionGroup, orderBy, filterBy, limit, \"F\" /* LimitType.First */, startAt, endAt);\n}\nfunction fromQueryTarget(target) {\n    return queryToTarget(convertQueryTargetToQuery(target));\n}\nfunction toListenRequestLabels(serializer, targetData) {\n    const value = toLabel(targetData.purpose);\n    if (value == null) {\n        return null;\n    }\n    else {\n        return {\n            'goog-listen-tags': value\n        };\n    }\n}\nfunction toLabel(purpose) {\n    switch (purpose) {\n        case \"TargetPurposeListen\" /* TargetPurpose.Listen */:\n            return null;\n        case \"TargetPurposeExistenceFilterMismatch\" /* TargetPurpose.ExistenceFilterMismatch */:\n            return 'existence-filter-mismatch';\n        case \"TargetPurposeExistenceFilterMismatchBloom\" /* TargetPurpose.ExistenceFilterMismatchBloom */:\n            return 'existence-filter-mismatch-bloom';\n        case \"TargetPurposeLimboResolution\" /* TargetPurpose.LimboResolution */:\n            return 'limbo-document';\n        default:\n            return fail();\n    }\n}\nfunction toTarget(serializer, targetData) {\n    let result;\n    const target = targetData.target;\n    if (targetIsDocumentTarget(target)) {\n        result = { documents: toDocumentsTarget(serializer, target) };\n    }\n    else {\n        result = { query: toQueryTarget(serializer, target).queryTarget };\n    }\n    result.targetId = targetData.targetId;\n    if (targetData.resumeToken.approximateByteSize() > 0) {\n        result.resumeToken = toBytes(serializer, targetData.resumeToken);\n        const expectedCount = toInt32Proto(serializer, targetData.expectedCount);\n        if (expectedCount !== null) {\n            result.expectedCount = expectedCount;\n        }\n    }\n    else if (targetData.snapshotVersion.compareTo(SnapshotVersion.min()) > 0) {\n        // TODO(wuandy): Consider removing above check because it is most likely true.\n        // Right now, many tests depend on this behaviour though (leaving min() out\n        // of serialization).\n        result.readTime = toTimestamp(serializer, targetData.snapshotVersion.toTimestamp());\n        const expectedCount = toInt32Proto(serializer, targetData.expectedCount);\n        if (expectedCount !== null) {\n            result.expectedCount = expectedCount;\n        }\n    }\n    return result;\n}\nfunction toFilters(filters) {\n    if (filters.length === 0) {\n        return;\n    }\n    return toFilter(CompositeFilter.create(filters, \"and\" /* CompositeOperator.AND */));\n}\nfunction fromFilters(filter) {\n    const result = fromFilter(filter);\n    if (result instanceof CompositeFilter &&\n        compositeFilterIsFlatConjunction(result)) {\n        return result.getFilters();\n    }\n    return [result];\n}\nfunction fromFilter(filter) {\n    if (filter.unaryFilter !== undefined) {\n        return fromUnaryFilter(filter);\n    }\n    else if (filter.fieldFilter !== undefined) {\n        return fromFieldFilter(filter);\n    }\n    else if (filter.compositeFilter !== undefined) {\n        return fromCompositeFilter(filter);\n    }\n    else {\n        return fail();\n    }\n}\nfunction toOrder(orderBys) {\n    if (orderBys.length === 0) {\n        return;\n    }\n    return orderBys.map(order => toPropertyOrder(order));\n}\nfunction fromOrder(orderBys) {\n    return orderBys.map(order => fromPropertyOrder(order));\n}\nfunction toStartAtCursor(cursor) {\n    return {\n        before: cursor.inclusive,\n        values: cursor.position\n    };\n}\nfunction toEndAtCursor(cursor) {\n    return {\n        before: !cursor.inclusive,\n        values: cursor.position\n    };\n}\nfunction fromStartAtCursor(cursor) {\n    const inclusive = !!cursor.before;\n    const position = cursor.values || [];\n    return new Bound(position, inclusive);\n}\nfunction fromEndAtCursor(cursor) {\n    const inclusive = !cursor.before;\n    const position = cursor.values || [];\n    return new Bound(position, inclusive);\n}\n// visible for testing\nfunction toDirection(dir) {\n    return DIRECTIONS[dir];\n}\n// visible for testing\nfunction fromDirection(dir) {\n    switch (dir) {\n        case 'ASCENDING':\n            return \"asc\" /* Direction.ASCENDING */;\n        case 'DESCENDING':\n            return \"desc\" /* Direction.DESCENDING */;\n        default:\n            return undefined;\n    }\n}\n// visible for testing\nfunction toOperatorName(op) {\n    return OPERATORS[op];\n}\nfunction toCompositeOperatorName(op) {\n    return COMPOSITE_OPERATORS[op];\n}\nfunction fromOperatorName(op) {\n    switch (op) {\n        case 'EQUAL':\n            return \"==\" /* Operator.EQUAL */;\n        case 'NOT_EQUAL':\n            return \"!=\" /* Operator.NOT_EQUAL */;\n        case 'GREATER_THAN':\n            return \">\" /* Operator.GREATER_THAN */;\n        case 'GREATER_THAN_OR_EQUAL':\n            return \">=\" /* Operator.GREATER_THAN_OR_EQUAL */;\n        case 'LESS_THAN':\n            return \"<\" /* Operator.LESS_THAN */;\n        case 'LESS_THAN_OR_EQUAL':\n            return \"<=\" /* Operator.LESS_THAN_OR_EQUAL */;\n        case 'ARRAY_CONTAINS':\n            return \"array-contains\" /* Operator.ARRAY_CONTAINS */;\n        case 'IN':\n            return \"in\" /* Operator.IN */;\n        case 'NOT_IN':\n            return \"not-in\" /* Operator.NOT_IN */;\n        case 'ARRAY_CONTAINS_ANY':\n            return \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */;\n        case 'OPERATOR_UNSPECIFIED':\n            return fail();\n        default:\n            return fail();\n    }\n}\nfunction fromCompositeOperatorName(op) {\n    switch (op) {\n        case 'AND':\n            return \"and\" /* CompositeOperator.AND */;\n        case 'OR':\n            return \"or\" /* CompositeOperator.OR */;\n        default:\n            return fail();\n    }\n}\nfunction toFieldPathReference(path) {\n    return { fieldPath: path.canonicalString() };\n}\nfunction fromFieldPathReference(fieldReference) {\n    return FieldPath$1.fromServerFormat(fieldReference.fieldPath);\n}\n// visible for testing\nfunction toPropertyOrder(orderBy) {\n    return {\n        field: toFieldPathReference(orderBy.field),\n        direction: toDirection(orderBy.dir)\n    };\n}\nfunction fromPropertyOrder(orderBy) {\n    return new OrderBy(fromFieldPathReference(orderBy.field), fromDirection(orderBy.direction));\n}\n// visible for testing\nfunction toFilter(filter) {\n    if (filter instanceof FieldFilter) {\n        return toUnaryOrFieldFilter(filter);\n    }\n    else if (filter instanceof CompositeFilter) {\n        return toCompositeFilter(filter);\n    }\n    else {\n        return fail();\n    }\n}\nfunction toCompositeFilter(filter) {\n    const protos = filter.getFilters().map(filter => toFilter(filter));\n    if (protos.length === 1) {\n        return protos[0];\n    }\n    return {\n        compositeFilter: {\n            op: toCompositeOperatorName(filter.op),\n            filters: protos\n        }\n    };\n}\nfunction toUnaryOrFieldFilter(filter) {\n    if (filter.op === \"==\" /* Operator.EQUAL */) {\n        if (isNanValue(filter.value)) {\n            return {\n                unaryFilter: {\n                    field: toFieldPathReference(filter.field),\n                    op: 'IS_NAN'\n                }\n            };\n        }\n        else if (isNullValue(filter.value)) {\n            return {\n                unaryFilter: {\n                    field: toFieldPathReference(filter.field),\n                    op: 'IS_NULL'\n                }\n            };\n        }\n    }\n    else if (filter.op === \"!=\" /* Operator.NOT_EQUAL */) {\n        if (isNanValue(filter.value)) {\n            return {\n                unaryFilter: {\n                    field: toFieldPathReference(filter.field),\n                    op: 'IS_NOT_NAN'\n                }\n            };\n        }\n        else if (isNullValue(filter.value)) {\n            return {\n                unaryFilter: {\n                    field: toFieldPathReference(filter.field),\n                    op: 'IS_NOT_NULL'\n                }\n            };\n        }\n    }\n    return {\n        fieldFilter: {\n            field: toFieldPathReference(filter.field),\n            op: toOperatorName(filter.op),\n            value: filter.value\n        }\n    };\n}\nfunction fromUnaryFilter(filter) {\n    switch (filter.unaryFilter.op) {\n        case 'IS_NAN':\n            const nanField = fromFieldPathReference(filter.unaryFilter.field);\n            return FieldFilter.create(nanField, \"==\" /* Operator.EQUAL */, {\n                doubleValue: NaN\n            });\n        case 'IS_NULL':\n            const nullField = fromFieldPathReference(filter.unaryFilter.field);\n            return FieldFilter.create(nullField, \"==\" /* Operator.EQUAL */, {\n                nullValue: 'NULL_VALUE'\n            });\n        case 'IS_NOT_NAN':\n            const notNanField = fromFieldPathReference(filter.unaryFilter.field);\n            return FieldFilter.create(notNanField, \"!=\" /* Operator.NOT_EQUAL */, {\n                doubleValue: NaN\n            });\n        case 'IS_NOT_NULL':\n            const notNullField = fromFieldPathReference(filter.unaryFilter.field);\n            return FieldFilter.create(notNullField, \"!=\" /* Operator.NOT_EQUAL */, {\n                nullValue: 'NULL_VALUE'\n            });\n        case 'OPERATOR_UNSPECIFIED':\n            return fail();\n        default:\n            return fail();\n    }\n}\nfunction fromFieldFilter(filter) {\n    return FieldFilter.create(fromFieldPathReference(filter.fieldFilter.field), fromOperatorName(filter.fieldFilter.op), filter.fieldFilter.value);\n}\nfunction fromCompositeFilter(filter) {\n    return CompositeFilter.create(filter.compositeFilter.filters.map(filter => fromFilter(filter)), fromCompositeOperatorName(filter.compositeFilter.op));\n}\nfunction toDocumentMask(fieldMask) {\n    const canonicalFields = [];\n    fieldMask.fields.forEach(field => canonicalFields.push(field.canonicalString()));\n    return {\n        fieldPaths: canonicalFields\n    };\n}\nfunction fromDocumentMask(proto) {\n    const paths = proto.fieldPaths || [];\n    return new FieldMask(paths.map(path => FieldPath$1.fromServerFormat(path)));\n}\nfunction isValidResourceName(path) {\n    // Resource names have at least 4 components (project ID, database ID)\n    return (path.length >= 4 &&\n        path.get(0) === 'projects' &&\n        path.get(2) === 'databases');\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An immutable set of metadata that the local store tracks for each target.\n */\nclass TargetData {\n    constructor(\n    /** The target being listened to. */\n    target, \n    /**\n     * The target ID to which the target corresponds; Assigned by the\n     * LocalStore for user listens and by the SyncEngine for limbo watches.\n     */\n    targetId, \n    /** The purpose of the target. */\n    purpose, \n    /**\n     * The sequence number of the last transaction during which this target data\n     * was modified.\n     */\n    sequenceNumber, \n    /** The latest snapshot version seen for this target. */\n    snapshotVersion = SnapshotVersion.min(), \n    /**\n     * The maximum snapshot version at which the associated view\n     * contained no limbo documents.\n     */\n    lastLimboFreeSnapshotVersion = SnapshotVersion.min(), \n    /**\n     * An opaque, server-assigned token that allows watching a target to be\n     * resumed after disconnecting without retransmitting all the data that\n     * matches the target. The resume token essentially identifies a point in\n     * time from which the server should resume sending results.\n     */\n    resumeToken = ByteString.EMPTY_BYTE_STRING, \n    /**\n     * The number of documents that last matched the query at the resume token or\n     * read time. Documents are counted only when making a listen request with\n     * resume token or read time, otherwise, keep it null.\n     */\n    expectedCount = null) {\n        this.target = target;\n        this.targetId = targetId;\n        this.purpose = purpose;\n        this.sequenceNumber = sequenceNumber;\n        this.snapshotVersion = snapshotVersion;\n        this.lastLimboFreeSnapshotVersion = lastLimboFreeSnapshotVersion;\n        this.resumeToken = resumeToken;\n        this.expectedCount = expectedCount;\n    }\n    /** Creates a new target data instance with an updated sequence number. */\n    withSequenceNumber(sequenceNumber) {\n        return new TargetData(this.target, this.targetId, this.purpose, sequenceNumber, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, this.expectedCount);\n    }\n    /**\n     * Creates a new target data instance with an updated resume token and\n     * snapshot version.\n     */\n    withResumeToken(resumeToken, snapshotVersion) {\n        return new TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, snapshotVersion, this.lastLimboFreeSnapshotVersion, resumeToken, \n        /* expectedCount= */ null);\n    }\n    /**\n     * Creates a new target data instance with an updated expected count.\n     */\n    withExpectedCount(expectedCount) {\n        return new TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, expectedCount);\n    }\n    /**\n     * Creates a new target data instance with an updated last limbo free\n     * snapshot version number.\n     */\n    withLastLimboFreeSnapshotVersion(lastLimboFreeSnapshotVersion) {\n        return new TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, lastLimboFreeSnapshotVersion, this.resumeToken, this.expectedCount);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Serializer for values stored in the LocalStore. */\nclass LocalSerializer {\n    constructor(remoteSerializer) {\n        this.remoteSerializer = remoteSerializer;\n    }\n}\n/** Decodes a remote document from storage locally to a Document. */\nfunction fromDbRemoteDocument(localSerializer, remoteDoc) {\n    let doc;\n    if (remoteDoc.document) {\n        doc = fromDocument(localSerializer.remoteSerializer, remoteDoc.document, !!remoteDoc.hasCommittedMutations);\n    }\n    else if (remoteDoc.noDocument) {\n        const key = DocumentKey.fromSegments(remoteDoc.noDocument.path);\n        const version = fromDbTimestamp(remoteDoc.noDocument.readTime);\n        doc = MutableDocument.newNoDocument(key, version);\n        if (remoteDoc.hasCommittedMutations) {\n            doc.setHasCommittedMutations();\n        }\n    }\n    else if (remoteDoc.unknownDocument) {\n        const key = DocumentKey.fromSegments(remoteDoc.unknownDocument.path);\n        const version = fromDbTimestamp(remoteDoc.unknownDocument.version);\n        doc = MutableDocument.newUnknownDocument(key, version);\n    }\n    else {\n        return fail();\n    }\n    if (remoteDoc.readTime) {\n        doc.setReadTime(fromDbTimestampKey(remoteDoc.readTime));\n    }\n    return doc;\n}\n/** Encodes a document for storage locally. */\nfunction toDbRemoteDocument(localSerializer, document) {\n    const key = document.key;\n    const remoteDoc = {\n        prefixPath: key.getCollectionPath().popLast().toArray(),\n        collectionGroup: key.collectionGroup,\n        documentId: key.path.lastSegment(),\n        readTime: toDbTimestampKey(document.readTime),\n        hasCommittedMutations: document.hasCommittedMutations\n    };\n    if (document.isFoundDocument()) {\n        remoteDoc.document = toDocument(localSerializer.remoteSerializer, document);\n    }\n    else if (document.isNoDocument()) {\n        remoteDoc.noDocument = {\n            path: key.path.toArray(),\n            readTime: toDbTimestamp(document.version)\n        };\n    }\n    else if (document.isUnknownDocument()) {\n        remoteDoc.unknownDocument = {\n            path: key.path.toArray(),\n            version: toDbTimestamp(document.version)\n        };\n    }\n    else {\n        return fail();\n    }\n    return remoteDoc;\n}\nfunction toDbTimestampKey(snapshotVersion) {\n    const timestamp = snapshotVersion.toTimestamp();\n    return [timestamp.seconds, timestamp.nanoseconds];\n}\nfunction fromDbTimestampKey(dbTimestampKey) {\n    const timestamp = new Timestamp(dbTimestampKey[0], dbTimestampKey[1]);\n    return SnapshotVersion.fromTimestamp(timestamp);\n}\nfunction toDbTimestamp(snapshotVersion) {\n    const timestamp = snapshotVersion.toTimestamp();\n    return { seconds: timestamp.seconds, nanoseconds: timestamp.nanoseconds };\n}\nfunction fromDbTimestamp(dbTimestamp) {\n    const timestamp = new Timestamp(dbTimestamp.seconds, dbTimestamp.nanoseconds);\n    return SnapshotVersion.fromTimestamp(timestamp);\n}\n/** Encodes a batch of mutations into a DbMutationBatch for local storage. */\nfunction toDbMutationBatch(localSerializer, userId, batch) {\n    const serializedBaseMutations = batch.baseMutations.map(m => toMutation(localSerializer.remoteSerializer, m));\n    const serializedMutations = batch.mutations.map(m => toMutation(localSerializer.remoteSerializer, m));\n    return {\n        userId,\n        batchId: batch.batchId,\n        localWriteTimeMs: batch.localWriteTime.toMillis(),\n        baseMutations: serializedBaseMutations,\n        mutations: serializedMutations\n    };\n}\n/** Decodes a DbMutationBatch into a MutationBatch */\nfunction fromDbMutationBatch(localSerializer, dbBatch) {\n    const baseMutations = (dbBatch.baseMutations || []).map(m => fromMutation(localSerializer.remoteSerializer, m));\n    // Squash old transform mutations into existing patch or set mutations.\n    // The replacement of representing `transforms` with `update_transforms`\n    // on the SDK means that old `transform` mutations stored in IndexedDB need\n    // to be updated to `update_transforms`.\n    // TODO(b/174608374): Remove this code once we perform a schema migration.\n    for (let i = 0; i < dbBatch.mutations.length - 1; ++i) {\n        const currentMutation = dbBatch.mutations[i];\n        const hasTransform = i + 1 < dbBatch.mutations.length &&\n            dbBatch.mutations[i + 1].transform !== undefined;\n        if (hasTransform) {\n            const transformMutation = dbBatch.mutations[i + 1];\n            currentMutation.updateTransforms =\n                transformMutation.transform.fieldTransforms;\n            dbBatch.mutations.splice(i + 1, 1);\n            ++i;\n        }\n    }\n    const mutations = dbBatch.mutations.map(m => fromMutation(localSerializer.remoteSerializer, m));\n    const timestamp = Timestamp.fromMillis(dbBatch.localWriteTimeMs);\n    return new MutationBatch(dbBatch.batchId, timestamp, baseMutations, mutations);\n}\n/** Decodes a DbTarget into TargetData */\nfunction fromDbTarget(dbTarget) {\n    const version = fromDbTimestamp(dbTarget.readTime);\n    const lastLimboFreeSnapshotVersion = dbTarget.lastLimboFreeSnapshotVersion !== undefined\n        ? fromDbTimestamp(dbTarget.lastLimboFreeSnapshotVersion)\n        : SnapshotVersion.min();\n    let target;\n    if (isDocumentQuery(dbTarget.query)) {\n        target = fromDocumentsTarget(dbTarget.query);\n    }\n    else {\n        target = fromQueryTarget(dbTarget.query);\n    }\n    return new TargetData(target, dbTarget.targetId, \"TargetPurposeListen\" /* TargetPurpose.Listen */, dbTarget.lastListenSequenceNumber, version, lastLimboFreeSnapshotVersion, ByteString.fromBase64String(dbTarget.resumeToken));\n}\n/** Encodes TargetData into a DbTarget for storage locally. */\nfunction toDbTarget(localSerializer, targetData) {\n    const dbTimestamp = toDbTimestamp(targetData.snapshotVersion);\n    const dbLastLimboFreeTimestamp = toDbTimestamp(targetData.lastLimboFreeSnapshotVersion);\n    let queryProto;\n    if (targetIsDocumentTarget(targetData.target)) {\n        queryProto = toDocumentsTarget(localSerializer.remoteSerializer, targetData.target);\n    }\n    else {\n        queryProto = toQueryTarget(localSerializer.remoteSerializer, targetData.target).queryTarget;\n    }\n    // We can't store the resumeToken as a ByteString in IndexedDb, so we\n    // convert it to a base64 string for storage.\n    const resumeToken = targetData.resumeToken.toBase64();\n    // lastListenSequenceNumber is always 0 until we do real GC.\n    return {\n        targetId: targetData.targetId,\n        canonicalId: canonifyTarget(targetData.target),\n        readTime: dbTimestamp,\n        resumeToken,\n        lastListenSequenceNumber: targetData.sequenceNumber,\n        lastLimboFreeSnapshotVersion: dbLastLimboFreeTimestamp,\n        query: queryProto\n    };\n}\n/**\n * A helper function for figuring out what kind of query has been stored.\n */\nfunction isDocumentQuery(dbQuery) {\n    return dbQuery.documents !== undefined;\n}\n/** Encodes a DbBundle to a BundleMetadata object. */\nfunction fromDbBundle(dbBundle) {\n    return {\n        id: dbBundle.bundleId,\n        createTime: fromDbTimestamp(dbBundle.createTime),\n        version: dbBundle.version\n    };\n}\n/** Encodes a BundleMetadata to a DbBundle. */\nfunction toDbBundle(metadata) {\n    return {\n        bundleId: metadata.id,\n        createTime: toDbTimestamp(fromVersion(metadata.createTime)),\n        version: metadata.version\n    };\n}\n/** Encodes a DbNamedQuery to a NamedQuery. */\nfunction fromDbNamedQuery(dbNamedQuery) {\n    return {\n        name: dbNamedQuery.name,\n        query: fromBundledQuery(dbNamedQuery.bundledQuery),\n        readTime: fromDbTimestamp(dbNamedQuery.readTime)\n    };\n}\n/** Encodes a NamedQuery from a bundle proto to a DbNamedQuery. */\nfunction toDbNamedQuery(query) {\n    return {\n        name: query.name,\n        readTime: toDbTimestamp(fromVersion(query.readTime)),\n        bundledQuery: query.bundledQuery\n    };\n}\n/**\n * Encodes a `BundledQuery` from bundle proto to a Query object.\n *\n * This reconstructs the original query used to build the bundle being loaded,\n * including features exists only in SDKs (for example: limit-to-last).\n */\nfunction fromBundledQuery(bundledQuery) {\n    const query = convertQueryTargetToQuery({\n        parent: bundledQuery.parent,\n        structuredQuery: bundledQuery.structuredQuery\n    });\n    if (bundledQuery.limitType === 'LAST') {\n        return queryWithLimit(query, query.limit, \"L\" /* LimitType.Last */);\n    }\n    return query;\n}\n/** Encodes a NamedQuery proto object to a NamedQuery model object. */\nfunction fromProtoNamedQuery(namedQuery) {\n    return {\n        name: namedQuery.name,\n        query: fromBundledQuery(namedQuery.bundledQuery),\n        readTime: fromVersion(namedQuery.readTime)\n    };\n}\n/** Decodes a BundleMetadata proto into a BundleMetadata object. */\nfunction fromBundleMetadata(metadata) {\n    return {\n        id: metadata.id,\n        version: metadata.version,\n        createTime: fromVersion(metadata.createTime)\n    };\n}\n/** Encodes a DbDocumentOverlay object to an Overlay model object. */\nfunction fromDbDocumentOverlay(localSerializer, dbDocumentOverlay) {\n    return new Overlay(dbDocumentOverlay.largestBatchId, fromMutation(localSerializer.remoteSerializer, dbDocumentOverlay.overlayMutation));\n}\n/** Decodes an Overlay model object into a DbDocumentOverlay object. */\nfunction toDbDocumentOverlay(localSerializer, userId, overlay) {\n    const [_, collectionPath, documentId] = toDbDocumentOverlayKey(userId, overlay.mutation.key);\n    return {\n        userId,\n        collectionPath,\n        documentId,\n        collectionGroup: overlay.mutation.key.getCollectionGroup(),\n        largestBatchId: overlay.largestBatchId,\n        overlayMutation: toMutation(localSerializer.remoteSerializer, overlay.mutation)\n    };\n}\n/**\n * Returns the DbDocumentOverlayKey corresponding to the given user and\n * document key.\n */\nfunction toDbDocumentOverlayKey(userId, docKey) {\n    const docId = docKey.path.lastSegment();\n    const collectionPath = encodeResourcePath(docKey.path.popLast());\n    return [userId, collectionPath, docId];\n}\nfunction toDbIndexConfiguration(index) {\n    return {\n        indexId: index.indexId,\n        collectionGroup: index.collectionGroup,\n        fields: index.fields.map(s => [s.fieldPath.canonicalString(), s.kind])\n    };\n}\nfunction fromDbIndexConfiguration(index, state) {\n    const decodedState = state\n        ? new IndexState(state.sequenceNumber, new IndexOffset(fromDbTimestamp(state.readTime), new DocumentKey(decodeResourcePath(state.documentKey)), state.largestBatchId))\n        : IndexState.empty();\n    const decodedSegments = index.fields.map(([fieldPath, kind]) => new IndexSegment(FieldPath$1.fromServerFormat(fieldPath), kind));\n    return new FieldIndex(index.indexId, index.collectionGroup, decodedSegments, decodedState);\n}\nfunction toDbIndexState(indexId, uid, sequenceNumber, offset) {\n    return {\n        indexId,\n        uid,\n        sequenceNumber,\n        readTime: toDbTimestamp(offset.readTime),\n        documentKey: encodeResourcePath(offset.documentKey.path),\n        largestBatchId: offset.largestBatchId\n    };\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass IndexedDbBundleCache {\n    getBundleMetadata(transaction, bundleId) {\n        return bundlesStore(transaction)\n            .get(bundleId)\n            .next(bundle => {\n            if (bundle) {\n                return fromDbBundle(bundle);\n            }\n            return undefined;\n        });\n    }\n    saveBundleMetadata(transaction, bundleMetadata) {\n        return bundlesStore(transaction).put(toDbBundle(bundleMetadata));\n    }\n    getNamedQuery(transaction, queryName) {\n        return namedQueriesStore(transaction)\n            .get(queryName)\n            .next(query => {\n            if (query) {\n                return fromDbNamedQuery(query);\n            }\n            return undefined;\n        });\n    }\n    saveNamedQuery(transaction, query) {\n        return namedQueriesStore(transaction).put(toDbNamedQuery(query));\n    }\n}\n/**\n * Helper to get a typed SimpleDbStore for the bundles object store.\n */\nfunction bundlesStore(txn) {\n    return getStore(txn, DbBundleStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the namedQueries object store.\n */\nfunction namedQueriesStore(txn) {\n    return getStore(txn, DbNamedQueryStore);\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Implementation of DocumentOverlayCache using IndexedDb.\n */\nclass IndexedDbDocumentOverlayCache {\n    /**\n     * @param serializer - The document serializer.\n     * @param userId - The userId for which we are accessing overlays.\n     */\n    constructor(serializer, userId) {\n        this.serializer = serializer;\n        this.userId = userId;\n    }\n    static forUser(serializer, user) {\n        const userId = user.uid || '';\n        return new IndexedDbDocumentOverlayCache(serializer, userId);\n    }\n    getOverlay(transaction, key) {\n        return documentOverlayStore(transaction)\n            .get(toDbDocumentOverlayKey(this.userId, key))\n            .next(dbOverlay => {\n            if (dbOverlay) {\n                return fromDbDocumentOverlay(this.serializer, dbOverlay);\n            }\n            return null;\n        });\n    }\n    getOverlays(transaction, keys) {\n        const result = newOverlayMap();\n        return PersistencePromise.forEach(keys, (key) => {\n            return this.getOverlay(transaction, key).next(overlay => {\n                if (overlay !== null) {\n                    result.set(key, overlay);\n                }\n            });\n        }).next(() => result);\n    }\n    saveOverlays(transaction, largestBatchId, overlays) {\n        const promises = [];\n        overlays.forEach((_, mutation) => {\n            const overlay = new Overlay(largestBatchId, mutation);\n            promises.push(this.saveOverlay(transaction, overlay));\n        });\n        return PersistencePromise.waitFor(promises);\n    }\n    removeOverlaysForBatchId(transaction, documentKeys, batchId) {\n        const collectionPaths = new Set();\n        // Get the set of unique collection paths.\n        documentKeys.forEach(key => collectionPaths.add(encodeResourcePath(key.getCollectionPath())));\n        const promises = [];\n        collectionPaths.forEach(collectionPath => {\n            const range = IDBKeyRange.bound([this.userId, collectionPath, batchId], [this.userId, collectionPath, batchId + 1], \n            /*lowerOpen=*/ false, \n            /*upperOpen=*/ true);\n            promises.push(documentOverlayStore(transaction).deleteAll(DbDocumentOverlayCollectionPathOverlayIndex, range));\n        });\n        return PersistencePromise.waitFor(promises);\n    }\n    getOverlaysForCollection(transaction, collection, sinceBatchId) {\n        const result = newOverlayMap();\n        const collectionPath = encodeResourcePath(collection);\n        // We want batch IDs larger than `sinceBatchId`, and so the lower bound\n        // is not inclusive.\n        const range = IDBKeyRange.bound([this.userId, collectionPath, sinceBatchId], [this.userId, collectionPath, Number.POSITIVE_INFINITY], \n        /*lowerOpen=*/ true);\n        return documentOverlayStore(transaction)\n            .loadAll(DbDocumentOverlayCollectionPathOverlayIndex, range)\n            .next(dbOverlays => {\n            for (const dbOverlay of dbOverlays) {\n                const overlay = fromDbDocumentOverlay(this.serializer, dbOverlay);\n                result.set(overlay.getKey(), overlay);\n            }\n            return result;\n        });\n    }\n    getOverlaysForCollectionGroup(transaction, collectionGroup, sinceBatchId, count) {\n        const result = newOverlayMap();\n        let currentBatchId = undefined;\n        // We want batch IDs larger than `sinceBatchId`, and so the lower bound\n        // is not inclusive.\n        const range = IDBKeyRange.bound([this.userId, collectionGroup, sinceBatchId], [this.userId, collectionGroup, Number.POSITIVE_INFINITY], \n        /*lowerOpen=*/ true);\n        return documentOverlayStore(transaction)\n            .iterate({\n            index: DbDocumentOverlayCollectionGroupOverlayIndex,\n            range\n        }, (_, dbOverlay, control) => {\n            // We do not want to return partial batch overlays, even if the size\n            // of the result set exceeds the given `count` argument. Therefore, we\n            // continue to aggregate results even after the result size exceeds\n            // `count` if there are more overlays from the `currentBatchId`.\n            const overlay = fromDbDocumentOverlay(this.serializer, dbOverlay);\n            if (result.size() < count ||\n                overlay.largestBatchId === currentBatchId) {\n                result.set(overlay.getKey(), overlay);\n                currentBatchId = overlay.largestBatchId;\n            }\n            else {\n                control.done();\n            }\n        })\n            .next(() => result);\n    }\n    saveOverlay(transaction, overlay) {\n        return documentOverlayStore(transaction).put(toDbDocumentOverlay(this.serializer, this.userId, overlay));\n    }\n}\n/**\n * Helper to get a typed SimpleDbStore for the document overlay object store.\n */\nfunction documentOverlayStore(txn) {\n    return getStore(txn, DbDocumentOverlayStore);\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass IndexedDbGlobalsCache {\n    globalsStore(txn) {\n        return getStore(txn, DbGlobalsStore);\n    }\n    getSessionToken(txn) {\n        const globals = this.globalsStore(txn);\n        return globals.get('sessionToken').next(global => {\n            const value = global === null || global === void 0 ? void 0 : global.value;\n            return value\n                ? ByteString.fromUint8Array(value)\n                : ByteString.EMPTY_BYTE_STRING;\n        });\n    }\n    setSessionToken(txn, sessionToken) {\n        const globals = this.globalsStore(txn);\n        return globals.put({\n            name: 'sessionToken',\n            value: sessionToken.toUint8Array()\n        });\n    }\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Note: This code is copied from the backend. Code that is not used by\n// Firestore was removed.\nconst INDEX_TYPE_NULL = 5;\nconst INDEX_TYPE_BOOLEAN = 10;\nconst INDEX_TYPE_NAN = 13;\nconst INDEX_TYPE_NUMBER = 15;\nconst INDEX_TYPE_TIMESTAMP = 20;\nconst INDEX_TYPE_STRING = 25;\nconst INDEX_TYPE_BLOB = 30;\nconst INDEX_TYPE_REFERENCE = 37;\nconst INDEX_TYPE_GEOPOINT = 45;\nconst INDEX_TYPE_ARRAY = 50;\nconst INDEX_TYPE_VECTOR = 53;\nconst INDEX_TYPE_MAP = 55;\nconst INDEX_TYPE_REFERENCE_SEGMENT = 60;\n// A terminator that indicates that a truncatable value was not truncated.\n// This must be smaller than all other type labels.\nconst NOT_TRUNCATED = 2;\n/** Firestore index value writer.  */\nclass FirestoreIndexValueWriter {\n    constructor() { }\n    // The write methods below short-circuit writing terminators for values\n    // containing a (terminating) truncated value.\n    //\n    // As an example, consider the resulting encoding for:\n    //\n    // [\"bar\", [2, \"foo\"]] -> (STRING, \"bar\", TERM, ARRAY, NUMBER, 2, STRING, \"foo\", TERM, TERM, TERM)\n    // [\"bar\", [2, truncated(\"foo\")]] -> (STRING, \"bar\", TERM, ARRAY, NUMBER, 2, STRING, \"foo\", TRUNC)\n    // [\"bar\", truncated([\"foo\"])] -> (STRING, \"bar\", TERM, ARRAY. STRING, \"foo\", TERM, TRUNC)\n    /** Writes an index value.  */\n    writeIndexValue(value, encoder) {\n        this.writeIndexValueAux(value, encoder);\n        // Write separator to split index values\n        // (see go/firestore-storage-format#encodings).\n        encoder.writeInfinity();\n    }\n    writeIndexValueAux(indexValue, encoder) {\n        if ('nullValue' in indexValue) {\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_NULL);\n        }\n        else if ('booleanValue' in indexValue) {\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_BOOLEAN);\n            encoder.writeNumber(indexValue.booleanValue ? 1 : 0);\n        }\n        else if ('integerValue' in indexValue) {\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_NUMBER);\n            encoder.writeNumber(normalizeNumber(indexValue.integerValue));\n        }\n        else if ('doubleValue' in indexValue) {\n            const n = normalizeNumber(indexValue.doubleValue);\n            if (isNaN(n)) {\n                this.writeValueTypeLabel(encoder, INDEX_TYPE_NAN);\n            }\n            else {\n                this.writeValueTypeLabel(encoder, INDEX_TYPE_NUMBER);\n                if (isNegativeZero(n)) {\n                    // -0.0, 0 and 0.0 are all considered the same\n                    encoder.writeNumber(0.0);\n                }\n                else {\n                    encoder.writeNumber(n);\n                }\n            }\n        }\n        else if ('timestampValue' in indexValue) {\n            let timestamp = indexValue.timestampValue;\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_TIMESTAMP);\n            if (typeof timestamp === 'string') {\n                timestamp = normalizeTimestamp(timestamp);\n            }\n            encoder.writeString(`${timestamp.seconds || ''}`);\n            encoder.writeNumber(timestamp.nanos || 0);\n        }\n        else if ('stringValue' in indexValue) {\n            this.writeIndexString(indexValue.stringValue, encoder);\n            this.writeTruncationMarker(encoder);\n        }\n        else if ('bytesValue' in indexValue) {\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_BLOB);\n            encoder.writeBytes(normalizeByteString(indexValue.bytesValue));\n            this.writeTruncationMarker(encoder);\n        }\n        else if ('referenceValue' in indexValue) {\n            this.writeIndexEntityRef(indexValue.referenceValue, encoder);\n        }\n        else if ('geoPointValue' in indexValue) {\n            const geoPoint = indexValue.geoPointValue;\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_GEOPOINT);\n            encoder.writeNumber(geoPoint.latitude || 0);\n            encoder.writeNumber(geoPoint.longitude || 0);\n        }\n        else if ('mapValue' in indexValue) {\n            if (isMaxValue(indexValue)) {\n                this.writeValueTypeLabel(encoder, Number.MAX_SAFE_INTEGER);\n            }\n            else if (isVectorValue(indexValue)) {\n                this.writeIndexVector(indexValue.mapValue, encoder);\n            }\n            else {\n                this.writeIndexMap(indexValue.mapValue, encoder);\n                this.writeTruncationMarker(encoder);\n            }\n        }\n        else if ('arrayValue' in indexValue) {\n            this.writeIndexArray(indexValue.arrayValue, encoder);\n            this.writeTruncationMarker(encoder);\n        }\n        else {\n            fail();\n        }\n    }\n    writeIndexString(stringIndexValue, encoder) {\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_STRING);\n        this.writeUnlabeledIndexString(stringIndexValue, encoder);\n    }\n    writeUnlabeledIndexString(stringIndexValue, encoder) {\n        encoder.writeString(stringIndexValue);\n    }\n    writeIndexMap(mapIndexValue, encoder) {\n        const map = mapIndexValue.fields || {};\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_MAP);\n        for (const key of Object.keys(map)) {\n            this.writeIndexString(key, encoder);\n            this.writeIndexValueAux(map[key], encoder);\n        }\n    }\n    writeIndexVector(mapIndexValue, encoder) {\n        var _a, _b;\n        const map = mapIndexValue.fields || {};\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_VECTOR);\n        // Vectors sort first by length\n        const key = VECTOR_MAP_VECTORS_KEY;\n        const length = ((_b = (_a = map[key].arrayValue) === null || _a === void 0 ? void 0 : _a.values) === null || _b === void 0 ? void 0 : _b.length) || 0;\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_NUMBER);\n        encoder.writeNumber(normalizeNumber(length));\n        // Vectors then sort by position value\n        this.writeIndexString(key, encoder);\n        this.writeIndexValueAux(map[key], encoder);\n    }\n    writeIndexArray(arrayIndexValue, encoder) {\n        const values = arrayIndexValue.values || [];\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_ARRAY);\n        for (const element of values) {\n            this.writeIndexValueAux(element, encoder);\n        }\n    }\n    writeIndexEntityRef(referenceValue, encoder) {\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_REFERENCE);\n        const path = DocumentKey.fromName(referenceValue).path;\n        path.forEach(segment => {\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_REFERENCE_SEGMENT);\n            this.writeUnlabeledIndexString(segment, encoder);\n        });\n    }\n    writeValueTypeLabel(encoder, typeOrder) {\n        encoder.writeNumber(typeOrder);\n    }\n    writeTruncationMarker(encoder) {\n        // While the SDK does not implement truncation, the truncation marker is\n        // used to terminate all variable length values (which are strings, bytes,\n        // references, arrays and maps).\n        encoder.writeNumber(NOT_TRUNCATED);\n    }\n}\nFirestoreIndexValueWriter.INSTANCE = new FirestoreIndexValueWriter();\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law | agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES | CONDITIONS OF ANY KIND, either express | implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** These constants are taken from the backend. */\nconst MIN_SURROGATE = '\\uD800';\nconst MAX_SURROGATE = '\\uDBFF';\nconst ESCAPE1 = 0x00;\nconst NULL_BYTE = 0xff; // Combined with ESCAPE1\nconst SEPARATOR = 0x01; // Combined with ESCAPE1\nconst ESCAPE2 = 0xff;\nconst INFINITY = 0xff; // Combined with ESCAPE2\nconst FF_BYTE = 0x00; // Combined with ESCAPE2\nconst LONG_SIZE = 64;\nconst BYTE_SIZE = 8;\n/**\n * The default size of the buffer. This is arbitrary, but likely larger than\n * most index values so that less copies of the underlying buffer will be made.\n * For large values, a single copy will made to double the buffer length.\n */\nconst DEFAULT_BUFFER_SIZE = 1024;\n/** Converts a JavaScript number to a byte array (using big endian encoding). */\nfunction doubleToLongBits(value) {\n    const dv = new DataView(new ArrayBuffer(8));\n    dv.setFloat64(0, value, /* littleEndian= */ false);\n    return new Uint8Array(dv.buffer);\n}\n/**\n * Counts the number of zeros in a byte.\n *\n * Visible for testing.\n */\nfunction numberOfLeadingZerosInByte(x) {\n    if (x === 0) {\n        return 8;\n    }\n    let zeros = 0;\n    if (x >> 4 === 0) {\n        // Test if the first four bits are zero.\n        zeros += 4;\n        x = x << 4;\n    }\n    if (x >> 6 === 0) {\n        // Test if the first two (or next two) bits are zero.\n        zeros += 2;\n        x = x << 2;\n    }\n    if (x >> 7 === 0) {\n        // Test if the remaining bit is zero.\n        zeros += 1;\n    }\n    return zeros;\n}\n/** Counts the number of leading zeros in the given byte array. */\nfunction numberOfLeadingZeros(bytes) {\n    let leadingZeros = 0;\n    for (let i = 0; i < 8; ++i) {\n        const zeros = numberOfLeadingZerosInByte(bytes[i] & 0xff);\n        leadingZeros += zeros;\n        if (zeros !== 8) {\n            break;\n        }\n    }\n    return leadingZeros;\n}\n/**\n * Returns the number of bytes required to store \"value\". Leading zero bytes\n * are skipped.\n */\nfunction unsignedNumLength(value) {\n    // This is just the number of bytes for the unsigned representation of the number.\n    const numBits = LONG_SIZE - numberOfLeadingZeros(value);\n    return Math.ceil(numBits / BYTE_SIZE);\n}\n/**\n * OrderedCodeWriter is a minimal-allocation implementation of the writing\n * behavior defined by the backend.\n *\n * The code is ported from its Java counterpart.\n */\nclass OrderedCodeWriter {\n    constructor() {\n        this.buffer = new Uint8Array(DEFAULT_BUFFER_SIZE);\n        this.position = 0;\n    }\n    writeBytesAscending(value) {\n        const it = value[Symbol.iterator]();\n        let byte = it.next();\n        while (!byte.done) {\n            this.writeByteAscending(byte.value);\n            byte = it.next();\n        }\n        this.writeSeparatorAscending();\n    }\n    writeBytesDescending(value) {\n        const it = value[Symbol.iterator]();\n        let byte = it.next();\n        while (!byte.done) {\n            this.writeByteDescending(byte.value);\n            byte = it.next();\n        }\n        this.writeSeparatorDescending();\n    }\n    /** Writes utf8 bytes into this byte sequence, ascending. */\n    writeUtf8Ascending(sequence) {\n        for (const c of sequence) {\n            const charCode = c.charCodeAt(0);\n            if (charCode < 0x80) {\n                this.writeByteAscending(charCode);\n            }\n            else if (charCode < 0x800) {\n                this.writeByteAscending((0x0f << 6) | (charCode >>> 6));\n                this.writeByteAscending(0x80 | (0x3f & charCode));\n            }\n            else if (c < MIN_SURROGATE || MAX_SURROGATE < c) {\n                this.writeByteAscending((0x0f << 5) | (charCode >>> 12));\n                this.writeByteAscending(0x80 | (0x3f & (charCode >>> 6)));\n                this.writeByteAscending(0x80 | (0x3f & charCode));\n            }\n            else {\n                const codePoint = c.codePointAt(0);\n                this.writeByteAscending((0x0f << 4) | (codePoint >>> 18));\n                this.writeByteAscending(0x80 | (0x3f & (codePoint >>> 12)));\n                this.writeByteAscending(0x80 | (0x3f & (codePoint >>> 6)));\n                this.writeByteAscending(0x80 | (0x3f & codePoint));\n            }\n        }\n        this.writeSeparatorAscending();\n    }\n    /** Writes utf8 bytes into this byte sequence, descending */\n    writeUtf8Descending(sequence) {\n        for (const c of sequence) {\n            const charCode = c.charCodeAt(0);\n            if (charCode < 0x80) {\n                this.writeByteDescending(charCode);\n            }\n            else if (charCode < 0x800) {\n                this.writeByteDescending((0x0f << 6) | (charCode >>> 6));\n                this.writeByteDescending(0x80 | (0x3f & charCode));\n            }\n            else if (c < MIN_SURROGATE || MAX_SURROGATE < c) {\n                this.writeByteDescending((0x0f << 5) | (charCode >>> 12));\n                this.writeByteDescending(0x80 | (0x3f & (charCode >>> 6)));\n                this.writeByteDescending(0x80 | (0x3f & charCode));\n            }\n            else {\n                const codePoint = c.codePointAt(0);\n                this.writeByteDescending((0x0f << 4) | (codePoint >>> 18));\n                this.writeByteDescending(0x80 | (0x3f & (codePoint >>> 12)));\n                this.writeByteDescending(0x80 | (0x3f & (codePoint >>> 6)));\n                this.writeByteDescending(0x80 | (0x3f & codePoint));\n            }\n        }\n        this.writeSeparatorDescending();\n    }\n    writeNumberAscending(val) {\n        // Values are encoded with a single byte length prefix, followed by the\n        // actual value in big-endian format with leading 0 bytes dropped.\n        const value = this.toOrderedBits(val);\n        const len = unsignedNumLength(value);\n        this.ensureAvailable(1 + len);\n        this.buffer[this.position++] = len & 0xff; // Write the length\n        for (let i = value.length - len; i < value.length; ++i) {\n            this.buffer[this.position++] = value[i] & 0xff;\n        }\n    }\n    writeNumberDescending(val) {\n        // Values are encoded with a single byte length prefix, followed by the\n        // inverted value in big-endian format with leading 0 bytes dropped.\n        const value = this.toOrderedBits(val);\n        const len = unsignedNumLength(value);\n        this.ensureAvailable(1 + len);\n        this.buffer[this.position++] = ~(len & 0xff); // Write the length\n        for (let i = value.length - len; i < value.length; ++i) {\n            this.buffer[this.position++] = ~(value[i] & 0xff);\n        }\n    }\n    /**\n     * Writes the \"infinity\" byte sequence that sorts after all other byte\n     * sequences written in ascending order.\n     */\n    writeInfinityAscending() {\n        this.writeEscapedByteAscending(ESCAPE2);\n        this.writeEscapedByteAscending(INFINITY);\n    }\n    /**\n     * Writes the \"infinity\" byte sequence that sorts before all other byte\n     * sequences written in descending order.\n     */\n    writeInfinityDescending() {\n        this.writeEscapedByteDescending(ESCAPE2);\n        this.writeEscapedByteDescending(INFINITY);\n    }\n    /**\n     * Resets the buffer such that it is the same as when it was newly\n     * constructed.\n     */\n    reset() {\n        this.position = 0;\n    }\n    seed(encodedBytes) {\n        this.ensureAvailable(encodedBytes.length);\n        this.buffer.set(encodedBytes, this.position);\n        this.position += encodedBytes.length;\n    }\n    /** Makes a copy of the encoded bytes in this buffer.  */\n    encodedBytes() {\n        return this.buffer.slice(0, this.position);\n    }\n    /**\n     * Encodes `val` into an encoding so that the order matches the IEEE 754\n     * floating-point comparison results with the following exceptions:\n     *   -0.0 < 0.0\n     *   all non-NaN < NaN\n     *   NaN = NaN\n     */\n    toOrderedBits(val) {\n        const value = doubleToLongBits(val);\n        // Check if the first bit is set. We use a bit mask since value[0] is\n        // encoded as a number from 0 to 255.\n        const isNegative = (value[0] & 0x80) !== 0;\n        // Revert the two complement to get natural ordering\n        value[0] ^= isNegative ? 0xff : 0x80;\n        for (let i = 1; i < value.length; ++i) {\n            value[i] ^= isNegative ? 0xff : 0x00;\n        }\n        return value;\n    }\n    /** Writes a single byte ascending to the buffer. */\n    writeByteAscending(b) {\n        const masked = b & 0xff;\n        if (masked === ESCAPE1) {\n            this.writeEscapedByteAscending(ESCAPE1);\n            this.writeEscapedByteAscending(NULL_BYTE);\n        }\n        else if (masked === ESCAPE2) {\n            this.writeEscapedByteAscending(ESCAPE2);\n            this.writeEscapedByteAscending(FF_BYTE);\n        }\n        else {\n            this.writeEscapedByteAscending(masked);\n        }\n    }\n    /** Writes a single byte descending to the buffer.  */\n    writeByteDescending(b) {\n        const masked = b & 0xff;\n        if (masked === ESCAPE1) {\n            this.writeEscapedByteDescending(ESCAPE1);\n            this.writeEscapedByteDescending(NULL_BYTE);\n        }\n        else if (masked === ESCAPE2) {\n            this.writeEscapedByteDescending(ESCAPE2);\n            this.writeEscapedByteDescending(FF_BYTE);\n        }\n        else {\n            this.writeEscapedByteDescending(b);\n        }\n    }\n    writeSeparatorAscending() {\n        this.writeEscapedByteAscending(ESCAPE1);\n        this.writeEscapedByteAscending(SEPARATOR);\n    }\n    writeSeparatorDescending() {\n        this.writeEscapedByteDescending(ESCAPE1);\n        this.writeEscapedByteDescending(SEPARATOR);\n    }\n    writeEscapedByteAscending(b) {\n        this.ensureAvailable(1);\n        this.buffer[this.position++] = b;\n    }\n    writeEscapedByteDescending(b) {\n        this.ensureAvailable(1);\n        this.buffer[this.position++] = ~b;\n    }\n    ensureAvailable(bytes) {\n        const minCapacity = bytes + this.position;\n        if (minCapacity <= this.buffer.length) {\n            return;\n        }\n        // Try doubling.\n        let newLength = this.buffer.length * 2;\n        // Still not big enough? Just allocate the right size.\n        if (newLength < minCapacity) {\n            newLength = minCapacity;\n        }\n        // Create the new buffer.\n        const newBuffer = new Uint8Array(newLength);\n        newBuffer.set(this.buffer); // copy old data\n        this.buffer = newBuffer;\n    }\n}\n\nclass AscendingIndexByteEncoder {\n    constructor(orderedCode) {\n        this.orderedCode = orderedCode;\n    }\n    writeBytes(value) {\n        this.orderedCode.writeBytesAscending(value);\n    }\n    writeString(value) {\n        this.orderedCode.writeUtf8Ascending(value);\n    }\n    writeNumber(value) {\n        this.orderedCode.writeNumberAscending(value);\n    }\n    writeInfinity() {\n        this.orderedCode.writeInfinityAscending();\n    }\n}\nclass DescendingIndexByteEncoder {\n    constructor(orderedCode) {\n        this.orderedCode = orderedCode;\n    }\n    writeBytes(value) {\n        this.orderedCode.writeBytesDescending(value);\n    }\n    writeString(value) {\n        this.orderedCode.writeUtf8Descending(value);\n    }\n    writeNumber(value) {\n        this.orderedCode.writeNumberDescending(value);\n    }\n    writeInfinity() {\n        this.orderedCode.writeInfinityDescending();\n    }\n}\n/**\n * Implements `DirectionalIndexByteEncoder` using `OrderedCodeWriter` for the\n * actual encoding.\n */\nclass IndexByteEncoder {\n    constructor() {\n        this.orderedCode = new OrderedCodeWriter();\n        this.ascending = new AscendingIndexByteEncoder(this.orderedCode);\n        this.descending = new DescendingIndexByteEncoder(this.orderedCode);\n    }\n    seed(encodedBytes) {\n        this.orderedCode.seed(encodedBytes);\n    }\n    forKind(kind) {\n        return kind === 0 /* IndexKind.ASCENDING */ ? this.ascending : this.descending;\n    }\n    encodedBytes() {\n        return this.orderedCode.encodedBytes();\n    }\n    reset() {\n        this.orderedCode.reset();\n    }\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Represents an index entry saved by the SDK in persisted storage. */\nclass IndexEntry {\n    constructor(indexId, documentKey, arrayValue, directionalValue) {\n        this.indexId = indexId;\n        this.documentKey = documentKey;\n        this.arrayValue = arrayValue;\n        this.directionalValue = directionalValue;\n    }\n    /**\n     * Returns an IndexEntry entry that sorts immediately after the current\n     * directional value.\n     */\n    successor() {\n        const currentLength = this.directionalValue.length;\n        const newLength = currentLength === 0 || this.directionalValue[currentLength - 1] === 255\n            ? currentLength + 1\n            : currentLength;\n        const successor = new Uint8Array(newLength);\n        successor.set(this.directionalValue, 0);\n        if (newLength !== currentLength) {\n            successor.set([0], this.directionalValue.length);\n        }\n        else {\n            ++successor[successor.length - 1];\n        }\n        return new IndexEntry(this.indexId, this.documentKey, this.arrayValue, successor);\n    }\n}\nfunction indexEntryComparator(left, right) {\n    let cmp = left.indexId - right.indexId;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = compareByteArrays(left.arrayValue, right.arrayValue);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = compareByteArrays(left.directionalValue, right.directionalValue);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return DocumentKey.comparator(left.documentKey, right.documentKey);\n}\nfunction compareByteArrays(left, right) {\n    for (let i = 0; i < left.length && i < right.length; ++i) {\n        const compare = left[i] - right[i];\n        if (compare !== 0) {\n            return compare;\n        }\n    }\n    return left.length - right.length;\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A light query planner for Firestore.\n *\n * This class matches a `FieldIndex` against a Firestore Query `Target`. It\n * determines whether a given index can be used to serve the specified target.\n *\n * The following table showcases some possible index configurations:\n *\n * Query                                               | Index\n * -----------------------------------------------------------------------------\n * where('a', '==', 'a').where('b', '==', 'b')         | a ASC, b DESC\n * where('a', '==', 'a').where('b', '==', 'b')         | a ASC\n * where('a', '==', 'a').where('b', '==', 'b')         | b DESC\n * where('a', '>=', 'a').orderBy('a')                  | a ASC\n * where('a', '>=', 'a').orderBy('a', 'desc')          | a DESC\n * where('a', '>=', 'a').orderBy('a').orderBy('b')     | a ASC, b ASC\n * where('a', '>=', 'a').orderBy('a').orderBy('b')     | a ASC\n * where('a', 'array-contains', 'a').orderBy('b')      | a CONTAINS, b ASCENDING\n * where('a', 'array-contains', 'a').orderBy('b')      | a CONTAINS\n */\nclass TargetIndexMatcher {\n    constructor(target) {\n        // The inequality filters of the target (if it exists).\n        // Note: The sort on FieldFilters is not required. Using SortedSet here just to utilize the custom\n        // comparator.\n        this.inequalityFilters = new SortedSet((lhs, rhs) => FieldPath$1.comparator(lhs.field, rhs.field));\n        this.collectionId =\n            target.collectionGroup != null\n                ? target.collectionGroup\n                : target.path.lastSegment();\n        this.orderBys = target.orderBy;\n        this.equalityFilters = [];\n        for (const filter of target.filters) {\n            const fieldFilter = filter;\n            if (fieldFilter.isInequality()) {\n                this.inequalityFilters = this.inequalityFilters.add(fieldFilter);\n            }\n            else {\n                this.equalityFilters.push(fieldFilter);\n            }\n        }\n    }\n    get hasMultipleInequality() {\n        return this.inequalityFilters.size > 1;\n    }\n    /**\n     * Returns whether the index can be used to serve the TargetIndexMatcher's\n     * target.\n     *\n     * An index is considered capable of serving the target when:\n     * - The target uses all index segments for its filters and orderBy clauses.\n     *   The target can have additional filter and orderBy clauses, but not\n     *   fewer.\n     * - If an ArrayContains/ArrayContainsAnyfilter is used, the index must also\n     *   have a corresponding `CONTAINS` segment.\n     * - All directional index segments can be mapped to the target as a series of\n     *   equality filters, a single inequality filter and a series of orderBy\n     *   clauses.\n     * - The segments that represent the equality filters may appear out of order.\n     * - The optional segment for the inequality filter must appear after all\n     *   equality segments.\n     * - The segments that represent that orderBy clause of the target must appear\n     *   in order after all equality and inequality segments. Single orderBy\n     *   clauses cannot be skipped, but a continuous orderBy suffix may be\n     *   omitted.\n     */\n    servedByIndex(index) {\n        hardAssert(index.collectionGroup === this.collectionId);\n        if (this.hasMultipleInequality) {\n            // Only single inequality is supported for now.\n            // TODO(Add support for multiple inequality query): b/298441043\n            return false;\n        }\n        // If there is an array element, find a matching filter.\n        const arraySegment = fieldIndexGetArraySegment(index);\n        if (arraySegment !== undefined &&\n            !this.hasMatchingEqualityFilter(arraySegment)) {\n            return false;\n        }\n        const segments = fieldIndexGetDirectionalSegments(index);\n        let equalitySegments = new Set();\n        let segmentIndex = 0;\n        let orderBysIndex = 0;\n        // Process all equalities first. Equalities can appear out of order.\n        for (; segmentIndex < segments.length; ++segmentIndex) {\n            // We attempt to greedily match all segments to equality filters. If a\n            // filter matches an index segment, we can mark the segment as used.\n            if (this.hasMatchingEqualityFilter(segments[segmentIndex])) {\n                equalitySegments = equalitySegments.add(segments[segmentIndex].fieldPath.canonicalString());\n            }\n            else {\n                // If we cannot find a matching filter, we need to verify whether the\n                // remaining segments map to the target's inequality and its orderBy\n                // clauses.\n                break;\n            }\n        }\n        // If we already have processed all segments, all segments are used to serve\n        // the equality filters and we do not need to map any segments to the\n        // target's inequality and orderBy clauses.\n        if (segmentIndex === segments.length) {\n            return true;\n        }\n        if (this.inequalityFilters.size > 0) {\n            // Only a single inequality is currently supported. Get the only entry in the set.\n            const inequalityFilter = this.inequalityFilters.getIterator().getNext();\n            // If there is an inequality filter and the field was not in one of the\n            // equality filters above, the next segment must match both the filter\n            // and the first orderBy clause.\n            if (!equalitySegments.has(inequalityFilter.field.canonicalString())) {\n                const segment = segments[segmentIndex];\n                if (!this.matchesFilter(inequalityFilter, segment) ||\n                    !this.matchesOrderBy(this.orderBys[orderBysIndex++], segment)) {\n                    return false;\n                }\n            }\n            ++segmentIndex;\n        }\n        // All remaining segments need to represent the prefix of the target's\n        // orderBy.\n        for (; segmentIndex < segments.length; ++segmentIndex) {\n            const segment = segments[segmentIndex];\n            if (orderBysIndex >= this.orderBys.length ||\n                !this.matchesOrderBy(this.orderBys[orderBysIndex++], segment)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Returns a full matched field index for this target. Currently multiple\n     * inequality query is not supported so function returns null.\n     */\n    buildTargetIndex() {\n        if (this.hasMultipleInequality) {\n            return null;\n        }\n        // We want to make sure only one segment created for one field. For example,\n        // in case like a == 3 and a > 2, Index {a ASCENDING} will only be created\n        // once.\n        let uniqueFields = new SortedSet(FieldPath$1.comparator);\n        const segments = [];\n        for (const filter of this.equalityFilters) {\n            if (filter.field.isKeyField()) {\n                continue;\n            }\n            const isArrayOperator = filter.op === \"array-contains\" /* Operator.ARRAY_CONTAINS */ ||\n                filter.op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */;\n            if (isArrayOperator) {\n                segments.push(new IndexSegment(filter.field, 2 /* IndexKind.CONTAINS */));\n            }\n            else {\n                if (uniqueFields.has(filter.field)) {\n                    continue;\n                }\n                uniqueFields = uniqueFields.add(filter.field);\n                segments.push(new IndexSegment(filter.field, 0 /* IndexKind.ASCENDING */));\n            }\n        }\n        // Note: We do not explicitly check `this.inequalityFilter` but rather rely\n        // on the target defining an appropriate \"order by\" to ensure that the\n        // required index segment is added. The query engine would reject a query\n        // with an inequality filter that lacks the required order-by clause.\n        for (const orderBy of this.orderBys) {\n            // Stop adding more segments if we see a order-by on key. Typically this\n            // is the default implicit order-by which is covered in the index_entry\n            // table as a separate column. If it is not the default order-by, the\n            // generated index will be missing some segments optimized for order-bys,\n            // which is probably fine.\n            if (orderBy.field.isKeyField()) {\n                continue;\n            }\n            if (uniqueFields.has(orderBy.field)) {\n                continue;\n            }\n            uniqueFields = uniqueFields.add(orderBy.field);\n            segments.push(new IndexSegment(orderBy.field, orderBy.dir === \"asc\" /* Direction.ASCENDING */\n                ? 0 /* IndexKind.ASCENDING */\n                : 1 /* IndexKind.DESCENDING */));\n        }\n        return new FieldIndex(FieldIndex.UNKNOWN_ID, this.collectionId, segments, IndexState.empty());\n    }\n    hasMatchingEqualityFilter(segment) {\n        for (const filter of this.equalityFilters) {\n            if (this.matchesFilter(filter, segment)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    matchesFilter(filter, segment) {\n        if (filter === undefined || !filter.field.isEqual(segment.fieldPath)) {\n            return false;\n        }\n        const isArrayOperator = filter.op === \"array-contains\" /* Operator.ARRAY_CONTAINS */ ||\n            filter.op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */;\n        return (segment.kind === 2 /* IndexKind.CONTAINS */) === isArrayOperator;\n    }\n    matchesOrderBy(orderBy, segment) {\n        if (!orderBy.field.isEqual(segment.fieldPath)) {\n            return false;\n        }\n        return ((segment.kind === 0 /* IndexKind.ASCENDING */ &&\n            orderBy.dir === \"asc\" /* Direction.ASCENDING */) ||\n            (segment.kind === 1 /* IndexKind.DESCENDING */ &&\n                orderBy.dir === \"desc\" /* Direction.DESCENDING */));\n    }\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provides utility functions that help with boolean logic transformations needed for handling\n * complex filters used in queries.\n */\n/**\n * The `in` filter is only a syntactic sugar over a disjunction of equalities. For instance: `a in\n * [1,2,3]` is in fact `a==1 || a==2 || a==3`. This method expands any `in` filter in the given\n * input into a disjunction of equality filters and returns the expanded filter.\n */\nfunction computeInExpansion(filter) {\n    var _a, _b;\n    hardAssert(filter instanceof FieldFilter || filter instanceof CompositeFilter);\n    if (filter instanceof FieldFilter) {\n        if (filter instanceof InFilter) {\n            const expandedFilters = ((_b = (_a = filter.value.arrayValue) === null || _a === void 0 ? void 0 : _a.values) === null || _b === void 0 ? void 0 : _b.map(value => FieldFilter.create(filter.field, \"==\" /* Operator.EQUAL */, value))) || [];\n            return CompositeFilter.create(expandedFilters, \"or\" /* CompositeOperator.OR */);\n        }\n        else {\n            // We have reached other kinds of field filters.\n            return filter;\n        }\n    }\n    // We have a composite filter.\n    const expandedFilters = filter.filters.map(subfilter => computeInExpansion(subfilter));\n    return CompositeFilter.create(expandedFilters, filter.op);\n}\n/**\n * Given a composite filter, returns the list of terms in its disjunctive normal form.\n *\n * <p>Each element in the return value is one term of the resulting DNF. For instance: For the\n * input: (A || B) && C, the DNF form is: (A && C) || (B && C), and the return value is a list\n * with two elements: a composite filter that performs (A && C), and a composite filter that\n * performs (B && C).\n *\n * @param filter the composite filter to calculate DNF transform for.\n * @return the terms in the DNF transform.\n */\nfunction getDnfTerms(filter) {\n    if (filter.getFilters().length === 0) {\n        return [];\n    }\n    const result = computeDistributedNormalForm(computeInExpansion(filter));\n    hardAssert(isDisjunctiveNormalForm(result));\n    if (isSingleFieldFilter(result) || isFlatConjunction(result)) {\n        return [result];\n    }\n    return result.getFilters();\n}\n/** Returns true if the given filter is a single field filter. e.g. (a == 10). */\nfunction isSingleFieldFilter(filter) {\n    return filter instanceof FieldFilter;\n}\n/**\n * Returns true if the given filter is the conjunction of one or more field filters. e.g. (a == 10\n * && b == 20)\n */\nfunction isFlatConjunction(filter) {\n    return (filter instanceof CompositeFilter &&\n        compositeFilterIsFlatConjunction(filter));\n}\n/**\n * Returns whether or not the given filter is in disjunctive normal form (DNF).\n *\n * <p>In boolean logic, a disjunctive normal form (DNF) is a canonical normal form of a logical\n * formula consisting of a disjunction of conjunctions; it can also be described as an OR of ANDs.\n *\n * <p>For more info, visit: https://en.wikipedia.org/wiki/Disjunctive_normal_form\n */\nfunction isDisjunctiveNormalForm(filter) {\n    return (isSingleFieldFilter(filter) ||\n        isFlatConjunction(filter) ||\n        isDisjunctionOfFieldFiltersAndFlatConjunctions(filter));\n}\n/**\n * Returns true if the given filter is the disjunction of one or more \"flat conjunctions\" and\n * field filters. e.g. (a == 10) || (b==20 && c==30)\n */\nfunction isDisjunctionOfFieldFiltersAndFlatConjunctions(filter) {\n    if (filter instanceof CompositeFilter) {\n        if (compositeFilterIsDisjunction(filter)) {\n            for (const subFilter of filter.getFilters()) {\n                if (!isSingleFieldFilter(subFilter) && !isFlatConjunction(subFilter)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    return false;\n}\nfunction computeDistributedNormalForm(filter) {\n    hardAssert(filter instanceof FieldFilter || filter instanceof CompositeFilter);\n    if (filter instanceof FieldFilter) {\n        return filter;\n    }\n    if (filter.filters.length === 1) {\n        return computeDistributedNormalForm(filter.filters[0]);\n    }\n    // Compute DNF for each of the subfilters first\n    const result = filter.filters.map(subfilter => computeDistributedNormalForm(subfilter));\n    let newFilter = CompositeFilter.create(result, filter.op);\n    newFilter = applyAssociation(newFilter);\n    if (isDisjunctiveNormalForm(newFilter)) {\n        return newFilter;\n    }\n    hardAssert(newFilter instanceof CompositeFilter);\n    hardAssert(compositeFilterIsConjunction(newFilter));\n    hardAssert(newFilter.filters.length > 1);\n    return newFilter.filters.reduce((runningResult, filter) => applyDistribution(runningResult, filter));\n}\nfunction applyDistribution(lhs, rhs) {\n    hardAssert(lhs instanceof FieldFilter || lhs instanceof CompositeFilter);\n    hardAssert(rhs instanceof FieldFilter || rhs instanceof CompositeFilter);\n    let result;\n    if (lhs instanceof FieldFilter) {\n        if (rhs instanceof FieldFilter) {\n            // FieldFilter FieldFilter\n            result = applyDistributionFieldFilters(lhs, rhs);\n        }\n        else {\n            // FieldFilter CompositeFilter\n            result = applyDistributionFieldAndCompositeFilters(lhs, rhs);\n        }\n    }\n    else {\n        if (rhs instanceof FieldFilter) {\n            // CompositeFilter FieldFilter\n            result = applyDistributionFieldAndCompositeFilters(rhs, lhs);\n        }\n        else {\n            // CompositeFilter CompositeFilter\n            result = applyDistributionCompositeFilters(lhs, rhs);\n        }\n    }\n    return applyAssociation(result);\n}\nfunction applyDistributionFieldFilters(lhs, rhs) {\n    // Conjunction distribution for two field filters is the conjunction of them.\n    return CompositeFilter.create([lhs, rhs], \"and\" /* CompositeOperator.AND */);\n}\nfunction applyDistributionCompositeFilters(lhs, rhs) {\n    hardAssert(lhs.filters.length > 0 && rhs.filters.length > 0);\n    // There are four cases:\n    // (A & B) & (C & D) --> (A & B & C & D)\n    // (A & B) & (C | D) --> (A & B & C) | (A & B & D)\n    // (A | B) & (C & D) --> (C & D & A) | (C & D & B)\n    // (A | B) & (C | D) --> (A & C) | (A & D) | (B & C) | (B & D)\n    // Case 1 is a merge.\n    if (compositeFilterIsConjunction(lhs) && compositeFilterIsConjunction(rhs)) {\n        return compositeFilterWithAddedFilters(lhs, rhs.getFilters());\n    }\n    // Case 2,3,4 all have at least one side (lhs or rhs) that is a disjunction. In all three cases\n    // we should take each element of the disjunction and distribute it over the other side, and\n    // return the disjunction of the distribution results.\n    const disjunctionSide = compositeFilterIsDisjunction(lhs) ? lhs : rhs;\n    const otherSide = compositeFilterIsDisjunction(lhs) ? rhs : lhs;\n    const results = disjunctionSide.filters.map(subfilter => applyDistribution(subfilter, otherSide));\n    return CompositeFilter.create(results, \"or\" /* CompositeOperator.OR */);\n}\nfunction applyDistributionFieldAndCompositeFilters(fieldFilter, compositeFilter) {\n    // There are two cases:\n    // A & (B & C) --> (A & B & C)\n    // A & (B | C) --> (A & B) | (A & C)\n    if (compositeFilterIsConjunction(compositeFilter)) {\n        // Case 1\n        return compositeFilterWithAddedFilters(compositeFilter, fieldFilter.getFilters());\n    }\n    else {\n        // Case 2\n        const newFilters = compositeFilter.filters.map(subfilter => applyDistribution(fieldFilter, subfilter));\n        return CompositeFilter.create(newFilters, \"or\" /* CompositeOperator.OR */);\n    }\n}\n/**\n * Applies the associativity property to the given filter and returns the resulting filter.\n *\n * <ul>\n *   <li>A | (B | C) == (A | B) | C == (A | B | C)\n *   <li>A & (B & C) == (A & B) & C == (A & B & C)\n * </ul>\n *\n * <p>For more info, visit: https://en.wikipedia.org/wiki/Associative_property#Propositional_logic\n */\nfunction applyAssociation(filter) {\n    hardAssert(filter instanceof FieldFilter || filter instanceof CompositeFilter);\n    if (filter instanceof FieldFilter) {\n        return filter;\n    }\n    const filters = filter.getFilters();\n    // If the composite filter only contains 1 filter, apply associativity to it.\n    if (filters.length === 1) {\n        return applyAssociation(filters[0]);\n    }\n    // Associativity applied to a flat composite filter results is itself.\n    if (compositeFilterIsFlat(filter)) {\n        return filter;\n    }\n    // First apply associativity to all subfilters. This will in turn recursively apply\n    // associativity to all nested composite filters and field filters.\n    const updatedFilters = filters.map(subfilter => applyAssociation(subfilter));\n    // For composite subfilters that perform the same kind of logical operation as `compositeFilter`\n    // take out their filters and add them to `compositeFilter`. For example:\n    // compositeFilter = (A | (B | C | D))\n    // compositeSubfilter = (B | C | D)\n    // Result: (A | B | C | D)\n    // Note that the `compositeSubfilter` has been eliminated, and its filters (B, C, D) have been\n    // added to the top-level \"compositeFilter\".\n    const newSubfilters = [];\n    updatedFilters.forEach(subfilter => {\n        if (subfilter instanceof FieldFilter) {\n            newSubfilters.push(subfilter);\n        }\n        else if (subfilter instanceof CompositeFilter) {\n            if (subfilter.op === filter.op) {\n                // compositeFilter: (A | (B | C))\n                // compositeSubfilter: (B | C)\n                // Result: (A | B | C)\n                newSubfilters.push(...subfilter.filters);\n            }\n            else {\n                // compositeFilter: (A | (B & C))\n                // compositeSubfilter: (B & C)\n                // Result: (A | (B & C))\n                newSubfilters.push(subfilter);\n            }\n        }\n    });\n    if (newSubfilters.length === 1) {\n        return newSubfilters[0];\n    }\n    return CompositeFilter.create(newSubfilters, filter.op);\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An in-memory implementation of IndexManager.\n */\nclass MemoryIndexManager {\n    constructor() {\n        this.collectionParentIndex = new MemoryCollectionParentIndex();\n    }\n    addToCollectionParentIndex(transaction, collectionPath) {\n        this.collectionParentIndex.add(collectionPath);\n        return PersistencePromise.resolve();\n    }\n    getCollectionParents(transaction, collectionId) {\n        return PersistencePromise.resolve(this.collectionParentIndex.getEntries(collectionId));\n    }\n    addFieldIndex(transaction, index) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve();\n    }\n    deleteFieldIndex(transaction, index) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve();\n    }\n    deleteAllFieldIndexes(transaction) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve();\n    }\n    createTargetIndexes(transaction, target) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve();\n    }\n    getDocumentsMatchingTarget(transaction, target) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve(null);\n    }\n    getIndexType(transaction, target) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve(0 /* IndexType.NONE */);\n    }\n    getFieldIndexes(transaction, collectionGroup) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve([]);\n    }\n    getNextCollectionGroupToUpdate(transaction) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve(null);\n    }\n    getMinOffset(transaction, target) {\n        return PersistencePromise.resolve(IndexOffset.min());\n    }\n    getMinOffsetFromCollectionGroup(transaction, collectionGroup) {\n        return PersistencePromise.resolve(IndexOffset.min());\n    }\n    updateCollectionGroup(transaction, collectionGroup, offset) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve();\n    }\n    updateIndexEntries(transaction, documents) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve();\n    }\n}\n/**\n * Internal implementation of the collection-parent index exposed by MemoryIndexManager.\n * Also used for in-memory caching by IndexedDbIndexManager and initial index population\n * in indexeddb_schema.ts\n */\nclass MemoryCollectionParentIndex {\n    constructor() {\n        this.index = {};\n    }\n    // Returns false if the entry already existed.\n    add(collectionPath) {\n        const collectionId = collectionPath.lastSegment();\n        const parentPath = collectionPath.popLast();\n        const existingParents = this.index[collectionId] ||\n            new SortedSet(ResourcePath.comparator);\n        const added = !existingParents.has(parentPath);\n        this.index[collectionId] = existingParents.add(parentPath);\n        return added;\n    }\n    has(collectionPath) {\n        const collectionId = collectionPath.lastSegment();\n        const parentPath = collectionPath.popLast();\n        const existingParents = this.index[collectionId];\n        return existingParents && existingParents.has(parentPath);\n    }\n    getEntries(collectionId) {\n        const parentPaths = this.index[collectionId] ||\n            new SortedSet(ResourcePath.comparator);\n        return parentPaths.toArray();\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$f = 'IndexedDbIndexManager';\nconst EMPTY_VALUE = new Uint8Array(0);\n/**\n * A persisted implementation of IndexManager.\n *\n * PORTING NOTE: Unlike iOS and Android, the Web SDK does not memoize index\n * data as it supports multi-tab access.\n */\nclass IndexedDbIndexManager {\n    constructor(user, databaseId) {\n        this.databaseId = databaseId;\n        /**\n         * An in-memory copy of the index entries we've already written since the SDK\n         * launched. Used to avoid re-writing the same entry repeatedly.\n         *\n         * This is *NOT* a complete cache of what's in persistence and so can never be\n         * used to satisfy reads.\n         */\n        this.collectionParentsCache = new MemoryCollectionParentIndex();\n        /**\n         * Maps from a target to its equivalent list of sub-targets. Each sub-target\n         * contains only one term from the target's disjunctive normal form (DNF).\n         */\n        this.targetToDnfSubTargets = new ObjectMap(t => canonifyTarget(t), (l, r) => targetEquals(l, r));\n        this.uid = user.uid || '';\n    }\n    /**\n     * Adds a new entry to the collection parent index.\n     *\n     * Repeated calls for the same collectionPath should be avoided within a\n     * transaction as IndexedDbIndexManager only caches writes once a transaction\n     * has been committed.\n     */\n    addToCollectionParentIndex(transaction, collectionPath) {\n        if (!this.collectionParentsCache.has(collectionPath)) {\n            const collectionId = collectionPath.lastSegment();\n            const parentPath = collectionPath.popLast();\n            transaction.addOnCommittedListener(() => {\n                // Add the collection to the in memory cache only if the transaction was\n                // successfully committed.\n                this.collectionParentsCache.add(collectionPath);\n            });\n            const collectionParent = {\n                collectionId,\n                parent: encodeResourcePath(parentPath)\n            };\n            return collectionParentsStore(transaction).put(collectionParent);\n        }\n        return PersistencePromise.resolve();\n    }\n    getCollectionParents(transaction, collectionId) {\n        const parentPaths = [];\n        const range = IDBKeyRange.bound([collectionId, ''], [immediateSuccessor(collectionId), ''], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        return collectionParentsStore(transaction)\n            .loadAll(range)\n            .next(entries => {\n            for (const entry of entries) {\n                // This collectionId guard shouldn't be necessary (and isn't as long\n                // as we're running in a real browser), but there's a bug in\n                // indexeddbshim that breaks our range in our tests running in node:\n                // https://github.com/axemclion/IndexedDBShim/issues/334\n                if (entry.collectionId !== collectionId) {\n                    break;\n                }\n                parentPaths.push(decodeResourcePath(entry.parent));\n            }\n            return parentPaths;\n        });\n    }\n    addFieldIndex(transaction, index) {\n        // TODO(indexing): Verify that the auto-incrementing index ID works in\n        // Safari & Firefox.\n        const indexes = indexConfigurationStore(transaction);\n        const dbIndex = toDbIndexConfiguration(index);\n        delete dbIndex.indexId; // `indexId` is auto-populated by IndexedDb\n        const result = indexes.add(dbIndex);\n        if (index.indexState) {\n            const states = indexStateStore(transaction);\n            return result.next(indexId => {\n                states.put(toDbIndexState(indexId, this.uid, index.indexState.sequenceNumber, index.indexState.offset));\n            });\n        }\n        else {\n            return result.next();\n        }\n    }\n    deleteFieldIndex(transaction, index) {\n        const indexes = indexConfigurationStore(transaction);\n        const states = indexStateStore(transaction);\n        const entries = indexEntriesStore(transaction);\n        return indexes\n            .delete(index.indexId)\n            .next(() => states.delete(IDBKeyRange.bound([index.indexId], [index.indexId + 1], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true)))\n            .next(() => entries.delete(IDBKeyRange.bound([index.indexId], [index.indexId + 1], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true)));\n    }\n    deleteAllFieldIndexes(transaction) {\n        const indexes = indexConfigurationStore(transaction);\n        const entries = indexEntriesStore(transaction);\n        const states = indexStateStore(transaction);\n        return indexes\n            .deleteAll()\n            .next(() => entries.deleteAll())\n            .next(() => states.deleteAll());\n    }\n    createTargetIndexes(transaction, target) {\n        return PersistencePromise.forEach(this.getSubTargets(target), (subTarget) => {\n            return this.getIndexType(transaction, subTarget).next(type => {\n                if (type === 0 /* IndexType.NONE */ || type === 1 /* IndexType.PARTIAL */) {\n                    const targetIndexMatcher = new TargetIndexMatcher(subTarget);\n                    const fieldIndex = targetIndexMatcher.buildTargetIndex();\n                    if (fieldIndex != null) {\n                        return this.addFieldIndex(transaction, fieldIndex);\n                    }\n                }\n            });\n        });\n    }\n    getDocumentsMatchingTarget(transaction, target) {\n        const indexEntries = indexEntriesStore(transaction);\n        let canServeTarget = true;\n        const indexes = new Map();\n        return PersistencePromise.forEach(this.getSubTargets(target), (subTarget) => {\n            return this.getFieldIndex(transaction, subTarget).next(index => {\n                canServeTarget && (canServeTarget = !!index);\n                indexes.set(subTarget, index);\n            });\n        }).next(() => {\n            if (!canServeTarget) {\n                return PersistencePromise.resolve(null);\n            }\n            else {\n                let existingKeys = documentKeySet();\n                const result = [];\n                return PersistencePromise.forEach(indexes, (index, subTarget) => {\n                    logDebug(LOG_TAG$f, `Using index ${fieldIndexToString(index)} to execute ${canonifyTarget(target)}`);\n                    const arrayValues = targetGetArrayValues(subTarget, index);\n                    const notInValues = targetGetNotInValues(subTarget, index);\n                    const lowerBound = targetGetLowerBound(subTarget, index);\n                    const upperBound = targetGetUpperBound(subTarget, index);\n                    const lowerBoundEncoded = this.encodeBound(index, subTarget, lowerBound);\n                    const upperBoundEncoded = this.encodeBound(index, subTarget, upperBound);\n                    const notInEncoded = this.encodeValues(index, subTarget, notInValues);\n                    const indexRanges = this.generateIndexRanges(index.indexId, arrayValues, lowerBoundEncoded, lowerBound.inclusive, upperBoundEncoded, upperBound.inclusive, notInEncoded);\n                    return PersistencePromise.forEach(indexRanges, (indexRange) => {\n                        return indexEntries\n                            .loadFirst(indexRange, target.limit)\n                            .next(entries => {\n                            entries.forEach(entry => {\n                                const documentKey = DocumentKey.fromSegments(entry.documentKey);\n                                if (!existingKeys.has(documentKey)) {\n                                    existingKeys = existingKeys.add(documentKey);\n                                    result.push(documentKey);\n                                }\n                            });\n                        });\n                    });\n                }).next(() => result);\n            }\n        });\n    }\n    getSubTargets(target) {\n        let subTargets = this.targetToDnfSubTargets.get(target);\n        if (subTargets) {\n            return subTargets;\n        }\n        if (target.filters.length === 0) {\n            subTargets = [target];\n        }\n        else {\n            // There is an implicit AND operation between all the filters stored in the target\n            const dnf = getDnfTerms(CompositeFilter.create(target.filters, \"and\" /* CompositeOperator.AND */));\n            subTargets = dnf.map(term => newTarget(target.path, target.collectionGroup, target.orderBy, term.getFilters(), target.limit, target.startAt, target.endAt));\n        }\n        this.targetToDnfSubTargets.set(target, subTargets);\n        return subTargets;\n    }\n    /**\n     * Constructs a key range query on `DbIndexEntryStore` that unions all\n     * bounds.\n     */\n    generateIndexRanges(indexId, arrayValues, lowerBounds, lowerBoundInclusive, upperBounds, upperBoundInclusive, notInValues) {\n        // The number of total index scans we union together. This is similar to a\n        // distributed normal form, but adapted for array values. We create a single\n        // index range per value in an ARRAY_CONTAINS or ARRAY_CONTAINS_ANY filter\n        // combined with the values from the query bounds.\n        const totalScans = (arrayValues != null ? arrayValues.length : 1) *\n            Math.max(lowerBounds.length, upperBounds.length);\n        const scansPerArrayElement = totalScans / (arrayValues != null ? arrayValues.length : 1);\n        const indexRanges = [];\n        for (let i = 0; i < totalScans; ++i) {\n            const arrayValue = arrayValues\n                ? this.encodeSingleElement(arrayValues[i / scansPerArrayElement])\n                : EMPTY_VALUE;\n            const lowerBound = this.generateLowerBound(indexId, arrayValue, lowerBounds[i % scansPerArrayElement], lowerBoundInclusive);\n            const upperBound = this.generateUpperBound(indexId, arrayValue, upperBounds[i % scansPerArrayElement], upperBoundInclusive);\n            const notInBound = notInValues.map(notIn => this.generateLowerBound(indexId, arrayValue, notIn, \n            /* inclusive= */ true));\n            indexRanges.push(...this.createRange(lowerBound, upperBound, notInBound));\n        }\n        return indexRanges;\n    }\n    /** Generates the lower bound for `arrayValue` and `directionalValue`. */\n    generateLowerBound(indexId, arrayValue, directionalValue, inclusive) {\n        const entry = new IndexEntry(indexId, DocumentKey.empty(), arrayValue, directionalValue);\n        return inclusive ? entry : entry.successor();\n    }\n    /** Generates the upper bound for `arrayValue` and `directionalValue`. */\n    generateUpperBound(indexId, arrayValue, directionalValue, inclusive) {\n        const entry = new IndexEntry(indexId, DocumentKey.empty(), arrayValue, directionalValue);\n        return inclusive ? entry.successor() : entry;\n    }\n    getFieldIndex(transaction, target) {\n        const targetIndexMatcher = new TargetIndexMatcher(target);\n        const collectionGroup = target.collectionGroup != null\n            ? target.collectionGroup\n            : target.path.lastSegment();\n        return this.getFieldIndexes(transaction, collectionGroup).next(indexes => {\n            // Return the index with the most number of segments.\n            let index = null;\n            for (const candidate of indexes) {\n                const matches = targetIndexMatcher.servedByIndex(candidate);\n                if (matches &&\n                    (!index || candidate.fields.length > index.fields.length)) {\n                    index = candidate;\n                }\n            }\n            return index;\n        });\n    }\n    getIndexType(transaction, target) {\n        let indexType = 2 /* IndexType.FULL */;\n        const subTargets = this.getSubTargets(target);\n        return PersistencePromise.forEach(subTargets, (target) => {\n            return this.getFieldIndex(transaction, target).next(index => {\n                if (!index) {\n                    indexType = 0 /* IndexType.NONE */;\n                }\n                else if (indexType !== 0 /* IndexType.NONE */ &&\n                    index.fields.length < targetGetSegmentCount(target)) {\n                    indexType = 1 /* IndexType.PARTIAL */;\n                }\n            });\n        }).next(() => {\n            // OR queries have more than one sub-target (one sub-target per DNF term). We currently consider\n            // OR queries that have a `limit` to have a partial index. For such queries we perform sorting\n            // and apply the limit in memory as a post-processing step.\n            if (targetHasLimit(target) &&\n                subTargets.length > 1 &&\n                indexType === 2 /* IndexType.FULL */) {\n                return 1 /* IndexType.PARTIAL */;\n            }\n            return indexType;\n        });\n    }\n    /**\n     * Returns the byte encoded form of the directional values in the field index.\n     * Returns `null` if the document does not have all fields specified in the\n     * index.\n     */\n    encodeDirectionalElements(fieldIndex, document) {\n        const encoder = new IndexByteEncoder();\n        for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\n            const field = document.data.field(segment.fieldPath);\n            if (field == null) {\n                return null;\n            }\n            const directionalEncoder = encoder.forKind(segment.kind);\n            FirestoreIndexValueWriter.INSTANCE.writeIndexValue(field, directionalEncoder);\n        }\n        return encoder.encodedBytes();\n    }\n    /** Encodes a single value to the ascending index format. */\n    encodeSingleElement(value) {\n        const encoder = new IndexByteEncoder();\n        FirestoreIndexValueWriter.INSTANCE.writeIndexValue(value, encoder.forKind(0 /* IndexKind.ASCENDING */));\n        return encoder.encodedBytes();\n    }\n    /**\n     * Returns an encoded form of the document key that sorts based on the key\n     * ordering of the field index.\n     */\n    encodeDirectionalKey(fieldIndex, documentKey) {\n        const encoder = new IndexByteEncoder();\n        FirestoreIndexValueWriter.INSTANCE.writeIndexValue(refValue(this.databaseId, documentKey), encoder.forKind(fieldIndexGetKeyOrder(fieldIndex)));\n        return encoder.encodedBytes();\n    }\n    /**\n     * Encodes the given field values according to the specification in `target`.\n     * For IN queries, a list of possible values is returned.\n     */\n    encodeValues(fieldIndex, target, values) {\n        if (values === null) {\n            return [];\n        }\n        let encoders = [];\n        encoders.push(new IndexByteEncoder());\n        let valueIdx = 0;\n        for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\n            const value = values[valueIdx++];\n            for (const encoder of encoders) {\n                if (this.isInFilter(target, segment.fieldPath) && isArray(value)) {\n                    encoders = this.expandIndexValues(encoders, segment, value);\n                }\n                else {\n                    const directionalEncoder = encoder.forKind(segment.kind);\n                    FirestoreIndexValueWriter.INSTANCE.writeIndexValue(value, directionalEncoder);\n                }\n            }\n        }\n        return this.getEncodedBytes(encoders);\n    }\n    /**\n     * Encodes the given bounds according to the specification in `target`. For IN\n     * queries, a list of possible values is returned.\n     */\n    encodeBound(fieldIndex, target, bound) {\n        return this.encodeValues(fieldIndex, target, bound.position);\n    }\n    /** Returns the byte representation for the provided encoders. */\n    getEncodedBytes(encoders) {\n        const result = [];\n        for (let i = 0; i < encoders.length; ++i) {\n            result[i] = encoders[i].encodedBytes();\n        }\n        return result;\n    }\n    /**\n     * Creates a separate encoder for each element of an array.\n     *\n     * The method appends each value to all existing encoders (e.g. filter(\"a\",\n     * \"==\", \"a1\").filter(\"b\", \"in\", [\"b1\", \"b2\"]) becomes [\"a1,b1\", \"a1,b2\"]). A\n     * list of new encoders is returned.\n     */\n    expandIndexValues(encoders, segment, value) {\n        const prefixes = [...encoders];\n        const results = [];\n        for (const arrayElement of value.arrayValue.values || []) {\n            for (const prefix of prefixes) {\n                const clonedEncoder = new IndexByteEncoder();\n                clonedEncoder.seed(prefix.encodedBytes());\n                FirestoreIndexValueWriter.INSTANCE.writeIndexValue(arrayElement, clonedEncoder.forKind(segment.kind));\n                results.push(clonedEncoder);\n            }\n        }\n        return results;\n    }\n    isInFilter(target, fieldPath) {\n        return !!target.filters.find(f => f instanceof FieldFilter &&\n            f.field.isEqual(fieldPath) &&\n            (f.op === \"in\" /* Operator.IN */ || f.op === \"not-in\" /* Operator.NOT_IN */));\n    }\n    getFieldIndexes(transaction, collectionGroup) {\n        const indexes = indexConfigurationStore(transaction);\n        const states = indexStateStore(transaction);\n        return (collectionGroup\n            ? indexes.loadAll(DbIndexConfigurationCollectionGroupIndex, IDBKeyRange.bound(collectionGroup, collectionGroup))\n            : indexes.loadAll()).next(indexConfigs => {\n            const result = [];\n            return PersistencePromise.forEach(indexConfigs, (indexConfig) => {\n                return states\n                    .get([indexConfig.indexId, this.uid])\n                    .next(indexState => {\n                    result.push(fromDbIndexConfiguration(indexConfig, indexState));\n                });\n            }).next(() => result);\n        });\n    }\n    getNextCollectionGroupToUpdate(transaction) {\n        return this.getFieldIndexes(transaction).next(indexes => {\n            if (indexes.length === 0) {\n                return null;\n            }\n            indexes.sort((l, r) => {\n                const cmp = l.indexState.sequenceNumber - r.indexState.sequenceNumber;\n                return cmp !== 0\n                    ? cmp\n                    : primitiveComparator(l.collectionGroup, r.collectionGroup);\n            });\n            return indexes[0].collectionGroup;\n        });\n    }\n    updateCollectionGroup(transaction, collectionGroup, offset) {\n        const indexes = indexConfigurationStore(transaction);\n        const states = indexStateStore(transaction);\n        return this.getNextSequenceNumber(transaction).next(nextSequenceNumber => indexes\n            .loadAll(DbIndexConfigurationCollectionGroupIndex, IDBKeyRange.bound(collectionGroup, collectionGroup))\n            .next(configs => PersistencePromise.forEach(configs, (config) => states.put(toDbIndexState(config.indexId, this.uid, nextSequenceNumber, offset)))));\n    }\n    updateIndexEntries(transaction, documents) {\n        // Porting Note: `getFieldIndexes()` on Web does not cache index lookups as\n        // it could be used across different IndexedDB transactions. As any cached\n        // data might be invalidated by other multi-tab clients, we can only trust\n        // data within a single IndexedDB transaction. We therefore add a cache\n        // here.\n        const memoizedIndexes = new Map();\n        return PersistencePromise.forEach(documents, (key, doc) => {\n            const memoizedCollectionIndexes = memoizedIndexes.get(key.collectionGroup);\n            const fieldIndexes = memoizedCollectionIndexes\n                ? PersistencePromise.resolve(memoizedCollectionIndexes)\n                : this.getFieldIndexes(transaction, key.collectionGroup);\n            return fieldIndexes.next(fieldIndexes => {\n                memoizedIndexes.set(key.collectionGroup, fieldIndexes);\n                return PersistencePromise.forEach(fieldIndexes, (fieldIndex) => {\n                    return this.getExistingIndexEntries(transaction, key, fieldIndex).next(existingEntries => {\n                        const newEntries = this.computeIndexEntries(doc, fieldIndex);\n                        if (!existingEntries.isEqual(newEntries)) {\n                            return this.updateEntries(transaction, doc, fieldIndex, existingEntries, newEntries);\n                        }\n                        return PersistencePromise.resolve();\n                    });\n                });\n            });\n        });\n    }\n    addIndexEntry(transaction, document, fieldIndex, indexEntry) {\n        const indexEntries = indexEntriesStore(transaction);\n        return indexEntries.put({\n            indexId: indexEntry.indexId,\n            uid: this.uid,\n            arrayValue: indexEntry.arrayValue,\n            directionalValue: indexEntry.directionalValue,\n            orderedDocumentKey: this.encodeDirectionalKey(fieldIndex, document.key),\n            documentKey: document.key.path.toArray()\n        });\n    }\n    deleteIndexEntry(transaction, document, fieldIndex, indexEntry) {\n        const indexEntries = indexEntriesStore(transaction);\n        return indexEntries.delete([\n            indexEntry.indexId,\n            this.uid,\n            indexEntry.arrayValue,\n            indexEntry.directionalValue,\n            this.encodeDirectionalKey(fieldIndex, document.key),\n            document.key.path.toArray()\n        ]);\n    }\n    getExistingIndexEntries(transaction, documentKey, fieldIndex) {\n        const indexEntries = indexEntriesStore(transaction);\n        let results = new SortedSet(indexEntryComparator);\n        return indexEntries\n            .iterate({\n            index: DbIndexEntryDocumentKeyIndex,\n            range: IDBKeyRange.only([\n                fieldIndex.indexId,\n                this.uid,\n                this.encodeDirectionalKey(fieldIndex, documentKey)\n            ])\n        }, (_, entry) => {\n            results = results.add(new IndexEntry(fieldIndex.indexId, documentKey, entry.arrayValue, entry.directionalValue));\n        })\n            .next(() => results);\n    }\n    /** Creates the index entries for the given document. */\n    computeIndexEntries(document, fieldIndex) {\n        let results = new SortedSet(indexEntryComparator);\n        const directionalValue = this.encodeDirectionalElements(fieldIndex, document);\n        if (directionalValue == null) {\n            return results;\n        }\n        const arraySegment = fieldIndexGetArraySegment(fieldIndex);\n        if (arraySegment != null) {\n            const value = document.data.field(arraySegment.fieldPath);\n            if (isArray(value)) {\n                for (const arrayValue of value.arrayValue.values || []) {\n                    results = results.add(new IndexEntry(fieldIndex.indexId, document.key, this.encodeSingleElement(arrayValue), directionalValue));\n                }\n            }\n        }\n        else {\n            results = results.add(new IndexEntry(fieldIndex.indexId, document.key, EMPTY_VALUE, directionalValue));\n        }\n        return results;\n    }\n    /**\n     * Updates the index entries for the provided document by deleting entries\n     * that are no longer referenced in `newEntries` and adding all newly added\n     * entries.\n     */\n    updateEntries(transaction, document, fieldIndex, existingEntries, newEntries) {\n        logDebug(LOG_TAG$f, \"Updating index entries for document '%s'\", document.key);\n        const promises = [];\n        diffSortedSets(existingEntries, newEntries, indexEntryComparator, \n        /* onAdd= */ entry => {\n            promises.push(this.addIndexEntry(transaction, document, fieldIndex, entry));\n        }, \n        /* onRemove= */ entry => {\n            promises.push(this.deleteIndexEntry(transaction, document, fieldIndex, entry));\n        });\n        return PersistencePromise.waitFor(promises);\n    }\n    getNextSequenceNumber(transaction) {\n        let nextSequenceNumber = 1;\n        const states = indexStateStore(transaction);\n        return states\n            .iterate({\n            index: DbIndexStateSequenceNumberIndex,\n            reverse: true,\n            range: IDBKeyRange.upperBound([this.uid, Number.MAX_SAFE_INTEGER])\n        }, (_, state, controller) => {\n            controller.done();\n            nextSequenceNumber = state.sequenceNumber + 1;\n        })\n            .next(() => nextSequenceNumber);\n    }\n    /**\n     * Returns a new set of IDB ranges that splits the existing range and excludes\n     * any values that match the `notInValue` from these ranges. As an example,\n     * '[foo > 2 && foo != 3]` becomes  `[foo > 2 && < 3, foo > 3]`.\n     */\n    createRange(lower, upper, notInValues) {\n        // The notIn values need to be sorted and unique so that we can return a\n        // sorted set of non-overlapping ranges.\n        notInValues = notInValues\n            .sort((l, r) => indexEntryComparator(l, r))\n            .filter((el, i, values) => !i || indexEntryComparator(el, values[i - 1]) !== 0);\n        const bounds = [];\n        bounds.push(lower);\n        for (const notInValue of notInValues) {\n            const cmpToLower = indexEntryComparator(notInValue, lower);\n            const cmpToUpper = indexEntryComparator(notInValue, upper);\n            if (cmpToLower === 0) {\n                // `notInValue` is the lower bound. We therefore need to raise the bound\n                // to the next value.\n                bounds[0] = lower.successor();\n            }\n            else if (cmpToLower > 0 && cmpToUpper < 0) {\n                // `notInValue` is in the middle of the range\n                bounds.push(notInValue);\n                bounds.push(notInValue.successor());\n            }\n            else if (cmpToUpper > 0) {\n                // `notInValue` (and all following values) are out of the range\n                break;\n            }\n        }\n        bounds.push(upper);\n        const ranges = [];\n        for (let i = 0; i < bounds.length; i += 2) {\n            // If we encounter two bounds that will create an unmatchable key range,\n            // then we return an empty set of key ranges.\n            if (this.isRangeMatchable(bounds[i], bounds[i + 1])) {\n                return [];\n            }\n            const lowerBound = [\n                bounds[i].indexId,\n                this.uid,\n                bounds[i].arrayValue,\n                bounds[i].directionalValue,\n                EMPTY_VALUE,\n                []\n            ];\n            const upperBound = [\n                bounds[i + 1].indexId,\n                this.uid,\n                bounds[i + 1].arrayValue,\n                bounds[i + 1].directionalValue,\n                EMPTY_VALUE,\n                []\n            ];\n            ranges.push(IDBKeyRange.bound(lowerBound, upperBound));\n        }\n        return ranges;\n    }\n    isRangeMatchable(lowerBound, upperBound) {\n        // If lower bound is greater than the upper bound, then the key\n        // range can never be matched.\n        return indexEntryComparator(lowerBound, upperBound) > 0;\n    }\n    getMinOffsetFromCollectionGroup(transaction, collectionGroup) {\n        return this.getFieldIndexes(transaction, collectionGroup).next(getMinOffsetFromFieldIndexes);\n    }\n    getMinOffset(transaction, target) {\n        return PersistencePromise.mapArray(this.getSubTargets(target), (subTarget) => this.getFieldIndex(transaction, subTarget).next(index => index ? index : fail())).next(getMinOffsetFromFieldIndexes);\n    }\n}\n/**\n * Helper to get a typed SimpleDbStore for the collectionParents\n * document store.\n */\nfunction collectionParentsStore(txn) {\n    return getStore(txn, DbCollectionParentStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the index entry object store.\n */\nfunction indexEntriesStore(txn) {\n    return getStore(txn, DbIndexEntryStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the index configuration object store.\n */\nfunction indexConfigurationStore(txn) {\n    return getStore(txn, DbIndexConfigurationStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the index state object store.\n */\nfunction indexStateStore(txn) {\n    return getStore(txn, DbIndexStateStore);\n}\nfunction getMinOffsetFromFieldIndexes(fieldIndexes) {\n    hardAssert(fieldIndexes.length !== 0);\n    let minOffset = fieldIndexes[0].indexState.offset;\n    let maxBatchId = minOffset.largestBatchId;\n    for (let i = 1; i < fieldIndexes.length; i++) {\n        const newOffset = fieldIndexes[i].indexState.offset;\n        if (indexOffsetComparator(newOffset, minOffset) < 0) {\n            minOffset = newOffset;\n        }\n        if (maxBatchId < newOffset.largestBatchId) {\n            maxBatchId = newOffset.largestBatchId;\n        }\n    }\n    return new IndexOffset(minOffset.readTime, minOffset.documentKey, maxBatchId);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Delete a mutation batch and the associated document mutations.\n * @returns A PersistencePromise of the document mutations that were removed.\n */\nfunction removeMutationBatch(txn, userId, batch) {\n    const mutationStore = txn.store(DbMutationBatchStore);\n    const indexTxn = txn.store(DbDocumentMutationStore);\n    const promises = [];\n    const range = IDBKeyRange.only(batch.batchId);\n    let numDeleted = 0;\n    const removePromise = mutationStore.iterate({ range }, (key, value, control) => {\n        numDeleted++;\n        return control.delete();\n    });\n    promises.push(removePromise.next(() => {\n        hardAssert(numDeleted === 1);\n    }));\n    const removedDocuments = [];\n    for (const mutation of batch.mutations) {\n        const indexKey = newDbDocumentMutationKey(userId, mutation.key.path, batch.batchId);\n        promises.push(indexTxn.delete(indexKey));\n        removedDocuments.push(mutation.key);\n    }\n    return PersistencePromise.waitFor(promises).next(() => removedDocuments);\n}\n/**\n * Returns an approximate size for the given document.\n */\nfunction dbDocumentSize(doc) {\n    if (!doc) {\n        return 0;\n    }\n    let value;\n    if (doc.document) {\n        value = doc.document;\n    }\n    else if (doc.unknownDocument) {\n        value = doc.unknownDocument;\n    }\n    else if (doc.noDocument) {\n        value = doc.noDocument;\n    }\n    else {\n        throw fail();\n    }\n    return JSON.stringify(value).length;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** A mutation queue for a specific user, backed by IndexedDB. */\nclass IndexedDbMutationQueue {\n    constructor(\n    /**\n     * The normalized userId (e.g. null UID => \"\" userId) used to store /\n     * retrieve mutations.\n     */\n    userId, serializer, indexManager, referenceDelegate) {\n        this.userId = userId;\n        this.serializer = serializer;\n        this.indexManager = indexManager;\n        this.referenceDelegate = referenceDelegate;\n        /**\n         * Caches the document keys for pending mutation batches. If the mutation\n         * has been removed from IndexedDb, the cached value may continue to\n         * be used to retrieve the batch's document keys. To remove a cached value\n         * locally, `removeCachedMutationKeys()` should be invoked either directly\n         * or through `removeMutationBatches()`.\n         *\n         * With multi-tab, when the primary client acknowledges or rejects a mutation,\n         * this cache is used by secondary clients to invalidate the local\n         * view of the documents that were previously affected by the mutation.\n         */\n        // PORTING NOTE: Multi-tab only.\n        this.documentKeysByBatchId = {};\n    }\n    /**\n     * Creates a new mutation queue for the given user.\n     * @param user - The user for which to create a mutation queue.\n     * @param serializer - The serializer to use when persisting to IndexedDb.\n     */\n    static forUser(user, serializer, indexManager, referenceDelegate) {\n        // TODO(mcg): Figure out what constraints there are on userIDs\n        // In particular, are there any reserved characters? are empty ids allowed?\n        // For the moment store these together in the same mutations table assuming\n        // that empty userIDs aren't allowed.\n        hardAssert(user.uid !== '');\n        const userId = user.isAuthenticated() ? user.uid : '';\n        return new IndexedDbMutationQueue(userId, serializer, indexManager, referenceDelegate);\n    }\n    checkEmpty(transaction) {\n        let empty = true;\n        const range = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);\n        return mutationsStore(transaction)\n            .iterate({ index: DbMutationBatchUserMutationsIndex, range }, (key, value, control) => {\n            empty = false;\n            control.done();\n        })\n            .next(() => empty);\n    }\n    addMutationBatch(transaction, localWriteTime, baseMutations, mutations) {\n        const documentStore = documentMutationsStore(transaction);\n        const mutationStore = mutationsStore(transaction);\n        // The IndexedDb implementation in Chrome (and Firefox) does not handle\n        // compound indices that include auto-generated keys correctly. To ensure\n        // that the index entry is added correctly in all browsers, we perform two\n        // writes: The first write is used to retrieve the next auto-generated Batch\n        // ID, and the second write populates the index and stores the actual\n        // mutation batch.\n        // See: https://bugs.chromium.org/p/chromium/issues/detail?id=701972\n        // We write an empty object to obtain key\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return mutationStore.add({}).next(batchId => {\n            hardAssert(typeof batchId === 'number');\n            const batch = new MutationBatch(batchId, localWriteTime, baseMutations, mutations);\n            const dbBatch = toDbMutationBatch(this.serializer, this.userId, batch);\n            const promises = [];\n            let collectionParents = new SortedSet((l, r) => primitiveComparator(l.canonicalString(), r.canonicalString()));\n            for (const mutation of mutations) {\n                const indexKey = newDbDocumentMutationKey(this.userId, mutation.key.path, batchId);\n                collectionParents = collectionParents.add(mutation.key.path.popLast());\n                promises.push(mutationStore.put(dbBatch));\n                promises.push(documentStore.put(indexKey, DbDocumentMutationPlaceholder));\n            }\n            collectionParents.forEach(parent => {\n                promises.push(this.indexManager.addToCollectionParentIndex(transaction, parent));\n            });\n            transaction.addOnCommittedListener(() => {\n                this.documentKeysByBatchId[batchId] = batch.keys();\n            });\n            return PersistencePromise.waitFor(promises).next(() => batch);\n        });\n    }\n    lookupMutationBatch(transaction, batchId) {\n        return mutationsStore(transaction)\n            .get(batchId)\n            .next(dbBatch => {\n            if (dbBatch) {\n                hardAssert(dbBatch.userId === this.userId);\n                return fromDbMutationBatch(this.serializer, dbBatch);\n            }\n            return null;\n        });\n    }\n    /**\n     * Returns the document keys for the mutation batch with the given batchId.\n     * For primary clients, this method returns `null` after\n     * `removeMutationBatches()` has been called. Secondary clients return a\n     * cached result until `removeCachedMutationKeys()` is invoked.\n     */\n    // PORTING NOTE: Multi-tab only.\n    lookupMutationKeys(transaction, batchId) {\n        if (this.documentKeysByBatchId[batchId]) {\n            return PersistencePromise.resolve(this.documentKeysByBatchId[batchId]);\n        }\n        else {\n            return this.lookupMutationBatch(transaction, batchId).next(batch => {\n                if (batch) {\n                    const keys = batch.keys();\n                    this.documentKeysByBatchId[batchId] = keys;\n                    return keys;\n                }\n                else {\n                    return null;\n                }\n            });\n        }\n    }\n    getNextMutationBatchAfterBatchId(transaction, batchId) {\n        const nextBatchId = batchId + 1;\n        const range = IDBKeyRange.lowerBound([this.userId, nextBatchId]);\n        let foundBatch = null;\n        return mutationsStore(transaction)\n            .iterate({ index: DbMutationBatchUserMutationsIndex, range }, (key, dbBatch, control) => {\n            if (dbBatch.userId === this.userId) {\n                hardAssert(dbBatch.batchId >= nextBatchId);\n                foundBatch = fromDbMutationBatch(this.serializer, dbBatch);\n            }\n            control.done();\n        })\n            .next(() => foundBatch);\n    }\n    getHighestUnacknowledgedBatchId(transaction) {\n        const range = IDBKeyRange.upperBound([\n            this.userId,\n            Number.POSITIVE_INFINITY\n        ]);\n        let batchId = BATCHID_UNKNOWN;\n        return mutationsStore(transaction)\n            .iterate({ index: DbMutationBatchUserMutationsIndex, range, reverse: true }, (key, dbBatch, control) => {\n            batchId = dbBatch.batchId;\n            control.done();\n        })\n            .next(() => batchId);\n    }\n    getAllMutationBatches(transaction) {\n        const range = IDBKeyRange.bound([this.userId, BATCHID_UNKNOWN], [this.userId, Number.POSITIVE_INFINITY]);\n        return mutationsStore(transaction)\n            .loadAll(DbMutationBatchUserMutationsIndex, range)\n            .next(dbBatches => dbBatches.map(dbBatch => fromDbMutationBatch(this.serializer, dbBatch)));\n    }\n    getAllMutationBatchesAffectingDocumentKey(transaction, documentKey) {\n        // Scan the document-mutation index starting with a prefix starting with\n        // the given documentKey.\n        const indexPrefix = newDbDocumentMutationPrefixForPath(this.userId, documentKey.path);\n        const indexStart = IDBKeyRange.lowerBound(indexPrefix);\n        const results = [];\n        return documentMutationsStore(transaction)\n            .iterate({ range: indexStart }, (indexKey, _, control) => {\n            const [userID, encodedPath, batchId] = indexKey;\n            // Only consider rows matching exactly the specific key of\n            // interest. Note that because we order by path first, and we\n            // order terminators before path separators, we'll encounter all\n            // the index rows for documentKey contiguously. In particular, all\n            // the rows for documentKey will occur before any rows for\n            // documents nested in a subcollection beneath documentKey so we\n            // can stop as soon as we hit any such row.\n            const path = decodeResourcePath(encodedPath);\n            if (userID !== this.userId || !documentKey.path.isEqual(path)) {\n                control.done();\n                return;\n            }\n            // Look up the mutation batch in the store.\n            return mutationsStore(transaction)\n                .get(batchId)\n                .next(mutation => {\n                if (!mutation) {\n                    throw fail();\n                }\n                hardAssert(mutation.userId === this.userId);\n                results.push(fromDbMutationBatch(this.serializer, mutation));\n            });\n        })\n            .next(() => results);\n    }\n    getAllMutationBatchesAffectingDocumentKeys(transaction, documentKeys) {\n        let uniqueBatchIDs = new SortedSet(primitiveComparator);\n        const promises = [];\n        documentKeys.forEach(documentKey => {\n            const indexStart = newDbDocumentMutationPrefixForPath(this.userId, documentKey.path);\n            const range = IDBKeyRange.lowerBound(indexStart);\n            const promise = documentMutationsStore(transaction).iterate({ range }, (indexKey, _, control) => {\n                const [userID, encodedPath, batchID] = indexKey;\n                // Only consider rows matching exactly the specific key of\n                // interest. Note that because we order by path first, and we\n                // order terminators before path separators, we'll encounter all\n                // the index rows for documentKey contiguously. In particular, all\n                // the rows for documentKey will occur before any rows for\n                // documents nested in a subcollection beneath documentKey so we\n                // can stop as soon as we hit any such row.\n                const path = decodeResourcePath(encodedPath);\n                if (userID !== this.userId || !documentKey.path.isEqual(path)) {\n                    control.done();\n                    return;\n                }\n                uniqueBatchIDs = uniqueBatchIDs.add(batchID);\n            });\n            promises.push(promise);\n        });\n        return PersistencePromise.waitFor(promises).next(() => this.lookupMutationBatches(transaction, uniqueBatchIDs));\n    }\n    getAllMutationBatchesAffectingQuery(transaction, query) {\n        const queryPath = query.path;\n        const immediateChildrenLength = queryPath.length + 1;\n        // TODO(mcg): Actually implement a single-collection query\n        //\n        // This is actually executing an ancestor query, traversing the whole\n        // subtree below the collection which can be horrifically inefficient for\n        // some structures. The right way to solve this is to implement the full\n        // value index, but that's not in the cards in the near future so this is\n        // the best we can do for the moment.\n        //\n        // Since we don't yet index the actual properties in the mutations, our\n        // current approach is to just return all mutation batches that affect\n        // documents in the collection being queried.\n        const indexPrefix = newDbDocumentMutationPrefixForPath(this.userId, queryPath);\n        const indexStart = IDBKeyRange.lowerBound(indexPrefix);\n        // Collect up unique batchIDs encountered during a scan of the index. Use a\n        // SortedSet to accumulate batch IDs so they can be traversed in order in a\n        // scan of the main table.\n        let uniqueBatchIDs = new SortedSet(primitiveComparator);\n        return documentMutationsStore(transaction)\n            .iterate({ range: indexStart }, (indexKey, _, control) => {\n            const [userID, encodedPath, batchID] = indexKey;\n            const path = decodeResourcePath(encodedPath);\n            if (userID !== this.userId || !queryPath.isPrefixOf(path)) {\n                control.done();\n                return;\n            }\n            // Rows with document keys more than one segment longer than the\n            // query path can't be matches. For example, a query on 'rooms'\n            // can't match the document /rooms/abc/messages/xyx.\n            // TODO(mcg): we'll need a different scanner when we implement\n            // ancestor queries.\n            if (path.length !== immediateChildrenLength) {\n                return;\n            }\n            uniqueBatchIDs = uniqueBatchIDs.add(batchID);\n        })\n            .next(() => this.lookupMutationBatches(transaction, uniqueBatchIDs));\n    }\n    lookupMutationBatches(transaction, batchIDs) {\n        const results = [];\n        const promises = [];\n        // TODO(rockwood): Implement this using iterate.\n        batchIDs.forEach(batchId => {\n            promises.push(mutationsStore(transaction)\n                .get(batchId)\n                .next(mutation => {\n                if (mutation === null) {\n                    throw fail();\n                }\n                hardAssert(mutation.userId === this.userId);\n                results.push(fromDbMutationBatch(this.serializer, mutation));\n            }));\n        });\n        return PersistencePromise.waitFor(promises).next(() => results);\n    }\n    removeMutationBatch(transaction, batch) {\n        return removeMutationBatch(transaction.simpleDbTransaction, this.userId, batch).next(removedDocuments => {\n            transaction.addOnCommittedListener(() => {\n                this.removeCachedMutationKeys(batch.batchId);\n            });\n            return PersistencePromise.forEach(removedDocuments, (key) => {\n                return this.referenceDelegate.markPotentiallyOrphaned(transaction, key);\n            });\n        });\n    }\n    /**\n     * Clears the cached keys for a mutation batch. This method should be\n     * called by secondary clients after they process mutation updates.\n     *\n     * Note that this method does not have to be called from primary clients as\n     * the corresponding cache entries are cleared when an acknowledged or\n     * rejected batch is removed from the mutation queue.\n     */\n    // PORTING NOTE: Multi-tab only\n    removeCachedMutationKeys(batchId) {\n        delete this.documentKeysByBatchId[batchId];\n    }\n    performConsistencyCheck(txn) {\n        return this.checkEmpty(txn).next(empty => {\n            if (!empty) {\n                return PersistencePromise.resolve();\n            }\n            // Verify that there are no entries in the documentMutations index if\n            // the queue is empty.\n            const startRange = IDBKeyRange.lowerBound(newDbDocumentMutationPrefixForUser(this.userId));\n            const danglingMutationReferences = [];\n            return documentMutationsStore(txn)\n                .iterate({ range: startRange }, (key, _, control) => {\n                const userID = key[0];\n                if (userID !== this.userId) {\n                    control.done();\n                    return;\n                }\n                else {\n                    const path = decodeResourcePath(key[1]);\n                    danglingMutationReferences.push(path);\n                }\n            })\n                .next(() => {\n                hardAssert(danglingMutationReferences.length === 0);\n            });\n        });\n    }\n    containsKey(txn, key) {\n        return mutationQueueContainsKey(txn, this.userId, key);\n    }\n    // PORTING NOTE: Multi-tab only (state is held in memory in other clients).\n    /** Returns the mutation queue's metadata from IndexedDb. */\n    getMutationQueueMetadata(transaction) {\n        return mutationQueuesStore(transaction)\n            .get(this.userId)\n            .next((metadata) => {\n            return (metadata || {\n                userId: this.userId,\n                lastAcknowledgedBatchId: BATCHID_UNKNOWN,\n                lastStreamToken: ''\n            });\n        });\n    }\n}\n/**\n * @returns true if the mutation queue for the given user contains a pending\n *         mutation for the given key.\n */\nfunction mutationQueueContainsKey(txn, userId, key) {\n    const indexKey = newDbDocumentMutationPrefixForPath(userId, key.path);\n    const encodedPath = indexKey[1];\n    const startRange = IDBKeyRange.lowerBound(indexKey);\n    let containsKey = false;\n    return documentMutationsStore(txn)\n        .iterate({ range: startRange, keysOnly: true }, (key, value, control) => {\n        const [userID, keyPath, /*batchID*/ _] = key;\n        if (userID === userId && keyPath === encodedPath) {\n            containsKey = true;\n        }\n        control.done();\n    })\n        .next(() => containsKey);\n}\n/** Returns true if any mutation queue contains the given document. */\nfunction mutationQueuesContainKey(txn, docKey) {\n    let found = false;\n    return mutationQueuesStore(txn)\n        .iterateSerial(userId => {\n        return mutationQueueContainsKey(txn, userId, docKey).next(containsKey => {\n            if (containsKey) {\n                found = true;\n            }\n            return PersistencePromise.resolve(!containsKey);\n        });\n    })\n        .next(() => found);\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutations object store.\n */\nfunction mutationsStore(txn) {\n    return getStore(txn, DbMutationBatchStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\n */\nfunction documentMutationsStore(txn) {\n    return getStore(txn, DbDocumentMutationStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\n */\nfunction mutationQueuesStore(txn) {\n    return getStore(txn, DbMutationQueueStore);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Offset to ensure non-overlapping target ids. */\nconst OFFSET = 2;\n/**\n * Generates monotonically increasing target IDs for sending targets to the\n * watch stream.\n *\n * The client constructs two generators, one for the target cache, and one for\n * for the sync engine (to generate limbo documents targets). These\n * generators produce non-overlapping IDs (by using even and odd IDs\n * respectively).\n *\n * By separating the target ID space, the query cache can generate target IDs\n * that persist across client restarts, while sync engine can independently\n * generate in-memory target IDs that are transient and can be reused after a\n * restart.\n */\nclass TargetIdGenerator {\n    constructor(lastId) {\n        this.lastId = lastId;\n    }\n    next() {\n        this.lastId += OFFSET;\n        return this.lastId;\n    }\n    static forTargetCache() {\n        // The target cache generator must return '2' in its first call to `next()`\n        // as there is no differentiation in the protocol layer between an unset\n        // number and the number '0'. If we were to sent a target with target ID\n        // '0', the backend would consider it unset and replace it with its own ID.\n        return new TargetIdGenerator(2 - OFFSET);\n    }\n    static forSyncEngine() {\n        // Sync engine assigns target IDs for limbo document detection.\n        return new TargetIdGenerator(1 - OFFSET);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass IndexedDbTargetCache {\n    constructor(referenceDelegate, serializer) {\n        this.referenceDelegate = referenceDelegate;\n        this.serializer = serializer;\n    }\n    // PORTING NOTE: We don't cache global metadata for the target cache, since\n    // some of it (in particular `highestTargetId`) can be modified by secondary\n    // tabs. We could perhaps be more granular (and e.g. still cache\n    // `lastRemoteSnapshotVersion` in memory) but for simplicity we currently go\n    // to IndexedDb whenever we need to read metadata. We can revisit if it turns\n    // out to have a meaningful performance impact.\n    allocateTargetId(transaction) {\n        return this.retrieveMetadata(transaction).next(metadata => {\n            const targetIdGenerator = new TargetIdGenerator(metadata.highestTargetId);\n            metadata.highestTargetId = targetIdGenerator.next();\n            return this.saveMetadata(transaction, metadata).next(() => metadata.highestTargetId);\n        });\n    }\n    getLastRemoteSnapshotVersion(transaction) {\n        return this.retrieveMetadata(transaction).next(metadata => {\n            return SnapshotVersion.fromTimestamp(new Timestamp(metadata.lastRemoteSnapshotVersion.seconds, metadata.lastRemoteSnapshotVersion.nanoseconds));\n        });\n    }\n    getHighestSequenceNumber(transaction) {\n        return this.retrieveMetadata(transaction).next(targetGlobal => targetGlobal.highestListenSequenceNumber);\n    }\n    setTargetsMetadata(transaction, highestListenSequenceNumber, lastRemoteSnapshotVersion) {\n        return this.retrieveMetadata(transaction).next(metadata => {\n            metadata.highestListenSequenceNumber = highestListenSequenceNumber;\n            if (lastRemoteSnapshotVersion) {\n                metadata.lastRemoteSnapshotVersion =\n                    lastRemoteSnapshotVersion.toTimestamp();\n            }\n            if (highestListenSequenceNumber > metadata.highestListenSequenceNumber) {\n                metadata.highestListenSequenceNumber = highestListenSequenceNumber;\n            }\n            return this.saveMetadata(transaction, metadata);\n        });\n    }\n    addTargetData(transaction, targetData) {\n        return this.saveTargetData(transaction, targetData).next(() => {\n            return this.retrieveMetadata(transaction).next(metadata => {\n                metadata.targetCount += 1;\n                this.updateMetadataFromTargetData(targetData, metadata);\n                return this.saveMetadata(transaction, metadata);\n            });\n        });\n    }\n    updateTargetData(transaction, targetData) {\n        return this.saveTargetData(transaction, targetData);\n    }\n    removeTargetData(transaction, targetData) {\n        return this.removeMatchingKeysForTargetId(transaction, targetData.targetId)\n            .next(() => targetsStore(transaction).delete(targetData.targetId))\n            .next(() => this.retrieveMetadata(transaction))\n            .next(metadata => {\n            hardAssert(metadata.targetCount > 0);\n            metadata.targetCount -= 1;\n            return this.saveMetadata(transaction, metadata);\n        });\n    }\n    /**\n     * Drops any targets with sequence number less than or equal to the upper bound, excepting those\n     * present in `activeTargetIds`. Document associations for the removed targets are also removed.\n     * Returns the number of targets removed.\n     */\n    removeTargets(txn, upperBound, activeTargetIds) {\n        let count = 0;\n        const promises = [];\n        return targetsStore(txn)\n            .iterate((key, value) => {\n            const targetData = fromDbTarget(value);\n            if (targetData.sequenceNumber <= upperBound &&\n                activeTargetIds.get(targetData.targetId) === null) {\n                count++;\n                promises.push(this.removeTargetData(txn, targetData));\n            }\n        })\n            .next(() => PersistencePromise.waitFor(promises))\n            .next(() => count);\n    }\n    /**\n     * Call provided function with each `TargetData` that we have cached.\n     */\n    forEachTarget(txn, f) {\n        return targetsStore(txn).iterate((key, value) => {\n            const targetData = fromDbTarget(value);\n            f(targetData);\n        });\n    }\n    retrieveMetadata(transaction) {\n        return globalTargetStore(transaction)\n            .get(DbTargetGlobalKey)\n            .next(metadata => {\n            hardAssert(metadata !== null);\n            return metadata;\n        });\n    }\n    saveMetadata(transaction, metadata) {\n        return globalTargetStore(transaction).put(DbTargetGlobalKey, metadata);\n    }\n    saveTargetData(transaction, targetData) {\n        return targetsStore(transaction).put(toDbTarget(this.serializer, targetData));\n    }\n    /**\n     * In-place updates the provided metadata to account for values in the given\n     * TargetData. Saving is done separately. Returns true if there were any\n     * changes to the metadata.\n     */\n    updateMetadataFromTargetData(targetData, metadata) {\n        let updated = false;\n        if (targetData.targetId > metadata.highestTargetId) {\n            metadata.highestTargetId = targetData.targetId;\n            updated = true;\n        }\n        if (targetData.sequenceNumber > metadata.highestListenSequenceNumber) {\n            metadata.highestListenSequenceNumber = targetData.sequenceNumber;\n            updated = true;\n        }\n        return updated;\n    }\n    getTargetCount(transaction) {\n        return this.retrieveMetadata(transaction).next(metadata => metadata.targetCount);\n    }\n    getTargetData(transaction, target) {\n        // Iterating by the canonicalId may yield more than one result because\n        // canonicalId values are not required to be unique per target. This query\n        // depends on the queryTargets index to be efficient.\n        const canonicalId = canonifyTarget(target);\n        const range = IDBKeyRange.bound([canonicalId, Number.NEGATIVE_INFINITY], [canonicalId, Number.POSITIVE_INFINITY]);\n        let result = null;\n        return targetsStore(transaction)\n            .iterate({ range, index: DbTargetQueryTargetsIndexName }, (key, value, control) => {\n            const found = fromDbTarget(value);\n            // After finding a potential match, check that the target is\n            // actually equal to the requested target.\n            if (targetEquals(target, found.target)) {\n                result = found;\n                control.done();\n            }\n        })\n            .next(() => result);\n    }\n    addMatchingKeys(txn, keys, targetId) {\n        // PORTING NOTE: The reverse index (documentsTargets) is maintained by\n        // IndexedDb.\n        const promises = [];\n        const store = documentTargetStore(txn);\n        keys.forEach(key => {\n            const path = encodeResourcePath(key.path);\n            promises.push(store.put({ targetId, path }));\n            promises.push(this.referenceDelegate.addReference(txn, targetId, key));\n        });\n        return PersistencePromise.waitFor(promises);\n    }\n    removeMatchingKeys(txn, keys, targetId) {\n        // PORTING NOTE: The reverse index (documentsTargets) is maintained by\n        // IndexedDb.\n        const store = documentTargetStore(txn);\n        return PersistencePromise.forEach(keys, (key) => {\n            const path = encodeResourcePath(key.path);\n            return PersistencePromise.waitFor([\n                store.delete([targetId, path]),\n                this.referenceDelegate.removeReference(txn, targetId, key)\n            ]);\n        });\n    }\n    removeMatchingKeysForTargetId(txn, targetId) {\n        const store = documentTargetStore(txn);\n        const range = IDBKeyRange.bound([targetId], [targetId + 1], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        return store.delete(range);\n    }\n    getMatchingKeysForTargetId(txn, targetId) {\n        const range = IDBKeyRange.bound([targetId], [targetId + 1], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        const store = documentTargetStore(txn);\n        let result = documentKeySet();\n        return store\n            .iterate({ range, keysOnly: true }, (key, _, control) => {\n            const path = decodeResourcePath(key[1]);\n            const docKey = new DocumentKey(path);\n            result = result.add(docKey);\n        })\n            .next(() => result);\n    }\n    containsKey(txn, key) {\n        const path = encodeResourcePath(key.path);\n        const range = IDBKeyRange.bound([path], [immediateSuccessor(path)], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        let count = 0;\n        return documentTargetStore(txn)\n            .iterate({\n            index: DbTargetDocumentDocumentTargetsIndex,\n            keysOnly: true,\n            range\n        }, ([targetId, path], _, control) => {\n            // Having a sentinel row for a document does not count as containing that document;\n            // For the target cache, containing the document means the document is part of some\n            // target.\n            if (targetId !== 0) {\n                count++;\n                control.done();\n            }\n        })\n            .next(() => count > 0);\n    }\n    /**\n     * Looks up a TargetData entry by target ID.\n     *\n     * @param targetId - The target ID of the TargetData entry to look up.\n     * @returns The cached TargetData entry, or null if the cache has no entry for\n     * the target.\n     */\n    // PORTING NOTE: Multi-tab only.\n    getTargetDataForTarget(transaction, targetId) {\n        return targetsStore(transaction)\n            .get(targetId)\n            .next(found => {\n            if (found) {\n                return fromDbTarget(found);\n            }\n            else {\n                return null;\n            }\n        });\n    }\n}\n/**\n * Helper to get a typed SimpleDbStore for the queries object store.\n */\nfunction targetsStore(txn) {\n    return getStore(txn, DbTargetStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the target globals object store.\n */\nfunction globalTargetStore(txn) {\n    return getStore(txn, DbTargetGlobalStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the document target object store.\n */\nfunction documentTargetStore(txn) {\n    return getStore(txn, DbTargetDocumentStore);\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst GC_DID_NOT_RUN = {\n    didRun: false,\n    sequenceNumbersCollected: 0,\n    targetsRemoved: 0,\n    documentsRemoved: 0\n};\nconst LRU_COLLECTION_DISABLED = -1;\nconst LRU_DEFAULT_CACHE_SIZE_BYTES = 40 * 1024 * 1024;\nclass LruParams {\n    static withCacheSize(cacheSize) {\n        return new LruParams(cacheSize, LruParams.DEFAULT_COLLECTION_PERCENTILE, LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);\n    }\n    constructor(\n    // When we attempt to collect, we will only do so if the cache size is greater than this\n    // threshold. Passing `COLLECTION_DISABLED` here will cause collection to always be skipped.\n    cacheSizeCollectionThreshold, \n    // The percentage of sequence numbers that we will attempt to collect\n    percentileToCollect, \n    // A cap on the total number of sequence numbers that will be collected. This prevents\n    // us from collecting a huge number of sequence numbers if the cache has grown very large.\n    maximumSequenceNumbersToCollect) {\n        this.cacheSizeCollectionThreshold = cacheSizeCollectionThreshold;\n        this.percentileToCollect = percentileToCollect;\n        this.maximumSequenceNumbersToCollect = maximumSequenceNumbersToCollect;\n    }\n}\nLruParams.DEFAULT_COLLECTION_PERCENTILE = 10;\nLruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1000;\nLruParams.DEFAULT = new LruParams(LRU_DEFAULT_CACHE_SIZE_BYTES, LruParams.DEFAULT_COLLECTION_PERCENTILE, LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);\nLruParams.DISABLED = new LruParams(LRU_COLLECTION_DISABLED, 0, 0);\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$e = 'LruGarbageCollector';\nconst LRU_MINIMUM_CACHE_SIZE_BYTES = 1 * 1024 * 1024;\n/** How long we wait to try running LRU GC after SDK initialization. */\nconst INITIAL_GC_DELAY_MS = 1 * 60 * 1000;\n/** Minimum amount of time between GC checks, after the first one. */\nconst REGULAR_GC_DELAY_MS = 5 * 60 * 1000;\nfunction bufferEntryComparator([aSequence, aIndex], [bSequence, bIndex]) {\n    const seqCmp = primitiveComparator(aSequence, bSequence);\n    if (seqCmp === 0) {\n        // This order doesn't matter, but we can bias against churn by sorting\n        // entries created earlier as less than newer entries.\n        return primitiveComparator(aIndex, bIndex);\n    }\n    else {\n        return seqCmp;\n    }\n}\n/**\n * Used to calculate the nth sequence number. Keeps a rolling buffer of the\n * lowest n values passed to `addElement`, and finally reports the largest of\n * them in `maxValue`.\n */\nclass RollingSequenceNumberBuffer {\n    constructor(maxElements) {\n        this.maxElements = maxElements;\n        this.buffer = new SortedSet(bufferEntryComparator);\n        this.previousIndex = 0;\n    }\n    nextIndex() {\n        return ++this.previousIndex;\n    }\n    addElement(sequenceNumber) {\n        const entry = [sequenceNumber, this.nextIndex()];\n        if (this.buffer.size < this.maxElements) {\n            this.buffer = this.buffer.add(entry);\n        }\n        else {\n            const highestValue = this.buffer.last();\n            if (bufferEntryComparator(entry, highestValue) < 0) {\n                this.buffer = this.buffer.delete(highestValue).add(entry);\n            }\n        }\n    }\n    get maxValue() {\n        // Guaranteed to be non-empty. If we decide we are not collecting any\n        // sequence numbers, nthSequenceNumber below short-circuits. If we have\n        // decided that we are collecting n sequence numbers, it's because n is some\n        // percentage of the existing sequence numbers. That means we should never\n        // be in a situation where we are collecting sequence numbers but don't\n        // actually have any.\n        return this.buffer.last()[0];\n    }\n}\n/**\n * This class is responsible for the scheduling of LRU garbage collection. It handles checking\n * whether or not GC is enabled, as well as which delay to use before the next run.\n */\nclass LruScheduler {\n    constructor(garbageCollector, asyncQueue, localStore) {\n        this.garbageCollector = garbageCollector;\n        this.asyncQueue = asyncQueue;\n        this.localStore = localStore;\n        this.gcTask = null;\n    }\n    start() {\n        if (this.garbageCollector.params.cacheSizeCollectionThreshold !==\n            LRU_COLLECTION_DISABLED) {\n            this.scheduleGC(INITIAL_GC_DELAY_MS);\n        }\n    }\n    stop() {\n        if (this.gcTask) {\n            this.gcTask.cancel();\n            this.gcTask = null;\n        }\n    }\n    get started() {\n        return this.gcTask !== null;\n    }\n    scheduleGC(delay) {\n        logDebug(LOG_TAG$e, `Garbage collection scheduled in ${delay}ms`);\n        this.gcTask = this.asyncQueue.enqueueAfterDelay(\"lru_garbage_collection\" /* TimerId.LruGarbageCollection */, delay, async () => {\n            this.gcTask = null;\n            try {\n                await this.localStore.collectGarbage(this.garbageCollector);\n            }\n            catch (e) {\n                if (isIndexedDbTransactionError(e)) {\n                    logDebug(LOG_TAG$e, 'Ignoring IndexedDB error during garbage collection: ', e);\n                }\n                else {\n                    await ignoreIfPrimaryLeaseLoss(e);\n                }\n            }\n            await this.scheduleGC(REGULAR_GC_DELAY_MS);\n        });\n    }\n}\n/**\n * Implements the steps for LRU garbage collection.\n */\nclass LruGarbageCollectorImpl {\n    constructor(delegate, params) {\n        this.delegate = delegate;\n        this.params = params;\n    }\n    calculateTargetCount(txn, percentile) {\n        return this.delegate.getSequenceNumberCount(txn).next(targetCount => {\n            return Math.floor((percentile / 100.0) * targetCount);\n        });\n    }\n    nthSequenceNumber(txn, n) {\n        if (n === 0) {\n            return PersistencePromise.resolve(ListenSequence.INVALID);\n        }\n        const buffer = new RollingSequenceNumberBuffer(n);\n        return this.delegate\n            .forEachTarget(txn, target => buffer.addElement(target.sequenceNumber))\n            .next(() => {\n            return this.delegate.forEachOrphanedDocumentSequenceNumber(txn, sequenceNumber => buffer.addElement(sequenceNumber));\n        })\n            .next(() => buffer.maxValue);\n    }\n    removeTargets(txn, upperBound, activeTargetIds) {\n        return this.delegate.removeTargets(txn, upperBound, activeTargetIds);\n    }\n    removeOrphanedDocuments(txn, upperBound) {\n        return this.delegate.removeOrphanedDocuments(txn, upperBound);\n    }\n    collect(txn, activeTargetIds) {\n        if (this.params.cacheSizeCollectionThreshold === LRU_COLLECTION_DISABLED) {\n            logDebug('LruGarbageCollector', 'Garbage collection skipped; disabled');\n            return PersistencePromise.resolve(GC_DID_NOT_RUN);\n        }\n        return this.getCacheSize(txn).next(cacheSize => {\n            if (cacheSize < this.params.cacheSizeCollectionThreshold) {\n                logDebug('LruGarbageCollector', `Garbage collection skipped; Cache size ${cacheSize} ` +\n                    `is lower than threshold ${this.params.cacheSizeCollectionThreshold}`);\n                return GC_DID_NOT_RUN;\n            }\n            else {\n                return this.runGarbageCollection(txn, activeTargetIds);\n            }\n        });\n    }\n    getCacheSize(txn) {\n        return this.delegate.getCacheSize(txn);\n    }\n    runGarbageCollection(txn, activeTargetIds) {\n        let upperBoundSequenceNumber;\n        let sequenceNumbersToCollect, targetsRemoved;\n        // Timestamps for various pieces of the process\n        let countedTargetsTs, foundUpperBoundTs, removedTargetsTs, removedDocumentsTs;\n        const startTs = Date.now();\n        return this.calculateTargetCount(txn, this.params.percentileToCollect)\n            .next(sequenceNumbers => {\n            // Cap at the configured max\n            if (sequenceNumbers > this.params.maximumSequenceNumbersToCollect) {\n                logDebug('LruGarbageCollector', 'Capping sequence numbers to collect down ' +\n                    `to the maximum of ${this.params.maximumSequenceNumbersToCollect} ` +\n                    `from ${sequenceNumbers}`);\n                sequenceNumbersToCollect =\n                    this.params.maximumSequenceNumbersToCollect;\n            }\n            else {\n                sequenceNumbersToCollect = sequenceNumbers;\n            }\n            countedTargetsTs = Date.now();\n            return this.nthSequenceNumber(txn, sequenceNumbersToCollect);\n        })\n            .next(upperBound => {\n            upperBoundSequenceNumber = upperBound;\n            foundUpperBoundTs = Date.now();\n            return this.removeTargets(txn, upperBoundSequenceNumber, activeTargetIds);\n        })\n            .next(numTargetsRemoved => {\n            targetsRemoved = numTargetsRemoved;\n            removedTargetsTs = Date.now();\n            return this.removeOrphanedDocuments(txn, upperBoundSequenceNumber);\n        })\n            .next(documentsRemoved => {\n            removedDocumentsTs = Date.now();\n            if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\n                const desc = 'LRU Garbage Collection\\n' +\n                    `\\tCounted targets in ${countedTargetsTs - startTs}ms\\n` +\n                    `\\tDetermined least recently used ${sequenceNumbersToCollect} in ` +\n                    `${foundUpperBoundTs - countedTargetsTs}ms\\n` +\n                    `\\tRemoved ${targetsRemoved} targets in ` +\n                    `${removedTargetsTs - foundUpperBoundTs}ms\\n` +\n                    `\\tRemoved ${documentsRemoved} documents in ` +\n                    `${removedDocumentsTs - removedTargetsTs}ms\\n` +\n                    `Total Duration: ${removedDocumentsTs - startTs}ms`;\n                logDebug('LruGarbageCollector', desc);\n            }\n            return PersistencePromise.resolve({\n                didRun: true,\n                sequenceNumbersCollected: sequenceNumbersToCollect,\n                targetsRemoved,\n                documentsRemoved\n            });\n        });\n    }\n}\nfunction newLruGarbageCollector(delegate, params) {\n    return new LruGarbageCollectorImpl(delegate, params);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Provides LRU functionality for IndexedDB persistence. */\nclass IndexedDbLruDelegateImpl {\n    constructor(db, params) {\n        this.db = db;\n        this.garbageCollector = newLruGarbageCollector(this, params);\n    }\n    getSequenceNumberCount(txn) {\n        const docCountPromise = this.orphanedDocumentCount(txn);\n        const targetCountPromise = this.db.getTargetCache().getTargetCount(txn);\n        return targetCountPromise.next(targetCount => docCountPromise.next(docCount => targetCount + docCount));\n    }\n    orphanedDocumentCount(txn) {\n        let orphanedCount = 0;\n        return this.forEachOrphanedDocumentSequenceNumber(txn, _ => {\n            orphanedCount++;\n        }).next(() => orphanedCount);\n    }\n    forEachTarget(txn, f) {\n        return this.db.getTargetCache().forEachTarget(txn, f);\n    }\n    forEachOrphanedDocumentSequenceNumber(txn, f) {\n        return this.forEachOrphanedDocument(txn, (docKey, sequenceNumber) => f(sequenceNumber));\n    }\n    addReference(txn, targetId, key) {\n        return writeSentinelKey(txn, key);\n    }\n    removeReference(txn, targetId, key) {\n        return writeSentinelKey(txn, key);\n    }\n    removeTargets(txn, upperBound, activeTargetIds) {\n        return this.db.getTargetCache().removeTargets(txn, upperBound, activeTargetIds);\n    }\n    markPotentiallyOrphaned(txn, key) {\n        return writeSentinelKey(txn, key);\n    }\n    /**\n     * Returns true if anything would prevent this document from being garbage\n     * collected, given that the document in question is not present in any\n     * targets and has a sequence number less than or equal to the upper bound for\n     * the collection run.\n     */\n    isPinned(txn, docKey) {\n        return mutationQueuesContainKey(txn, docKey);\n    }\n    removeOrphanedDocuments(txn, upperBound) {\n        const documentCache = this.db.getRemoteDocumentCache();\n        const changeBuffer = documentCache.newChangeBuffer();\n        const promises = [];\n        let documentCount = 0;\n        const iteration = this.forEachOrphanedDocument(txn, (docKey, sequenceNumber) => {\n            if (sequenceNumber <= upperBound) {\n                const p = this.isPinned(txn, docKey).next(isPinned => {\n                    if (!isPinned) {\n                        documentCount++;\n                        // Our size accounting requires us to read all documents before\n                        // removing them.\n                        return changeBuffer.getEntry(txn, docKey).next(() => {\n                            changeBuffer.removeEntry(docKey, SnapshotVersion.min());\n                            return documentTargetStore(txn).delete(sentinelKey$1(docKey));\n                        });\n                    }\n                });\n                promises.push(p);\n            }\n        });\n        return iteration\n            .next(() => PersistencePromise.waitFor(promises))\n            .next(() => changeBuffer.apply(txn))\n            .next(() => documentCount);\n    }\n    removeTarget(txn, targetData) {\n        const updated = targetData.withSequenceNumber(txn.currentSequenceNumber);\n        return this.db.getTargetCache().updateTargetData(txn, updated);\n    }\n    updateLimboDocument(txn, key) {\n        return writeSentinelKey(txn, key);\n    }\n    /**\n     * Call provided function for each document in the cache that is 'orphaned'. Orphaned\n     * means not a part of any target, so the only entry in the target-document index for\n     * that document will be the sentinel row (targetId 0), which will also have the sequence\n     * number for the last time the document was accessed.\n     */\n    forEachOrphanedDocument(txn, f) {\n        const store = documentTargetStore(txn);\n        let nextToReport = ListenSequence.INVALID;\n        let nextPath;\n        return store\n            .iterate({\n            index: DbTargetDocumentDocumentTargetsIndex\n        }, ([targetId, docKey], { path, sequenceNumber }) => {\n            if (targetId === 0) {\n                // if nextToReport is valid, report it, this is a new key so the\n                // last one must not be a member of any targets.\n                if (nextToReport !== ListenSequence.INVALID) {\n                    f(new DocumentKey(decodeResourcePath(nextPath)), nextToReport);\n                }\n                // set nextToReport to be this sequence number. It's the next one we\n                // might report, if we don't find any targets for this document.\n                // Note that the sequence number must be defined when the targetId\n                // is 0.\n                nextToReport = sequenceNumber;\n                nextPath = path;\n            }\n            else {\n                // set nextToReport to be invalid, we know we don't need to report\n                // this one since we found a target for it.\n                nextToReport = ListenSequence.INVALID;\n            }\n        })\n            .next(() => {\n            // Since we report sequence numbers after getting to the next key, we\n            // need to check if the last key we iterated over was an orphaned\n            // document and report it.\n            if (nextToReport !== ListenSequence.INVALID) {\n                f(new DocumentKey(decodeResourcePath(nextPath)), nextToReport);\n            }\n        });\n    }\n    getCacheSize(txn) {\n        return this.db.getRemoteDocumentCache().getSize(txn);\n    }\n}\nfunction sentinelKey$1(key) {\n    return [0, encodeResourcePath(key.path)];\n}\n/**\n * @returns A value suitable for writing a sentinel row in the target-document\n * store.\n */\nfunction sentinelRow(key, sequenceNumber) {\n    return { targetId: 0, path: encodeResourcePath(key.path), sequenceNumber };\n}\nfunction writeSentinelKey(txn, key) {\n    return documentTargetStore(txn).put(sentinelRow(key, txn.currentSequenceNumber));\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An in-memory buffer of entries to be written to a RemoteDocumentCache.\n * It can be used to batch up a set of changes to be written to the cache, but\n * additionally supports reading entries back with the `getEntry()` method,\n * falling back to the underlying RemoteDocumentCache if no entry is\n * buffered.\n *\n * Entries added to the cache *must* be read first. This is to facilitate\n * calculating the size delta of the pending changes.\n *\n * PORTING NOTE: This class was implemented then removed from other platforms.\n * If byte-counting ends up being needed on the other platforms, consider\n * porting this class as part of that implementation work.\n */\nclass RemoteDocumentChangeBuffer {\n    constructor() {\n        // A mapping of document key to the new cache entry that should be written.\n        this.changes = new ObjectMap(key => key.toString(), (l, r) => l.isEqual(r));\n        this.changesApplied = false;\n    }\n    /**\n     * Buffers a `RemoteDocumentCache.addEntry()` call.\n     *\n     * You can only modify documents that have already been retrieved via\n     * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).\n     */\n    addEntry(document) {\n        this.assertNotApplied();\n        this.changes.set(document.key, document);\n    }\n    /**\n     * Buffers a `RemoteDocumentCache.removeEntry()` call.\n     *\n     * You can only remove documents that have already been retrieved via\n     * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).\n     */\n    removeEntry(key, readTime) {\n        this.assertNotApplied();\n        this.changes.set(key, MutableDocument.newInvalidDocument(key).setReadTime(readTime));\n    }\n    /**\n     * Looks up an entry in the cache. The buffered changes will first be checked,\n     * and if no buffered change applies, this will forward to\n     * `RemoteDocumentCache.getEntry()`.\n     *\n     * @param transaction - The transaction in which to perform any persistence\n     *     operations.\n     * @param documentKey - The key of the entry to look up.\n     * @returns The cached document or an invalid document if we have nothing\n     * cached.\n     */\n    getEntry(transaction, documentKey) {\n        this.assertNotApplied();\n        const bufferedEntry = this.changes.get(documentKey);\n        if (bufferedEntry !== undefined) {\n            return PersistencePromise.resolve(bufferedEntry);\n        }\n        else {\n            return this.getFromCache(transaction, documentKey);\n        }\n    }\n    /**\n     * Looks up several entries in the cache, forwarding to\n     * `RemoteDocumentCache.getEntry()`.\n     *\n     * @param transaction - The transaction in which to perform any persistence\n     *     operations.\n     * @param documentKeys - The keys of the entries to look up.\n     * @returns A map of cached documents, indexed by key. If an entry cannot be\n     *     found, the corresponding key will be mapped to an invalid document.\n     */\n    getEntries(transaction, documentKeys) {\n        return this.getAllFromCache(transaction, documentKeys);\n    }\n    /**\n     * Applies buffered changes to the underlying RemoteDocumentCache, using\n     * the provided transaction.\n     */\n    apply(transaction) {\n        this.assertNotApplied();\n        this.changesApplied = true;\n        return this.applyChanges(transaction);\n    }\n    /** Helper to assert this.changes is not null  */\n    assertNotApplied() {\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The RemoteDocumentCache for IndexedDb. To construct, invoke\n * `newIndexedDbRemoteDocumentCache()`.\n */\nclass IndexedDbRemoteDocumentCacheImpl {\n    constructor(serializer) {\n        this.serializer = serializer;\n    }\n    setIndexManager(indexManager) {\n        this.indexManager = indexManager;\n    }\n    /**\n     * Adds the supplied entries to the cache.\n     *\n     * All calls of `addEntry` are required to go through the RemoteDocumentChangeBuffer\n     * returned by `newChangeBuffer()` to ensure proper accounting of metadata.\n     */\n    addEntry(transaction, key, doc) {\n        const documentStore = remoteDocumentsStore(transaction);\n        return documentStore.put(doc);\n    }\n    /**\n     * Removes a document from the cache.\n     *\n     * All calls of `removeEntry`  are required to go through the RemoteDocumentChangeBuffer\n     * returned by `newChangeBuffer()` to ensure proper accounting of metadata.\n     */\n    removeEntry(transaction, documentKey, readTime) {\n        const store = remoteDocumentsStore(transaction);\n        return store.delete(dbReadTimeKey(documentKey, readTime));\n    }\n    /**\n     * Updates the current cache size.\n     *\n     * Callers to `addEntry()` and `removeEntry()` *must* call this afterwards to update the\n     * cache's metadata.\n     */\n    updateMetadata(transaction, sizeDelta) {\n        return this.getMetadata(transaction).next(metadata => {\n            metadata.byteSize += sizeDelta;\n            return this.setMetadata(transaction, metadata);\n        });\n    }\n    getEntry(transaction, documentKey) {\n        let doc = MutableDocument.newInvalidDocument(documentKey);\n        return remoteDocumentsStore(transaction)\n            .iterate({\n            index: DbRemoteDocumentDocumentKeyIndex,\n            range: IDBKeyRange.only(dbKey(documentKey))\n        }, (_, dbRemoteDoc) => {\n            doc = this.maybeDecodeDocument(documentKey, dbRemoteDoc);\n        })\n            .next(() => doc);\n    }\n    /**\n     * Looks up an entry in the cache.\n     *\n     * @param documentKey - The key of the entry to look up.\n     * @returns The cached document entry and its size.\n     */\n    getSizedEntry(transaction, documentKey) {\n        let result = {\n            size: 0,\n            document: MutableDocument.newInvalidDocument(documentKey)\n        };\n        return remoteDocumentsStore(transaction)\n            .iterate({\n            index: DbRemoteDocumentDocumentKeyIndex,\n            range: IDBKeyRange.only(dbKey(documentKey))\n        }, (_, dbRemoteDoc) => {\n            result = {\n                document: this.maybeDecodeDocument(documentKey, dbRemoteDoc),\n                size: dbDocumentSize(dbRemoteDoc)\n            };\n        })\n            .next(() => result);\n    }\n    getEntries(transaction, documentKeys) {\n        let results = mutableDocumentMap();\n        return this.forEachDbEntry(transaction, documentKeys, (key, dbRemoteDoc) => {\n            const doc = this.maybeDecodeDocument(key, dbRemoteDoc);\n            results = results.insert(key, doc);\n        }).next(() => results);\n    }\n    /**\n     * Looks up several entries in the cache.\n     *\n     * @param documentKeys - The set of keys entries to look up.\n     * @returns A map of documents indexed by key and a map of sizes indexed by\n     *     key (zero if the document does not exist).\n     */\n    getSizedEntries(transaction, documentKeys) {\n        let results = mutableDocumentMap();\n        let sizeMap = new SortedMap(DocumentKey.comparator);\n        return this.forEachDbEntry(transaction, documentKeys, (key, dbRemoteDoc) => {\n            const doc = this.maybeDecodeDocument(key, dbRemoteDoc);\n            results = results.insert(key, doc);\n            sizeMap = sizeMap.insert(key, dbDocumentSize(dbRemoteDoc));\n        }).next(() => {\n            return { documents: results, sizeMap };\n        });\n    }\n    forEachDbEntry(transaction, documentKeys, callback) {\n        if (documentKeys.isEmpty()) {\n            return PersistencePromise.resolve();\n        }\n        let sortedKeys = new SortedSet(dbKeyComparator);\n        documentKeys.forEach(e => (sortedKeys = sortedKeys.add(e)));\n        const range = IDBKeyRange.bound(dbKey(sortedKeys.first()), dbKey(sortedKeys.last()));\n        const keyIter = sortedKeys.getIterator();\n        let nextKey = keyIter.getNext();\n        return remoteDocumentsStore(transaction)\n            .iterate({ index: DbRemoteDocumentDocumentKeyIndex, range }, (_, dbRemoteDoc, control) => {\n            const potentialKey = DocumentKey.fromSegments([\n                ...dbRemoteDoc.prefixPath,\n                dbRemoteDoc.collectionGroup,\n                dbRemoteDoc.documentId\n            ]);\n            // Go through keys not found in cache.\n            while (nextKey && dbKeyComparator(nextKey, potentialKey) < 0) {\n                callback(nextKey, null);\n                nextKey = keyIter.getNext();\n            }\n            if (nextKey && nextKey.isEqual(potentialKey)) {\n                // Key found in cache.\n                callback(nextKey, dbRemoteDoc);\n                nextKey = keyIter.hasNext() ? keyIter.getNext() : null;\n            }\n            // Skip to the next key (if there is one).\n            if (nextKey) {\n                control.skip(dbKey(nextKey));\n            }\n            else {\n                control.done();\n            }\n        })\n            .next(() => {\n            // The rest of the keys are not in the cache. One case where `iterate`\n            // above won't go through them is when the cache is empty.\n            while (nextKey) {\n                callback(nextKey, null);\n                nextKey = keyIter.hasNext() ? keyIter.getNext() : null;\n            }\n        });\n    }\n    getDocumentsMatchingQuery(transaction, query, offset, mutatedDocs, context) {\n        const collection = query.path;\n        const startKey = [\n            collection.popLast().toArray(),\n            collection.lastSegment(),\n            toDbTimestampKey(offset.readTime),\n            offset.documentKey.path.isEmpty()\n                ? ''\n                : offset.documentKey.path.lastSegment()\n        ];\n        const endKey = [\n            collection.popLast().toArray(),\n            collection.lastSegment(),\n            [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],\n            ''\n        ];\n        return remoteDocumentsStore(transaction)\n            .loadAll(IDBKeyRange.bound(startKey, endKey, true))\n            .next(dbRemoteDocs => {\n            context === null || context === void 0 ? void 0 : context.incrementDocumentReadCount(dbRemoteDocs.length);\n            let results = mutableDocumentMap();\n            for (const dbRemoteDoc of dbRemoteDocs) {\n                const document = this.maybeDecodeDocument(DocumentKey.fromSegments(dbRemoteDoc.prefixPath.concat(dbRemoteDoc.collectionGroup, dbRemoteDoc.documentId)), dbRemoteDoc);\n                if (document.isFoundDocument() &&\n                    (queryMatches(query, document) || mutatedDocs.has(document.key))) {\n                    // Either the document matches the given query, or it is mutated.\n                    results = results.insert(document.key, document);\n                }\n            }\n            return results;\n        });\n    }\n    getAllFromCollectionGroup(transaction, collectionGroup, offset, limit) {\n        let results = mutableDocumentMap();\n        const startKey = dbCollectionGroupKey(collectionGroup, offset);\n        const endKey = dbCollectionGroupKey(collectionGroup, IndexOffset.max());\n        return remoteDocumentsStore(transaction)\n            .iterate({\n            index: DbRemoteDocumentCollectionGroupIndex,\n            range: IDBKeyRange.bound(startKey, endKey, true)\n        }, (_, dbRemoteDoc, control) => {\n            const document = this.maybeDecodeDocument(DocumentKey.fromSegments(dbRemoteDoc.prefixPath.concat(dbRemoteDoc.collectionGroup, dbRemoteDoc.documentId)), dbRemoteDoc);\n            results = results.insert(document.key, document);\n            if (results.size === limit) {\n                control.done();\n            }\n        })\n            .next(() => results);\n    }\n    newChangeBuffer(options) {\n        return new IndexedDbRemoteDocumentChangeBuffer(this, !!options && options.trackRemovals);\n    }\n    getSize(txn) {\n        return this.getMetadata(txn).next(metadata => metadata.byteSize);\n    }\n    getMetadata(txn) {\n        return documentGlobalStore(txn)\n            .get(DbRemoteDocumentGlobalKey)\n            .next(metadata => {\n            hardAssert(!!metadata);\n            return metadata;\n        });\n    }\n    setMetadata(txn, metadata) {\n        return documentGlobalStore(txn).put(DbRemoteDocumentGlobalKey, metadata);\n    }\n    /**\n     * Decodes `dbRemoteDoc` and returns the document (or an invalid document if\n     * the document corresponds to the format used for sentinel deletes).\n     */\n    maybeDecodeDocument(documentKey, dbRemoteDoc) {\n        if (dbRemoteDoc) {\n            const doc = fromDbRemoteDocument(this.serializer, dbRemoteDoc);\n            // Whether the document is a sentinel removal and should only be used in the\n            // `getNewDocumentChanges()`\n            const isSentinelRemoval = doc.isNoDocument() && doc.version.isEqual(SnapshotVersion.min());\n            if (!isSentinelRemoval) {\n                return doc;\n            }\n        }\n        return MutableDocument.newInvalidDocument(documentKey);\n    }\n}\n/** Creates a new IndexedDbRemoteDocumentCache. */\nfunction newIndexedDbRemoteDocumentCache(serializer) {\n    return new IndexedDbRemoteDocumentCacheImpl(serializer);\n}\n/**\n * Handles the details of adding and updating documents in the IndexedDbRemoteDocumentCache.\n *\n * Unlike the MemoryRemoteDocumentChangeBuffer, the IndexedDb implementation computes the size\n * delta for all submitted changes. This avoids having to re-read all documents from IndexedDb\n * when we apply the changes.\n */\nclass IndexedDbRemoteDocumentChangeBuffer extends RemoteDocumentChangeBuffer {\n    /**\n     * @param documentCache - The IndexedDbRemoteDocumentCache to apply the changes to.\n     * @param trackRemovals - Whether to create sentinel deletes that can be tracked by\n     * `getNewDocumentChanges()`.\n     */\n    constructor(documentCache, trackRemovals) {\n        super();\n        this.documentCache = documentCache;\n        this.trackRemovals = trackRemovals;\n        // A map of document sizes and read times prior to applying the changes in\n        // this buffer.\n        this.documentStates = new ObjectMap(key => key.toString(), (l, r) => l.isEqual(r));\n    }\n    applyChanges(transaction) {\n        const promises = [];\n        let sizeDelta = 0;\n        let collectionParents = new SortedSet((l, r) => primitiveComparator(l.canonicalString(), r.canonicalString()));\n        this.changes.forEach((key, documentChange) => {\n            const previousDoc = this.documentStates.get(key);\n            promises.push(this.documentCache.removeEntry(transaction, key, previousDoc.readTime));\n            if (documentChange.isValidDocument()) {\n                const doc = toDbRemoteDocument(this.documentCache.serializer, documentChange);\n                collectionParents = collectionParents.add(key.path.popLast());\n                const size = dbDocumentSize(doc);\n                sizeDelta += size - previousDoc.size;\n                promises.push(this.documentCache.addEntry(transaction, key, doc));\n            }\n            else {\n                sizeDelta -= previousDoc.size;\n                if (this.trackRemovals) {\n                    // In order to track removals, we store a \"sentinel delete\" in the\n                    // RemoteDocumentCache. This entry is represented by a NoDocument\n                    // with a version of 0 and ignored by `maybeDecodeDocument()` but\n                    // preserved in `getNewDocumentChanges()`.\n                    const deletedDoc = toDbRemoteDocument(this.documentCache.serializer, documentChange.convertToNoDocument(SnapshotVersion.min()));\n                    promises.push(this.documentCache.addEntry(transaction, key, deletedDoc));\n                }\n            }\n        });\n        collectionParents.forEach(parent => {\n            promises.push(this.documentCache.indexManager.addToCollectionParentIndex(transaction, parent));\n        });\n        promises.push(this.documentCache.updateMetadata(transaction, sizeDelta));\n        return PersistencePromise.waitFor(promises);\n    }\n    getFromCache(transaction, documentKey) {\n        // Record the size of everything we load from the cache so we can compute a delta later.\n        return this.documentCache\n            .getSizedEntry(transaction, documentKey)\n            .next(getResult => {\n            this.documentStates.set(documentKey, {\n                size: getResult.size,\n                readTime: getResult.document.readTime\n            });\n            return getResult.document;\n        });\n    }\n    getAllFromCache(transaction, documentKeys) {\n        // Record the size of everything we load from the cache so we can compute\n        // a delta later.\n        return this.documentCache\n            .getSizedEntries(transaction, documentKeys)\n            .next(({ documents, sizeMap }) => {\n            // Note: `getAllFromCache` returns two maps instead of a single map from\n            // keys to `DocumentSizeEntry`s. This is to allow returning the\n            // `MutableDocumentMap` directly, without a conversion.\n            sizeMap.forEach((documentKey, size) => {\n                this.documentStates.set(documentKey, {\n                    size,\n                    readTime: documents.get(documentKey).readTime\n                });\n            });\n            return documents;\n        });\n    }\n}\nfunction documentGlobalStore(txn) {\n    return getStore(txn, DbRemoteDocumentGlobalStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the remoteDocuments object store.\n */\nfunction remoteDocumentsStore(txn) {\n    return getStore(txn, DbRemoteDocumentStore);\n}\n/**\n * Returns a key that can be used for document lookups on the\n * `DbRemoteDocumentDocumentKeyIndex` index.\n */\nfunction dbKey(documentKey) {\n    const path = documentKey.path.toArray();\n    return [\n        /* prefix path */ path.slice(0, path.length - 2),\n        /* collection id */ path[path.length - 2],\n        /* document id */ path[path.length - 1]\n    ];\n}\n/**\n * Returns a key that can be used for document lookups via the primary key of\n * the DbRemoteDocument object store.\n */\nfunction dbReadTimeKey(documentKey, readTime) {\n    const path = documentKey.path.toArray();\n    return [\n        /* prefix path */ path.slice(0, path.length - 2),\n        /* collection id */ path[path.length - 2],\n        toDbTimestampKey(readTime),\n        /* document id */ path[path.length - 1]\n    ];\n}\n/**\n * Returns a key that can be used for document lookups on the\n * `DbRemoteDocumentDocumentCollectionGroupIndex` index.\n */\nfunction dbCollectionGroupKey(collectionGroup, offset) {\n    const path = offset.documentKey.path.toArray();\n    return [\n        /* collection id */ collectionGroup,\n        toDbTimestampKey(offset.readTime),\n        /* prefix path */ path.slice(0, path.length - 2),\n        /* document id */ path.length > 0 ? path[path.length - 1] : ''\n    ];\n}\n/**\n * Comparator that compares document keys according to the primary key sorting\n * used by the `DbRemoteDocumentDocument` store (by prefix path, collection id\n * and then document ID).\n *\n * Visible for testing.\n */\nfunction dbKeyComparator(l, r) {\n    const left = l.path.toArray();\n    const right = r.path.toArray();\n    // The ordering is based on https://chromium.googlesource.com/chromium/blink/+/fe5c21fef94dae71c1c3344775b8d8a7f7e6d9ec/Source/modules/indexeddb/IDBKey.cpp#74\n    let cmp = 0;\n    for (let i = 0; i < left.length - 2 && i < right.length - 2; ++i) {\n        cmp = primitiveComparator(left[i], right[i]);\n        if (cmp) {\n            return cmp;\n        }\n    }\n    cmp = primitiveComparator(left.length, right.length);\n    if (cmp) {\n        return cmp;\n    }\n    cmp = primitiveComparator(left[left.length - 2], right[right.length - 2]);\n    if (cmp) {\n        return cmp;\n    }\n    return primitiveComparator(left[left.length - 1], right[right.length - 1]);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Schema Version for the Web client:\n * 1.  Initial version including Mutation Queue, Query Cache, and Remote\n *     Document Cache\n * 2.  Used to ensure a targetGlobal object exists and add targetCount to it. No\n *     longer required because migration 3 unconditionally clears it.\n * 3.  Dropped and re-created Query Cache to deal with cache corruption related\n *     to limbo resolution. Addresses\n *     https://github.com/firebase/firebase-ios-sdk/issues/1548\n * 4.  Multi-Tab Support.\n * 5.  Removal of held write acks.\n * 6.  Create document global for tracking document cache size.\n * 7.  Ensure every cached document has a sentinel row with a sequence number.\n * 8.  Add collection-parent index for Collection Group queries.\n * 9.  Change RemoteDocumentChanges store to be keyed by readTime rather than\n *     an auto-incrementing ID. This is required for Index-Free queries.\n * 10. Rewrite the canonical IDs to the explicit Protobuf-based format.\n * 11. Add bundles and named_queries for bundle support.\n * 12. Add document overlays.\n * 13. Rewrite the keys of the remote document cache to allow for efficient\n *     document lookup via `getAll()`.\n * 14. Add overlays.\n * 15. Add indexing support.\n * 16. Parse timestamp strings before creating index entries.\n */\nconst SCHEMA_VERSION = 17;\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a local view (overlay) of a document, and the fields that are\n * locally mutated.\n */\nclass OverlayedDocument {\n    constructor(overlayedDocument, \n    /**\n     * The fields that are locally mutated by patch mutations.\n     *\n     * If the overlayed\tdocument is from set or delete mutations, this is `null`.\n     * If there is no overlay (mutation) for the document, this is an empty `FieldMask`.\n     */\n    mutatedFields) {\n        this.overlayedDocument = overlayedDocument;\n        this.mutatedFields = mutatedFields;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A readonly view of the local state of all documents we're tracking (i.e. we\n * have a cached version in remoteDocumentCache or local mutations for the\n * document). The view is computed by applying the mutations in the\n * MutationQueue to the RemoteDocumentCache.\n */\nclass LocalDocumentsView {\n    constructor(remoteDocumentCache, mutationQueue, documentOverlayCache, indexManager) {\n        this.remoteDocumentCache = remoteDocumentCache;\n        this.mutationQueue = mutationQueue;\n        this.documentOverlayCache = documentOverlayCache;\n        this.indexManager = indexManager;\n    }\n    /**\n     * Get the local view of the document identified by `key`.\n     *\n     * @returns Local view of the document or null if we don't have any cached\n     * state for it.\n     */\n    getDocument(transaction, key) {\n        let overlay = null;\n        return this.documentOverlayCache\n            .getOverlay(transaction, key)\n            .next(value => {\n            overlay = value;\n            return this.remoteDocumentCache.getEntry(transaction, key);\n        })\n            .next(document => {\n            if (overlay !== null) {\n                mutationApplyToLocalView(overlay.mutation, document, FieldMask.empty(), Timestamp.now());\n            }\n            return document;\n        });\n    }\n    /**\n     * Gets the local view of the documents identified by `keys`.\n     *\n     * If we don't have cached state for a document in `keys`, a NoDocument will\n     * be stored for that key in the resulting set.\n     */\n    getDocuments(transaction, keys) {\n        return this.remoteDocumentCache\n            .getEntries(transaction, keys)\n            .next(docs => this.getLocalViewOfDocuments(transaction, docs, documentKeySet()).next(() => docs));\n    }\n    /**\n     * Similar to `getDocuments`, but creates the local view from the given\n     * `baseDocs` without retrieving documents from the local store.\n     *\n     * @param transaction - The transaction this operation is scoped to.\n     * @param docs - The documents to apply local mutations to get the local views.\n     * @param existenceStateChanged - The set of document keys whose existence state\n     *   is changed. This is useful to determine if some documents overlay needs\n     *   to be recalculated.\n     */\n    getLocalViewOfDocuments(transaction, docs, existenceStateChanged = documentKeySet()) {\n        const overlays = newOverlayMap();\n        return this.populateOverlays(transaction, overlays, docs).next(() => {\n            return this.computeViews(transaction, docs, overlays, existenceStateChanged).next(computeViewsResult => {\n                let result = documentMap();\n                computeViewsResult.forEach((documentKey, overlayedDocument) => {\n                    result = result.insert(documentKey, overlayedDocument.overlayedDocument);\n                });\n                return result;\n            });\n        });\n    }\n    /**\n     * Gets the overlayed documents for the given document map, which will include\n     * the local view of those documents and a `FieldMask` indicating which fields\n     * are mutated locally, `null` if overlay is a Set or Delete mutation.\n     */\n    getOverlayedDocuments(transaction, docs) {\n        const overlays = newOverlayMap();\n        return this.populateOverlays(transaction, overlays, docs).next(() => this.computeViews(transaction, docs, overlays, documentKeySet()));\n    }\n    /**\n     * Fetches the overlays for {@code docs} and adds them to provided overlay map\n     * if the map does not already contain an entry for the given document key.\n     */\n    populateOverlays(transaction, overlays, docs) {\n        const missingOverlays = [];\n        docs.forEach(key => {\n            if (!overlays.has(key)) {\n                missingOverlays.push(key);\n            }\n        });\n        return this.documentOverlayCache\n            .getOverlays(transaction, missingOverlays)\n            .next(result => {\n            result.forEach((key, val) => {\n                overlays.set(key, val);\n            });\n        });\n    }\n    /**\n     * Computes the local view for the given documents.\n     *\n     * @param docs - The documents to compute views for. It also has the base\n     *   version of the documents.\n     * @param overlays - The overlays that need to be applied to the given base\n     *   version of the documents.\n     * @param existenceStateChanged - A set of documents whose existence states\n     *   might have changed. This is used to determine if we need to re-calculate\n     *   overlays from mutation queues.\n     * @return A map represents the local documents view.\n     */\n    computeViews(transaction, docs, overlays, existenceStateChanged) {\n        let recalculateDocuments = mutableDocumentMap();\n        const mutatedFields = newDocumentKeyMap();\n        const results = newOverlayedDocumentMap();\n        docs.forEach((_, doc) => {\n            const overlay = overlays.get(doc.key);\n            // Recalculate an overlay if the document's existence state changed due to\n            // a remote event *and* the overlay is a PatchMutation. This is because\n            // document existence state can change if some patch mutation's\n            // preconditions are met.\n            // NOTE: we recalculate when `overlay` is undefined as well, because there\n            // might be a patch mutation whose precondition does not match before the\n            // change (hence overlay is undefined), but would now match.\n            if (existenceStateChanged.has(doc.key) &&\n                (overlay === undefined || overlay.mutation instanceof PatchMutation)) {\n                recalculateDocuments = recalculateDocuments.insert(doc.key, doc);\n            }\n            else if (overlay !== undefined) {\n                mutatedFields.set(doc.key, overlay.mutation.getFieldMask());\n                mutationApplyToLocalView(overlay.mutation, doc, overlay.mutation.getFieldMask(), Timestamp.now());\n            }\n            else {\n                // no overlay exists\n                // Using EMPTY to indicate there is no overlay for the document.\n                mutatedFields.set(doc.key, FieldMask.empty());\n            }\n        });\n        return this.recalculateAndSaveOverlays(transaction, recalculateDocuments).next(recalculatedFields => {\n            recalculatedFields.forEach((documentKey, mask) => mutatedFields.set(documentKey, mask));\n            docs.forEach((documentKey, document) => {\n                var _a;\n                return results.set(documentKey, new OverlayedDocument(document, (_a = mutatedFields.get(documentKey)) !== null && _a !== void 0 ? _a : null));\n            });\n            return results;\n        });\n    }\n    recalculateAndSaveOverlays(transaction, docs) {\n        const masks = newDocumentKeyMap();\n        // A reverse lookup map from batch id to the documents within that batch.\n        let documentsByBatchId = new SortedMap((key1, key2) => key1 - key2);\n        let processed = documentKeySet();\n        return this.mutationQueue\n            .getAllMutationBatchesAffectingDocumentKeys(transaction, docs)\n            .next(batches => {\n            for (const batch of batches) {\n                batch.keys().forEach(key => {\n                    const baseDoc = docs.get(key);\n                    if (baseDoc === null) {\n                        return;\n                    }\n                    let mask = masks.get(key) || FieldMask.empty();\n                    mask = batch.applyToLocalView(baseDoc, mask);\n                    masks.set(key, mask);\n                    const newSet = (documentsByBatchId.get(batch.batchId) || documentKeySet()).add(key);\n                    documentsByBatchId = documentsByBatchId.insert(batch.batchId, newSet);\n                });\n            }\n        })\n            .next(() => {\n            const promises = [];\n            // Iterate in descending order of batch IDs, and skip documents that are\n            // already saved.\n            const iter = documentsByBatchId.getReverseIterator();\n            while (iter.hasNext()) {\n                const entry = iter.getNext();\n                const batchId = entry.key;\n                const keys = entry.value;\n                const overlays = newMutationMap();\n                keys.forEach(key => {\n                    if (!processed.has(key)) {\n                        const overlayMutation = calculateOverlayMutation(docs.get(key), masks.get(key));\n                        if (overlayMutation !== null) {\n                            overlays.set(key, overlayMutation);\n                        }\n                        processed = processed.add(key);\n                    }\n                });\n                promises.push(this.documentOverlayCache.saveOverlays(transaction, batchId, overlays));\n            }\n            return PersistencePromise.waitFor(promises);\n        })\n            .next(() => masks);\n    }\n    /**\n     * Recalculates overlays by reading the documents from remote document cache\n     * first, and saves them after they are calculated.\n     */\n    recalculateAndSaveOverlaysForDocumentKeys(transaction, documentKeys) {\n        return this.remoteDocumentCache\n            .getEntries(transaction, documentKeys)\n            .next(docs => this.recalculateAndSaveOverlays(transaction, docs));\n    }\n    /**\n     * Performs a query against the local view of all documents.\n     *\n     * @param transaction - The persistence transaction.\n     * @param query - The query to match documents against.\n     * @param offset - Read time and key to start scanning by (exclusive).\n     * @param context - A optional tracker to keep a record of important details\n     *   during database local query execution.\n     */\n    getDocumentsMatchingQuery(transaction, query, offset, context) {\n        if (isDocumentQuery$1(query)) {\n            return this.getDocumentsMatchingDocumentQuery(transaction, query.path);\n        }\n        else if (isCollectionGroupQuery(query)) {\n            return this.getDocumentsMatchingCollectionGroupQuery(transaction, query, offset, context);\n        }\n        else {\n            return this.getDocumentsMatchingCollectionQuery(transaction, query, offset, context);\n        }\n    }\n    /**\n     * Given a collection group, returns the next documents that follow the provided offset, along\n     * with an updated batch ID.\n     *\n     * <p>The documents returned by this method are ordered by remote version from the provided\n     * offset. If there are no more remote documents after the provided offset, documents with\n     * mutations in order of batch id from the offset are returned. Since all documents in a batch are\n     * returned together, the total number of documents returned can exceed {@code count}.\n     *\n     * @param transaction\n     * @param collectionGroup The collection group for the documents.\n     * @param offset The offset to index into.\n     * @param count The number of documents to return\n     * @return A LocalWriteResult with the documents that follow the provided offset and the last processed batch id.\n     */\n    getNextDocuments(transaction, collectionGroup, offset, count) {\n        return this.remoteDocumentCache\n            .getAllFromCollectionGroup(transaction, collectionGroup, offset, count)\n            .next((originalDocs) => {\n            const overlaysPromise = count - originalDocs.size > 0\n                ? this.documentOverlayCache.getOverlaysForCollectionGroup(transaction, collectionGroup, offset.largestBatchId, count - originalDocs.size)\n                : PersistencePromise.resolve(newOverlayMap());\n            // The callsite will use the largest batch ID together with the latest read time to create\n            // a new index offset. Since we only process batch IDs if all remote documents have been read,\n            // no overlay will increase the overall read time. This is why we only need to special case\n            // the batch id.\n            let largestBatchId = INITIAL_LARGEST_BATCH_ID;\n            let modifiedDocs = originalDocs;\n            return overlaysPromise.next(overlays => {\n                return PersistencePromise.forEach(overlays, (key, overlay) => {\n                    if (largestBatchId < overlay.largestBatchId) {\n                        largestBatchId = overlay.largestBatchId;\n                    }\n                    if (originalDocs.get(key)) {\n                        return PersistencePromise.resolve();\n                    }\n                    return this.remoteDocumentCache\n                        .getEntry(transaction, key)\n                        .next(doc => {\n                        modifiedDocs = modifiedDocs.insert(key, doc);\n                    });\n                })\n                    .next(() => this.populateOverlays(transaction, overlays, originalDocs))\n                    .next(() => this.computeViews(transaction, modifiedDocs, overlays, documentKeySet()))\n                    .next(localDocs => ({\n                    batchId: largestBatchId,\n                    changes: convertOverlayedDocumentMapToDocumentMap(localDocs)\n                }));\n            });\n        });\n    }\n    getDocumentsMatchingDocumentQuery(transaction, docPath) {\n        // Just do a simple document lookup.\n        return this.getDocument(transaction, new DocumentKey(docPath)).next(document => {\n            let result = documentMap();\n            if (document.isFoundDocument()) {\n                result = result.insert(document.key, document);\n            }\n            return result;\n        });\n    }\n    getDocumentsMatchingCollectionGroupQuery(transaction, query, offset, context) {\n        const collectionId = query.collectionGroup;\n        let results = documentMap();\n        return this.indexManager\n            .getCollectionParents(transaction, collectionId)\n            .next(parents => {\n            // Perform a collection query against each parent that contains the\n            // collectionId and aggregate the results.\n            return PersistencePromise.forEach(parents, (parent) => {\n                const collectionQuery = asCollectionQueryAtPath(query, parent.child(collectionId));\n                return this.getDocumentsMatchingCollectionQuery(transaction, collectionQuery, offset, context).next(r => {\n                    r.forEach((key, doc) => {\n                        results = results.insert(key, doc);\n                    });\n                });\n            }).next(() => results);\n        });\n    }\n    getDocumentsMatchingCollectionQuery(transaction, query, offset, context) {\n        // Query the remote documents and overlay mutations.\n        let overlays;\n        return this.documentOverlayCache\n            .getOverlaysForCollection(transaction, query.path, offset.largestBatchId)\n            .next(result => {\n            overlays = result;\n            return this.remoteDocumentCache.getDocumentsMatchingQuery(transaction, query, offset, overlays, context);\n        })\n            .next(remoteDocuments => {\n            // As documents might match the query because of their overlay we need to\n            // include documents for all overlays in the initial document set.\n            overlays.forEach((_, overlay) => {\n                const key = overlay.getKey();\n                if (remoteDocuments.get(key) === null) {\n                    remoteDocuments = remoteDocuments.insert(key, MutableDocument.newInvalidDocument(key));\n                }\n            });\n            // Apply the overlays and match against the query.\n            let results = documentMap();\n            remoteDocuments.forEach((key, document) => {\n                const overlay = overlays.get(key);\n                if (overlay !== undefined) {\n                    mutationApplyToLocalView(overlay.mutation, document, FieldMask.empty(), Timestamp.now());\n                }\n                // Finally, insert the documents that still match the query\n                if (queryMatches(query, document)) {\n                    results = results.insert(key, document);\n                }\n            });\n            return results;\n        });\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MemoryBundleCache {\n    constructor(serializer) {\n        this.serializer = serializer;\n        this.bundles = new Map();\n        this.namedQueries = new Map();\n    }\n    getBundleMetadata(transaction, bundleId) {\n        return PersistencePromise.resolve(this.bundles.get(bundleId));\n    }\n    saveBundleMetadata(transaction, bundleMetadata) {\n        this.bundles.set(bundleMetadata.id, fromBundleMetadata(bundleMetadata));\n        return PersistencePromise.resolve();\n    }\n    getNamedQuery(transaction, queryName) {\n        return PersistencePromise.resolve(this.namedQueries.get(queryName));\n    }\n    saveNamedQuery(transaction, query) {\n        this.namedQueries.set(query.name, fromProtoNamedQuery(query));\n        return PersistencePromise.resolve();\n    }\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An in-memory implementation of DocumentOverlayCache.\n */\nclass MemoryDocumentOverlayCache {\n    constructor() {\n        // A map sorted by DocumentKey, whose value is a pair of the largest batch id\n        // for the overlay and the overlay itself.\n        this.overlays = new SortedMap(DocumentKey.comparator);\n        this.overlayByBatchId = new Map();\n    }\n    getOverlay(transaction, key) {\n        return PersistencePromise.resolve(this.overlays.get(key));\n    }\n    getOverlays(transaction, keys) {\n        const result = newOverlayMap();\n        return PersistencePromise.forEach(keys, (key) => {\n            return this.getOverlay(transaction, key).next(overlay => {\n                if (overlay !== null) {\n                    result.set(key, overlay);\n                }\n            });\n        }).next(() => result);\n    }\n    saveOverlays(transaction, largestBatchId, overlays) {\n        overlays.forEach((_, mutation) => {\n            this.saveOverlay(transaction, largestBatchId, mutation);\n        });\n        return PersistencePromise.resolve();\n    }\n    removeOverlaysForBatchId(transaction, documentKeys, batchId) {\n        const keys = this.overlayByBatchId.get(batchId);\n        if (keys !== undefined) {\n            keys.forEach(key => (this.overlays = this.overlays.remove(key)));\n            this.overlayByBatchId.delete(batchId);\n        }\n        return PersistencePromise.resolve();\n    }\n    getOverlaysForCollection(transaction, collection, sinceBatchId) {\n        const result = newOverlayMap();\n        const immediateChildrenPathLength = collection.length + 1;\n        const prefix = new DocumentKey(collection.child(''));\n        const iter = this.overlays.getIteratorFrom(prefix);\n        while (iter.hasNext()) {\n            const entry = iter.getNext();\n            const overlay = entry.value;\n            const key = overlay.getKey();\n            if (!collection.isPrefixOf(key.path)) {\n                break;\n            }\n            // Documents from sub-collections\n            if (key.path.length !== immediateChildrenPathLength) {\n                continue;\n            }\n            if (overlay.largestBatchId > sinceBatchId) {\n                result.set(overlay.getKey(), overlay);\n            }\n        }\n        return PersistencePromise.resolve(result);\n    }\n    getOverlaysForCollectionGroup(transaction, collectionGroup, sinceBatchId, count) {\n        let batchIdToOverlays = new SortedMap((key1, key2) => key1 - key2);\n        const iter = this.overlays.getIterator();\n        while (iter.hasNext()) {\n            const entry = iter.getNext();\n            const overlay = entry.value;\n            const key = overlay.getKey();\n            if (key.getCollectionGroup() !== collectionGroup) {\n                continue;\n            }\n            if (overlay.largestBatchId > sinceBatchId) {\n                let overlaysForBatchId = batchIdToOverlays.get(overlay.largestBatchId);\n                if (overlaysForBatchId === null) {\n                    overlaysForBatchId = newOverlayMap();\n                    batchIdToOverlays = batchIdToOverlays.insert(overlay.largestBatchId, overlaysForBatchId);\n                }\n                overlaysForBatchId.set(overlay.getKey(), overlay);\n            }\n        }\n        const result = newOverlayMap();\n        const batchIter = batchIdToOverlays.getIterator();\n        while (batchIter.hasNext()) {\n            const entry = batchIter.getNext();\n            const overlays = entry.value;\n            overlays.forEach((key, overlay) => result.set(key, overlay));\n            if (result.size() >= count) {\n                break;\n            }\n        }\n        return PersistencePromise.resolve(result);\n    }\n    saveOverlay(transaction, largestBatchId, mutation) {\n        // Remove the association of the overlay to its batch id.\n        const existing = this.overlays.get(mutation.key);\n        if (existing !== null) {\n            const newSet = this.overlayByBatchId\n                .get(existing.largestBatchId)\n                .delete(mutation.key);\n            this.overlayByBatchId.set(existing.largestBatchId, newSet);\n        }\n        this.overlays = this.overlays.insert(mutation.key, new Overlay(largestBatchId, mutation));\n        // Create the association of this overlay to the given largestBatchId.\n        let batch = this.overlayByBatchId.get(largestBatchId);\n        if (batch === undefined) {\n            batch = documentKeySet();\n            this.overlayByBatchId.set(largestBatchId, batch);\n        }\n        this.overlayByBatchId.set(largestBatchId, batch.add(mutation.key));\n    }\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MemoryGlobalsCache {\n    constructor() {\n        this.sessionToken = ByteString.EMPTY_BYTE_STRING;\n    }\n    getSessionToken(transaction) {\n        return PersistencePromise.resolve(this.sessionToken);\n    }\n    setSessionToken(transaction, sessionToken) {\n        this.sessionToken = sessionToken;\n        return PersistencePromise.resolve();\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A collection of references to a document from some kind of numbered entity\n * (either a target ID or batch ID). As references are added to or removed from\n * the set corresponding events are emitted to a registered garbage collector.\n *\n * Each reference is represented by a DocumentReference object. Each of them\n * contains enough information to uniquely identify the reference. They are all\n * stored primarily in a set sorted by key. A document is considered garbage if\n * there's no references in that set (this can be efficiently checked thanks to\n * sorting by key).\n *\n * ReferenceSet also keeps a secondary set that contains references sorted by\n * IDs. This one is used to efficiently implement removal of all references by\n * some target ID.\n */\nclass ReferenceSet {\n    constructor() {\n        // A set of outstanding references to a document sorted by key.\n        this.refsByKey = new SortedSet(DocReference.compareByKey);\n        // A set of outstanding references to a document sorted by target id.\n        this.refsByTarget = new SortedSet(DocReference.compareByTargetId);\n    }\n    /** Returns true if the reference set contains no references. */\n    isEmpty() {\n        return this.refsByKey.isEmpty();\n    }\n    /** Adds a reference to the given document key for the given ID. */\n    addReference(key, id) {\n        const ref = new DocReference(key, id);\n        this.refsByKey = this.refsByKey.add(ref);\n        this.refsByTarget = this.refsByTarget.add(ref);\n    }\n    /** Add references to the given document keys for the given ID. */\n    addReferences(keys, id) {\n        keys.forEach(key => this.addReference(key, id));\n    }\n    /**\n     * Removes a reference to the given document key for the given\n     * ID.\n     */\n    removeReference(key, id) {\n        this.removeRef(new DocReference(key, id));\n    }\n    removeReferences(keys, id) {\n        keys.forEach(key => this.removeReference(key, id));\n    }\n    /**\n     * Clears all references with a given ID. Calls removeRef() for each key\n     * removed.\n     */\n    removeReferencesForId(id) {\n        const emptyKey = new DocumentKey(new ResourcePath([]));\n        const startRef = new DocReference(emptyKey, id);\n        const endRef = new DocReference(emptyKey, id + 1);\n        const keys = [];\n        this.refsByTarget.forEachInRange([startRef, endRef], ref => {\n            this.removeRef(ref);\n            keys.push(ref.key);\n        });\n        return keys;\n    }\n    removeAllReferences() {\n        this.refsByKey.forEach(ref => this.removeRef(ref));\n    }\n    removeRef(ref) {\n        this.refsByKey = this.refsByKey.delete(ref);\n        this.refsByTarget = this.refsByTarget.delete(ref);\n    }\n    referencesForId(id) {\n        const emptyKey = new DocumentKey(new ResourcePath([]));\n        const startRef = new DocReference(emptyKey, id);\n        const endRef = new DocReference(emptyKey, id + 1);\n        let keys = documentKeySet();\n        this.refsByTarget.forEachInRange([startRef, endRef], ref => {\n            keys = keys.add(ref.key);\n        });\n        return keys;\n    }\n    containsKey(key) {\n        const ref = new DocReference(key, 0);\n        const firstRef = this.refsByKey.firstAfterOrEqual(ref);\n        return firstRef !== null && key.isEqual(firstRef.key);\n    }\n}\nclass DocReference {\n    constructor(key, targetOrBatchId) {\n        this.key = key;\n        this.targetOrBatchId = targetOrBatchId;\n    }\n    /** Compare by key then by ID */\n    static compareByKey(left, right) {\n        return (DocumentKey.comparator(left.key, right.key) ||\n            primitiveComparator(left.targetOrBatchId, right.targetOrBatchId));\n    }\n    /** Compare by ID then by key */\n    static compareByTargetId(left, right) {\n        return (primitiveComparator(left.targetOrBatchId, right.targetOrBatchId) ||\n            DocumentKey.comparator(left.key, right.key));\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MemoryMutationQueue {\n    constructor(indexManager, referenceDelegate) {\n        this.indexManager = indexManager;\n        this.referenceDelegate = referenceDelegate;\n        /**\n         * The set of all mutations that have been sent but not yet been applied to\n         * the backend.\n         */\n        this.mutationQueue = [];\n        /** Next value to use when assigning sequential IDs to each mutation batch. */\n        this.nextBatchId = 1;\n        /** An ordered mapping between documents and the mutations batch IDs. */\n        this.batchesByDocumentKey = new SortedSet(DocReference.compareByKey);\n    }\n    checkEmpty(transaction) {\n        return PersistencePromise.resolve(this.mutationQueue.length === 0);\n    }\n    addMutationBatch(transaction, localWriteTime, baseMutations, mutations) {\n        const batchId = this.nextBatchId;\n        this.nextBatchId++;\n        if (this.mutationQueue.length > 0) {\n            this.mutationQueue[this.mutationQueue.length - 1];\n        }\n        const batch = new MutationBatch(batchId, localWriteTime, baseMutations, mutations);\n        this.mutationQueue.push(batch);\n        // Track references by document key and index collection parents.\n        for (const mutation of mutations) {\n            this.batchesByDocumentKey = this.batchesByDocumentKey.add(new DocReference(mutation.key, batchId));\n            this.indexManager.addToCollectionParentIndex(transaction, mutation.key.path.popLast());\n        }\n        return PersistencePromise.resolve(batch);\n    }\n    lookupMutationBatch(transaction, batchId) {\n        return PersistencePromise.resolve(this.findMutationBatch(batchId));\n    }\n    getNextMutationBatchAfterBatchId(transaction, batchId) {\n        const nextBatchId = batchId + 1;\n        // The requested batchId may still be out of range so normalize it to the\n        // start of the queue.\n        const rawIndex = this.indexOfBatchId(nextBatchId);\n        const index = rawIndex < 0 ? 0 : rawIndex;\n        return PersistencePromise.resolve(this.mutationQueue.length > index ? this.mutationQueue[index] : null);\n    }\n    getHighestUnacknowledgedBatchId() {\n        return PersistencePromise.resolve(this.mutationQueue.length === 0 ? BATCHID_UNKNOWN : this.nextBatchId - 1);\n    }\n    getAllMutationBatches(transaction) {\n        return PersistencePromise.resolve(this.mutationQueue.slice());\n    }\n    getAllMutationBatchesAffectingDocumentKey(transaction, documentKey) {\n        const start = new DocReference(documentKey, 0);\n        const end = new DocReference(documentKey, Number.POSITIVE_INFINITY);\n        const result = [];\n        this.batchesByDocumentKey.forEachInRange([start, end], ref => {\n            const batch = this.findMutationBatch(ref.targetOrBatchId);\n            result.push(batch);\n        });\n        return PersistencePromise.resolve(result);\n    }\n    getAllMutationBatchesAffectingDocumentKeys(transaction, documentKeys) {\n        let uniqueBatchIDs = new SortedSet(primitiveComparator);\n        documentKeys.forEach(documentKey => {\n            const start = new DocReference(documentKey, 0);\n            const end = new DocReference(documentKey, Number.POSITIVE_INFINITY);\n            this.batchesByDocumentKey.forEachInRange([start, end], ref => {\n                uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);\n            });\n        });\n        return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));\n    }\n    getAllMutationBatchesAffectingQuery(transaction, query) {\n        // Use the query path as a prefix for testing if a document matches the\n        // query.\n        const prefix = query.path;\n        const immediateChildrenPathLength = prefix.length + 1;\n        // Construct a document reference for actually scanning the index. Unlike\n        // the prefix the document key in this reference must have an even number of\n        // segments. The empty segment can be used a suffix of the query path\n        // because it precedes all other segments in an ordered traversal.\n        let startPath = prefix;\n        if (!DocumentKey.isDocumentKey(startPath)) {\n            startPath = startPath.child('');\n        }\n        const start = new DocReference(new DocumentKey(startPath), 0);\n        // Find unique batchIDs referenced by all documents potentially matching the\n        // query.\n        let uniqueBatchIDs = new SortedSet(primitiveComparator);\n        this.batchesByDocumentKey.forEachWhile(ref => {\n            const rowKeyPath = ref.key.path;\n            if (!prefix.isPrefixOf(rowKeyPath)) {\n                return false;\n            }\n            else {\n                // Rows with document keys more than one segment longer than the query\n                // path can't be matches. For example, a query on 'rooms' can't match\n                // the document /rooms/abc/messages/xyx.\n                // TODO(mcg): we'll need a different scanner when we implement\n                // ancestor queries.\n                if (rowKeyPath.length === immediateChildrenPathLength) {\n                    uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);\n                }\n                return true;\n            }\n        }, start);\n        return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));\n    }\n    findMutationBatches(batchIDs) {\n        // Construct an array of matching batches, sorted by batchID to ensure that\n        // multiple mutations affecting the same document key are applied in order.\n        const result = [];\n        batchIDs.forEach(batchId => {\n            const batch = this.findMutationBatch(batchId);\n            if (batch !== null) {\n                result.push(batch);\n            }\n        });\n        return result;\n    }\n    removeMutationBatch(transaction, batch) {\n        // Find the position of the first batch for removal.\n        const batchIndex = this.indexOfExistingBatchId(batch.batchId, 'removed');\n        hardAssert(batchIndex === 0);\n        this.mutationQueue.shift();\n        let references = this.batchesByDocumentKey;\n        return PersistencePromise.forEach(batch.mutations, (mutation) => {\n            const ref = new DocReference(mutation.key, batch.batchId);\n            references = references.delete(ref);\n            return this.referenceDelegate.markPotentiallyOrphaned(transaction, mutation.key);\n        }).next(() => {\n            this.batchesByDocumentKey = references;\n        });\n    }\n    removeCachedMutationKeys(batchId) {\n        // No-op since the memory mutation queue does not maintain a separate cache.\n    }\n    containsKey(txn, key) {\n        const ref = new DocReference(key, 0);\n        const firstRef = this.batchesByDocumentKey.firstAfterOrEqual(ref);\n        return PersistencePromise.resolve(key.isEqual(firstRef && firstRef.key));\n    }\n    performConsistencyCheck(txn) {\n        if (this.mutationQueue.length === 0) ;\n        return PersistencePromise.resolve();\n    }\n    /**\n     * Finds the index of the given batchId in the mutation queue and asserts that\n     * the resulting index is within the bounds of the queue.\n     *\n     * @param batchId - The batchId to search for\n     * @param action - A description of what the caller is doing, phrased in passive\n     * form (e.g. \"acknowledged\" in a routine that acknowledges batches).\n     */\n    indexOfExistingBatchId(batchId, action) {\n        const index = this.indexOfBatchId(batchId);\n        return index;\n    }\n    /**\n     * Finds the index of the given batchId in the mutation queue. This operation\n     * is O(1).\n     *\n     * @returns The computed index of the batch with the given batchId, based on\n     * the state of the queue. Note this index can be negative if the requested\n     * batchId has already been removed from the queue or past the end of the\n     * queue if the batchId is larger than the last added batch.\n     */\n    indexOfBatchId(batchId) {\n        if (this.mutationQueue.length === 0) {\n            // As an index this is past the end of the queue\n            return 0;\n        }\n        // Examine the front of the queue to figure out the difference between the\n        // batchId and indexes in the array. Note that since the queue is ordered\n        // by batchId, if the first batch has a larger batchId then the requested\n        // batchId doesn't exist in the queue.\n        const firstBatchId = this.mutationQueue[0].batchId;\n        return batchId - firstBatchId;\n    }\n    /**\n     * A version of lookupMutationBatch that doesn't return a promise, this makes\n     * other functions that uses this code easier to read and more efficient.\n     */\n    findMutationBatch(batchId) {\n        const index = this.indexOfBatchId(batchId);\n        if (index < 0 || index >= this.mutationQueue.length) {\n            return null;\n        }\n        const batch = this.mutationQueue[index];\n        return batch;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction documentEntryMap() {\n    return new SortedMap(DocumentKey.comparator);\n}\n/**\n * The memory-only RemoteDocumentCache for IndexedDb. To construct, invoke\n * `newMemoryRemoteDocumentCache()`.\n */\nclass MemoryRemoteDocumentCacheImpl {\n    /**\n     * @param sizer - Used to assess the size of a document. For eager GC, this is\n     * expected to just return 0 to avoid unnecessarily doing the work of\n     * calculating the size.\n     */\n    constructor(sizer) {\n        this.sizer = sizer;\n        /** Underlying cache of documents and their read times. */\n        this.docs = documentEntryMap();\n        /** Size of all cached documents. */\n        this.size = 0;\n    }\n    setIndexManager(indexManager) {\n        this.indexManager = indexManager;\n    }\n    /**\n     * Adds the supplied entry to the cache and updates the cache size as appropriate.\n     *\n     * All calls of `addEntry`  are required to go through the RemoteDocumentChangeBuffer\n     * returned by `newChangeBuffer()`.\n     */\n    addEntry(transaction, doc) {\n        const key = doc.key;\n        const entry = this.docs.get(key);\n        const previousSize = entry ? entry.size : 0;\n        const currentSize = this.sizer(doc);\n        this.docs = this.docs.insert(key, {\n            document: doc.mutableCopy(),\n            size: currentSize\n        });\n        this.size += currentSize - previousSize;\n        return this.indexManager.addToCollectionParentIndex(transaction, key.path.popLast());\n    }\n    /**\n     * Removes the specified entry from the cache and updates the cache size as appropriate.\n     *\n     * All calls of `removeEntry` are required to go through the RemoteDocumentChangeBuffer\n     * returned by `newChangeBuffer()`.\n     */\n    removeEntry(documentKey) {\n        const entry = this.docs.get(documentKey);\n        if (entry) {\n            this.docs = this.docs.remove(documentKey);\n            this.size -= entry.size;\n        }\n    }\n    getEntry(transaction, documentKey) {\n        const entry = this.docs.get(documentKey);\n        return PersistencePromise.resolve(entry\n            ? entry.document.mutableCopy()\n            : MutableDocument.newInvalidDocument(documentKey));\n    }\n    getEntries(transaction, documentKeys) {\n        let results = mutableDocumentMap();\n        documentKeys.forEach(documentKey => {\n            const entry = this.docs.get(documentKey);\n            results = results.insert(documentKey, entry\n                ? entry.document.mutableCopy()\n                : MutableDocument.newInvalidDocument(documentKey));\n        });\n        return PersistencePromise.resolve(results);\n    }\n    getDocumentsMatchingQuery(transaction, query, offset, mutatedDocs) {\n        let results = mutableDocumentMap();\n        // Documents are ordered by key, so we can use a prefix scan to narrow down\n        // the documents we need to match the query against.\n        const collectionPath = query.path;\n        const prefix = new DocumentKey(collectionPath.child(''));\n        const iterator = this.docs.getIteratorFrom(prefix);\n        while (iterator.hasNext()) {\n            const { key, value: { document } } = iterator.getNext();\n            if (!collectionPath.isPrefixOf(key.path)) {\n                break;\n            }\n            if (key.path.length > collectionPath.length + 1) {\n                // Exclude entries from subcollections.\n                continue;\n            }\n            if (indexOffsetComparator(newIndexOffsetFromDocument(document), offset) <= 0) {\n                // The document sorts before the offset.\n                continue;\n            }\n            if (!mutatedDocs.has(document.key) && !queryMatches(query, document)) {\n                // The document cannot possibly match the query.\n                continue;\n            }\n            results = results.insert(document.key, document.mutableCopy());\n        }\n        return PersistencePromise.resolve(results);\n    }\n    getAllFromCollectionGroup(transaction, collectionGroup, offset, limit) {\n        // This method should only be called from the IndexBackfiller if persistence\n        // is enabled.\n        fail();\n    }\n    forEachDocumentKey(transaction, f) {\n        return PersistencePromise.forEach(this.docs, (key) => f(key));\n    }\n    newChangeBuffer(options) {\n        // `trackRemovals` is ignores since the MemoryRemoteDocumentCache keeps\n        // a separate changelog and does not need special handling for removals.\n        return new MemoryRemoteDocumentChangeBuffer(this);\n    }\n    getSize(txn) {\n        return PersistencePromise.resolve(this.size);\n    }\n}\n/**\n * Creates a new memory-only RemoteDocumentCache.\n *\n * @param sizer - Used to assess the size of a document. For eager GC, this is\n * expected to just return 0 to avoid unnecessarily doing the work of\n * calculating the size.\n */\nfunction newMemoryRemoteDocumentCache(sizer) {\n    return new MemoryRemoteDocumentCacheImpl(sizer);\n}\n/**\n * Handles the details of adding and updating documents in the MemoryRemoteDocumentCache.\n */\nclass MemoryRemoteDocumentChangeBuffer extends RemoteDocumentChangeBuffer {\n    constructor(documentCache) {\n        super();\n        this.documentCache = documentCache;\n    }\n    applyChanges(transaction) {\n        const promises = [];\n        this.changes.forEach((key, doc) => {\n            if (doc.isValidDocument()) {\n                promises.push(this.documentCache.addEntry(transaction, doc));\n            }\n            else {\n                this.documentCache.removeEntry(key);\n            }\n        });\n        return PersistencePromise.waitFor(promises);\n    }\n    getFromCache(transaction, documentKey) {\n        return this.documentCache.getEntry(transaction, documentKey);\n    }\n    getAllFromCache(transaction, documentKeys) {\n        return this.documentCache.getEntries(transaction, documentKeys);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MemoryTargetCache {\n    constructor(persistence) {\n        this.persistence = persistence;\n        /**\n         * Maps a target to the data about that target\n         */\n        this.targets = new ObjectMap(t => canonifyTarget(t), targetEquals);\n        /** The last received snapshot version. */\n        this.lastRemoteSnapshotVersion = SnapshotVersion.min();\n        /** The highest numbered target ID encountered. */\n        this.highestTargetId = 0;\n        /** The highest sequence number encountered. */\n        this.highestSequenceNumber = 0;\n        /**\n         * A ordered bidirectional mapping between documents and the remote target\n         * IDs.\n         */\n        this.references = new ReferenceSet();\n        this.targetCount = 0;\n        this.targetIdGenerator = TargetIdGenerator.forTargetCache();\n    }\n    forEachTarget(txn, f) {\n        this.targets.forEach((_, targetData) => f(targetData));\n        return PersistencePromise.resolve();\n    }\n    getLastRemoteSnapshotVersion(transaction) {\n        return PersistencePromise.resolve(this.lastRemoteSnapshotVersion);\n    }\n    getHighestSequenceNumber(transaction) {\n        return PersistencePromise.resolve(this.highestSequenceNumber);\n    }\n    allocateTargetId(transaction) {\n        this.highestTargetId = this.targetIdGenerator.next();\n        return PersistencePromise.resolve(this.highestTargetId);\n    }\n    setTargetsMetadata(transaction, highestListenSequenceNumber, lastRemoteSnapshotVersion) {\n        if (lastRemoteSnapshotVersion) {\n            this.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion;\n        }\n        if (highestListenSequenceNumber > this.highestSequenceNumber) {\n            this.highestSequenceNumber = highestListenSequenceNumber;\n        }\n        return PersistencePromise.resolve();\n    }\n    saveTargetData(targetData) {\n        this.targets.set(targetData.target, targetData);\n        const targetId = targetData.targetId;\n        if (targetId > this.highestTargetId) {\n            this.targetIdGenerator = new TargetIdGenerator(targetId);\n            this.highestTargetId = targetId;\n        }\n        if (targetData.sequenceNumber > this.highestSequenceNumber) {\n            this.highestSequenceNumber = targetData.sequenceNumber;\n        }\n    }\n    addTargetData(transaction, targetData) {\n        this.saveTargetData(targetData);\n        this.targetCount += 1;\n        return PersistencePromise.resolve();\n    }\n    updateTargetData(transaction, targetData) {\n        this.saveTargetData(targetData);\n        return PersistencePromise.resolve();\n    }\n    removeTargetData(transaction, targetData) {\n        this.targets.delete(targetData.target);\n        this.references.removeReferencesForId(targetData.targetId);\n        this.targetCount -= 1;\n        return PersistencePromise.resolve();\n    }\n    removeTargets(transaction, upperBound, activeTargetIds) {\n        let count = 0;\n        const removals = [];\n        this.targets.forEach((key, targetData) => {\n            if (targetData.sequenceNumber <= upperBound &&\n                activeTargetIds.get(targetData.targetId) === null) {\n                this.targets.delete(key);\n                removals.push(this.removeMatchingKeysForTargetId(transaction, targetData.targetId));\n                count++;\n            }\n        });\n        return PersistencePromise.waitFor(removals).next(() => count);\n    }\n    getTargetCount(transaction) {\n        return PersistencePromise.resolve(this.targetCount);\n    }\n    getTargetData(transaction, target) {\n        const targetData = this.targets.get(target) || null;\n        return PersistencePromise.resolve(targetData);\n    }\n    addMatchingKeys(txn, keys, targetId) {\n        this.references.addReferences(keys, targetId);\n        return PersistencePromise.resolve();\n    }\n    removeMatchingKeys(txn, keys, targetId) {\n        this.references.removeReferences(keys, targetId);\n        const referenceDelegate = this.persistence.referenceDelegate;\n        const promises = [];\n        if (referenceDelegate) {\n            keys.forEach(key => {\n                promises.push(referenceDelegate.markPotentiallyOrphaned(txn, key));\n            });\n        }\n        return PersistencePromise.waitFor(promises);\n    }\n    removeMatchingKeysForTargetId(txn, targetId) {\n        this.references.removeReferencesForId(targetId);\n        return PersistencePromise.resolve();\n    }\n    getMatchingKeysForTargetId(txn, targetId) {\n        const matchingKeys = this.references.referencesForId(targetId);\n        return PersistencePromise.resolve(matchingKeys);\n    }\n    containsKey(txn, key) {\n        return PersistencePromise.resolve(this.references.containsKey(key));\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$d = 'MemoryPersistence';\n/**\n * A memory-backed instance of Persistence. Data is stored only in RAM and\n * not persisted across sessions.\n */\nclass MemoryPersistence {\n    /**\n     * The constructor accepts a factory for creating a reference delegate. This\n     * allows both the delegate and this instance to have strong references to\n     * each other without having nullable fields that would then need to be\n     * checked or asserted on every access.\n     */\n    constructor(referenceDelegateFactory, serializer) {\n        this.mutationQueues = {};\n        this.overlays = {};\n        this.listenSequence = new ListenSequence(0);\n        this._started = false;\n        this._started = true;\n        this.globalsCache = new MemoryGlobalsCache();\n        this.referenceDelegate = referenceDelegateFactory(this);\n        this.targetCache = new MemoryTargetCache(this);\n        const sizer = (doc) => this.referenceDelegate.documentSize(doc);\n        this.indexManager = new MemoryIndexManager();\n        this.remoteDocumentCache = newMemoryRemoteDocumentCache(sizer);\n        this.serializer = new LocalSerializer(serializer);\n        this.bundleCache = new MemoryBundleCache(this.serializer);\n    }\n    start() {\n        return Promise.resolve();\n    }\n    shutdown() {\n        // No durable state to ensure is closed on shutdown.\n        this._started = false;\n        return Promise.resolve();\n    }\n    get started() {\n        return this._started;\n    }\n    setDatabaseDeletedListener() {\n        // No op.\n    }\n    setNetworkEnabled() {\n        // No op.\n    }\n    getIndexManager(user) {\n        // We do not currently support indices for memory persistence, so we can\n        // return the same shared instance of the memory index manager.\n        return this.indexManager;\n    }\n    getDocumentOverlayCache(user) {\n        let overlay = this.overlays[user.toKey()];\n        if (!overlay) {\n            overlay = new MemoryDocumentOverlayCache();\n            this.overlays[user.toKey()] = overlay;\n        }\n        return overlay;\n    }\n    getMutationQueue(user, indexManager) {\n        let queue = this.mutationQueues[user.toKey()];\n        if (!queue) {\n            queue = new MemoryMutationQueue(indexManager, this.referenceDelegate);\n            this.mutationQueues[user.toKey()] = queue;\n        }\n        return queue;\n    }\n    getGlobalsCache() {\n        return this.globalsCache;\n    }\n    getTargetCache() {\n        return this.targetCache;\n    }\n    getRemoteDocumentCache() {\n        return this.remoteDocumentCache;\n    }\n    getBundleCache() {\n        return this.bundleCache;\n    }\n    runTransaction(action, mode, transactionOperation) {\n        logDebug(LOG_TAG$d, 'Starting transaction:', action);\n        const txn = new MemoryTransaction(this.listenSequence.next());\n        this.referenceDelegate.onTransactionStarted();\n        return transactionOperation(txn)\n            .next(result => {\n            return this.referenceDelegate\n                .onTransactionCommitted(txn)\n                .next(() => result);\n        })\n            .toPromise()\n            .then(result => {\n            txn.raiseOnCommittedEvent();\n            return result;\n        });\n    }\n    mutationQueuesContainKey(transaction, key) {\n        return PersistencePromise.or(Object.values(this.mutationQueues).map(queue => () => queue.containsKey(transaction, key)));\n    }\n}\n/**\n * Memory persistence is not actually transactional, but future implementations\n * may have transaction-scoped state.\n */\nclass MemoryTransaction extends PersistenceTransaction {\n    constructor(currentSequenceNumber) {\n        super();\n        this.currentSequenceNumber = currentSequenceNumber;\n    }\n}\nclass MemoryEagerDelegate {\n    constructor(persistence) {\n        this.persistence = persistence;\n        /** Tracks all documents that are active in Query views. */\n        this.localViewReferences = new ReferenceSet();\n        /** The list of documents that are potentially GCed after each transaction. */\n        this._orphanedDocuments = null;\n    }\n    static factory(persistence) {\n        return new MemoryEagerDelegate(persistence);\n    }\n    get orphanedDocuments() {\n        if (!this._orphanedDocuments) {\n            throw fail();\n        }\n        else {\n            return this._orphanedDocuments;\n        }\n    }\n    addReference(txn, targetId, key) {\n        this.localViewReferences.addReference(key, targetId);\n        this.orphanedDocuments.delete(key.toString());\n        return PersistencePromise.resolve();\n    }\n    removeReference(txn, targetId, key) {\n        this.localViewReferences.removeReference(key, targetId);\n        this.orphanedDocuments.add(key.toString());\n        return PersistencePromise.resolve();\n    }\n    markPotentiallyOrphaned(txn, key) {\n        this.orphanedDocuments.add(key.toString());\n        return PersistencePromise.resolve();\n    }\n    removeTarget(txn, targetData) {\n        const orphaned = this.localViewReferences.removeReferencesForId(targetData.targetId);\n        orphaned.forEach(key => this.orphanedDocuments.add(key.toString()));\n        const cache = this.persistence.getTargetCache();\n        return cache\n            .getMatchingKeysForTargetId(txn, targetData.targetId)\n            .next(keys => {\n            keys.forEach(key => this.orphanedDocuments.add(key.toString()));\n        })\n            .next(() => cache.removeTargetData(txn, targetData));\n    }\n    onTransactionStarted() {\n        this._orphanedDocuments = new Set();\n    }\n    onTransactionCommitted(txn) {\n        // Remove newly orphaned documents.\n        const cache = this.persistence.getRemoteDocumentCache();\n        const changeBuffer = cache.newChangeBuffer();\n        return PersistencePromise.forEach(this.orphanedDocuments, (path) => {\n            const key = DocumentKey.fromPath(path);\n            return this.isReferenced(txn, key).next(isReferenced => {\n                if (!isReferenced) {\n                    changeBuffer.removeEntry(key, SnapshotVersion.min());\n                }\n            });\n        }).next(() => {\n            this._orphanedDocuments = null;\n            return changeBuffer.apply(txn);\n        });\n    }\n    updateLimboDocument(txn, key) {\n        return this.isReferenced(txn, key).next(isReferenced => {\n            if (isReferenced) {\n                this.orphanedDocuments.delete(key.toString());\n            }\n            else {\n                this.orphanedDocuments.add(key.toString());\n            }\n        });\n    }\n    documentSize(doc) {\n        // For eager GC, we don't care about the document size, there are no size thresholds.\n        return 0;\n    }\n    isReferenced(txn, key) {\n        return PersistencePromise.or([\n            () => PersistencePromise.resolve(this.localViewReferences.containsKey(key)),\n            () => this.persistence.getTargetCache().containsKey(txn, key),\n            () => this.persistence.mutationQueuesContainKey(txn, key)\n        ]);\n    }\n}\nclass MemoryLruDelegate {\n    constructor(persistence, lruParams) {\n        this.persistence = persistence;\n        this.orphanedSequenceNumbers = new ObjectMap(k => encodeResourcePath(k.path), (l, r) => l.isEqual(r));\n        this.garbageCollector = newLruGarbageCollector(this, lruParams);\n    }\n    static factory(persistence, lruParams) {\n        return new MemoryLruDelegate(persistence, lruParams);\n    }\n    // No-ops, present so memory persistence doesn't have to care which delegate\n    // it has.\n    onTransactionStarted() { }\n    onTransactionCommitted(txn) {\n        return PersistencePromise.resolve();\n    }\n    forEachTarget(txn, f) {\n        return this.persistence.getTargetCache().forEachTarget(txn, f);\n    }\n    getSequenceNumberCount(txn) {\n        const docCountPromise = this.orphanedDocumentCount(txn);\n        const targetCountPromise = this.persistence\n            .getTargetCache()\n            .getTargetCount(txn);\n        return targetCountPromise.next(targetCount => docCountPromise.next(docCount => targetCount + docCount));\n    }\n    orphanedDocumentCount(txn) {\n        let orphanedCount = 0;\n        return this.forEachOrphanedDocumentSequenceNumber(txn, _ => {\n            orphanedCount++;\n        }).next(() => orphanedCount);\n    }\n    forEachOrphanedDocumentSequenceNumber(txn, f) {\n        return PersistencePromise.forEach(this.orphanedSequenceNumbers, (key, sequenceNumber) => {\n            // Pass in the exact sequence number as the upper bound so we know it won't be pinned by\n            // being too recent.\n            return this.isPinned(txn, key, sequenceNumber).next(isPinned => {\n                if (!isPinned) {\n                    return f(sequenceNumber);\n                }\n                else {\n                    return PersistencePromise.resolve();\n                }\n            });\n        });\n    }\n    removeTargets(txn, upperBound, activeTargetIds) {\n        return this.persistence\n            .getTargetCache()\n            .removeTargets(txn, upperBound, activeTargetIds);\n    }\n    removeOrphanedDocuments(txn, upperBound) {\n        let count = 0;\n        const cache = this.persistence.getRemoteDocumentCache();\n        const changeBuffer = cache.newChangeBuffer();\n        const p = cache.forEachDocumentKey(txn, key => {\n            return this.isPinned(txn, key, upperBound).next(isPinned => {\n                if (!isPinned) {\n                    count++;\n                    changeBuffer.removeEntry(key, SnapshotVersion.min());\n                }\n            });\n        });\n        return p.next(() => changeBuffer.apply(txn)).next(() => count);\n    }\n    markPotentiallyOrphaned(txn, key) {\n        this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);\n        return PersistencePromise.resolve();\n    }\n    removeTarget(txn, targetData) {\n        const updated = targetData.withSequenceNumber(txn.currentSequenceNumber);\n        return this.persistence.getTargetCache().updateTargetData(txn, updated);\n    }\n    addReference(txn, targetId, key) {\n        this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);\n        return PersistencePromise.resolve();\n    }\n    removeReference(txn, targetId, key) {\n        this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);\n        return PersistencePromise.resolve();\n    }\n    updateLimboDocument(txn, key) {\n        this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);\n        return PersistencePromise.resolve();\n    }\n    documentSize(document) {\n        let documentSize = document.key.toString().length;\n        if (document.isFoundDocument()) {\n            documentSize += estimateByteSize(document.data.value);\n        }\n        return documentSize;\n    }\n    isPinned(txn, key, upperBound) {\n        return PersistencePromise.or([\n            () => this.persistence.mutationQueuesContainKey(txn, key),\n            () => this.persistence.getTargetCache().containsKey(txn, key),\n            () => {\n                const orphanedAt = this.orphanedSequenceNumbers.get(key);\n                return PersistencePromise.resolve(orphanedAt !== undefined && orphanedAt > upperBound);\n            }\n        ]);\n    }\n    getCacheSize(txn) {\n        return this.persistence.getRemoteDocumentCache().getSize(txn);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Performs database creation and schema upgrades. */\nclass SchemaConverter {\n    constructor(serializer) {\n        this.serializer = serializer;\n    }\n    /**\n     * Performs database creation and schema upgrades.\n     *\n     * Note that in production, this method is only ever used to upgrade the schema\n     * to SCHEMA_VERSION. Different values of toVersion are only used for testing\n     * and local feature development.\n     */\n    createOrUpgrade(db, txn, fromVersion, toVersion) {\n        const simpleDbTransaction = new SimpleDbTransaction('createOrUpgrade', txn);\n        if (fromVersion < 1 && toVersion >= 1) {\n            createPrimaryClientStore(db);\n            createMutationQueue(db);\n            createQueryCache(db);\n            createLegacyRemoteDocumentCache(db);\n        }\n        // Migration 2 to populate the targetGlobal object no longer needed since\n        // migration 3 unconditionally clears it.\n        let p = PersistencePromise.resolve();\n        if (fromVersion < 3 && toVersion >= 3) {\n            // Brand new clients don't need to drop and recreate--only clients that\n            // potentially have corrupt data.\n            if (fromVersion !== 0) {\n                dropQueryCache(db);\n                createQueryCache(db);\n            }\n            p = p.next(() => writeEmptyTargetGlobalEntry(simpleDbTransaction));\n        }\n        if (fromVersion < 4 && toVersion >= 4) {\n            if (fromVersion !== 0) {\n                // Schema version 3 uses auto-generated keys to generate globally unique\n                // mutation batch IDs (this was previously ensured internally by the\n                // client). To migrate to the new schema, we have to read all mutations\n                // and write them back out. We preserve the existing batch IDs to guarantee\n                // consistency with other object stores. Any further mutation batch IDs will\n                // be auto-generated.\n                p = p.next(() => upgradeMutationBatchSchemaAndMigrateData(db, simpleDbTransaction));\n            }\n            p = p.next(() => {\n                createClientMetadataStore(db);\n            });\n        }\n        if (fromVersion < 5 && toVersion >= 5) {\n            p = p.next(() => this.removeAcknowledgedMutations(simpleDbTransaction));\n        }\n        if (fromVersion < 6 && toVersion >= 6) {\n            p = p.next(() => {\n                createDocumentGlobalStore(db);\n                return this.addDocumentGlobal(simpleDbTransaction);\n            });\n        }\n        if (fromVersion < 7 && toVersion >= 7) {\n            p = p.next(() => this.ensureSequenceNumbers(simpleDbTransaction));\n        }\n        if (fromVersion < 8 && toVersion >= 8) {\n            p = p.next(() => this.createCollectionParentIndex(db, simpleDbTransaction));\n        }\n        if (fromVersion < 9 && toVersion >= 9) {\n            p = p.next(() => {\n                // Multi-Tab used to manage its own changelog, but this has been moved\n                // to the DbRemoteDocument object store itself. Since the previous change\n                // log only contained transient data, we can drop its object store.\n                dropRemoteDocumentChangesStore(db);\n                // Note: Schema version 9 used to create a read time index for the\n                // RemoteDocumentCache. This is now done with schema version 13.\n            });\n        }\n        if (fromVersion < 10 && toVersion >= 10) {\n            p = p.next(() => this.rewriteCanonicalIds(simpleDbTransaction));\n        }\n        if (fromVersion < 11 && toVersion >= 11) {\n            p = p.next(() => {\n                createBundlesStore(db);\n                createNamedQueriesStore(db);\n            });\n        }\n        if (fromVersion < 12 && toVersion >= 12) {\n            p = p.next(() => {\n                createDocumentOverlayStore(db);\n            });\n        }\n        if (fromVersion < 13 && toVersion >= 13) {\n            p = p\n                .next(() => createRemoteDocumentCache(db))\n                .next(() => this.rewriteRemoteDocumentCache(db, simpleDbTransaction))\n                .next(() => db.deleteObjectStore(DbRemoteDocumentStore$1));\n        }\n        if (fromVersion < 14 && toVersion >= 14) {\n            p = p.next(() => this.runOverlayMigration(db, simpleDbTransaction));\n        }\n        if (fromVersion < 15 && toVersion >= 15) {\n            p = p.next(() => createFieldIndex(db));\n        }\n        if (fromVersion < 16 && toVersion >= 16) {\n            // Clear the object stores to remove possibly corrupted index entries\n            p = p\n                .next(() => {\n                const indexStateStore = txn.objectStore(DbIndexStateStore);\n                indexStateStore.clear();\n            })\n                .next(() => {\n                const indexEntryStore = txn.objectStore(DbIndexEntryStore);\n                indexEntryStore.clear();\n            });\n        }\n        if (fromVersion < 17 && toVersion >= 17) {\n            p = p.next(() => {\n                createGlobalsStore(db);\n            });\n        }\n        return p;\n    }\n    addDocumentGlobal(txn) {\n        let byteSize = 0;\n        return txn\n            .store(DbRemoteDocumentStore$1)\n            .iterate((_, doc) => {\n            byteSize += dbDocumentSize(doc);\n        })\n            .next(() => {\n            const metadata = { byteSize };\n            return txn\n                .store(DbRemoteDocumentGlobalStore)\n                .put(DbRemoteDocumentGlobalKey, metadata);\n        });\n    }\n    removeAcknowledgedMutations(txn) {\n        const queuesStore = txn.store(DbMutationQueueStore);\n        const mutationsStore = txn.store(DbMutationBatchStore);\n        return queuesStore.loadAll().next(queues => {\n            return PersistencePromise.forEach(queues, (queue) => {\n                const range = IDBKeyRange.bound([queue.userId, BATCHID_UNKNOWN], [queue.userId, queue.lastAcknowledgedBatchId]);\n                return mutationsStore\n                    .loadAll(DbMutationBatchUserMutationsIndex, range)\n                    .next(dbBatches => {\n                    return PersistencePromise.forEach(dbBatches, (dbBatch) => {\n                        hardAssert(dbBatch.userId === queue.userId);\n                        const batch = fromDbMutationBatch(this.serializer, dbBatch);\n                        return removeMutationBatch(txn, queue.userId, batch).next(() => { });\n                    });\n                });\n            });\n        });\n    }\n    /**\n     * Ensures that every document in the remote document cache has a corresponding sentinel row\n     * with a sequence number. Missing rows are given the most recently used sequence number.\n     */\n    ensureSequenceNumbers(txn) {\n        const documentTargetStore = txn.store(DbTargetDocumentStore);\n        const documentsStore = txn.store(DbRemoteDocumentStore$1);\n        const globalTargetStore = txn.store(DbTargetGlobalStore);\n        return globalTargetStore.get(DbTargetGlobalKey).next(metadata => {\n            const writeSentinelKey = (path) => {\n                return documentTargetStore.put({\n                    targetId: 0,\n                    path: encodeResourcePath(path),\n                    sequenceNumber: metadata.highestListenSequenceNumber\n                });\n            };\n            const promises = [];\n            return documentsStore\n                .iterate((key, doc) => {\n                const path = new ResourcePath(key);\n                const docSentinelKey = sentinelKey(path);\n                promises.push(documentTargetStore.get(docSentinelKey).next(maybeSentinel => {\n                    if (!maybeSentinel) {\n                        return writeSentinelKey(path);\n                    }\n                    else {\n                        return PersistencePromise.resolve();\n                    }\n                }));\n            })\n                .next(() => PersistencePromise.waitFor(promises));\n        });\n    }\n    createCollectionParentIndex(db, txn) {\n        // Create the index.\n        db.createObjectStore(DbCollectionParentStore, {\n            keyPath: DbCollectionParentKeyPath\n        });\n        const collectionParentsStore = txn.store(DbCollectionParentStore);\n        // Helper to add an index entry iff we haven't already written it.\n        const cache = new MemoryCollectionParentIndex();\n        const addEntry = (collectionPath) => {\n            if (cache.add(collectionPath)) {\n                const collectionId = collectionPath.lastSegment();\n                const parentPath = collectionPath.popLast();\n                return collectionParentsStore.put({\n                    collectionId,\n                    parent: encodeResourcePath(parentPath)\n                });\n            }\n        };\n        // Index existing remote documents.\n        return txn\n            .store(DbRemoteDocumentStore$1)\n            .iterate({ keysOnly: true }, (pathSegments, _) => {\n            const path = new ResourcePath(pathSegments);\n            return addEntry(path.popLast());\n        })\n            .next(() => {\n            // Index existing mutations.\n            return txn\n                .store(DbDocumentMutationStore)\n                .iterate({ keysOnly: true }, ([userID, encodedPath, batchId], _) => {\n                const path = decodeResourcePath(encodedPath);\n                return addEntry(path.popLast());\n            });\n        });\n    }\n    rewriteCanonicalIds(txn) {\n        const targetStore = txn.store(DbTargetStore);\n        return targetStore.iterate((key, originalDbTarget) => {\n            const originalTargetData = fromDbTarget(originalDbTarget);\n            const updatedDbTarget = toDbTarget(this.serializer, originalTargetData);\n            return targetStore.put(updatedDbTarget);\n        });\n    }\n    rewriteRemoteDocumentCache(db, transaction) {\n        const legacyRemoteDocumentStore = transaction.store(DbRemoteDocumentStore$1);\n        const writes = [];\n        return legacyRemoteDocumentStore\n            .iterate((_, legacyDocument) => {\n            const remoteDocumentStore = transaction.store(DbRemoteDocumentStore);\n            const path = extractKey(legacyDocument).path.toArray();\n            const dbRemoteDocument = {\n                prefixPath: path.slice(0, path.length - 2),\n                collectionGroup: path[path.length - 2],\n                documentId: path[path.length - 1],\n                readTime: legacyDocument.readTime || [0, 0],\n                unknownDocument: legacyDocument.unknownDocument,\n                noDocument: legacyDocument.noDocument,\n                document: legacyDocument.document,\n                hasCommittedMutations: !!legacyDocument.hasCommittedMutations\n            };\n            writes.push(remoteDocumentStore.put(dbRemoteDocument));\n        })\n            .next(() => PersistencePromise.waitFor(writes));\n    }\n    runOverlayMigration(db, transaction) {\n        const mutationsStore = transaction.store(DbMutationBatchStore);\n        const remoteDocumentCache = newIndexedDbRemoteDocumentCache(this.serializer);\n        const memoryPersistence = new MemoryPersistence(MemoryEagerDelegate.factory, this.serializer.remoteSerializer);\n        return mutationsStore.loadAll().next(dbBatches => {\n            const userToDocumentSet = new Map();\n            dbBatches.forEach(dbBatch => {\n                var _a;\n                let documentSet = (_a = userToDocumentSet.get(dbBatch.userId)) !== null && _a !== void 0 ? _a : documentKeySet();\n                const batch = fromDbMutationBatch(this.serializer, dbBatch);\n                batch.keys().forEach(key => (documentSet = documentSet.add(key)));\n                userToDocumentSet.set(dbBatch.userId, documentSet);\n            });\n            return PersistencePromise.forEach(userToDocumentSet, (allDocumentKeysForUser, userId) => {\n                const user = new User(userId);\n                const documentOverlayCache = IndexedDbDocumentOverlayCache.forUser(this.serializer, user);\n                // NOTE: The index manager and the reference delegate are\n                // irrelevant for the purpose of recalculating and saving\n                // overlays. We can therefore simply use the memory\n                // implementation.\n                const indexManager = memoryPersistence.getIndexManager(user);\n                const mutationQueue = IndexedDbMutationQueue.forUser(user, this.serializer, indexManager, memoryPersistence.referenceDelegate);\n                const localDocumentsView = new LocalDocumentsView(remoteDocumentCache, mutationQueue, documentOverlayCache, indexManager);\n                return localDocumentsView\n                    .recalculateAndSaveOverlaysForDocumentKeys(new IndexedDbTransaction(transaction, ListenSequence.INVALID), allDocumentKeysForUser)\n                    .next();\n            });\n        });\n    }\n}\nfunction sentinelKey(path) {\n    return [0, encodeResourcePath(path)];\n}\nfunction createPrimaryClientStore(db) {\n    db.createObjectStore(DbPrimaryClientStore);\n}\nfunction createMutationQueue(db) {\n    db.createObjectStore(DbMutationQueueStore, {\n        keyPath: DbMutationQueueKeyPath\n    });\n    const mutationBatchesStore = db.createObjectStore(DbMutationBatchStore, {\n        keyPath: DbMutationBatchKeyPath,\n        autoIncrement: true\n    });\n    mutationBatchesStore.createIndex(DbMutationBatchUserMutationsIndex, DbMutationBatchUserMutationsKeyPath, { unique: true });\n    db.createObjectStore(DbDocumentMutationStore);\n}\n/**\n * Upgrade function to migrate the 'mutations' store from V1 to V3. Loads\n * and rewrites all data.\n */\nfunction upgradeMutationBatchSchemaAndMigrateData(db, txn) {\n    const v1MutationsStore = txn.store(DbMutationBatchStore);\n    return v1MutationsStore.loadAll().next(existingMutations => {\n        db.deleteObjectStore(DbMutationBatchStore);\n        const mutationsStore = db.createObjectStore(DbMutationBatchStore, {\n            keyPath: DbMutationBatchKeyPath,\n            autoIncrement: true\n        });\n        mutationsStore.createIndex(DbMutationBatchUserMutationsIndex, DbMutationBatchUserMutationsKeyPath, { unique: true });\n        const v3MutationsStore = txn.store(DbMutationBatchStore);\n        const writeAll = existingMutations.map(mutation => v3MutationsStore.put(mutation));\n        return PersistencePromise.waitFor(writeAll);\n    });\n}\nfunction createLegacyRemoteDocumentCache(db) {\n    db.createObjectStore(DbRemoteDocumentStore$1);\n}\nfunction createRemoteDocumentCache(db) {\n    const remoteDocumentStore = db.createObjectStore(DbRemoteDocumentStore, {\n        keyPath: DbRemoteDocumentKeyPath\n    });\n    remoteDocumentStore.createIndex(DbRemoteDocumentDocumentKeyIndex, DbRemoteDocumentDocumentKeyIndexPath);\n    remoteDocumentStore.createIndex(DbRemoteDocumentCollectionGroupIndex, DbRemoteDocumentCollectionGroupIndexPath);\n}\nfunction createDocumentGlobalStore(db) {\n    db.createObjectStore(DbRemoteDocumentGlobalStore);\n}\nfunction createQueryCache(db) {\n    const targetDocumentsStore = db.createObjectStore(DbTargetDocumentStore, {\n        keyPath: DbTargetDocumentKeyPath\n    });\n    targetDocumentsStore.createIndex(DbTargetDocumentDocumentTargetsIndex, DbTargetDocumentDocumentTargetsKeyPath, { unique: true });\n    const targetStore = db.createObjectStore(DbTargetStore, {\n        keyPath: DbTargetKeyPath\n    });\n    // NOTE: This is unique only because the TargetId is the suffix.\n    targetStore.createIndex(DbTargetQueryTargetsIndexName, DbTargetQueryTargetsKeyPath, { unique: true });\n    db.createObjectStore(DbTargetGlobalStore);\n}\nfunction dropQueryCache(db) {\n    db.deleteObjectStore(DbTargetDocumentStore);\n    db.deleteObjectStore(DbTargetStore);\n    db.deleteObjectStore(DbTargetGlobalStore);\n}\nfunction dropRemoteDocumentChangesStore(db) {\n    if (db.objectStoreNames.contains('remoteDocumentChanges')) {\n        db.deleteObjectStore('remoteDocumentChanges');\n    }\n}\n/**\n * Creates the target global singleton row.\n *\n * @param txn - The version upgrade transaction for indexeddb\n */\nfunction writeEmptyTargetGlobalEntry(txn) {\n    const globalStore = txn.store(DbTargetGlobalStore);\n    const metadata = {\n        highestTargetId: 0,\n        highestListenSequenceNumber: 0,\n        lastRemoteSnapshotVersion: SnapshotVersion.min().toTimestamp(),\n        targetCount: 0\n    };\n    return globalStore.put(DbTargetGlobalKey, metadata);\n}\nfunction createClientMetadataStore(db) {\n    db.createObjectStore(DbClientMetadataStore, {\n        keyPath: DbClientMetadataKeyPath\n    });\n}\nfunction createBundlesStore(db) {\n    db.createObjectStore(DbBundleStore, {\n        keyPath: DbBundleKeyPath\n    });\n}\nfunction createNamedQueriesStore(db) {\n    db.createObjectStore(DbNamedQueryStore, {\n        keyPath: DbNamedQueryKeyPath\n    });\n}\nfunction createFieldIndex(db) {\n    const indexConfigurationStore = db.createObjectStore(DbIndexConfigurationStore, {\n        keyPath: DbIndexConfigurationKeyPath,\n        autoIncrement: true\n    });\n    indexConfigurationStore.createIndex(DbIndexConfigurationCollectionGroupIndex, DbIndexConfigurationCollectionGroupIndexPath, { unique: false });\n    const indexStateStore = db.createObjectStore(DbIndexStateStore, {\n        keyPath: DbIndexStateKeyPath\n    });\n    indexStateStore.createIndex(DbIndexStateSequenceNumberIndex, DbIndexStateSequenceNumberIndexPath, { unique: false });\n    const indexEntryStore = db.createObjectStore(DbIndexEntryStore, {\n        keyPath: DbIndexEntryKeyPath\n    });\n    indexEntryStore.createIndex(DbIndexEntryDocumentKeyIndex, DbIndexEntryDocumentKeyIndexPath, { unique: false });\n}\nfunction createDocumentOverlayStore(db) {\n    const documentOverlayStore = db.createObjectStore(DbDocumentOverlayStore, {\n        keyPath: DbDocumentOverlayKeyPath\n    });\n    documentOverlayStore.createIndex(DbDocumentOverlayCollectionPathOverlayIndex, DbDocumentOverlayCollectionPathOverlayIndexPath, { unique: false });\n    documentOverlayStore.createIndex(DbDocumentOverlayCollectionGroupOverlayIndex, DbDocumentOverlayCollectionGroupOverlayIndexPath, { unique: false });\n}\nfunction createGlobalsStore(db) {\n    db.createObjectStore(DbGlobalsStore, {\n        keyPath: DbGlobalsKeyPath\n    });\n}\nfunction extractKey(remoteDoc) {\n    if (remoteDoc.document) {\n        return new DocumentKey(ResourcePath.fromString(remoteDoc.document.name).popFirst(5));\n    }\n    else if (remoteDoc.noDocument) {\n        return DocumentKey.fromSegments(remoteDoc.noDocument.path);\n    }\n    else if (remoteDoc.unknownDocument) {\n        return DocumentKey.fromSegments(remoteDoc.unknownDocument.path);\n    }\n    else {\n        return fail();\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$c = 'IndexedDbPersistence';\n/**\n * Oldest acceptable age in milliseconds for client metadata before the client\n * is considered inactive and its associated data is garbage collected.\n */\nconst MAX_CLIENT_AGE_MS = 30 * 60 * 1000; // 30 minutes\n/**\n * Oldest acceptable metadata age for clients that may participate in the\n * primary lease election. Clients that have not updated their client metadata\n * within 5 seconds are not eligible to receive a primary lease.\n */\nconst MAX_PRIMARY_ELIGIBLE_AGE_MS = 5000;\n/**\n * The interval at which clients will update their metadata, including\n * refreshing their primary lease if held or potentially trying to acquire it if\n * not held.\n *\n * Primary clients may opportunistically refresh their metadata earlier\n * if they're already performing an IndexedDB operation.\n */\nconst CLIENT_METADATA_REFRESH_INTERVAL_MS = 4000;\n/** User-facing error when the primary lease is required but not available. */\nconst PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG = 'Failed to obtain exclusive access to the persistence layer. To allow ' +\n    'shared access, multi-tab synchronization has to be enabled in all tabs. ' +\n    'If you are using `experimentalForceOwningTab:true`, make sure that only ' +\n    'one tab has persistence enabled at any given time.';\nconst UNSUPPORTED_PLATFORM_ERROR_MSG = 'This platform is either missing IndexedDB or is known to have ' +\n    'an incomplete implementation. Offline persistence has been disabled.';\n// The format of the LocalStorage key that stores zombied client is:\n//     firestore_zombie_<persistence_prefix>_<instance_key>\nconst ZOMBIED_CLIENTS_KEY_PREFIX = 'firestore_zombie';\n/**\n * The name of the main (and currently only) IndexedDB database. This name is\n * appended to the prefix provided to the IndexedDbPersistence constructor.\n */\nconst MAIN_DATABASE = 'main';\n/**\n * An IndexedDB-backed instance of Persistence. Data is stored persistently\n * across sessions.\n *\n * On Web only, the Firestore SDKs support shared access to its persistence\n * layer. This allows multiple browser tabs to read and write to IndexedDb and\n * to synchronize state even without network connectivity. Shared access is\n * currently optional and not enabled unless all clients invoke\n * `enablePersistence()` with `{synchronizeTabs:true}`.\n *\n * In multi-tab mode, if multiple clients are active at the same time, the SDK\n * will designate one client as the primary client. An effort is made to pick\n * a visible, network-connected and active client, and this client is\n * responsible for letting other clients know about its presence. The primary\n * client writes a unique client-generated identifier (the client ID) to\n * IndexedDbs owner store every 4 seconds. If the primary client fails to\n * update this entry, another client can acquire the lease and take over as\n * primary.\n *\n * Some persistence operations in the SDK are designated as primary-client only\n * operations. This includes the acknowledgment of mutations and all updates of\n * remote documents. The effects of these operations are written to persistence\n * and then broadcast to other tabs via LocalStorage (see\n * `WebStorageSharedClientState`), which then refresh their state from\n * persistence.\n *\n * Similarly, the primary client listens to notifications sent by secondary\n * clients to discover persistence changes written by secondary clients, such as\n * the addition of new mutations and query targets.\n *\n * If multi-tab is not enabled and another tab already obtained the primary\n * lease, IndexedDbPersistence enters a failed state and all subsequent\n * operations will automatically fail.\n *\n * Additionally, there is an optimization so that when a tab is closed, the\n * primary lease is released immediately (this is especially important to make\n * sure that a refreshed tab is able to immediately re-acquire the primary\n * lease). Unfortunately, IndexedDB cannot be reliably used in window.unload\n * since it is an asynchronous API. So in addition to attempting to give up the\n * lease, the leaseholder writes its client ID to a \"zombiedClient\" entry in\n * LocalStorage which acts as an indicator that another tab should go ahead and\n * take the primary lease immediately regardless of the current lease timestamp.\n *\n * TODO(b/114226234): Remove `synchronizeTabs` section when multi-tab is no\n * longer optional.\n */\nclass IndexedDbPersistence {\n    constructor(\n    /**\n     * Whether to synchronize the in-memory state of multiple tabs and share\n     * access to local persistence.\n     */\n    allowTabSynchronization, persistenceKey, clientId, lruParams, queue, window, document, serializer, sequenceNumberSyncer, \n    /**\n     * If set to true, forcefully obtains database access. Existing tabs will\n     * no longer be able to access IndexedDB.\n     */\n    forceOwningTab, schemaVersion = SCHEMA_VERSION) {\n        this.allowTabSynchronization = allowTabSynchronization;\n        this.persistenceKey = persistenceKey;\n        this.clientId = clientId;\n        this.queue = queue;\n        this.window = window;\n        this.document = document;\n        this.sequenceNumberSyncer = sequenceNumberSyncer;\n        this.forceOwningTab = forceOwningTab;\n        this.schemaVersion = schemaVersion;\n        this.listenSequence = null;\n        this._started = false;\n        this.isPrimary = false;\n        this.networkEnabled = true;\n        /** Our window.unload handler, if registered. */\n        this.windowUnloadHandler = null;\n        this.inForeground = false;\n        /** Our 'visibilitychange' listener if registered. */\n        this.documentVisibilityHandler = null;\n        /** The client metadata refresh task. */\n        this.clientMetadataRefresher = null;\n        /** The last time we garbage collected the client metadata object store. */\n        this.lastGarbageCollectionTime = Number.NEGATIVE_INFINITY;\n        /** A listener to notify on primary state changes. */\n        this.primaryStateListener = _ => Promise.resolve();\n        if (!IndexedDbPersistence.isAvailable()) {\n            throw new FirestoreError(Code.UNIMPLEMENTED, UNSUPPORTED_PLATFORM_ERROR_MSG);\n        }\n        this.referenceDelegate = new IndexedDbLruDelegateImpl(this, lruParams);\n        this.dbName = persistenceKey + MAIN_DATABASE;\n        this.serializer = new LocalSerializer(serializer);\n        this.simpleDb = new SimpleDb(this.dbName, this.schemaVersion, new SchemaConverter(this.serializer));\n        this.globalsCache = new IndexedDbGlobalsCache();\n        this.targetCache = new IndexedDbTargetCache(this.referenceDelegate, this.serializer);\n        this.remoteDocumentCache = newIndexedDbRemoteDocumentCache(this.serializer);\n        this.bundleCache = new IndexedDbBundleCache();\n        if (this.window && this.window.localStorage) {\n            this.webStorage = this.window.localStorage;\n        }\n        else {\n            this.webStorage = null;\n            if (forceOwningTab === false) {\n                logError(LOG_TAG$c, 'LocalStorage is unavailable. As a result, persistence may not work ' +\n                    'reliably. In particular enablePersistence() could fail immediately ' +\n                    'after refreshing the page.');\n            }\n        }\n    }\n    /**\n     * Attempt to start IndexedDb persistence.\n     *\n     * @returns Whether persistence was enabled.\n     */\n    start() {\n        // NOTE: This is expected to fail sometimes (in the case of another tab\n        // already having the persistence lock), so it's the first thing we should\n        // do.\n        return this.updateClientMetadataAndTryBecomePrimary()\n            .then(() => {\n            if (!this.isPrimary && !this.allowTabSynchronization) {\n                // Fail `start()` if `synchronizeTabs` is disabled and we cannot\n                // obtain the primary lease.\n                throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);\n            }\n            this.attachVisibilityHandler();\n            this.attachWindowUnloadHook();\n            this.scheduleClientMetadataAndPrimaryLeaseRefreshes();\n            return this.runTransaction('getHighestListenSequenceNumber', 'readonly', txn => this.targetCache.getHighestSequenceNumber(txn));\n        })\n            .then(highestListenSequenceNumber => {\n            this.listenSequence = new ListenSequence(highestListenSequenceNumber, this.sequenceNumberSyncer);\n        })\n            .then(() => {\n            this._started = true;\n        })\n            .catch(reason => {\n            this.simpleDb && this.simpleDb.close();\n            return Promise.reject(reason);\n        });\n    }\n    /**\n     * Registers a listener that gets called when the primary state of the\n     * instance changes. Upon registering, this listener is invoked immediately\n     * with the current primary state.\n     *\n     * PORTING NOTE: This is only used for Web multi-tab.\n     */\n    setPrimaryStateListener(primaryStateListener) {\n        this.primaryStateListener = async (primaryState) => {\n            if (this.started) {\n                return primaryStateListener(primaryState);\n            }\n        };\n        return primaryStateListener(this.isPrimary);\n    }\n    /**\n     * Registers a listener that gets called when the database receives a\n     * version change event indicating that it has deleted.\n     *\n     * PORTING NOTE: This is only used for Web multi-tab.\n     */\n    setDatabaseDeletedListener(databaseDeletedListener) {\n        this.simpleDb.setVersionChangeListener(async (event) => {\n            // Check if an attempt is made to delete IndexedDB.\n            if (event.newVersion === null) {\n                await databaseDeletedListener();\n            }\n        });\n    }\n    /**\n     * Adjusts the current network state in the client's metadata, potentially\n     * affecting the primary lease.\n     *\n     * PORTING NOTE: This is only used for Web multi-tab.\n     */\n    setNetworkEnabled(networkEnabled) {\n        if (this.networkEnabled !== networkEnabled) {\n            this.networkEnabled = networkEnabled;\n            // Schedule a primary lease refresh for immediate execution. The eventual\n            // lease update will be propagated via `primaryStateListener`.\n            this.queue.enqueueAndForget(async () => {\n                if (this.started) {\n                    await this.updateClientMetadataAndTryBecomePrimary();\n                }\n            });\n        }\n    }\n    /**\n     * Updates the client metadata in IndexedDb and attempts to either obtain or\n     * extend the primary lease for the local client. Asynchronously notifies the\n     * primary state listener if the client either newly obtained or released its\n     * primary lease.\n     */\n    updateClientMetadataAndTryBecomePrimary() {\n        return this.runTransaction('updateClientMetadataAndTryBecomePrimary', 'readwrite', txn => {\n            const metadataStore = clientMetadataStore(txn);\n            return metadataStore\n                .put({\n                clientId: this.clientId,\n                updateTimeMs: Date.now(),\n                networkEnabled: this.networkEnabled,\n                inForeground: this.inForeground\n            })\n                .next(() => {\n                if (this.isPrimary) {\n                    return this.verifyPrimaryLease(txn).next(success => {\n                        if (!success) {\n                            this.isPrimary = false;\n                            this.queue.enqueueRetryable(() => this.primaryStateListener(false));\n                        }\n                    });\n                }\n            })\n                .next(() => this.canActAsPrimary(txn))\n                .next(canActAsPrimary => {\n                if (this.isPrimary && !canActAsPrimary) {\n                    return this.releasePrimaryLeaseIfHeld(txn).next(() => false);\n                }\n                else if (canActAsPrimary) {\n                    return this.acquireOrExtendPrimaryLease(txn).next(() => true);\n                }\n                else {\n                    return /* canActAsPrimary= */ false;\n                }\n            });\n        })\n            .catch(e => {\n            if (isIndexedDbTransactionError(e)) {\n                logDebug(LOG_TAG$c, 'Failed to extend owner lease: ', e);\n                // Proceed with the existing state. Any subsequent access to\n                // IndexedDB will verify the lease.\n                return this.isPrimary;\n            }\n            if (!this.allowTabSynchronization) {\n                throw e;\n            }\n            logDebug(LOG_TAG$c, 'Releasing owner lease after error during lease refresh', e);\n            return /* isPrimary= */ false;\n        })\n            .then(isPrimary => {\n            if (this.isPrimary !== isPrimary) {\n                this.queue.enqueueRetryable(() => this.primaryStateListener(isPrimary));\n            }\n            this.isPrimary = isPrimary;\n        });\n    }\n    verifyPrimaryLease(txn) {\n        const store = primaryClientStore(txn);\n        return store.get(DbPrimaryClientKey).next(primaryClient => {\n            return PersistencePromise.resolve(this.isLocalClient(primaryClient));\n        });\n    }\n    removeClientMetadata(txn) {\n        const metadataStore = clientMetadataStore(txn);\n        return metadataStore.delete(this.clientId);\n    }\n    /**\n     * If the garbage collection threshold has passed, prunes the\n     * RemoteDocumentChanges and the ClientMetadata store based on the last update\n     * time of all clients.\n     */\n    async maybeGarbageCollectMultiClientState() {\n        if (this.isPrimary &&\n            !this.isWithinAge(this.lastGarbageCollectionTime, MAX_CLIENT_AGE_MS)) {\n            this.lastGarbageCollectionTime = Date.now();\n            const inactiveClients = await this.runTransaction('maybeGarbageCollectMultiClientState', 'readwrite-primary', txn => {\n                const metadataStore = getStore(txn, DbClientMetadataStore);\n                return metadataStore.loadAll().next(existingClients => {\n                    const active = this.filterActiveClients(existingClients, MAX_CLIENT_AGE_MS);\n                    const inactive = existingClients.filter(client => active.indexOf(client) === -1);\n                    // Delete metadata for clients that are no longer considered active.\n                    return PersistencePromise.forEach(inactive, (inactiveClient) => metadataStore.delete(inactiveClient.clientId)).next(() => inactive);\n                });\n            }).catch(() => {\n                // Ignore primary lease violations or any other type of error. The next\n                // primary will run `maybeGarbageCollectMultiClientState()` again.\n                // We don't use `ignoreIfPrimaryLeaseLoss()` since we don't want to depend\n                // on LocalStore.\n                return [];\n            });\n            // Delete potential leftover entries that may continue to mark the\n            // inactive clients as zombied in LocalStorage.\n            // Ideally we'd delete the IndexedDb and LocalStorage zombie entries for\n            // the client atomically, but we can't. So we opt to delete the IndexedDb\n            // entries first to avoid potentially reviving a zombied client.\n            if (this.webStorage) {\n                for (const inactiveClient of inactiveClients) {\n                    this.webStorage.removeItem(this.zombiedClientLocalStorageKey(inactiveClient.clientId));\n                }\n            }\n        }\n    }\n    /**\n     * Schedules a recurring timer to update the client metadata and to either\n     * extend or acquire the primary lease if the client is eligible.\n     */\n    scheduleClientMetadataAndPrimaryLeaseRefreshes() {\n        this.clientMetadataRefresher = this.queue.enqueueAfterDelay(\"client_metadata_refresh\" /* TimerId.ClientMetadataRefresh */, CLIENT_METADATA_REFRESH_INTERVAL_MS, () => {\n            return this.updateClientMetadataAndTryBecomePrimary()\n                .then(() => this.maybeGarbageCollectMultiClientState())\n                .then(() => this.scheduleClientMetadataAndPrimaryLeaseRefreshes());\n        });\n    }\n    /** Checks whether `client` is the local client. */\n    isLocalClient(client) {\n        return client ? client.ownerId === this.clientId : false;\n    }\n    /**\n     * Evaluate the state of all active clients and determine whether the local\n     * client is or can act as the holder of the primary lease. Returns whether\n     * the client is eligible for the lease, but does not actually acquire it.\n     * May return 'false' even if there is no active leaseholder and another\n     * (foreground) client should become leaseholder instead.\n     */\n    canActAsPrimary(txn) {\n        if (this.forceOwningTab) {\n            return PersistencePromise.resolve(true);\n        }\n        const store = primaryClientStore(txn);\n        return store\n            .get(DbPrimaryClientKey)\n            .next(currentPrimary => {\n            const currentLeaseIsValid = currentPrimary !== null &&\n                this.isWithinAge(currentPrimary.leaseTimestampMs, MAX_PRIMARY_ELIGIBLE_AGE_MS) &&\n                !this.isClientZombied(currentPrimary.ownerId);\n            // A client is eligible for the primary lease if:\n            // - its network is enabled and the client's tab is in the foreground.\n            // - its network is enabled and no other client's tab is in the\n            //   foreground.\n            // - every clients network is disabled and the client's tab is in the\n            //   foreground.\n            // - every clients network is disabled and no other client's tab is in\n            //   the foreground.\n            // - the `forceOwningTab` setting was passed in.\n            if (currentLeaseIsValid) {\n                if (this.isLocalClient(currentPrimary) && this.networkEnabled) {\n                    return true;\n                }\n                if (!this.isLocalClient(currentPrimary)) {\n                    if (!currentPrimary.allowTabSynchronization) {\n                        // Fail the `canActAsPrimary` check if the current leaseholder has\n                        // not opted into multi-tab synchronization. If this happens at\n                        // client startup, we reject the Promise returned by\n                        // `enablePersistence()` and the user can continue to use Firestore\n                        // with in-memory persistence.\n                        // If this fails during a lease refresh, we will instead block the\n                        // AsyncQueue from executing further operations. Note that this is\n                        // acceptable since mixing & matching different `synchronizeTabs`\n                        // settings is not supported.\n                        //\n                        // TODO(b/114226234): Remove this check when `synchronizeTabs` can\n                        // no longer be turned off.\n                        throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);\n                    }\n                    return false;\n                }\n            }\n            if (this.networkEnabled && this.inForeground) {\n                return true;\n            }\n            return clientMetadataStore(txn)\n                .loadAll()\n                .next(existingClients => {\n                // Process all existing clients and determine whether at least one of\n                // them is better suited to obtain the primary lease.\n                const preferredCandidate = this.filterActiveClients(existingClients, MAX_PRIMARY_ELIGIBLE_AGE_MS).find(otherClient => {\n                    if (this.clientId !== otherClient.clientId) {\n                        const otherClientHasBetterNetworkState = !this.networkEnabled && otherClient.networkEnabled;\n                        const otherClientHasBetterVisibility = !this.inForeground && otherClient.inForeground;\n                        const otherClientHasSameNetworkState = this.networkEnabled === otherClient.networkEnabled;\n                        if (otherClientHasBetterNetworkState ||\n                            (otherClientHasBetterVisibility &&\n                                otherClientHasSameNetworkState)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                });\n                return preferredCandidate === undefined;\n            });\n        })\n            .next(canActAsPrimary => {\n            if (this.isPrimary !== canActAsPrimary) {\n                logDebug(LOG_TAG$c, `Client ${canActAsPrimary ? 'is' : 'is not'} eligible for a primary lease.`);\n            }\n            return canActAsPrimary;\n        });\n    }\n    async shutdown() {\n        // The shutdown() operations are idempotent and can be called even when\n        // start() aborted (e.g. because it couldn't acquire the persistence lease).\n        this._started = false;\n        this.markClientZombied();\n        if (this.clientMetadataRefresher) {\n            this.clientMetadataRefresher.cancel();\n            this.clientMetadataRefresher = null;\n        }\n        this.detachVisibilityHandler();\n        this.detachWindowUnloadHook();\n        // Use `SimpleDb.runTransaction` directly to avoid failing if another tab\n        // has obtained the primary lease.\n        await this.simpleDb.runTransaction('shutdown', 'readwrite', [DbPrimaryClientStore, DbClientMetadataStore], simpleDbTxn => {\n            const persistenceTransaction = new IndexedDbTransaction(simpleDbTxn, ListenSequence.INVALID);\n            return this.releasePrimaryLeaseIfHeld(persistenceTransaction).next(() => this.removeClientMetadata(persistenceTransaction));\n        });\n        this.simpleDb.close();\n        // Remove the entry marking the client as zombied from LocalStorage since\n        // we successfully deleted its metadata from IndexedDb.\n        this.removeClientZombiedEntry();\n    }\n    /**\n     * Returns clients that are not zombied and have an updateTime within the\n     * provided threshold.\n     */\n    filterActiveClients(clients, activityThresholdMs) {\n        return clients.filter(client => this.isWithinAge(client.updateTimeMs, activityThresholdMs) &&\n            !this.isClientZombied(client.clientId));\n    }\n    /**\n     * Returns the IDs of the clients that are currently active. If multi-tab\n     * is not supported, returns an array that only contains the local client's\n     * ID.\n     *\n     * PORTING NOTE: This is only used for Web multi-tab.\n     */\n    getActiveClients() {\n        return this.runTransaction('getActiveClients', 'readonly', txn => {\n            return clientMetadataStore(txn)\n                .loadAll()\n                .next(clients => this.filterActiveClients(clients, MAX_CLIENT_AGE_MS).map(clientMetadata => clientMetadata.clientId));\n        });\n    }\n    get started() {\n        return this._started;\n    }\n    getGlobalsCache() {\n        return this.globalsCache;\n    }\n    getMutationQueue(user, indexManager) {\n        return IndexedDbMutationQueue.forUser(user, this.serializer, indexManager, this.referenceDelegate);\n    }\n    getTargetCache() {\n        return this.targetCache;\n    }\n    getRemoteDocumentCache() {\n        return this.remoteDocumentCache;\n    }\n    getIndexManager(user) {\n        return new IndexedDbIndexManager(user, this.serializer.remoteSerializer.databaseId);\n    }\n    getDocumentOverlayCache(user) {\n        return IndexedDbDocumentOverlayCache.forUser(this.serializer, user);\n    }\n    getBundleCache() {\n        return this.bundleCache;\n    }\n    runTransaction(action, mode, transactionOperation) {\n        logDebug(LOG_TAG$c, 'Starting transaction:', action);\n        const simpleDbMode = mode === 'readonly' ? 'readonly' : 'readwrite';\n        const objectStores = getObjectStores(this.schemaVersion);\n        let persistenceTransaction;\n        // Do all transactions as readwrite against all object stores, since we\n        // are the only reader/writer.\n        return this.simpleDb\n            .runTransaction(action, simpleDbMode, objectStores, simpleDbTxn => {\n            persistenceTransaction = new IndexedDbTransaction(simpleDbTxn, this.listenSequence\n                ? this.listenSequence.next()\n                : ListenSequence.INVALID);\n            if (mode === 'readwrite-primary') {\n                // While we merely verify that we have (or can acquire) the lease\n                // immediately, we wait to extend the primary lease until after\n                // executing transactionOperation(). This ensures that even if the\n                // transactionOperation takes a long time, we'll use a recent\n                // leaseTimestampMs in the extended (or newly acquired) lease.\n                return this.verifyPrimaryLease(persistenceTransaction)\n                    .next(holdsPrimaryLease => {\n                    if (holdsPrimaryLease) {\n                        return /* holdsPrimaryLease= */ true;\n                    }\n                    return this.canActAsPrimary(persistenceTransaction);\n                })\n                    .next(holdsPrimaryLease => {\n                    if (!holdsPrimaryLease) {\n                        logError(`Failed to obtain primary lease for action '${action}'.`);\n                        this.isPrimary = false;\n                        this.queue.enqueueRetryable(() => this.primaryStateListener(false));\n                        throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_LOST_ERROR_MSG);\n                    }\n                    return transactionOperation(persistenceTransaction);\n                })\n                    .next(result => {\n                    return this.acquireOrExtendPrimaryLease(persistenceTransaction).next(() => result);\n                });\n            }\n            else {\n                return this.verifyAllowTabSynchronization(persistenceTransaction).next(() => transactionOperation(persistenceTransaction));\n            }\n        })\n            .then(result => {\n            persistenceTransaction.raiseOnCommittedEvent();\n            return result;\n        });\n    }\n    /**\n     * Verifies that the current tab is the primary leaseholder or alternatively\n     * that the leaseholder has opted into multi-tab synchronization.\n     */\n    // TODO(b/114226234): Remove this check when `synchronizeTabs` can no longer\n    // be turned off.\n    verifyAllowTabSynchronization(txn) {\n        const store = primaryClientStore(txn);\n        return store.get(DbPrimaryClientKey).next(currentPrimary => {\n            const currentLeaseIsValid = currentPrimary !== null &&\n                this.isWithinAge(currentPrimary.leaseTimestampMs, MAX_PRIMARY_ELIGIBLE_AGE_MS) &&\n                !this.isClientZombied(currentPrimary.ownerId);\n            if (currentLeaseIsValid && !this.isLocalClient(currentPrimary)) {\n                if (!this.forceOwningTab &&\n                    (!this.allowTabSynchronization ||\n                        !currentPrimary.allowTabSynchronization)) {\n                    throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);\n                }\n            }\n        });\n    }\n    /**\n     * Obtains or extends the new primary lease for the local client. This\n     * method does not verify that the client is eligible for this lease.\n     */\n    acquireOrExtendPrimaryLease(txn) {\n        const newPrimary = {\n            ownerId: this.clientId,\n            allowTabSynchronization: this.allowTabSynchronization,\n            leaseTimestampMs: Date.now()\n        };\n        return primaryClientStore(txn).put(DbPrimaryClientKey, newPrimary);\n    }\n    static isAvailable() {\n        return SimpleDb.isAvailable();\n    }\n    /** Checks the primary lease and removes it if we are the current primary. */\n    releasePrimaryLeaseIfHeld(txn) {\n        const store = primaryClientStore(txn);\n        return store.get(DbPrimaryClientKey).next(primaryClient => {\n            if (this.isLocalClient(primaryClient)) {\n                logDebug(LOG_TAG$c, 'Releasing primary lease.');\n                return store.delete(DbPrimaryClientKey);\n            }\n            else {\n                return PersistencePromise.resolve();\n            }\n        });\n    }\n    /** Verifies that `updateTimeMs` is within `maxAgeMs`. */\n    isWithinAge(updateTimeMs, maxAgeMs) {\n        const now = Date.now();\n        const minAcceptable = now - maxAgeMs;\n        const maxAcceptable = now;\n        if (updateTimeMs < minAcceptable) {\n            return false;\n        }\n        else if (updateTimeMs > maxAcceptable) {\n            logError(`Detected an update time that is in the future: ${updateTimeMs} > ${maxAcceptable}`);\n            return false;\n        }\n        return true;\n    }\n    attachVisibilityHandler() {\n        if (this.document !== null &&\n            typeof this.document.addEventListener === 'function') {\n            this.documentVisibilityHandler = () => {\n                this.queue.enqueueAndForget(() => {\n                    this.inForeground = this.document.visibilityState === 'visible';\n                    return this.updateClientMetadataAndTryBecomePrimary();\n                });\n            };\n            this.document.addEventListener('visibilitychange', this.documentVisibilityHandler);\n            this.inForeground = this.document.visibilityState === 'visible';\n        }\n    }\n    detachVisibilityHandler() {\n        if (this.documentVisibilityHandler) {\n            this.document.removeEventListener('visibilitychange', this.documentVisibilityHandler);\n            this.documentVisibilityHandler = null;\n        }\n    }\n    /**\n     * Attaches a window.unload handler that will synchronously write our\n     * clientId to a \"zombie client id\" location in LocalStorage. This can be used\n     * by tabs trying to acquire the primary lease to determine that the lease\n     * is no longer valid even if the timestamp is recent. This is particularly\n     * important for the refresh case (so the tab correctly re-acquires the\n     * primary lease). LocalStorage is used for this rather than IndexedDb because\n     * it is a synchronous API and so can be used reliably from  an unload\n     * handler.\n     */\n    attachWindowUnloadHook() {\n        var _a;\n        if (typeof ((_a = this.window) === null || _a === void 0 ? void 0 : _a.addEventListener) === 'function') {\n            this.windowUnloadHandler = () => {\n                // Note: In theory, this should be scheduled on the AsyncQueue since it\n                // accesses internal state. We execute this code directly during shutdown\n                // to make sure it gets a chance to run.\n                this.markClientZombied();\n                const safariIndexdbBugVersionRegex = /(?:Version|Mobile)\\/1[456]/;\n                if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isSafari)() &&\n                    (navigator.appVersion.match(safariIndexdbBugVersionRegex) ||\n                        navigator.userAgent.match(safariIndexdbBugVersionRegex))) {\n                    // On Safari 14, 15, and 16, we do not run any cleanup actions as it might\n                    // trigger a bug that prevents Safari from re-opening IndexedDB during\n                    // the next page load.\n                    // See https://bugs.webkit.org/show_bug.cgi?id=226547\n                    this.queue.enterRestrictedMode(/* purgeExistingTasks= */ true);\n                }\n                this.queue.enqueueAndForget(() => {\n                    // Attempt graceful shutdown (including releasing our primary lease),\n                    // but there's no guarantee it will complete.\n                    return this.shutdown();\n                });\n            };\n            this.window.addEventListener('pagehide', this.windowUnloadHandler);\n        }\n    }\n    detachWindowUnloadHook() {\n        if (this.windowUnloadHandler) {\n            this.window.removeEventListener('pagehide', this.windowUnloadHandler);\n            this.windowUnloadHandler = null;\n        }\n    }\n    /**\n     * Returns whether a client is \"zombied\" based on its LocalStorage entry.\n     * Clients become zombied when their tab closes without running all of the\n     * cleanup logic in `shutdown()`.\n     */\n    isClientZombied(clientId) {\n        var _a;\n        try {\n            const isZombied = ((_a = this.webStorage) === null || _a === void 0 ? void 0 : _a.getItem(this.zombiedClientLocalStorageKey(clientId))) !== null;\n            logDebug(LOG_TAG$c, `Client '${clientId}' ${isZombied ? 'is' : 'is not'} zombied in LocalStorage`);\n            return isZombied;\n        }\n        catch (e) {\n            // Gracefully handle if LocalStorage isn't working.\n            logError(LOG_TAG$c, 'Failed to get zombied client id.', e);\n            return false;\n        }\n    }\n    /**\n     * Record client as zombied (a client that had its tab closed). Zombied\n     * clients are ignored during primary tab selection.\n     */\n    markClientZombied() {\n        if (!this.webStorage) {\n            return;\n        }\n        try {\n            this.webStorage.setItem(this.zombiedClientLocalStorageKey(this.clientId), String(Date.now()));\n        }\n        catch (e) {\n            // Gracefully handle if LocalStorage isn't available / working.\n            logError('Failed to set zombie client id.', e);\n        }\n    }\n    /** Removes the zombied client entry if it exists. */\n    removeClientZombiedEntry() {\n        if (!this.webStorage) {\n            return;\n        }\n        try {\n            this.webStorage.removeItem(this.zombiedClientLocalStorageKey(this.clientId));\n        }\n        catch (e) {\n            // Ignore\n        }\n    }\n    zombiedClientLocalStorageKey(clientId) {\n        return `${ZOMBIED_CLIENTS_KEY_PREFIX}_${this.persistenceKey}_${clientId}`;\n    }\n}\n/**\n * Helper to get a typed SimpleDbStore for the primary client object store.\n */\nfunction primaryClientStore(txn) {\n    return getStore(txn, DbPrimaryClientStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the client metadata object store.\n */\nfunction clientMetadataStore(txn) {\n    return getStore(txn, DbClientMetadataStore);\n}\n/**\n * Generates a string used as a prefix when storing data in IndexedDB and\n * LocalStorage.\n */\nfunction indexedDbStoragePrefix(databaseId, persistenceKey) {\n    // Use two different prefix formats:\n    //\n    //   * firestore / persistenceKey / projectID . databaseID / ...\n    //   * firestore / persistenceKey / projectID / ...\n    //\n    // projectIDs are DNS-compatible names and cannot contain dots\n    // so there's no danger of collisions.\n    let database = databaseId.projectId;\n    if (!databaseId.isDefaultDatabase) {\n        database += '.' + databaseId.database;\n    }\n    return 'firestore/' + persistenceKey + '/' + database + '/';\n}\nasync function indexedDbClearPersistence(persistenceKey) {\n    if (!SimpleDb.isAvailable()) {\n        return Promise.resolve();\n    }\n    const dbName = persistenceKey + MAIN_DATABASE;\n    await SimpleDb.delete(dbName);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Compares two array for equality using comparator. The method computes the\n * intersection and invokes `onAdd` for every element that is in `after` but not\n * `before`. `onRemove` is invoked for every element in `before` but missing\n * from `after`.\n *\n * The method creates a copy of both `before` and `after` and runs in O(n log\n * n), where n is the size of the two lists.\n *\n * @param before - The elements that exist in the original array.\n * @param after - The elements to diff against the original array.\n * @param comparator - The comparator for the elements in before and after.\n * @param onAdd - A function to invoke for every element that is part of `\n * after` but not `before`.\n * @param onRemove - A function to invoke for every element that is part of\n * `before` but not `after`.\n */\nfunction diffArrays(before, after, comparator, onAdd, onRemove) {\n    before = [...before];\n    after = [...after];\n    before.sort(comparator);\n    after.sort(comparator);\n    const bLen = before.length;\n    const aLen = after.length;\n    let a = 0;\n    let b = 0;\n    while (a < aLen && b < bLen) {\n        const cmp = comparator(before[b], after[a]);\n        if (cmp < 0) {\n            // The element was removed if the next element in our ordered\n            // walkthrough is only in `before`.\n            onRemove(before[b++]);\n        }\n        else if (cmp > 0) {\n            // The element was added if the next element in our ordered walkthrough\n            // is only in `after`.\n            onAdd(after[a++]);\n        }\n        else {\n            a++;\n            b++;\n        }\n    }\n    while (a < aLen) {\n        onAdd(after[a++]);\n    }\n    while (b < bLen) {\n        onRemove(before[b++]);\n    }\n}\n/**\n * Verifies equality for an array of primitives.\n *\n * @private\n * @internal\n * @param left Array of primitives.\n * @param right Array of primitives.\n * @return True if arrays are equal.\n */\nfunction isPrimitiveArrayEqual(left, right) {\n    if (left.length !== right.length) {\n        return false;\n    }\n    for (let i = 0; i < left.length; ++i) {\n        if (left[i] !== right[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$b = 'LocalStore';\n/**\n * The maximum time to leave a resume token buffered without writing it out.\n * This value is arbitrary: it's long enough to avoid several writes\n * (possibly indefinitely if updates come more frequently than this) but\n * short enough that restarting after crashing will still have a pretty\n * recent resume token.\n */\nconst RESUME_TOKEN_MAX_AGE_MICROS = 5 * 60 * 1e6;\n/**\n * Implements `LocalStore` interface.\n *\n * Note: some field defined in this class might have public access level, but\n * the class is not exported so they are only accessible from this module.\n * This is useful to implement optional features (like bundles) in free\n * functions, such that they are tree-shakeable.\n */\nclass LocalStoreImpl {\n    constructor(\n    /** Manages our in-memory or durable persistence. */\n    persistence, queryEngine, initialUser, serializer) {\n        this.persistence = persistence;\n        this.queryEngine = queryEngine;\n        this.serializer = serializer;\n        /**\n         * Maps a targetID to data about its target.\n         *\n         * PORTING NOTE: We are using an immutable data structure on Web to make re-runs\n         * of `applyRemoteEvent()` idempotent.\n         */\n        this.targetDataByTarget = new SortedMap(primitiveComparator);\n        /** Maps a target to its targetID. */\n        // TODO(wuandy): Evaluate if TargetId can be part of Target.\n        this.targetIdByTarget = new ObjectMap(t => canonifyTarget(t), targetEquals);\n        /**\n         * A per collection group index of the last read time processed by\n         * `getNewDocumentChanges()`.\n         *\n         * PORTING NOTE: This is only used for multi-tab synchronization.\n         */\n        this.collectionGroupReadTime = new Map();\n        this.remoteDocuments = persistence.getRemoteDocumentCache();\n        this.targetCache = persistence.getTargetCache();\n        this.bundleCache = persistence.getBundleCache();\n        this.initializeUserComponents(initialUser);\n    }\n    initializeUserComponents(user) {\n        // TODO(indexing): Add spec tests that test these components change after a\n        // user change\n        this.documentOverlayCache = this.persistence.getDocumentOverlayCache(user);\n        this.indexManager = this.persistence.getIndexManager(user);\n        this.mutationQueue = this.persistence.getMutationQueue(user, this.indexManager);\n        this.localDocuments = new LocalDocumentsView(this.remoteDocuments, this.mutationQueue, this.documentOverlayCache, this.indexManager);\n        this.remoteDocuments.setIndexManager(this.indexManager);\n        this.queryEngine.initialize(this.localDocuments, this.indexManager);\n    }\n    collectGarbage(garbageCollector) {\n        return this.persistence.runTransaction('Collect garbage', 'readwrite-primary', txn => garbageCollector.collect(txn, this.targetDataByTarget));\n    }\n}\nfunction newLocalStore(\n/** Manages our in-memory or durable persistence. */\npersistence, queryEngine, initialUser, serializer) {\n    return new LocalStoreImpl(persistence, queryEngine, initialUser, serializer);\n}\n/**\n * Tells the LocalStore that the currently authenticated user has changed.\n *\n * In response the local store switches the mutation queue to the new user and\n * returns any resulting document changes.\n */\n// PORTING NOTE: Android and iOS only return the documents affected by the\n// change.\nasync function localStoreHandleUserChange(localStore, user) {\n    const localStoreImpl = debugCast(localStore);\n    const result = await localStoreImpl.persistence.runTransaction('Handle user change', 'readonly', txn => {\n        // Swap out the mutation queue, grabbing the pending mutation batches\n        // before and after.\n        let oldBatches;\n        return localStoreImpl.mutationQueue\n            .getAllMutationBatches(txn)\n            .next(promisedOldBatches => {\n            oldBatches = promisedOldBatches;\n            localStoreImpl.initializeUserComponents(user);\n            return localStoreImpl.mutationQueue.getAllMutationBatches(txn);\n        })\n            .next(newBatches => {\n            const removedBatchIds = [];\n            const addedBatchIds = [];\n            // Union the old/new changed keys.\n            let changedKeys = documentKeySet();\n            for (const batch of oldBatches) {\n                removedBatchIds.push(batch.batchId);\n                for (const mutation of batch.mutations) {\n                    changedKeys = changedKeys.add(mutation.key);\n                }\n            }\n            for (const batch of newBatches) {\n                addedBatchIds.push(batch.batchId);\n                for (const mutation of batch.mutations) {\n                    changedKeys = changedKeys.add(mutation.key);\n                }\n            }\n            // Return the set of all (potentially) changed documents and the list\n            // of mutation batch IDs that were affected by change.\n            return localStoreImpl.localDocuments\n                .getDocuments(txn, changedKeys)\n                .next(affectedDocuments => {\n                return {\n                    affectedDocuments,\n                    removedBatchIds,\n                    addedBatchIds\n                };\n            });\n        });\n    });\n    return result;\n}\n/* Accepts locally generated Mutations and commit them to storage. */\nfunction localStoreWriteLocally(localStore, mutations) {\n    const localStoreImpl = debugCast(localStore);\n    const localWriteTime = Timestamp.now();\n    const keys = mutations.reduce((keys, m) => keys.add(m.key), documentKeySet());\n    let overlayedDocuments;\n    let mutationBatch;\n    return localStoreImpl.persistence\n        .runTransaction('Locally write mutations', 'readwrite', txn => {\n        // Figure out which keys do not have a remote version in the cache, this\n        // is needed to create the right overlay mutation: if no remote version\n        // presents, we do not need to create overlays as patch mutations.\n        // TODO(Overlay): Is there a better way to determine this? Using the\n        //  document version does not work because local mutations set them back\n        //  to 0.\n        let remoteDocs = mutableDocumentMap();\n        let docsWithoutRemoteVersion = documentKeySet();\n        return localStoreImpl.remoteDocuments\n            .getEntries(txn, keys)\n            .next(docs => {\n            remoteDocs = docs;\n            remoteDocs.forEach((key, doc) => {\n                if (!doc.isValidDocument()) {\n                    docsWithoutRemoteVersion = docsWithoutRemoteVersion.add(key);\n                }\n            });\n        })\n            .next(() => {\n            // Load and apply all existing mutations. This lets us compute the\n            // current base state for all non-idempotent transforms before applying\n            // any additional user-provided writes.\n            return localStoreImpl.localDocuments.getOverlayedDocuments(txn, remoteDocs);\n        })\n            .next((docs) => {\n            overlayedDocuments = docs;\n            // For non-idempotent mutations (such as `FieldValue.increment()`),\n            // we record the base state in a separate patch mutation. This is\n            // later used to guarantee consistent values and prevents flicker\n            // even if the backend sends us an update that already includes our\n            // transform.\n            const baseMutations = [];\n            for (const mutation of mutations) {\n                const baseValue = mutationExtractBaseValue(mutation, overlayedDocuments.get(mutation.key).overlayedDocument);\n                if (baseValue != null) {\n                    // NOTE: The base state should only be applied if there's some\n                    // existing document to override, so use a Precondition of\n                    // exists=true\n                    baseMutations.push(new PatchMutation(mutation.key, baseValue, extractFieldMask(baseValue.value.mapValue), Precondition.exists(true)));\n                }\n            }\n            return localStoreImpl.mutationQueue.addMutationBatch(txn, localWriteTime, baseMutations, mutations);\n        })\n            .next(batch => {\n            mutationBatch = batch;\n            const overlays = batch.applyToLocalDocumentSet(overlayedDocuments, docsWithoutRemoteVersion);\n            return localStoreImpl.documentOverlayCache.saveOverlays(txn, batch.batchId, overlays);\n        });\n    })\n        .then(() => ({\n        batchId: mutationBatch.batchId,\n        changes: convertOverlayedDocumentMapToDocumentMap(overlayedDocuments)\n    }));\n}\n/**\n * Acknowledges the given batch.\n *\n * On the happy path when a batch is acknowledged, the local store will\n *\n *  + remove the batch from the mutation queue;\n *  + apply the changes to the remote document cache;\n *  + recalculate the latency compensated view implied by those changes (there\n *    may be mutations in the queue that affect the documents but haven't been\n *    acknowledged yet); and\n *  + give the changed documents back the sync engine\n *\n * @returns The resulting (modified) documents.\n */\nfunction localStoreAcknowledgeBatch(localStore, batchResult) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Acknowledge batch', 'readwrite-primary', txn => {\n        const affected = batchResult.batch.keys();\n        const documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({\n            trackRemovals: true // Make sure document removals show up in `getNewDocumentChanges()`\n        });\n        return applyWriteToRemoteDocuments(localStoreImpl, txn, batchResult, documentBuffer)\n            .next(() => documentBuffer.apply(txn))\n            .next(() => localStoreImpl.mutationQueue.performConsistencyCheck(txn))\n            .next(() => localStoreImpl.documentOverlayCache.removeOverlaysForBatchId(txn, affected, batchResult.batch.batchId))\n            .next(() => localStoreImpl.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(txn, getKeysWithTransformResults(batchResult)))\n            .next(() => localStoreImpl.localDocuments.getDocuments(txn, affected));\n    });\n}\nfunction getKeysWithTransformResults(batchResult) {\n    let result = documentKeySet();\n    for (let i = 0; i < batchResult.mutationResults.length; ++i) {\n        const mutationResult = batchResult.mutationResults[i];\n        if (mutationResult.transformResults.length > 0) {\n            result = result.add(batchResult.batch.mutations[i].key);\n        }\n    }\n    return result;\n}\n/**\n * Removes mutations from the MutationQueue for the specified batch;\n * LocalDocuments will be recalculated.\n *\n * @returns The resulting modified documents.\n */\nfunction localStoreRejectBatch(localStore, batchId) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Reject batch', 'readwrite-primary', txn => {\n        let affectedKeys;\n        return localStoreImpl.mutationQueue\n            .lookupMutationBatch(txn, batchId)\n            .next((batch) => {\n            hardAssert(batch !== null);\n            affectedKeys = batch.keys();\n            return localStoreImpl.mutationQueue.removeMutationBatch(txn, batch);\n        })\n            .next(() => localStoreImpl.mutationQueue.performConsistencyCheck(txn))\n            .next(() => localStoreImpl.documentOverlayCache.removeOverlaysForBatchId(txn, affectedKeys, batchId))\n            .next(() => localStoreImpl.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(txn, affectedKeys))\n            .next(() => localStoreImpl.localDocuments.getDocuments(txn, affectedKeys));\n    });\n}\n/**\n * Returns the largest (latest) batch id in mutation queue that is pending\n * server response.\n *\n * Returns `BATCHID_UNKNOWN` if the queue is empty.\n */\nfunction localStoreGetHighestUnacknowledgedBatchId(localStore) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Get highest unacknowledged batch id', 'readonly', txn => localStoreImpl.mutationQueue.getHighestUnacknowledgedBatchId(txn));\n}\n/**\n * Returns the last consistent snapshot processed (used by the RemoteStore to\n * determine whether to buffer incoming snapshots from the backend).\n */\nfunction localStoreGetLastRemoteSnapshotVersion(localStore) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Get last remote snapshot version', 'readonly', txn => localStoreImpl.targetCache.getLastRemoteSnapshotVersion(txn));\n}\n/**\n * Updates the \"ground-state\" (remote) documents. We assume that the remote\n * event reflects any write batches that have been acknowledged or rejected\n * (i.e. we do not re-apply local mutations to updates from this event).\n *\n * LocalDocuments are re-calculated if there are remaining mutations in the\n * queue.\n */\nfunction localStoreApplyRemoteEventToLocalCache(localStore, remoteEvent) {\n    const localStoreImpl = debugCast(localStore);\n    const remoteVersion = remoteEvent.snapshotVersion;\n    let newTargetDataByTargetMap = localStoreImpl.targetDataByTarget;\n    return localStoreImpl.persistence\n        .runTransaction('Apply remote event', 'readwrite-primary', txn => {\n        const documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({\n            trackRemovals: true // Make sure document removals show up in `getNewDocumentChanges()`\n        });\n        // Reset newTargetDataByTargetMap in case this transaction gets re-run.\n        newTargetDataByTargetMap = localStoreImpl.targetDataByTarget;\n        const promises = [];\n        remoteEvent.targetChanges.forEach((change, targetId) => {\n            const oldTargetData = newTargetDataByTargetMap.get(targetId);\n            if (!oldTargetData) {\n                return;\n            }\n            // Only update the remote keys if the target is still active. This\n            // ensures that we can persist the updated target data along with\n            // the updated assignment.\n            promises.push(localStoreImpl.targetCache\n                .removeMatchingKeys(txn, change.removedDocuments, targetId)\n                .next(() => {\n                return localStoreImpl.targetCache.addMatchingKeys(txn, change.addedDocuments, targetId);\n            }));\n            let newTargetData = oldTargetData.withSequenceNumber(txn.currentSequenceNumber);\n            if (remoteEvent.targetMismatches.get(targetId) !== null) {\n                newTargetData = newTargetData\n                    .withResumeToken(ByteString.EMPTY_BYTE_STRING, SnapshotVersion.min())\n                    .withLastLimboFreeSnapshotVersion(SnapshotVersion.min());\n            }\n            else if (change.resumeToken.approximateByteSize() > 0) {\n                newTargetData = newTargetData.withResumeToken(change.resumeToken, remoteVersion);\n            }\n            newTargetDataByTargetMap = newTargetDataByTargetMap.insert(targetId, newTargetData);\n            // Update the target data if there are target changes (or if\n            // sufficient time has passed since the last update).\n            if (shouldPersistTargetData(oldTargetData, newTargetData, change)) {\n                promises.push(localStoreImpl.targetCache.updateTargetData(txn, newTargetData));\n            }\n        });\n        let changedDocs = mutableDocumentMap();\n        let existenceChangedKeys = documentKeySet();\n        remoteEvent.documentUpdates.forEach(key => {\n            if (remoteEvent.resolvedLimboDocuments.has(key)) {\n                promises.push(localStoreImpl.persistence.referenceDelegate.updateLimboDocument(txn, key));\n            }\n        });\n        // Each loop iteration only affects its \"own\" doc, so it's safe to get all\n        // the remote documents in advance in a single call.\n        promises.push(populateDocumentChangeBuffer(txn, documentBuffer, remoteEvent.documentUpdates).next(result => {\n            changedDocs = result.changedDocuments;\n            existenceChangedKeys = result.existenceChangedKeys;\n        }));\n        // HACK: The only reason we allow a null snapshot version is so that we\n        // can synthesize remote events when we get permission denied errors while\n        // trying to resolve the state of a locally cached document that is in\n        // limbo.\n        if (!remoteVersion.isEqual(SnapshotVersion.min())) {\n            const updateRemoteVersion = localStoreImpl.targetCache\n                .getLastRemoteSnapshotVersion(txn)\n                .next(lastRemoteSnapshotVersion => {\n                return localStoreImpl.targetCache.setTargetsMetadata(txn, txn.currentSequenceNumber, remoteVersion);\n            });\n            promises.push(updateRemoteVersion);\n        }\n        return PersistencePromise.waitFor(promises)\n            .next(() => documentBuffer.apply(txn))\n            .next(() => localStoreImpl.localDocuments.getLocalViewOfDocuments(txn, changedDocs, existenceChangedKeys))\n            .next(() => changedDocs);\n    })\n        .then(changedDocs => {\n        localStoreImpl.targetDataByTarget = newTargetDataByTargetMap;\n        return changedDocs;\n    });\n}\n/**\n * Populates document change buffer with documents from backend or a bundle.\n * Returns the document changes resulting from applying those documents, and\n * also a set of documents whose existence state are changed as a result.\n *\n * @param txn - Transaction to use to read existing documents from storage.\n * @param documentBuffer - Document buffer to collect the resulted changes to be\n *        applied to storage.\n * @param documents - Documents to be applied.\n */\nfunction populateDocumentChangeBuffer(txn, documentBuffer, documents) {\n    let updatedKeys = documentKeySet();\n    let existenceChangedKeys = documentKeySet();\n    documents.forEach(k => (updatedKeys = updatedKeys.add(k)));\n    return documentBuffer.getEntries(txn, updatedKeys).next(existingDocs => {\n        let changedDocuments = mutableDocumentMap();\n        documents.forEach((key, doc) => {\n            const existingDoc = existingDocs.get(key);\n            // Check if see if there is a existence state change for this document.\n            if (doc.isFoundDocument() !== existingDoc.isFoundDocument()) {\n                existenceChangedKeys = existenceChangedKeys.add(key);\n            }\n            // Note: The order of the steps below is important, since we want\n            // to ensure that rejected limbo resolutions (which fabricate\n            // NoDocuments with SnapshotVersion.min()) never add documents to\n            // cache.\n            if (doc.isNoDocument() && doc.version.isEqual(SnapshotVersion.min())) {\n                // NoDocuments with SnapshotVersion.min() are used in manufactured\n                // events. We remove these documents from cache since we lost\n                // access.\n                documentBuffer.removeEntry(key, doc.readTime);\n                changedDocuments = changedDocuments.insert(key, doc);\n            }\n            else if (!existingDoc.isValidDocument() ||\n                doc.version.compareTo(existingDoc.version) > 0 ||\n                (doc.version.compareTo(existingDoc.version) === 0 &&\n                    existingDoc.hasPendingWrites)) {\n                documentBuffer.addEntry(doc);\n                changedDocuments = changedDocuments.insert(key, doc);\n            }\n            else {\n                logDebug(LOG_TAG$b, 'Ignoring outdated watch update for ', key, '. Current version:', existingDoc.version, ' Watch version:', doc.version);\n            }\n        });\n        return { changedDocuments, existenceChangedKeys };\n    });\n}\n/**\n * Returns true if the newTargetData should be persisted during an update of\n * an active target. TargetData should always be persisted when a target is\n * being released and should not call this function.\n *\n * While the target is active, TargetData updates can be omitted when nothing\n * about the target has changed except metadata like the resume token or\n * snapshot version. Occasionally it's worth the extra write to prevent these\n * values from getting too stale after a crash, but this doesn't have to be\n * too frequent.\n */\nfunction shouldPersistTargetData(oldTargetData, newTargetData, change) {\n    // Always persist target data if we don't already have a resume token.\n    if (oldTargetData.resumeToken.approximateByteSize() === 0) {\n        return true;\n    }\n    // Don't allow resume token changes to be buffered indefinitely. This\n    // allows us to be reasonably up-to-date after a crash and avoids needing\n    // to loop over all active queries on shutdown. Especially in the browser\n    // we may not get time to do anything interesting while the current tab is\n    // closing.\n    const timeDelta = newTargetData.snapshotVersion.toMicroseconds() -\n        oldTargetData.snapshotVersion.toMicroseconds();\n    if (timeDelta >= RESUME_TOKEN_MAX_AGE_MICROS) {\n        return true;\n    }\n    // Otherwise if the only thing that has changed about a target is its resume\n    // token it's not worth persisting. Note that the RemoteStore keeps an\n    // in-memory view of the currently active targets which includes the current\n    // resume token, so stream failure or user changes will still use an\n    // up-to-date resume token regardless of what we do here.\n    const changes = change.addedDocuments.size +\n        change.modifiedDocuments.size +\n        change.removedDocuments.size;\n    return changes > 0;\n}\n/**\n * Notifies local store of the changed views to locally pin documents.\n */\nasync function localStoreNotifyLocalViewChanges(localStore, viewChanges) {\n    const localStoreImpl = debugCast(localStore);\n    try {\n        await localStoreImpl.persistence.runTransaction('notifyLocalViewChanges', 'readwrite', txn => {\n            return PersistencePromise.forEach(viewChanges, (viewChange) => {\n                return PersistencePromise.forEach(viewChange.addedKeys, (key) => localStoreImpl.persistence.referenceDelegate.addReference(txn, viewChange.targetId, key)).next(() => PersistencePromise.forEach(viewChange.removedKeys, (key) => localStoreImpl.persistence.referenceDelegate.removeReference(txn, viewChange.targetId, key)));\n            });\n        });\n    }\n    catch (e) {\n        if (isIndexedDbTransactionError(e)) {\n            // If `notifyLocalViewChanges` fails, we did not advance the sequence\n            // number for the documents that were included in this transaction.\n            // This might trigger them to be deleted earlier than they otherwise\n            // would have, but it should not invalidate the integrity of the data.\n            logDebug(LOG_TAG$b, 'Failed to update sequence numbers: ' + e);\n        }\n        else {\n            throw e;\n        }\n    }\n    for (const viewChange of viewChanges) {\n        const targetId = viewChange.targetId;\n        if (!viewChange.fromCache) {\n            const targetData = localStoreImpl.targetDataByTarget.get(targetId);\n            // Advance the last limbo free snapshot version\n            const lastLimboFreeSnapshotVersion = targetData.snapshotVersion;\n            const updatedTargetData = targetData.withLastLimboFreeSnapshotVersion(lastLimboFreeSnapshotVersion);\n            localStoreImpl.targetDataByTarget =\n                localStoreImpl.targetDataByTarget.insert(targetId, updatedTargetData);\n            // TODO(b/272564316): Apply the optimization done on other platforms.\n            // This is a problem for web because saving the updated targetData from\n            // non-primary client conflicts with what primary client saved.\n        }\n    }\n}\n/**\n * Gets the mutation batch after the passed in batchId in the mutation queue\n * or null if empty.\n * @param afterBatchId - If provided, the batch to search after.\n * @returns The next mutation or null if there wasn't one.\n */\nfunction localStoreGetNextMutationBatch(localStore, afterBatchId) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Get next mutation batch', 'readonly', txn => {\n        if (afterBatchId === undefined) {\n            afterBatchId = BATCHID_UNKNOWN;\n        }\n        return localStoreImpl.mutationQueue.getNextMutationBatchAfterBatchId(txn, afterBatchId);\n    });\n}\n/**\n * Reads the current value of a Document with a given key or null if not\n * found - used for testing.\n */\nfunction localStoreReadDocument(localStore, key) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('read document', 'readonly', txn => localStoreImpl.localDocuments.getDocument(txn, key));\n}\n/**\n * Assigns the given target an internal ID so that its results can be pinned so\n * they don't get GC'd. A target must be allocated in the local store before\n * the store can be used to manage its view.\n *\n * Allocating an already allocated `Target` will return the existing `TargetData`\n * for that `Target`.\n */\nfunction localStoreAllocateTarget(localStore, target) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence\n        .runTransaction('Allocate target', 'readwrite', txn => {\n        let targetData;\n        return localStoreImpl.targetCache\n            .getTargetData(txn, target)\n            .next((cached) => {\n            if (cached) {\n                // This target has been listened to previously, so reuse the\n                // previous targetID.\n                // TODO(mcg): freshen last accessed date?\n                targetData = cached;\n                return PersistencePromise.resolve(targetData);\n            }\n            else {\n                return localStoreImpl.targetCache\n                    .allocateTargetId(txn)\n                    .next(targetId => {\n                    targetData = new TargetData(target, targetId, \"TargetPurposeListen\" /* TargetPurpose.Listen */, txn.currentSequenceNumber);\n                    return localStoreImpl.targetCache\n                        .addTargetData(txn, targetData)\n                        .next(() => targetData);\n                });\n            }\n        });\n    })\n        .then(targetData => {\n        // If Multi-Tab is enabled, the existing target data may be newer than\n        // the in-memory data\n        const cachedTargetData = localStoreImpl.targetDataByTarget.get(targetData.targetId);\n        if (cachedTargetData === null ||\n            targetData.snapshotVersion.compareTo(cachedTargetData.snapshotVersion) >\n                0) {\n            localStoreImpl.targetDataByTarget =\n                localStoreImpl.targetDataByTarget.insert(targetData.targetId, targetData);\n            localStoreImpl.targetIdByTarget.set(target, targetData.targetId);\n        }\n        return targetData;\n    });\n}\n/**\n * Returns the TargetData as seen by the LocalStore, including updates that may\n * have not yet been persisted to the TargetCache.\n */\n// Visible for testing.\nfunction localStoreGetTargetData(localStore, transaction, target) {\n    const localStoreImpl = debugCast(localStore);\n    const targetId = localStoreImpl.targetIdByTarget.get(target);\n    if (targetId !== undefined) {\n        return PersistencePromise.resolve(localStoreImpl.targetDataByTarget.get(targetId));\n    }\n    else {\n        return localStoreImpl.targetCache.getTargetData(transaction, target);\n    }\n}\n/**\n * Unpins all the documents associated with the given target. If\n * `keepPersistedTargetData` is set to false and Eager GC enabled, the method\n * directly removes the associated target data from the target cache.\n *\n * Releasing a non-existing `Target` is a no-op.\n */\n// PORTING NOTE: `keepPersistedTargetData` is multi-tab only.\nasync function localStoreReleaseTarget(localStore, targetId, keepPersistedTargetData) {\n    const localStoreImpl = debugCast(localStore);\n    const targetData = localStoreImpl.targetDataByTarget.get(targetId);\n    const mode = keepPersistedTargetData ? 'readwrite' : 'readwrite-primary';\n    try {\n        if (!keepPersistedTargetData) {\n            await localStoreImpl.persistence.runTransaction('Release target', mode, txn => {\n                return localStoreImpl.persistence.referenceDelegate.removeTarget(txn, targetData);\n            });\n        }\n    }\n    catch (e) {\n        if (isIndexedDbTransactionError(e)) {\n            // All `releaseTarget` does is record the final metadata state for the\n            // target, but we've been recording this periodically during target\n            // activity. If we lose this write this could cause a very slight\n            // difference in the order of target deletion during GC, but we\n            // don't define exact LRU semantics so this is acceptable.\n            logDebug(LOG_TAG$b, `Failed to update sequence numbers for target ${targetId}: ${e}`);\n        }\n        else {\n            throw e;\n        }\n    }\n    localStoreImpl.targetDataByTarget =\n        localStoreImpl.targetDataByTarget.remove(targetId);\n    localStoreImpl.targetIdByTarget.delete(targetData.target);\n}\n/**\n * Runs the specified query against the local store and returns the results,\n * potentially taking advantage of query data from previous executions (such\n * as the set of remote keys).\n *\n * @param usePreviousResults - Whether results from previous executions can\n * be used to optimize this query execution.\n */\nfunction localStoreExecuteQuery(localStore, query, usePreviousResults) {\n    const localStoreImpl = debugCast(localStore);\n    let lastLimboFreeSnapshotVersion = SnapshotVersion.min();\n    let remoteKeys = documentKeySet();\n    return localStoreImpl.persistence.runTransaction('Execute query', 'readwrite', // Use readwrite instead of readonly so indexes can be created\n    // Use readwrite instead of readonly so indexes can be created\n    txn => {\n        return localStoreGetTargetData(localStoreImpl, txn, queryToTarget(query))\n            .next(targetData => {\n            if (targetData) {\n                lastLimboFreeSnapshotVersion =\n                    targetData.lastLimboFreeSnapshotVersion;\n                return localStoreImpl.targetCache\n                    .getMatchingKeysForTargetId(txn, targetData.targetId)\n                    .next(result => {\n                    remoteKeys = result;\n                });\n            }\n        })\n            .next(() => localStoreImpl.queryEngine.getDocumentsMatchingQuery(txn, query, usePreviousResults\n            ? lastLimboFreeSnapshotVersion\n            : SnapshotVersion.min(), usePreviousResults ? remoteKeys : documentKeySet()))\n            .next(documents => {\n            setMaxReadTime(localStoreImpl, queryCollectionGroup(query), documents);\n            return { documents, remoteKeys };\n        });\n    });\n}\nfunction applyWriteToRemoteDocuments(localStoreImpl, txn, batchResult, documentBuffer) {\n    const batch = batchResult.batch;\n    const docKeys = batch.keys();\n    let promiseChain = PersistencePromise.resolve();\n    docKeys.forEach(docKey => {\n        promiseChain = promiseChain\n            .next(() => documentBuffer.getEntry(txn, docKey))\n            .next(doc => {\n            const ackVersion = batchResult.docVersions.get(docKey);\n            hardAssert(ackVersion !== null);\n            if (doc.version.compareTo(ackVersion) < 0) {\n                batch.applyToRemoteDocument(doc, batchResult);\n                if (doc.isValidDocument()) {\n                    // We use the commitVersion as the readTime rather than the\n                    // document's updateTime since the updateTime is not advanced\n                    // for updates that do not modify the underlying document.\n                    doc.setReadTime(batchResult.commitVersion);\n                    documentBuffer.addEntry(doc);\n                }\n            }\n        });\n    });\n    return promiseChain.next(() => localStoreImpl.mutationQueue.removeMutationBatch(txn, batch));\n}\n/** Returns the local view of the documents affected by a mutation batch. */\n// PORTING NOTE: Multi-Tab only.\nfunction localStoreLookupMutationDocuments(localStore, batchId) {\n    const localStoreImpl = debugCast(localStore);\n    const mutationQueueImpl = debugCast(localStoreImpl.mutationQueue);\n    return localStoreImpl.persistence.runTransaction('Lookup mutation documents', 'readonly', txn => {\n        return mutationQueueImpl.lookupMutationKeys(txn, batchId).next(keys => {\n            if (keys) {\n                return localStoreImpl.localDocuments.getDocuments(txn, keys);\n            }\n            else {\n                return PersistencePromise.resolve(null);\n            }\n        });\n    });\n}\n// PORTING NOTE: Multi-Tab only.\nfunction localStoreRemoveCachedMutationBatchMetadata(localStore, batchId) {\n    const mutationQueueImpl = debugCast(debugCast(localStore, LocalStoreImpl).mutationQueue);\n    mutationQueueImpl.removeCachedMutationKeys(batchId);\n}\n// PORTING NOTE: Multi-Tab only.\nfunction localStoreGetActiveClients(localStore) {\n    const persistenceImpl = debugCast(debugCast(localStore, LocalStoreImpl).persistence);\n    return persistenceImpl.getActiveClients();\n}\n// PORTING NOTE: Multi-Tab only.\nfunction localStoreGetCachedTarget(localStore, targetId) {\n    const localStoreImpl = debugCast(localStore);\n    const targetCacheImpl = debugCast(localStoreImpl.targetCache);\n    const cachedTargetData = localStoreImpl.targetDataByTarget.get(targetId);\n    if (cachedTargetData) {\n        return Promise.resolve(cachedTargetData.target);\n    }\n    else {\n        return localStoreImpl.persistence.runTransaction('Get target data', 'readonly', txn => {\n            return targetCacheImpl\n                .getTargetDataForTarget(txn, targetId)\n                .next(targetData => (targetData ? targetData.target : null));\n        });\n    }\n}\n/**\n * Returns the set of documents that have been updated since the last call.\n * If this is the first call, returns the set of changes since client\n * initialization. Further invocations will return document that have changed\n * since the prior call.\n */\n// PORTING NOTE: Multi-Tab only.\nfunction localStoreGetNewDocumentChanges(localStore, collectionGroup) {\n    const localStoreImpl = debugCast(localStore);\n    // Get the current maximum read time for the collection. This should always\n    // exist, but to reduce the chance for regressions we default to\n    // SnapshotVersion.Min()\n    // TODO(indexing): Consider removing the default value.\n    const readTime = localStoreImpl.collectionGroupReadTime.get(collectionGroup) ||\n        SnapshotVersion.min();\n    return localStoreImpl.persistence\n        .runTransaction('Get new document changes', 'readonly', txn => localStoreImpl.remoteDocuments.getAllFromCollectionGroup(txn, collectionGroup, newIndexOffsetSuccessorFromReadTime(readTime, INITIAL_LARGEST_BATCH_ID), \n    /* limit= */ Number.MAX_SAFE_INTEGER))\n        .then(changedDocs => {\n        setMaxReadTime(localStoreImpl, collectionGroup, changedDocs);\n        return changedDocs;\n    });\n}\n/** Sets the collection group's maximum read time from the given documents. */\n// PORTING NOTE: Multi-Tab only.\nfunction setMaxReadTime(localStoreImpl, collectionGroup, changedDocs) {\n    let readTime = localStoreImpl.collectionGroupReadTime.get(collectionGroup) ||\n        SnapshotVersion.min();\n    changedDocs.forEach((_, doc) => {\n        if (doc.readTime.compareTo(readTime) > 0) {\n            readTime = doc.readTime;\n        }\n    });\n    localStoreImpl.collectionGroupReadTime.set(collectionGroup, readTime);\n}\n/**\n * Creates a new target using the given bundle name, which will be used to\n * hold the keys of all documents from the bundle in query-document mappings.\n * This ensures that the loaded documents do not get garbage collected\n * right away.\n */\nfunction umbrellaTarget(bundleName) {\n    // It is OK that the path used for the query is not valid, because this will\n    // not be read and queried.\n    return queryToTarget(newQueryForPath(ResourcePath.fromString(`__bundle__/docs/${bundleName}`)));\n}\n/**\n * Applies the documents from a bundle to the \"ground-state\" (remote)\n * documents.\n *\n * LocalDocuments are re-calculated if there are remaining mutations in the\n * queue.\n */\nasync function localStoreApplyBundledDocuments(localStore, bundleConverter, documents, bundleName) {\n    const localStoreImpl = debugCast(localStore);\n    let documentKeys = documentKeySet();\n    let documentMap = mutableDocumentMap();\n    for (const bundleDoc of documents) {\n        const documentKey = bundleConverter.toDocumentKey(bundleDoc.metadata.name);\n        if (bundleDoc.document) {\n            documentKeys = documentKeys.add(documentKey);\n        }\n        const doc = bundleConverter.toMutableDocument(bundleDoc);\n        doc.setReadTime(bundleConverter.toSnapshotVersion(bundleDoc.metadata.readTime));\n        documentMap = documentMap.insert(documentKey, doc);\n    }\n    const documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({\n        trackRemovals: true // Make sure document removals show up in `getNewDocumentChanges()`\n    });\n    // Allocates a target to hold all document keys from the bundle, such that\n    // they will not get garbage collected right away.\n    const umbrellaTargetData = await localStoreAllocateTarget(localStoreImpl, umbrellaTarget(bundleName));\n    return localStoreImpl.persistence.runTransaction('Apply bundle documents', 'readwrite', txn => {\n        return populateDocumentChangeBuffer(txn, documentBuffer, documentMap)\n            .next(documentChangeResult => {\n            documentBuffer.apply(txn);\n            return documentChangeResult;\n        })\n            .next(documentChangeResult => {\n            return localStoreImpl.targetCache\n                .removeMatchingKeysForTargetId(txn, umbrellaTargetData.targetId)\n                .next(() => localStoreImpl.targetCache.addMatchingKeys(txn, documentKeys, umbrellaTargetData.targetId))\n                .next(() => localStoreImpl.localDocuments.getLocalViewOfDocuments(txn, documentChangeResult.changedDocuments, documentChangeResult.existenceChangedKeys))\n                .next(() => documentChangeResult.changedDocuments);\n        });\n    });\n}\n/**\n * Returns a promise of a boolean to indicate if the given bundle has already\n * been loaded and the create time is newer than the current loading bundle.\n */\nfunction localStoreHasNewerBundle(localStore, bundleMetadata) {\n    const localStoreImpl = debugCast(localStore);\n    const currentReadTime = fromVersion(bundleMetadata.createTime);\n    return localStoreImpl.persistence\n        .runTransaction('hasNewerBundle', 'readonly', transaction => {\n        return localStoreImpl.bundleCache.getBundleMetadata(transaction, bundleMetadata.id);\n    })\n        .then(cached => {\n        return !!cached && cached.createTime.compareTo(currentReadTime) >= 0;\n    });\n}\n/**\n * Saves the given `BundleMetadata` to local persistence.\n */\nfunction localStoreSaveBundle(localStore, bundleMetadata) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Save bundle', 'readwrite', transaction => {\n        return localStoreImpl.bundleCache.saveBundleMetadata(transaction, bundleMetadata);\n    });\n}\n/**\n * Returns a promise of a `NamedQuery` associated with given query name. Promise\n * resolves to undefined if no persisted data can be found.\n */\nfunction localStoreGetNamedQuery(localStore, queryName) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Get named query', 'readonly', transaction => localStoreImpl.bundleCache.getNamedQuery(transaction, queryName));\n}\n/**\n * Saves the given `NamedQuery` to local persistence.\n */\nasync function localStoreSaveNamedQuery(localStore, query, documents = documentKeySet()) {\n    // Allocate a target for the named query such that it can be resumed\n    // from associated read time if users use it to listen.\n    // NOTE: this also means if no corresponding target exists, the new target\n    // will remain active and will not get collected, unless users happen to\n    // unlisten the query somehow.\n    const allocated = await localStoreAllocateTarget(localStore, queryToTarget(fromBundledQuery(query.bundledQuery)));\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Save named query', 'readwrite', transaction => {\n        const readTime = fromVersion(query.readTime);\n        // Simply save the query itself if it is older than what the SDK already\n        // has.\n        if (allocated.snapshotVersion.compareTo(readTime) >= 0) {\n            return localStoreImpl.bundleCache.saveNamedQuery(transaction, query);\n        }\n        // Update existing target data because the query from the bundle is newer.\n        const newTargetData = allocated.withResumeToken(ByteString.EMPTY_BYTE_STRING, readTime);\n        localStoreImpl.targetDataByTarget =\n            localStoreImpl.targetDataByTarget.insert(newTargetData.targetId, newTargetData);\n        return localStoreImpl.targetCache\n            .updateTargetData(transaction, newTargetData)\n            .next(() => localStoreImpl.targetCache.removeMatchingKeysForTargetId(transaction, allocated.targetId))\n            .next(() => localStoreImpl.targetCache.addMatchingKeys(transaction, documents, allocated.targetId))\n            .next(() => localStoreImpl.bundleCache.saveNamedQuery(transaction, query));\n    });\n}\nasync function localStoreConfigureFieldIndexes(localStore, newFieldIndexes) {\n    const localStoreImpl = debugCast(localStore);\n    const indexManager = localStoreImpl.indexManager;\n    const promises = [];\n    return localStoreImpl.persistence.runTransaction('Configure indexes', 'readwrite', transaction => indexManager\n        .getFieldIndexes(transaction)\n        .next(oldFieldIndexes => diffArrays(oldFieldIndexes, newFieldIndexes, fieldIndexSemanticComparator, fieldIndex => {\n        promises.push(indexManager.addFieldIndex(transaction, fieldIndex));\n    }, fieldIndex => {\n        promises.push(indexManager.deleteFieldIndex(transaction, fieldIndex));\n    }))\n        .next(() => PersistencePromise.waitFor(promises)));\n}\nfunction localStoreSetIndexAutoCreationEnabled(localStore, isEnabled) {\n    const localStoreImpl = debugCast(localStore);\n    localStoreImpl.queryEngine.indexAutoCreationEnabled = isEnabled;\n}\nfunction localStoreDeleteAllFieldIndexes(localStore) {\n    const localStoreImpl = debugCast(localStore);\n    const indexManager = localStoreImpl.indexManager;\n    return localStoreImpl.persistence.runTransaction('Delete All Indexes', 'readwrite', transaction => indexManager.deleteAllFieldIndexes(transaction));\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A tracker to keep a record of important details during database local query\n * execution.\n */\nclass QueryContext {\n    constructor() {\n        /**\n         * Counts the number of documents passed through during local query execution.\n         */\n        this._documentReadCount = 0;\n    }\n    get documentReadCount() {\n        return this._documentReadCount;\n    }\n    incrementDocumentReadCount(amount) {\n        this._documentReadCount += amount;\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DEFAULT_INDEX_AUTO_CREATION_MIN_COLLECTION_SIZE = 100;\n/**\n * This cost represents the evaluation result of\n * (([index, docKey] + [docKey, docContent]) per document in the result set)\n * / ([docKey, docContent] per documents in full collection scan) coming from\n * experiment [enter PR experiment URL here].\n */\nfunction getDefaultRelativeIndexReadCostPerDocument() {\n    // These values were derived from an experiment where several members of the\n    // Firestore SDK team ran a performance test in various environments.\n    // Googlers can see b/299284287 for details.\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isSafari)()) {\n        return 8;\n    }\n    else if (getAndroidVersion((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getUA)()) > 0) {\n        return 6;\n    }\n    else {\n        return 4;\n    }\n}\n/**\n * The Firestore query engine.\n *\n * Firestore queries can be executed in three modes. The Query Engine determines\n * what mode to use based on what data is persisted. The mode only determines\n * the runtime complexity of the query - the result set is equivalent across all\n * implementations.\n *\n * The Query engine will use indexed-based execution if a user has configured\n * any index that can be used to execute query (via `setIndexConfiguration()`).\n * Otherwise, the engine will try to optimize the query by re-using a previously\n * persisted query result. If that is not possible, the query will be executed\n * via a full collection scan.\n *\n * Index-based execution is the default when available. The query engine\n * supports partial indexed execution and merges the result from the index\n * lookup with documents that have not yet been indexed. The index evaluation\n * matches the backend's format and as such, the SDK can use indexing for all\n * queries that the backend supports.\n *\n * If no index exists, the query engine tries to take advantage of the target\n * document mapping in the TargetCache. These mappings exists for all queries\n * that have been synced with the backend at least once and allow the query\n * engine to only read documents that previously matched a query plus any\n * documents that were edited after the query was last listened to.\n *\n * There are some cases when this optimization is not guaranteed to produce\n * the same results as full collection scans. In these cases, query\n * processing falls back to full scans. These cases are:\n *\n * - Limit queries where a document that matched the query previously no longer\n *   matches the query.\n *\n * - Limit queries where a document edit may cause the document to sort below\n *   another document that is in the local cache.\n *\n * - Queries that have never been CURRENT or free of limbo documents.\n */\nclass QueryEngine {\n    constructor() {\n        this.initialized = false;\n        this.indexAutoCreationEnabled = false;\n        /**\n         * SDK only decides whether it should create index when collection size is\n         * larger than this.\n         */\n        this.indexAutoCreationMinCollectionSize = DEFAULT_INDEX_AUTO_CREATION_MIN_COLLECTION_SIZE;\n        this.relativeIndexReadCostPerDocument = getDefaultRelativeIndexReadCostPerDocument();\n    }\n    /** Sets the document view to query against. */\n    initialize(localDocuments, indexManager) {\n        this.localDocumentsView = localDocuments;\n        this.indexManager = indexManager;\n        this.initialized = true;\n    }\n    /** Returns all local documents matching the specified query. */\n    getDocumentsMatchingQuery(transaction, query, lastLimboFreeSnapshotVersion, remoteKeys) {\n        // Stores the result from executing the query; using this object is more\n        // convenient than passing the result between steps of the persistence\n        // transaction and improves readability comparatively.\n        const queryResult = { result: null };\n        return this.performQueryUsingIndex(transaction, query)\n            .next(result => {\n            queryResult.result = result;\n        })\n            .next(() => {\n            if (queryResult.result) {\n                return;\n            }\n            return this.performQueryUsingRemoteKeys(transaction, query, remoteKeys, lastLimboFreeSnapshotVersion).next(result => {\n                queryResult.result = result;\n            });\n        })\n            .next(() => {\n            if (queryResult.result) {\n                return;\n            }\n            const context = new QueryContext();\n            return this.executeFullCollectionScan(transaction, query, context).next(result => {\n                queryResult.result = result;\n                if (this.indexAutoCreationEnabled) {\n                    return this.createCacheIndexes(transaction, query, context, result.size);\n                }\n            });\n        })\n            .next(() => queryResult.result);\n    }\n    createCacheIndexes(transaction, query, context, resultSize) {\n        if (context.documentReadCount < this.indexAutoCreationMinCollectionSize) {\n            if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\n                logDebug('QueryEngine', 'SDK will not create cache indexes for query:', stringifyQuery(query), 'since it only creates cache indexes for collection contains', 'more than or equal to', this.indexAutoCreationMinCollectionSize, 'documents');\n            }\n            return PersistencePromise.resolve();\n        }\n        if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\n            logDebug('QueryEngine', 'Query:', stringifyQuery(query), 'scans', context.documentReadCount, 'local documents and returns', resultSize, 'documents as results.');\n        }\n        if (context.documentReadCount >\n            this.relativeIndexReadCostPerDocument * resultSize) {\n            if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\n                logDebug('QueryEngine', 'The SDK decides to create cache indexes for query:', stringifyQuery(query), 'as using cache indexes may help improve performance.');\n            }\n            return this.indexManager.createTargetIndexes(transaction, queryToTarget(query));\n        }\n        return PersistencePromise.resolve();\n    }\n    /**\n     * Performs an indexed query that evaluates the query based on a collection's\n     * persisted index values. Returns `null` if an index is not available.\n     */\n    performQueryUsingIndex(transaction, query) {\n        if (queryMatchesAllDocuments(query)) {\n            // Queries that match all documents don't benefit from using\n            // key-based lookups. It is more efficient to scan all documents in a\n            // collection, rather than to perform individual lookups.\n            return PersistencePromise.resolve(null);\n        }\n        let target = queryToTarget(query);\n        return this.indexManager\n            .getIndexType(transaction, target)\n            .next(indexType => {\n            if (indexType === 0 /* IndexType.NONE */) {\n                // The target cannot be served from any index.\n                return null;\n            }\n            if (query.limit !== null && indexType === 1 /* IndexType.PARTIAL */) {\n                // We cannot apply a limit for targets that are served using a partial\n                // index. If a partial index will be used to serve the target, the\n                // query may return a superset of documents that match the target\n                // (e.g. if the index doesn't include all the target's filters), or\n                // may return the correct set of documents in the wrong order (e.g. if\n                // the index doesn't include a segment for one of the orderBys).\n                // Therefore, a limit should not be applied in such cases.\n                query = queryWithLimit(query, null, \"F\" /* LimitType.First */);\n                target = queryToTarget(query);\n            }\n            return this.indexManager\n                .getDocumentsMatchingTarget(transaction, target)\n                .next(keys => {\n                const sortedKeys = documentKeySet(...keys);\n                return this.localDocumentsView\n                    .getDocuments(transaction, sortedKeys)\n                    .next(indexedDocuments => {\n                    return this.indexManager\n                        .getMinOffset(transaction, target)\n                        .next(offset => {\n                        const previousResults = this.applyQuery(query, indexedDocuments);\n                        if (this.needsRefill(query, previousResults, sortedKeys, offset.readTime)) {\n                            // A limit query whose boundaries change due to local\n                            // edits can be re-run against the cache by excluding the\n                            // limit. This ensures that all documents that match the\n                            // query's filters are included in the result set. The SDK\n                            // can then apply the limit once all local edits are\n                            // incorporated.\n                            return this.performQueryUsingIndex(transaction, queryWithLimit(query, null, \"F\" /* LimitType.First */));\n                        }\n                        return this.appendRemainingResults(transaction, previousResults, query, offset);\n                    });\n                });\n            });\n        });\n    }\n    /**\n     * Performs a query based on the target's persisted query mapping. Returns\n     * `null` if the mapping is not available or cannot be used.\n     */\n    performQueryUsingRemoteKeys(transaction, query, remoteKeys, lastLimboFreeSnapshotVersion) {\n        if (queryMatchesAllDocuments(query)) {\n            // Queries that match all documents don't benefit from using\n            // key-based lookups. It is more efficient to scan all documents in a\n            // collection, rather than to perform individual lookups.\n            return PersistencePromise.resolve(null);\n        }\n        // Queries that have never seen a snapshot without limbo free documents\n        // should also be run as a full collection scan.\n        if (lastLimboFreeSnapshotVersion.isEqual(SnapshotVersion.min())) {\n            return PersistencePromise.resolve(null);\n        }\n        return this.localDocumentsView.getDocuments(transaction, remoteKeys).next(documents => {\n            const previousResults = this.applyQuery(query, documents);\n            if (this.needsRefill(query, previousResults, remoteKeys, lastLimboFreeSnapshotVersion)) {\n                return PersistencePromise.resolve(null);\n            }\n            if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\n                logDebug('QueryEngine', 'Re-using previous result from %s to execute query: %s', lastLimboFreeSnapshotVersion.toString(), stringifyQuery(query));\n            }\n            // Retrieve all results for documents that were updated since the last\n            // limbo-document free remote snapshot.\n            return this.appendRemainingResults(transaction, previousResults, query, newIndexOffsetSuccessorFromReadTime(lastLimboFreeSnapshotVersion, INITIAL_LARGEST_BATCH_ID)).next(results => results);\n        });\n    }\n    /** Applies the query filter and sorting to the provided documents.  */\n    applyQuery(query, documents) {\n        // Sort the documents and re-apply the query filter since previously\n        // matching documents do not necessarily still match the query.\n        let queryResults = new SortedSet(newQueryComparator(query));\n        documents.forEach((_, maybeDoc) => {\n            if (queryMatches(query, maybeDoc)) {\n                queryResults = queryResults.add(maybeDoc);\n            }\n        });\n        return queryResults;\n    }\n    /**\n     * Determines if a limit query needs to be refilled from cache, making it\n     * ineligible for index-free execution.\n     *\n     * @param query - The query.\n     * @param sortedPreviousResults - The documents that matched the query when it\n     * was last synchronized, sorted by the query's comparator.\n     * @param remoteKeys - The document keys that matched the query at the last\n     * snapshot.\n     * @param limboFreeSnapshotVersion - The version of the snapshot when the\n     * query was last synchronized.\n     */\n    needsRefill(query, sortedPreviousResults, remoteKeys, limboFreeSnapshotVersion) {\n        if (query.limit === null) {\n            // Queries without limits do not need to be refilled.\n            return false;\n        }\n        if (remoteKeys.size !== sortedPreviousResults.size) {\n            // The query needs to be refilled if a previously matching document no\n            // longer matches.\n            return true;\n        }\n        // Limit queries are not eligible for index-free query execution if there is\n        // a potential that an older document from cache now sorts before a document\n        // that was previously part of the limit. This, however, can only happen if\n        // the document at the edge of the limit goes out of limit.\n        // If a document that is not the limit boundary sorts differently,\n        // the boundary of the limit itself did not change and documents from cache\n        // will continue to be \"rejected\" by this boundary. Therefore, we can ignore\n        // any modifications that don't affect the last document.\n        const docAtLimitEdge = query.limitType === \"F\" /* LimitType.First */\n            ? sortedPreviousResults.last()\n            : sortedPreviousResults.first();\n        if (!docAtLimitEdge) {\n            // We don't need to refill the query if there were already no documents.\n            return false;\n        }\n        return (docAtLimitEdge.hasPendingWrites ||\n            docAtLimitEdge.version.compareTo(limboFreeSnapshotVersion) > 0);\n    }\n    executeFullCollectionScan(transaction, query, context) {\n        if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\n            logDebug('QueryEngine', 'Using full collection scan to execute query:', stringifyQuery(query));\n        }\n        return this.localDocumentsView.getDocumentsMatchingQuery(transaction, query, IndexOffset.min(), context);\n    }\n    /**\n     * Combines the results from an indexed execution with the remaining documents\n     * that have not yet been indexed.\n     */\n    appendRemainingResults(transaction, indexedResults, query, offset) {\n        // Retrieve all results for documents that were updated since the offset.\n        return this.localDocumentsView\n            .getDocumentsMatchingQuery(transaction, query, offset)\n            .next(remainingResults => {\n            // Merge with existing results\n            indexedResults.forEach(d => {\n                remainingResults = remainingResults.insert(d.key, d);\n            });\n            return remainingResults;\n        });\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// The format of the LocalStorage key that stores the client state is:\n//     firestore_clients_<persistence_prefix>_<instance_key>\nconst CLIENT_STATE_KEY_PREFIX = 'firestore_clients';\n/** Assembles the key for a client state in WebStorage */\nfunction createWebStorageClientStateKey(persistenceKey, clientId) {\n    return `${CLIENT_STATE_KEY_PREFIX}_${persistenceKey}_${clientId}`;\n}\n// The format of the WebStorage key that stores the mutation state is:\n//     firestore_mutations_<persistence_prefix>_<batch_id>\n//     (for unauthenticated users)\n// or: firestore_mutations_<persistence_prefix>_<batch_id>_<user_uid>\n//\n// 'user_uid' is last to avoid needing to escape '_' characters that it might\n// contain.\nconst MUTATION_BATCH_KEY_PREFIX = 'firestore_mutations';\n/** Assembles the key for a mutation batch in WebStorage */\nfunction createWebStorageMutationBatchKey(persistenceKey, user, batchId) {\n    let mutationKey = `${MUTATION_BATCH_KEY_PREFIX}_${persistenceKey}_${batchId}`;\n    if (user.isAuthenticated()) {\n        mutationKey += `_${user.uid}`;\n    }\n    return mutationKey;\n}\n// The format of the WebStorage key that stores a query target's metadata is:\n//     firestore_targets_<persistence_prefix>_<target_id>\nconst QUERY_TARGET_KEY_PREFIX = 'firestore_targets';\n/** Assembles the key for a query state in WebStorage */\nfunction createWebStorageQueryTargetMetadataKey(persistenceKey, targetId) {\n    return `${QUERY_TARGET_KEY_PREFIX}_${persistenceKey}_${targetId}`;\n}\n// The WebStorage prefix that stores the primary tab's online state. The\n// format of the key is:\n//     firestore_online_state_<persistence_prefix>\nconst ONLINE_STATE_KEY_PREFIX = 'firestore_online_state';\n/** Assembles the key for the online state of the primary tab. */\nfunction createWebStorageOnlineStateKey(persistenceKey) {\n    return `${ONLINE_STATE_KEY_PREFIX}_${persistenceKey}`;\n}\n// The WebStorage prefix that plays as a event to indicate the remote documents\n// might have changed due to some secondary tabs loading a bundle.\n// format of the key is:\n//     firestore_bundle_loaded_v2_<persistenceKey>\n// The version ending with \"v2\" stores the list of modified collection groups.\nconst BUNDLE_LOADED_KEY_PREFIX = 'firestore_bundle_loaded_v2';\nfunction createBundleLoadedKey(persistenceKey) {\n    return `${BUNDLE_LOADED_KEY_PREFIX}_${persistenceKey}`;\n}\n// The WebStorage key prefix for the key that stores the last sequence number allocated. The key\n// looks like 'firestore_sequence_number_<persistence_prefix>'.\nconst SEQUENCE_NUMBER_KEY_PREFIX = 'firestore_sequence_number';\n/** Assembles the key for the current sequence number. */\nfunction createWebStorageSequenceNumberKey(persistenceKey) {\n    return `${SEQUENCE_NUMBER_KEY_PREFIX}_${persistenceKey}`;\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$a = 'SharedClientState';\n/**\n * Holds the state of a mutation batch, including its user ID, batch ID and\n * whether the batch is 'pending', 'acknowledged' or 'rejected'.\n */\n// Visible for testing\nclass MutationMetadata {\n    constructor(user, batchId, state, error) {\n        this.user = user;\n        this.batchId = batchId;\n        this.state = state;\n        this.error = error;\n    }\n    /**\n     * Parses a MutationMetadata from its JSON representation in WebStorage.\n     * Logs a warning and returns null if the format of the data is not valid.\n     */\n    static fromWebStorageEntry(user, batchId, value) {\n        const mutationBatch = JSON.parse(value);\n        let validData = typeof mutationBatch === 'object' &&\n            ['pending', 'acknowledged', 'rejected'].indexOf(mutationBatch.state) !==\n                -1 &&\n            (mutationBatch.error === undefined ||\n                typeof mutationBatch.error === 'object');\n        let firestoreError = undefined;\n        if (validData && mutationBatch.error) {\n            validData =\n                typeof mutationBatch.error.message === 'string' &&\n                    typeof mutationBatch.error.code === 'string';\n            if (validData) {\n                firestoreError = new FirestoreError(mutationBatch.error.code, mutationBatch.error.message);\n            }\n        }\n        if (validData) {\n            return new MutationMetadata(user, batchId, mutationBatch.state, firestoreError);\n        }\n        else {\n            logError(LOG_TAG$a, `Failed to parse mutation state for ID '${batchId}': ${value}`);\n            return null;\n        }\n    }\n    toWebStorageJSON() {\n        const batchMetadata = {\n            state: this.state,\n            updateTimeMs: Date.now() // Modify the existing value to trigger update.\n        };\n        if (this.error) {\n            batchMetadata.error = {\n                code: this.error.code,\n                message: this.error.message\n            };\n        }\n        return JSON.stringify(batchMetadata);\n    }\n}\n/**\n * Holds the state of a query target, including its target ID and whether the\n * target is 'not-current', 'current' or 'rejected'.\n */\n// Visible for testing\nclass QueryTargetMetadata {\n    constructor(targetId, state, error) {\n        this.targetId = targetId;\n        this.state = state;\n        this.error = error;\n    }\n    /**\n     * Parses a QueryTargetMetadata from its JSON representation in WebStorage.\n     * Logs a warning and returns null if the format of the data is not valid.\n     */\n    static fromWebStorageEntry(targetId, value) {\n        const targetState = JSON.parse(value);\n        let validData = typeof targetState === 'object' &&\n            ['not-current', 'current', 'rejected'].indexOf(targetState.state) !==\n                -1 &&\n            (targetState.error === undefined ||\n                typeof targetState.error === 'object');\n        let firestoreError = undefined;\n        if (validData && targetState.error) {\n            validData =\n                typeof targetState.error.message === 'string' &&\n                    typeof targetState.error.code === 'string';\n            if (validData) {\n                firestoreError = new FirestoreError(targetState.error.code, targetState.error.message);\n            }\n        }\n        if (validData) {\n            return new QueryTargetMetadata(targetId, targetState.state, firestoreError);\n        }\n        else {\n            logError(LOG_TAG$a, `Failed to parse target state for ID '${targetId}': ${value}`);\n            return null;\n        }\n    }\n    toWebStorageJSON() {\n        const targetState = {\n            state: this.state,\n            updateTimeMs: Date.now() // Modify the existing value to trigger update.\n        };\n        if (this.error) {\n            targetState.error = {\n                code: this.error.code,\n                message: this.error.message\n            };\n        }\n        return JSON.stringify(targetState);\n    }\n}\n/**\n * This class represents the immutable ClientState for a client read from\n * WebStorage, containing the list of active query targets.\n */\nclass RemoteClientState {\n    constructor(clientId, activeTargetIds) {\n        this.clientId = clientId;\n        this.activeTargetIds = activeTargetIds;\n    }\n    /**\n     * Parses a RemoteClientState from the JSON representation in WebStorage.\n     * Logs a warning and returns null if the format of the data is not valid.\n     */\n    static fromWebStorageEntry(clientId, value) {\n        const clientState = JSON.parse(value);\n        let validData = typeof clientState === 'object' &&\n            clientState.activeTargetIds instanceof Array;\n        let activeTargetIdsSet = targetIdSet();\n        for (let i = 0; validData && i < clientState.activeTargetIds.length; ++i) {\n            validData = isSafeInteger(clientState.activeTargetIds[i]);\n            activeTargetIdsSet = activeTargetIdsSet.add(clientState.activeTargetIds[i]);\n        }\n        if (validData) {\n            return new RemoteClientState(clientId, activeTargetIdsSet);\n        }\n        else {\n            logError(LOG_TAG$a, `Failed to parse client data for instance '${clientId}': ${value}`);\n            return null;\n        }\n    }\n}\n/**\n * This class represents the online state for all clients participating in\n * multi-tab. The online state is only written to by the primary client, and\n * used in secondary clients to update their query views.\n */\nclass SharedOnlineState {\n    constructor(clientId, onlineState) {\n        this.clientId = clientId;\n        this.onlineState = onlineState;\n    }\n    /**\n     * Parses a SharedOnlineState from its JSON representation in WebStorage.\n     * Logs a warning and returns null if the format of the data is not valid.\n     */\n    static fromWebStorageEntry(value) {\n        const onlineState = JSON.parse(value);\n        const validData = typeof onlineState === 'object' &&\n            ['Unknown', 'Online', 'Offline'].indexOf(onlineState.onlineState) !==\n                -1 &&\n            typeof onlineState.clientId === 'string';\n        if (validData) {\n            return new SharedOnlineState(onlineState.clientId, onlineState.onlineState);\n        }\n        else {\n            logError(LOG_TAG$a, `Failed to parse online state: ${value}`);\n            return null;\n        }\n    }\n}\n/**\n * Metadata state of the local client. Unlike `RemoteClientState`, this class is\n * mutable and keeps track of all pending mutations, which allows us to\n * update the range of pending mutation batch IDs as new mutations are added or\n * removed.\n *\n * The data in `LocalClientState` is not read from WebStorage and instead\n * updated via its instance methods. The updated state can be serialized via\n * `toWebStorageJSON()`.\n */\n// Visible for testing.\nclass LocalClientState {\n    constructor() {\n        this.activeTargetIds = targetIdSet();\n    }\n    addQueryTarget(targetId) {\n        this.activeTargetIds = this.activeTargetIds.add(targetId);\n    }\n    removeQueryTarget(targetId) {\n        this.activeTargetIds = this.activeTargetIds.delete(targetId);\n    }\n    /**\n     * Converts this entry into a JSON-encoded format we can use for WebStorage.\n     * Does not encode `clientId` as it is part of the key in WebStorage.\n     */\n    toWebStorageJSON() {\n        const data = {\n            activeTargetIds: this.activeTargetIds.toArray(),\n            updateTimeMs: Date.now() // Modify the existing value to trigger update.\n        };\n        return JSON.stringify(data);\n    }\n}\n/**\n * `WebStorageSharedClientState` uses WebStorage (window.localStorage) as the\n * backing store for the SharedClientState. It keeps track of all active\n * clients and supports modifications of the local client's data.\n */\nclass WebStorageSharedClientState {\n    constructor(window, queue, persistenceKey, localClientId, initialUser) {\n        this.window = window;\n        this.queue = queue;\n        this.persistenceKey = persistenceKey;\n        this.localClientId = localClientId;\n        this.syncEngine = null;\n        this.onlineStateHandler = null;\n        this.sequenceNumberHandler = null;\n        this.storageListener = this.handleWebStorageEvent.bind(this);\n        this.activeClients = new SortedMap(primitiveComparator);\n        this.started = false;\n        /**\n         * Captures WebStorage events that occur before `start()` is called. These\n         * events are replayed once `WebStorageSharedClientState` is started.\n         */\n        this.earlyEvents = [];\n        // Escape the special characters mentioned here:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\n        const escapedPersistenceKey = persistenceKey.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n        this.storage = this.window.localStorage;\n        this.currentUser = initialUser;\n        this.localClientStorageKey = createWebStorageClientStateKey(this.persistenceKey, this.localClientId);\n        this.sequenceNumberKey = createWebStorageSequenceNumberKey(this.persistenceKey);\n        this.activeClients = this.activeClients.insert(this.localClientId, new LocalClientState());\n        this.clientStateKeyRe = new RegExp(`^${CLIENT_STATE_KEY_PREFIX}_${escapedPersistenceKey}_([^_]*)$`);\n        this.mutationBatchKeyRe = new RegExp(`^${MUTATION_BATCH_KEY_PREFIX}_${escapedPersistenceKey}_(\\\\d+)(?:_(.*))?$`);\n        this.queryTargetKeyRe = new RegExp(`^${QUERY_TARGET_KEY_PREFIX}_${escapedPersistenceKey}_(\\\\d+)$`);\n        this.onlineStateKey = createWebStorageOnlineStateKey(this.persistenceKey);\n        this.bundleLoadedKey = createBundleLoadedKey(this.persistenceKey);\n        // Rather than adding the storage observer during start(), we add the\n        // storage observer during initialization. This ensures that we collect\n        // events before other components populate their initial state (during their\n        // respective start() calls). Otherwise, we might for example miss a\n        // mutation that is added after LocalStore's start() processed the existing\n        // mutations but before we observe WebStorage events.\n        this.window.addEventListener('storage', this.storageListener);\n    }\n    /** Returns 'true' if WebStorage is available in the current environment. */\n    static isAvailable(window) {\n        return !!(window && window.localStorage);\n    }\n    async start() {\n        // Retrieve the list of existing clients to backfill the data in\n        // SharedClientState.\n        const existingClients = await this.syncEngine.getActiveClients();\n        for (const clientId of existingClients) {\n            if (clientId === this.localClientId) {\n                continue;\n            }\n            const storageItem = this.getItem(createWebStorageClientStateKey(this.persistenceKey, clientId));\n            if (storageItem) {\n                const clientState = RemoteClientState.fromWebStorageEntry(clientId, storageItem);\n                if (clientState) {\n                    this.activeClients = this.activeClients.insert(clientState.clientId, clientState);\n                }\n            }\n        }\n        this.persistClientState();\n        // Check if there is an existing online state and call the callback handler\n        // if applicable.\n        const onlineStateJSON = this.storage.getItem(this.onlineStateKey);\n        if (onlineStateJSON) {\n            const onlineState = this.fromWebStorageOnlineState(onlineStateJSON);\n            if (onlineState) {\n                this.handleOnlineStateEvent(onlineState);\n            }\n        }\n        for (const event of this.earlyEvents) {\n            this.handleWebStorageEvent(event);\n        }\n        this.earlyEvents = [];\n        // Register a window unload hook to remove the client metadata entry from\n        // WebStorage even if `shutdown()` was not called.\n        this.window.addEventListener('pagehide', () => this.shutdown());\n        this.started = true;\n    }\n    writeSequenceNumber(sequenceNumber) {\n        this.setItem(this.sequenceNumberKey, JSON.stringify(sequenceNumber));\n    }\n    getAllActiveQueryTargets() {\n        return this.extractActiveQueryTargets(this.activeClients);\n    }\n    isActiveQueryTarget(targetId) {\n        let found = false;\n        this.activeClients.forEach((key, value) => {\n            if (value.activeTargetIds.has(targetId)) {\n                found = true;\n            }\n        });\n        return found;\n    }\n    addPendingMutation(batchId) {\n        this.persistMutationState(batchId, 'pending');\n    }\n    updateMutationState(batchId, state, error) {\n        this.persistMutationState(batchId, state, error);\n        // Once a final mutation result is observed by other clients, they no longer\n        // access the mutation's metadata entry. Since WebStorage replays events\n        // in order, it is safe to delete the entry right after updating it.\n        this.removeMutationState(batchId);\n    }\n    addLocalQueryTarget(targetId, addToActiveTargetIds = true) {\n        let queryState = 'not-current';\n        // Lookup an existing query state if the target ID was already registered\n        // by another tab\n        if (this.isActiveQueryTarget(targetId)) {\n            const storageItem = this.storage.getItem(createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId));\n            if (storageItem) {\n                const metadata = QueryTargetMetadata.fromWebStorageEntry(targetId, storageItem);\n                if (metadata) {\n                    queryState = metadata.state;\n                }\n            }\n        }\n        // If the query is listening to cache only, the target ID should not be registered with the\n        // local Firestore client as an active watch target.\n        if (addToActiveTargetIds) {\n            this.localClientState.addQueryTarget(targetId);\n        }\n        this.persistClientState();\n        return queryState;\n    }\n    removeLocalQueryTarget(targetId) {\n        this.localClientState.removeQueryTarget(targetId);\n        this.persistClientState();\n    }\n    isLocalQueryTarget(targetId) {\n        return this.localClientState.activeTargetIds.has(targetId);\n    }\n    clearQueryState(targetId) {\n        this.removeItem(createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId));\n    }\n    updateQueryState(targetId, state, error) {\n        this.persistQueryTargetState(targetId, state, error);\n    }\n    handleUserChange(user, removedBatchIds, addedBatchIds) {\n        removedBatchIds.forEach(batchId => {\n            this.removeMutationState(batchId);\n        });\n        this.currentUser = user;\n        addedBatchIds.forEach(batchId => {\n            this.addPendingMutation(batchId);\n        });\n    }\n    setOnlineState(onlineState) {\n        this.persistOnlineState(onlineState);\n    }\n    notifyBundleLoaded(collectionGroups) {\n        this.persistBundleLoadedState(collectionGroups);\n    }\n    shutdown() {\n        if (this.started) {\n            this.window.removeEventListener('storage', this.storageListener);\n            this.removeItem(this.localClientStorageKey);\n            this.started = false;\n        }\n    }\n    getItem(key) {\n        const value = this.storage.getItem(key);\n        logDebug(LOG_TAG$a, 'READ', key, value);\n        return value;\n    }\n    setItem(key, value) {\n        logDebug(LOG_TAG$a, 'SET', key, value);\n        this.storage.setItem(key, value);\n    }\n    removeItem(key) {\n        logDebug(LOG_TAG$a, 'REMOVE', key);\n        this.storage.removeItem(key);\n    }\n    handleWebStorageEvent(event) {\n        // Note: The function is typed to take Event to be interface-compatible with\n        // `Window.addEventListener`.\n        const storageEvent = event;\n        if (storageEvent.storageArea === this.storage) {\n            logDebug(LOG_TAG$a, 'EVENT', storageEvent.key, storageEvent.newValue);\n            if (storageEvent.key === this.localClientStorageKey) {\n                logError('Received WebStorage notification for local change. Another client might have ' +\n                    'garbage-collected our state');\n                return;\n            }\n            this.queue.enqueueRetryable(async () => {\n                if (!this.started) {\n                    this.earlyEvents.push(storageEvent);\n                    return;\n                }\n                if (storageEvent.key === null) {\n                    return;\n                }\n                if (this.clientStateKeyRe.test(storageEvent.key)) {\n                    if (storageEvent.newValue != null) {\n                        const clientState = this.fromWebStorageClientState(storageEvent.key, storageEvent.newValue);\n                        if (clientState) {\n                            return this.handleClientStateEvent(clientState.clientId, clientState);\n                        }\n                    }\n                    else {\n                        const clientId = this.fromWebStorageClientStateKey(storageEvent.key);\n                        return this.handleClientStateEvent(clientId, null);\n                    }\n                }\n                else if (this.mutationBatchKeyRe.test(storageEvent.key)) {\n                    if (storageEvent.newValue !== null) {\n                        const mutationMetadata = this.fromWebStorageMutationMetadata(storageEvent.key, storageEvent.newValue);\n                        if (mutationMetadata) {\n                            return this.handleMutationBatchEvent(mutationMetadata);\n                        }\n                    }\n                }\n                else if (this.queryTargetKeyRe.test(storageEvent.key)) {\n                    if (storageEvent.newValue !== null) {\n                        const queryTargetMetadata = this.fromWebStorageQueryTargetMetadata(storageEvent.key, storageEvent.newValue);\n                        if (queryTargetMetadata) {\n                            return this.handleQueryTargetEvent(queryTargetMetadata);\n                        }\n                    }\n                }\n                else if (storageEvent.key === this.onlineStateKey) {\n                    if (storageEvent.newValue !== null) {\n                        const onlineState = this.fromWebStorageOnlineState(storageEvent.newValue);\n                        if (onlineState) {\n                            return this.handleOnlineStateEvent(onlineState);\n                        }\n                    }\n                }\n                else if (storageEvent.key === this.sequenceNumberKey) {\n                    const sequenceNumber = fromWebStorageSequenceNumber(storageEvent.newValue);\n                    if (sequenceNumber !== ListenSequence.INVALID) {\n                        this.sequenceNumberHandler(sequenceNumber);\n                    }\n                }\n                else if (storageEvent.key === this.bundleLoadedKey) {\n                    const collectionGroups = this.fromWebStoreBundleLoadedState(storageEvent.newValue);\n                    await Promise.all(collectionGroups.map(cg => this.syncEngine.synchronizeWithChangedDocuments(cg)));\n                }\n            });\n        }\n    }\n    get localClientState() {\n        return this.activeClients.get(this.localClientId);\n    }\n    persistClientState() {\n        this.setItem(this.localClientStorageKey, this.localClientState.toWebStorageJSON());\n    }\n    persistMutationState(batchId, state, error) {\n        const mutationState = new MutationMetadata(this.currentUser, batchId, state, error);\n        const mutationKey = createWebStorageMutationBatchKey(this.persistenceKey, this.currentUser, batchId);\n        this.setItem(mutationKey, mutationState.toWebStorageJSON());\n    }\n    removeMutationState(batchId) {\n        const mutationKey = createWebStorageMutationBatchKey(this.persistenceKey, this.currentUser, batchId);\n        this.removeItem(mutationKey);\n    }\n    persistOnlineState(onlineState) {\n        const entry = {\n            clientId: this.localClientId,\n            onlineState\n        };\n        this.storage.setItem(this.onlineStateKey, JSON.stringify(entry));\n    }\n    persistQueryTargetState(targetId, state, error) {\n        const targetKey = createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId);\n        const targetMetadata = new QueryTargetMetadata(targetId, state, error);\n        this.setItem(targetKey, targetMetadata.toWebStorageJSON());\n    }\n    persistBundleLoadedState(collectionGroups) {\n        const json = JSON.stringify(Array.from(collectionGroups));\n        this.setItem(this.bundleLoadedKey, json);\n    }\n    /**\n     * Parses a client state key in WebStorage. Returns null if the key does not\n     * match the expected key format.\n     */\n    fromWebStorageClientStateKey(key) {\n        const match = this.clientStateKeyRe.exec(key);\n        return match ? match[1] : null;\n    }\n    /**\n     * Parses a client state in WebStorage. Returns 'null' if the value could not\n     * be parsed.\n     */\n    fromWebStorageClientState(key, value) {\n        const clientId = this.fromWebStorageClientStateKey(key);\n        return RemoteClientState.fromWebStorageEntry(clientId, value);\n    }\n    /**\n     * Parses a mutation batch state in WebStorage. Returns 'null' if the value\n     * could not be parsed.\n     */\n    fromWebStorageMutationMetadata(key, value) {\n        const match = this.mutationBatchKeyRe.exec(key);\n        const batchId = Number(match[1]);\n        const userId = match[2] !== undefined ? match[2] : null;\n        return MutationMetadata.fromWebStorageEntry(new User(userId), batchId, value);\n    }\n    /**\n     * Parses a query target state from WebStorage. Returns 'null' if the value\n     * could not be parsed.\n     */\n    fromWebStorageQueryTargetMetadata(key, value) {\n        const match = this.queryTargetKeyRe.exec(key);\n        const targetId = Number(match[1]);\n        return QueryTargetMetadata.fromWebStorageEntry(targetId, value);\n    }\n    /**\n     * Parses an online state from WebStorage. Returns 'null' if the value\n     * could not be parsed.\n     */\n    fromWebStorageOnlineState(value) {\n        return SharedOnlineState.fromWebStorageEntry(value);\n    }\n    fromWebStoreBundleLoadedState(value) {\n        return JSON.parse(value);\n    }\n    async handleMutationBatchEvent(mutationBatch) {\n        if (mutationBatch.user.uid !== this.currentUser.uid) {\n            logDebug(LOG_TAG$a, `Ignoring mutation for non-active user ${mutationBatch.user.uid}`);\n            return;\n        }\n        return this.syncEngine.applyBatchState(mutationBatch.batchId, mutationBatch.state, mutationBatch.error);\n    }\n    handleQueryTargetEvent(targetMetadata) {\n        return this.syncEngine.applyTargetState(targetMetadata.targetId, targetMetadata.state, targetMetadata.error);\n    }\n    handleClientStateEvent(clientId, clientState) {\n        const updatedClients = clientState\n            ? this.activeClients.insert(clientId, clientState)\n            : this.activeClients.remove(clientId);\n        const existingTargets = this.extractActiveQueryTargets(this.activeClients);\n        const newTargets = this.extractActiveQueryTargets(updatedClients);\n        const addedTargets = [];\n        const removedTargets = [];\n        newTargets.forEach(targetId => {\n            if (!existingTargets.has(targetId)) {\n                addedTargets.push(targetId);\n            }\n        });\n        existingTargets.forEach(targetId => {\n            if (!newTargets.has(targetId)) {\n                removedTargets.push(targetId);\n            }\n        });\n        return this.syncEngine.applyActiveTargetsChange(addedTargets, removedTargets).then(() => {\n            this.activeClients = updatedClients;\n        });\n    }\n    handleOnlineStateEvent(onlineState) {\n        // We check whether the client that wrote this online state is still active\n        // by comparing its client ID to the list of clients kept active in\n        // IndexedDb. If a client does not update their IndexedDb client state\n        // within 5 seconds, it is considered inactive and we don't emit an online\n        // state event.\n        if (this.activeClients.get(onlineState.clientId)) {\n            this.onlineStateHandler(onlineState.onlineState);\n        }\n    }\n    extractActiveQueryTargets(clients) {\n        let activeTargets = targetIdSet();\n        clients.forEach((kev, value) => {\n            activeTargets = activeTargets.unionWith(value.activeTargetIds);\n        });\n        return activeTargets;\n    }\n}\nfunction fromWebStorageSequenceNumber(seqString) {\n    let sequenceNumber = ListenSequence.INVALID;\n    if (seqString != null) {\n        try {\n            const parsed = JSON.parse(seqString);\n            hardAssert(typeof parsed === 'number');\n            sequenceNumber = parsed;\n        }\n        catch (e) {\n            logError(LOG_TAG$a, 'Failed to read sequence number from WebStorage', e);\n        }\n    }\n    return sequenceNumber;\n}\n/**\n * `MemorySharedClientState` is a simple implementation of SharedClientState for\n * clients using memory persistence. The state in this class remains fully\n * isolated and no synchronization is performed.\n */\nclass MemorySharedClientState {\n    constructor() {\n        this.localState = new LocalClientState();\n        this.queryState = {};\n        this.onlineStateHandler = null;\n        this.sequenceNumberHandler = null;\n    }\n    addPendingMutation(batchId) {\n        // No op.\n    }\n    updateMutationState(batchId, state, error) {\n        // No op.\n    }\n    addLocalQueryTarget(targetId, addToActiveTargetIds = true) {\n        if (addToActiveTargetIds) {\n            this.localState.addQueryTarget(targetId);\n        }\n        return this.queryState[targetId] || 'not-current';\n    }\n    updateQueryState(targetId, state, error) {\n        this.queryState[targetId] = state;\n    }\n    removeLocalQueryTarget(targetId) {\n        this.localState.removeQueryTarget(targetId);\n    }\n    isLocalQueryTarget(targetId) {\n        return this.localState.activeTargetIds.has(targetId);\n    }\n    clearQueryState(targetId) {\n        delete this.queryState[targetId];\n    }\n    getAllActiveQueryTargets() {\n        return this.localState.activeTargetIds;\n    }\n    isActiveQueryTarget(targetId) {\n        return this.localState.activeTargetIds.has(targetId);\n    }\n    start() {\n        this.localState = new LocalClientState();\n        return Promise.resolve();\n    }\n    handleUserChange(user, removedBatchIds, addedBatchIds) {\n        // No op.\n    }\n    setOnlineState(onlineState) {\n        // No op.\n    }\n    shutdown() { }\n    writeSequenceNumber(sequenceNumber) { }\n    notifyBundleLoaded(collectionGroups) {\n        // No op.\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass NoopConnectivityMonitor {\n    addCallback(callback) {\n        // No-op.\n    }\n    shutdown() {\n        // No-op.\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provides a simple helper class that implements the Stream interface to\n * bridge to other implementations that are streams but do not implement the\n * interface. The stream callbacks are invoked with the callOn... methods.\n */\nclass StreamBridge {\n    constructor(args) {\n        this.sendFn = args.sendFn;\n        this.closeFn = args.closeFn;\n    }\n    onConnected(callback) {\n        this.wrappedOnConnected = callback;\n    }\n    onOpen(callback) {\n        this.wrappedOnOpen = callback;\n    }\n    onClose(callback) {\n        this.wrappedOnClose = callback;\n    }\n    onMessage(callback) {\n        this.wrappedOnMessage = callback;\n    }\n    close() {\n        this.closeFn();\n    }\n    send(msg) {\n        this.sendFn(msg);\n    }\n    callOnConnected() {\n        this.wrappedOnConnected();\n    }\n    callOnOpen() {\n        this.wrappedOnOpen();\n    }\n    callOnClose(err) {\n        this.wrappedOnClose(err);\n    }\n    callOnMessage(msg) {\n        this.wrappedOnMessage(msg);\n    }\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The value returned from the most recent invocation of\n * `generateUniqueDebugId()`, or null if it has never been invoked.\n */\nlet lastUniqueDebugId = null;\n/**\n * Generates and returns an initial value for `lastUniqueDebugId`.\n *\n * The returned value is randomly selected from a range of integers that are\n * represented as 8 hexadecimal digits. This means that (within reason) any\n * numbers generated by incrementing the returned number by 1 will also be\n * represented by 8 hexadecimal digits. This leads to all \"IDs\" having the same\n * length when converted to a hexadecimal string, making reading logs containing\n * these IDs easier to follow. And since the return value is randomly selected\n * it will help to differentiate between logs from different executions.\n */\nfunction generateInitialUniqueDebugId() {\n    const minResult = 0x10000000;\n    const maxResult = 0x90000000;\n    const resultRange = maxResult - minResult;\n    const resultOffset = Math.round(resultRange * Math.random());\n    return minResult + resultOffset;\n}\n/**\n * Generates and returns a unique ID as a hexadecimal string.\n *\n * The returned ID is intended to be used in debug logging messages to help\n * correlate log messages that may be spatially separated in the logs, but\n * logically related. For example, a network connection could include the same\n * \"debug ID\" string in all of its log messages to help trace a specific\n * connection over time.\n *\n * @return the 10-character generated ID (e.g. \"0xa1b2c3d4\").\n */\nfunction generateUniqueDebugId() {\n    if (lastUniqueDebugId === null) {\n        lastUniqueDebugId = generateInitialUniqueDebugId();\n    }\n    else {\n        lastUniqueDebugId++;\n    }\n    return '0x' + lastUniqueDebugId.toString(16);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * Utilities for dealing with node.js-style APIs. See nodePromise for more\n * details.\n */\n/**\n * Creates a node-style callback that resolves or rejects a new Promise. The\n * callback is passed to the given action which can then use the callback as\n * a parameter to a node-style function.\n *\n * The intent is to directly bridge a node-style function (which takes a\n * callback) into a Promise without manually converting between the node-style\n * callback and the promise at each call.\n *\n * In effect it allows you to convert:\n *\n * @example\n * new Promise((resolve: (value?: fs.Stats) => void,\n *              reject: (error?: any) => void) => {\n *   fs.stat(path, (error?: any, stat?: fs.Stats) => {\n *     if (error) {\n *       reject(error);\n *     } else {\n *       resolve(stat);\n *     }\n *   });\n * });\n *\n * Into\n * @example\n * nodePromise((callback: NodeCallback<fs.Stats>) => {\n *   fs.stat(path, callback);\n * });\n *\n * @param action - a function that takes a node-style callback as an argument\n *     and then uses that callback to invoke some node-style API.\n * @returns a new Promise which will be rejected if the callback is given the\n *     first Error parameter or will resolve to the value given otherwise.\n */\nfunction nodePromise(action) {\n    return new Promise((resolve, reject) => {\n        action((error, value) => {\n            if (error) {\n                reject(error);\n            }\n            else {\n                resolve(value);\n            }\n        });\n    });\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// TODO: Fetch runtime version from grpc-js/package.json instead\n// when there's a cleaner way to dynamic require JSON in both Node ESM and CJS\nconst grpcVersion = '1.9.1';\nconst LOG_TAG$9 = 'GrpcConnection';\nconst X_GOOG_API_CLIENT_VALUE = `gl-node/${process.versions.node} fire/${SDK_VERSION} grpc/${grpcVersion}`;\nfunction createMetadata(databasePath, authToken, appCheckToken, appId) {\n    hardAssert(authToken === null || authToken.type === 'OAuth');\n    const metadata = new _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_7__.Metadata();\n    if (authToken) {\n        authToken.headers.forEach((value, key) => metadata.set(key, value));\n    }\n    if (appCheckToken) {\n        appCheckToken.headers.forEach((value, key) => metadata.set(key, value));\n    }\n    if (appId) {\n        metadata.set('X-Firebase-GMPID', appId);\n    }\n    metadata.set('X-Goog-Api-Client', X_GOOG_API_CLIENT_VALUE);\n    // These headers are used to improve routing and project isolation by the\n    // backend.\n    // TODO(b/199767712): We are keeping 'Google-Cloud-Resource-Prefix' until Emulators can be\n    // released with cl/428820046. Currently blocked because Emulators are now built with Java\n    // 11 from Google3.\n    metadata.set('Google-Cloud-Resource-Prefix', databasePath);\n    metadata.set('x-goog-request-params', databasePath);\n    return metadata;\n}\n/**\n * A Connection implemented by GRPC-Node.\n */\nclass GrpcConnection {\n    get shouldResourcePathBeIncludedInRequest() {\n        // Both `invokeRPC()` and `invokeStreamingRPC()` ignore their `path` arguments, and expect\n        // the \"path\" to be part of the given `request`.\n        return true;\n    }\n    constructor(protos, databaseInfo) {\n        this.databaseInfo = databaseInfo;\n        // We cache stubs for the most-recently-used token.\n        this.cachedStub = null;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.firestore = protos['google']['firestore']['v1'];\n        this.databasePath = `projects/${databaseInfo.databaseId.projectId}/databases/${databaseInfo.databaseId.database}`;\n    }\n    ensureActiveStub() {\n        if (!this.cachedStub) {\n            logDebug(LOG_TAG$9, 'Creating Firestore stub.');\n            const credentials = this.databaseInfo.ssl\n                ? _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_7__.credentials.createSsl()\n                : _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_7__.credentials.createInsecure();\n            this.cachedStub = new this.firestore.Firestore(this.databaseInfo.host, credentials);\n        }\n        return this.cachedStub;\n    }\n    invokeRPC(rpcName, path, request, authToken, appCheckToken) {\n        const streamId = generateUniqueDebugId();\n        const stub = this.ensureActiveStub();\n        const metadata = createMetadata(this.databasePath, authToken, appCheckToken, this.databaseInfo.appId);\n        const jsonRequest = Object.assign({ database: this.databasePath }, request);\n        return nodePromise((callback) => {\n            logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} invoked with request:`, request);\n            return stub[rpcName](jsonRequest, metadata, (grpcError, value) => {\n                if (grpcError) {\n                    logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} failed with error:`, grpcError);\n                    callback(new FirestoreError(mapCodeFromRpcCode(grpcError.code), grpcError.message));\n                }\n                else {\n                    logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} completed with response:`, value);\n                    callback(undefined, value);\n                }\n            });\n        });\n    }\n    invokeStreamingRPC(rpcName, path, request, authToken, appCheckToken, expectedResponseCount) {\n        const streamId = generateUniqueDebugId();\n        const results = [];\n        const responseDeferred = new Deferred();\n        logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} invoked (streaming) with request:`, request);\n        const stub = this.ensureActiveStub();\n        const metadata = createMetadata(this.databasePath, authToken, appCheckToken, this.databaseInfo.appId);\n        const jsonRequest = Object.assign(Object.assign({}, request), { database: this.databasePath });\n        const stream = stub[rpcName](jsonRequest, metadata);\n        let callbackFired = false;\n        stream.on('data', (response) => {\n            logDebug(LOG_TAG$9, `RPC ${rpcName} ${streamId} received result:`, response);\n            results.push(response);\n            if (expectedResponseCount !== undefined &&\n                results.length === expectedResponseCount) {\n                callbackFired = true;\n                responseDeferred.resolve(results);\n            }\n        });\n        stream.on('end', () => {\n            logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} completed.`);\n            if (!callbackFired) {\n                callbackFired = true;\n                responseDeferred.resolve(results);\n            }\n        });\n        stream.on('error', (grpcError) => {\n            logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} failed with error:`, grpcError);\n            const code = mapCodeFromRpcCode(grpcError.code);\n            responseDeferred.reject(new FirestoreError(code, grpcError.message));\n        });\n        return responseDeferred.promise;\n    }\n    // TODO(mikelehen): This \"method\" is a monster. Should be refactored.\n    openStream(rpcName, authToken, appCheckToken) {\n        const streamId = generateUniqueDebugId();\n        const stub = this.ensureActiveStub();\n        const metadata = createMetadata(this.databasePath, authToken, appCheckToken, this.databaseInfo.appId);\n        const grpcStream = stub[rpcName](metadata);\n        let closed = false;\n        const close = (err) => {\n            if (!closed) {\n                closed = true;\n                stream.callOnClose(err);\n                grpcStream.end();\n            }\n        };\n        const stream = new StreamBridge({\n            sendFn: (msg) => {\n                if (!closed) {\n                    logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} sending:`, msg);\n                    try {\n                        grpcStream.write(msg);\n                    }\n                    catch (e) {\n                        // This probably means we didn't conform to the proto.  Make sure to\n                        // log the message we sent.\n                        logError('Failure sending:', msg);\n                        logError('Error:', e);\n                        throw e;\n                    }\n                }\n                else {\n                    logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} ` +\n                        'not sending because gRPC stream is closed:', msg);\n                }\n            },\n            closeFn: () => {\n                logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} closed locally via close().`);\n                close();\n            }\n        });\n        let onConnectedSent = false;\n        grpcStream.on('data', (msg) => {\n            if (!closed) {\n                logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} received:`, msg);\n                // Emulate the \"onConnected\" event that WebChannelConnection sends.\n                if (!onConnectedSent) {\n                    stream.callOnConnected();\n                    onConnectedSent = true;\n                }\n                stream.callOnMessage(msg);\n            }\n        });\n        grpcStream.on('end', () => {\n            logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} ended.`);\n            close();\n        });\n        grpcStream.on('error', (grpcError) => {\n            if (!closed) {\n                logWarn(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} error. Code:`, grpcError.code, 'Message:', grpcError.message);\n                const code = mapCodeFromRpcCode(grpcError.code);\n                close(new FirestoreError(code, grpcError.message));\n            }\n        });\n        logDebug(LOG_TAG$9, `Opening RPC '${rpcName}' stream ${streamId} ` +\n            `to ${this.databaseInfo.host}`);\n        // TODO(dimond): Since grpc has no explicit open status (or does it?) we\n        // simulate an onOpen in the next loop after the stream had it's listeners\n        // registered\n        setTimeout(() => {\n            stream.callOnOpen();\n        }, 0);\n        return stream;\n    }\n    /**\n     * Closes and cleans up any resources associated with the GrpcConnection.\n     * If a gRPC client has been generated for this connection, the gRPC client\n     * is closed. Failure to call terminate on a GrpcConnection can result\n     * in leaked resources of the gRPC client.\n     */\n    terminate() {\n        if (this.cachedStub) {\n            this.cachedStub.close();\n            this.cachedStub = undefined;\n        }\n    }\n}\n\nconst nested = {\n\tgoogle: {\n\t\tnested: {\n\t\t\tprotobuf: {\n\t\t\t\toptions: {\n\t\t\t\t\tcsharp_namespace: \"Google.Protobuf.WellKnownTypes\",\n\t\t\t\t\tgo_package: \"github.com/golang/protobuf/ptypes/wrappers\",\n\t\t\t\t\tjava_package: \"com.google.protobuf\",\n\t\t\t\t\tjava_outer_classname: \"WrappersProto\",\n\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\tobjc_class_prefix: \"GPB\",\n\t\t\t\t\tcc_enable_arenas: true,\n\t\t\t\t\toptimize_for: \"SPEED\"\n\t\t\t\t},\n\t\t\t\tnested: {\n\t\t\t\t\tTimestamp: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tseconds: {\n\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnanos: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFileDescriptorSet: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tfile: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"FileDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFileDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"package\": {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdependency: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpublicDependency: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 10,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\tpacked: false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tweakDependency: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 11,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\tpacked: false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmessageType: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"DescriptorProto\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tenumType: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"EnumDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tservice: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"ServiceDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\textension: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"FieldDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"FileOptions\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tsourceCodeInfo: {\n\t\t\t\t\t\t\t\ttype: \"SourceCodeInfo\",\n\t\t\t\t\t\t\t\tid: 9\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tsyntax: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 12\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"FieldDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\textension: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"FieldDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnestedType: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"DescriptorProto\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tenumType: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"EnumDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\textensionRange: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"ExtensionRange\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toneofDecl: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"OneofDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"MessageOptions\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\treservedRange: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"ReservedRange\",\n\t\t\t\t\t\t\t\tid: 9\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\treservedName: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tExtensionRange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tend: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tReservedRange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tend: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFieldDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnumber: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlabel: {\n\t\t\t\t\t\t\t\ttype: \"Label\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ttype: {\n\t\t\t\t\t\t\t\ttype: \"Type\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ttypeName: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\textendee: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdefaultValue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toneofIndex: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 9\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjsonName: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"FieldOptions\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tType: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tTYPE_DOUBLE: 1,\n\t\t\t\t\t\t\t\t\tTYPE_FLOAT: 2,\n\t\t\t\t\t\t\t\t\tTYPE_INT64: 3,\n\t\t\t\t\t\t\t\t\tTYPE_UINT64: 4,\n\t\t\t\t\t\t\t\t\tTYPE_INT32: 5,\n\t\t\t\t\t\t\t\t\tTYPE_FIXED64: 6,\n\t\t\t\t\t\t\t\t\tTYPE_FIXED32: 7,\n\t\t\t\t\t\t\t\t\tTYPE_BOOL: 8,\n\t\t\t\t\t\t\t\t\tTYPE_STRING: 9,\n\t\t\t\t\t\t\t\t\tTYPE_GROUP: 10,\n\t\t\t\t\t\t\t\t\tTYPE_MESSAGE: 11,\n\t\t\t\t\t\t\t\t\tTYPE_BYTES: 12,\n\t\t\t\t\t\t\t\t\tTYPE_UINT32: 13,\n\t\t\t\t\t\t\t\t\tTYPE_ENUM: 14,\n\t\t\t\t\t\t\t\t\tTYPE_SFIXED32: 15,\n\t\t\t\t\t\t\t\t\tTYPE_SFIXED64: 16,\n\t\t\t\t\t\t\t\t\tTYPE_SINT32: 17,\n\t\t\t\t\t\t\t\t\tTYPE_SINT64: 18\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tLabel: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tLABEL_OPTIONAL: 1,\n\t\t\t\t\t\t\t\t\tLABEL_REQUIRED: 2,\n\t\t\t\t\t\t\t\t\tLABEL_REPEATED: 3\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tOneofDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"OneofOptions\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tEnumDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"EnumValueDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"EnumOptions\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tEnumValueDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnumber: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"EnumValueOptions\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tServiceDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmethod: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"MethodDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"ServiceOptions\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tMethodDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tinputType: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toutputType: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"MethodOptions\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tclientStreaming: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tserverStreaming: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFileOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tjavaPackage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaOuterClassname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaMultipleFiles: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaGenerateEqualsAndHash: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 20,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\tdeprecated: true\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaStringCheckUtf8: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 27\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptimizeFor: {\n\t\t\t\t\t\t\t\ttype: \"OptimizeMode\",\n\t\t\t\t\t\t\t\tid: 9,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": \"SPEED\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tgoPackage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 11\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tccGenericServices: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 16\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaGenericServices: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 17\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpyGenericServices: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 18\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 23\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tccEnableArenas: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 31\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tobjcClassPrefix: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 36\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tcsharpNamespace: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 37\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\treserved: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t38,\n\t\t\t\t\t\t\t\t38\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tOptimizeMode: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tSPEED: 1,\n\t\t\t\t\t\t\t\t\tCODE_SIZE: 2,\n\t\t\t\t\t\t\t\t\tLITE_RUNTIME: 3\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tMessageOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tmessageSetWireFormat: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnoStandardDescriptorAccessor: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmapEntry: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\treserved: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t8,\n\t\t\t\t\t\t\t\t8\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tFieldOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tctype: {\n\t\t\t\t\t\t\t\ttype: \"CType\",\n\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": \"STRING\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpacked: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjstype: {\n\t\t\t\t\t\t\t\ttype: \"JSType\",\n\t\t\t\t\t\t\t\tid: 6,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": \"JS_NORMAL\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlazy: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tweak: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\treserved: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t4,\n\t\t\t\t\t\t\t\t4\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tCType: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tSTRING: 0,\n\t\t\t\t\t\t\t\t\tCORD: 1,\n\t\t\t\t\t\t\t\t\tSTRING_PIECE: 2\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tJSType: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tJS_NORMAL: 0,\n\t\t\t\t\t\t\t\t\tJS_STRING: 1,\n\t\t\t\t\t\t\t\t\tJS_NUMBER: 2\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tOneofOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tEnumOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tallowAlias: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tEnumValueOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tServiceOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 33\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tMethodOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 33\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tUninterpretedOption: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"NamePart\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tidentifierValue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpositiveIntValue: {\n\t\t\t\t\t\t\t\ttype: \"uint64\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnegativeIntValue: {\n\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdoubleValue: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstringValue: {\n\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\taggregateValue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tNamePart: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tnamePart: {\n\t\t\t\t\t\t\t\t\t\trule: \"required\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tisExtension: {\n\t\t\t\t\t\t\t\t\t\trule: \"required\",\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tSourceCodeInfo: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tlocation: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"Location\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tLocation: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tpath: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tspan: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tleadingComments: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttrailingComments: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tleadingDetachedComments: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tGeneratedCodeInfo: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tannotation: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"Annotation\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tAnnotation: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tpath: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tsourceFile: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbegin: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tend: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tStruct: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tValue: {\n\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\tkind: {\n\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\"nullValue\",\n\t\t\t\t\t\t\t\t\t\"numberValue\",\n\t\t\t\t\t\t\t\t\t\"stringValue\",\n\t\t\t\t\t\t\t\t\t\"boolValue\",\n\t\t\t\t\t\t\t\t\t\"structValue\",\n\t\t\t\t\t\t\t\t\t\"listValue\"\n\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tnullValue: {\n\t\t\t\t\t\t\t\ttype: \"NullValue\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnumberValue: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstringValue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tboolValue: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstructValue: {\n\t\t\t\t\t\t\t\ttype: \"Struct\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlistValue: {\n\t\t\t\t\t\t\t\ttype: \"ListValue\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tNullValue: {\n\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\tNULL_VALUE: 0\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tListValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tEmpty: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tDoubleValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFloatValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"float\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tInt64Value: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tUInt64Value: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"uint64\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tInt32Value: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tUInt32Value: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"uint32\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tBoolValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tStringValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tBytesValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tAny: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\ttypeUrl: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tfirestore: {\n\t\t\t\tnested: {\n\t\t\t\t\tv1: {\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tcsharp_namespace: \"Google.Cloud.Firestore.V1\",\n\t\t\t\t\t\t\tgo_package: \"google.golang.org/genproto/googleapis/firestore/v1;firestore\",\n\t\t\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\t\t\tjava_outer_classname: \"WriteProto\",\n\t\t\t\t\t\t\tjava_package: \"com.google.firestore.v1\",\n\t\t\t\t\t\t\tobjc_class_prefix: \"GCFS\",\n\t\t\t\t\t\t\tphp_namespace: \"Google\\\\Cloud\\\\Firestore\\\\V1\",\n\t\t\t\t\t\t\truby_package: \"Google::Cloud::Firestore::V1\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tAggregationResult: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\taggregateFields: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBitSequence: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tbitmap: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpadding: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBloomFilter: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tbits: {\n\t\t\t\t\t\t\t\t\t\ttype: \"BitSequence\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\thashCount: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentMask: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tfieldPaths: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tPrecondition: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tconditionType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"exists\",\n\t\t\t\t\t\t\t\t\t\t\t\"updateTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\texists: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTransactionOptions: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tmode: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"readOnly\",\n\t\t\t\t\t\t\t\t\t\t\t\"readWrite\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\treadOnly: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ReadOnly\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadWrite: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ReadWrite\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tReadWrite: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tretryTransaction: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tReadOnly: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocument: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcreateTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tValue: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tvalueType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"nullValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"booleanValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"integerValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"doubleValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"timestampValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"stringValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"bytesValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"referenceValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"geoPointValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"arrayValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"mapValue\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tnullValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.NullValue\",\n\t\t\t\t\t\t\t\t\t\tid: 11\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbooleanValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tintegerValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdoubleValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttimestampValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstringValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 17\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbytesValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 18\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treferenceValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tgeoPointValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.type.LatLng\",\n\t\t\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tarrayValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ArrayValue\",\n\t\t\t\t\t\t\t\t\t\tid: 9\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmapValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"MapValue\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tArrayValue: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMapValue: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tFirestore: {\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"(google.api.default_host)\": \"firestore.googleapis.com\",\n\t\t\t\t\t\t\t\t\t\"(google.api.oauth_scopes)\": \"https://www.googleapis.com/auth/cloud-platform,https://www.googleapis.com/auth/datastore\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tmethods: {\n\t\t\t\t\t\t\t\t\tGetDocument: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"GetDocumentRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"Document\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).get\": \"/v1/{name=projects/*/databases/*/documents/*/**}\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tget: \"/v1/{name=projects/*/databases/*/documents/*/**}\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tListDocuments: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"ListDocumentsRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"ListDocumentsResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).get\": \"/v1/{parent=projects/*/databases/*/documents/*/**}/{collection_id}\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tget: \"/v1/{parent=projects/*/databases/*/documents/*/**}/{collection_id}\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tUpdateDocument: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"UpdateDocumentRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"Document\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).patch\": \"/v1/{document.name=projects/*/databases/*/documents/*/**}\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"document\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"document,update_mask\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpatch: \"/v1/{document.name=projects/*/databases/*/documents/*/**}\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"document\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"document,update_mask\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tDeleteDocument: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"DeleteDocumentRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"google.protobuf.Empty\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).delete\": \"/v1/{name=projects/*/databases/*/documents/*/**}\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"name\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"delete\": \"/v1/{name=projects/*/databases/*/documents/*/**}\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"name\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tBatchGetDocuments: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"BatchGetDocumentsRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"BatchGetDocumentsResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:batchGet\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:batchGet\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tBeginTransaction: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"BeginTransactionRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"BeginTransactionResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:beginTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:beginTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tCommit: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"CommitRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"CommitResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:commit\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database,writes\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:commit\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database,writes\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tRollback: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"RollbackRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"google.protobuf.Empty\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:rollback\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database,transaction\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:rollback\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database,transaction\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tRunQuery: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"RunQueryRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"RunQueryResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents}:runQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.post\": \"/v1/{parent=projects/*/databases/*/documents/*/**}:runQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents}:runQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tadditional_bindings: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/*/**}:runQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tRunAggregationQuery: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"RunAggregationQueryRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"RunAggregationQueryResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents}:runAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.post\": \"/v1/{parent=projects/*/databases/*/documents/*/**}:runAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents}:runAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tadditional_bindings: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/*/**}:runAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tPartitionQuery: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"PartitionQueryRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"PartitionQueryResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents}:partitionQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.post\": \"/v1/{parent=projects/*/databases/*/documents/*/**}:partitionQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents}:partitionQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tadditional_bindings: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/*/**}:partitionQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tWrite: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"WriteRequest\",\n\t\t\t\t\t\t\t\t\t\trequestStream: true,\n\t\t\t\t\t\t\t\t\t\tresponseType: \"WriteResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:write\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:write\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tListen: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"ListenRequest\",\n\t\t\t\t\t\t\t\t\t\trequestStream: true,\n\t\t\t\t\t\t\t\t\t\tresponseType: \"ListenResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:listen\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:listen\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tListCollectionIds: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"ListCollectionIdsRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"ListCollectionIdsResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents}:listCollectionIds\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.post\": \"/v1/{parent=projects/*/databases/*/documents/*/**}:listCollectionIds\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"parent\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents}:listCollectionIds\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tadditional_bindings: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/*/**}:listCollectionIds\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"parent\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tBatchWrite: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"BatchWriteRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"BatchWriteResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:batchWrite\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:batchWrite\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tCreateDocument: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"CreateDocumentRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"Document\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents/**}/{collection_id}\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"document\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/**}/{collection_id}\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"document\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tGetDocumentRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListDocumentsRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcollectionId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageSize: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\torderBy: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tshowMissing: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 12\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListDocumentsResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocuments: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnextPageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCreateDocumentRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcollectionId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocumentId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 4,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tUpdateDocumentRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateMask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcurrentDocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Precondition\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDeleteDocumentRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcurrentDocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Precondition\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBatchGetDocumentsRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"newTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocuments: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnewTransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TransactionOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBatchGetDocumentsResponse: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tresult: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"found\",\n\t\t\t\t\t\t\t\t\t\t\t\"missing\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tfound: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmissing: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBeginTransactionRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TransactionOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBeginTransactionResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCommitRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twrites: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Write\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCommitResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\twriteResults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"WriteResult\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcommitTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRollbackRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 2,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRunQueryRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"structuredQuery\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"newTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstructuredQuery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnewTransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TransactionOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRunQueryResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tskippedResults: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRunAggregationQueryRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"structuredAggregationQuery\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"newTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstructuredAggregationQuery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"StructuredAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnewTransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TransactionOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRunAggregationQueryResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tresult: {\n\t\t\t\t\t\t\t\t\t\ttype: \"AggregationResult\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tPartitionQueryRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"structuredQuery\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstructuredQuery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpartitionCount: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageSize: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tPartitionQueryResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tpartitions: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Cursor\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnextPageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tWriteRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstreamId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twrites: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Write\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstreamToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlabels: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tWriteResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstreamId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstreamToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twriteResults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"WriteResult\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcommitTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListenRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\ttargetChange: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"addTarget\",\n\t\t\t\t\t\t\t\t\t\t\t\"removeTarget\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\taddTarget: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Target\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tremoveTarget: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlabels: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListenResponse: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tresponseType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"targetChange\",\n\t\t\t\t\t\t\t\t\t\t\t\"documentChange\",\n\t\t\t\t\t\t\t\t\t\t\t\"documentDelete\",\n\t\t\t\t\t\t\t\t\t\t\t\"documentRemove\",\n\t\t\t\t\t\t\t\t\t\t\t\"filter\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttargetChange: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TargetChange\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocumentChange: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentChange\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocumentDelete: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentDelete\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocumentRemove: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentRemove\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfilter: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ExistenceFilter\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTarget: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\ttargetType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"query\",\n\t\t\t\t\t\t\t\t\t\t\t\"documents\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tresumeType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"resumeToken\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tquery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"QueryTarget\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocuments: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentsTarget\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tresumeToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 11\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttargetId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tonce: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\texpectedCount: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Int32Value\",\n\t\t\t\t\t\t\t\t\t\tid: 12\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tDocumentsTarget: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tdocuments: {\n\t\t\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tQueryTarget: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"structuredQuery\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tstructuredQuery: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTargetChange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttargetChangeType: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TargetChangeType\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcause: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.rpc.Status\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tresumeToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tTargetChangeType: {\n\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\tNO_CHANGE: 0,\n\t\t\t\t\t\t\t\t\t\t\tADD: 1,\n\t\t\t\t\t\t\t\t\t\t\tREMOVE: 2,\n\t\t\t\t\t\t\t\t\t\t\tCURRENT: 3,\n\t\t\t\t\t\t\t\t\t\t\tRESET: 4\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListCollectionIdsRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageSize: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListCollectionIdsResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tcollectionIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnextPageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBatchWriteRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twrites: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Write\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlabels: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBatchWriteResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\twriteResults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"WriteResult\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"google.rpc.Status\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tStructuredQuery: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tselect: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Projection\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfrom: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"CollectionSelector\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twhere: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Filter\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\torderBy: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Order\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstartAt: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Cursor\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tendAt: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Cursor\",\n\t\t\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\toffset: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlimit: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Int32Value\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tCollectionSelector: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tcollectionId: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tallDescendants: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tFilter: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\tfilterType: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"compositeFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"fieldFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"unaryFilter\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tcompositeFilter: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"CompositeFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tfieldFilter: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tunaryFilter: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"UnaryFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tCompositeFilter: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\top: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Operator\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tfilters: {\n\t\t\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Filter\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tOperator: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tOPERATOR_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tAND: 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\tOR: 2\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tFieldFilter: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\top: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Operator\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tOperator: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tOPERATOR_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tLESS_THAN: 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\tLESS_THAN_OR_EQUAL: 2,\n\t\t\t\t\t\t\t\t\t\t\t\t\tGREATER_THAN: 3,\n\t\t\t\t\t\t\t\t\t\t\t\t\tGREATER_THAN_OR_EQUAL: 4,\n\t\t\t\t\t\t\t\t\t\t\t\t\tEQUAL: 5,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNOT_EQUAL: 6,\n\t\t\t\t\t\t\t\t\t\t\t\t\tARRAY_CONTAINS: 7,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIN: 8,\n\t\t\t\t\t\t\t\t\t\t\t\t\tARRAY_CONTAINS_ANY: 9,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNOT_IN: 10\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tUnaryFilter: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\toperandType: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"field\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\top: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Operator\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tOperator: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tOPERATOR_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIS_NAN: 2,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIS_NULL: 3,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIS_NOT_NAN: 4,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIS_NOT_NULL: 5\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tOrder: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tdirection: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Direction\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tFieldReference: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfieldPath: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tProjection: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tDirection: {\n\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\tDIRECTION_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\tASCENDING: 1,\n\t\t\t\t\t\t\t\t\t\t\tDESCENDING: 2\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tStructuredAggregationQuery: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"structuredQuery\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstructuredQuery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\taggregations: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Aggregation\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tAggregation: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\toperator: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"count\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"sum\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"avg\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tcount: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Count\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tsum: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Sum\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tavg: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Avg\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\talias: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tCount: {\n\t\t\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tupTo: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Int64Value\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tSum: {\n\t\t\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tAvg: {\n\t\t\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCursor: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbefore: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tWrite: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\toperation: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"update\",\n\t\t\t\t\t\t\t\t\t\t\t\"delete\",\n\t\t\t\t\t\t\t\t\t\t\t\"verify\",\n\t\t\t\t\t\t\t\t\t\t\t\"transform\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tupdate: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\"delete\": {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tverify: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransform: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentTransform\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateMask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateTransforms: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentTransform.FieldTransform\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcurrentDocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Precondition\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentTransform: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfieldTransforms: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"FieldTransform\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tFieldTransform: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\ttransformType: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"setToServerValue\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"increment\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"maximum\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"minimum\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"appendMissingElements\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"removeAllFromArray\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfieldPath: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tsetToServerValue: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"ServerValue\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tincrement: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tmaximum: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tminimum: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tappendMissingElements: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"ArrayValue\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tremoveAllFromArray: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"ArrayValue\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tServerValue: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tSERVER_VALUE_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tREQUEST_TIME: 1\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tWriteResult: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tupdateTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransformResults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentChange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tremovedTargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentDelete: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tremovedTargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentRemove: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tremovedTargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tExistenceFilter: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttargetId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcount: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tunchangedNames: {\n\t\t\t\t\t\t\t\t\t\ttype: \"BloomFilter\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tapi: {\n\t\t\t\toptions: {\n\t\t\t\t\tgo_package: \"google.golang.org/genproto/googleapis/api/annotations;annotations\",\n\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\tjava_outer_classname: \"HttpProto\",\n\t\t\t\t\tjava_package: \"com.google.api\",\n\t\t\t\t\tobjc_class_prefix: \"GAPI\",\n\t\t\t\t\tcc_enable_arenas: true\n\t\t\t\t},\n\t\t\t\tnested: {\n\t\t\t\t\thttp: {\n\t\t\t\t\t\ttype: \"HttpRule\",\n\t\t\t\t\t\tid: 72295728,\n\t\t\t\t\t\textend: \"google.protobuf.MethodOptions\"\n\t\t\t\t\t},\n\t\t\t\t\tHttp: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\trules: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"HttpRule\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tHttpRule: {\n\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\tpattern: {\n\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\"get\",\n\t\t\t\t\t\t\t\t\t\"put\",\n\t\t\t\t\t\t\t\t\t\"post\",\n\t\t\t\t\t\t\t\t\t\"delete\",\n\t\t\t\t\t\t\t\t\t\"patch\",\n\t\t\t\t\t\t\t\t\t\"custom\"\n\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tget: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tput: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpost: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"delete\": {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpatch: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tcustom: {\n\t\t\t\t\t\t\t\ttype: \"CustomHttpPattern\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tselector: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tadditionalBindings: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"HttpRule\",\n\t\t\t\t\t\t\t\tid: 11\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tCustomHttpPattern: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tkind: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpath: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tmethodSignature: {\n\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tid: 1051,\n\t\t\t\t\t\textend: \"google.protobuf.MethodOptions\"\n\t\t\t\t\t},\n\t\t\t\t\tdefaultHost: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tid: 1049,\n\t\t\t\t\t\textend: \"google.protobuf.ServiceOptions\"\n\t\t\t\t\t},\n\t\t\t\t\toauthScopes: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tid: 1050,\n\t\t\t\t\t\textend: \"google.protobuf.ServiceOptions\"\n\t\t\t\t\t},\n\t\t\t\t\tfieldBehavior: {\n\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\ttype: \"google.api.FieldBehavior\",\n\t\t\t\t\t\tid: 1052,\n\t\t\t\t\t\textend: \"google.protobuf.FieldOptions\"\n\t\t\t\t\t},\n\t\t\t\t\tFieldBehavior: {\n\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\tFIELD_BEHAVIOR_UNSPECIFIED: 0,\n\t\t\t\t\t\t\tOPTIONAL: 1,\n\t\t\t\t\t\t\tREQUIRED: 2,\n\t\t\t\t\t\t\tOUTPUT_ONLY: 3,\n\t\t\t\t\t\t\tINPUT_ONLY: 4,\n\t\t\t\t\t\t\tIMMUTABLE: 5,\n\t\t\t\t\t\t\tUNORDERED_LIST: 6,\n\t\t\t\t\t\t\tNON_EMPTY_DEFAULT: 7\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\ttype: {\n\t\t\t\toptions: {\n\t\t\t\t\tcc_enable_arenas: true,\n\t\t\t\t\tgo_package: \"google.golang.org/genproto/googleapis/type/latlng;latlng\",\n\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\tjava_outer_classname: \"LatLngProto\",\n\t\t\t\t\tjava_package: \"com.google.type\",\n\t\t\t\t\tobjc_class_prefix: \"GTP\"\n\t\t\t\t},\n\t\t\t\tnested: {\n\t\t\t\t\tLatLng: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tlatitude: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlongitude: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\trpc: {\n\t\t\t\toptions: {\n\t\t\t\t\tcc_enable_arenas: true,\n\t\t\t\t\tgo_package: \"google.golang.org/genproto/googleapis/rpc/status;status\",\n\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\tjava_outer_classname: \"StatusProto\",\n\t\t\t\t\tjava_package: \"com.google.rpc\",\n\t\t\t\t\tobjc_class_prefix: \"RPC\"\n\t\t\t\t},\n\t\t\t\tnested: {\n\t\t\t\t\tStatus: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tcode: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdetails: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"google.protobuf.Any\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\nvar protos = {\n\tnested: nested\n};\n\nvar protos$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  nested: nested,\n  'default': protos\n});\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Used by tests so we can match @grpc/proto-loader behavior. */\nconst protoLoaderOptions = {\n    longs: String,\n    enums: String,\n    defaults: true,\n    oneofs: false\n};\n/**\n * Loads the protocol buffer definitions for Firestore.\n *\n * @returns The GrpcObject representing our protos.\n */\nfunction loadProtos() {\n    const packageDefinition = _grpc_proto_loader__WEBPACK_IMPORTED_MODULE_8__.fromJSON(protos$1, protoLoaderOptions);\n    return _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_7__.loadPackageDefinition(packageDefinition);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Loads the GRPC stack */\nfunction newConnection(databaseInfo) {\n    const protos = loadProtos();\n    return new GrpcConnection(protos, databaseInfo);\n}\n/** Return the Platform-specific connectivity monitor. */\nfunction newConnectivityMonitor() {\n    return new NoopConnectivityMonitor();\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** The Platform's 'window' implementation or null if not available. */\nfunction getWindow() {\n    if (process.env.USE_MOCK_PERSISTENCE === 'YES') {\n        // eslint-disable-next-line no-restricted-globals\n        return window;\n    }\n    return null;\n}\n/** The Platform's 'document' implementation or null if not available. */\nfunction getDocument() {\n    return null;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction newSerializer(databaseId) {\n    return new JsonProtoSerializer(databaseId, /* useProto3Json= */ false);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$8 = 'ExponentialBackoff';\n/**\n * Initial backoff time in milliseconds after an error.\n * Set to 1s according to https://cloud.google.com/apis/design/errors.\n */\nconst DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1000;\nconst DEFAULT_BACKOFF_FACTOR = 1.5;\n/** Maximum backoff time in milliseconds */\nconst DEFAULT_BACKOFF_MAX_DELAY_MS = 60 * 1000;\n/**\n * A helper for running delayed tasks following an exponential backoff curve\n * between attempts.\n *\n * Each delay is made up of a \"base\" delay which follows the exponential\n * backoff curve, and a +/- 50% \"jitter\" that is calculated and added to the\n * base delay. This prevents clients from accidentally synchronizing their\n * delays causing spikes of load to the backend.\n */\nclass ExponentialBackoff {\n    constructor(\n    /**\n     * The AsyncQueue to run backoff operations on.\n     */\n    queue, \n    /**\n     * The ID to use when scheduling backoff operations on the AsyncQueue.\n     */\n    timerId, \n    /**\n     * The initial delay (used as the base delay on the first retry attempt).\n     * Note that jitter will still be applied, so the actual delay could be as\n     * little as 0.5*initialDelayMs.\n     */\n    initialDelayMs = DEFAULT_BACKOFF_INITIAL_DELAY_MS, \n    /**\n     * The multiplier to use to determine the extended base delay after each\n     * attempt.\n     */\n    backoffFactor = DEFAULT_BACKOFF_FACTOR, \n    /**\n     * The maximum base delay after which no further backoff is performed.\n     * Note that jitter will still be applied, so the actual delay could be as\n     * much as 1.5*maxDelayMs.\n     */\n    maxDelayMs = DEFAULT_BACKOFF_MAX_DELAY_MS) {\n        this.queue = queue;\n        this.timerId = timerId;\n        this.initialDelayMs = initialDelayMs;\n        this.backoffFactor = backoffFactor;\n        this.maxDelayMs = maxDelayMs;\n        this.currentBaseMs = 0;\n        this.timerPromise = null;\n        /** The last backoff attempt, as epoch milliseconds. */\n        this.lastAttemptTime = Date.now();\n        this.reset();\n    }\n    /**\n     * Resets the backoff delay.\n     *\n     * The very next backoffAndWait() will have no delay. If it is called again\n     * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and\n     * subsequent ones will increase according to the backoffFactor.\n     */\n    reset() {\n        this.currentBaseMs = 0;\n    }\n    /**\n     * Resets the backoff delay to the maximum delay (e.g. for use after a\n     * RESOURCE_EXHAUSTED error).\n     */\n    resetToMax() {\n        this.currentBaseMs = this.maxDelayMs;\n    }\n    /**\n     * Returns a promise that resolves after currentDelayMs, and increases the\n     * delay for any subsequent attempts. If there was a pending backoff operation\n     * already, it will be canceled.\n     */\n    backoffAndRun(op) {\n        // Cancel any pending backoff operation.\n        this.cancel();\n        // First schedule using the current base (which may be 0 and should be\n        // honored as such).\n        const desiredDelayWithJitterMs = Math.floor(this.currentBaseMs + this.jitterDelayMs());\n        // Guard against lastAttemptTime being in the future due to a clock change.\n        const delaySoFarMs = Math.max(0, Date.now() - this.lastAttemptTime);\n        // Guard against the backoff delay already being past.\n        const remainingDelayMs = Math.max(0, desiredDelayWithJitterMs - delaySoFarMs);\n        if (remainingDelayMs > 0) {\n            logDebug(LOG_TAG$8, `Backing off for ${remainingDelayMs} ms ` +\n                `(base delay: ${this.currentBaseMs} ms, ` +\n                `delay with jitter: ${desiredDelayWithJitterMs} ms, ` +\n                `last attempt: ${delaySoFarMs} ms ago)`);\n        }\n        this.timerPromise = this.queue.enqueueAfterDelay(this.timerId, remainingDelayMs, () => {\n            this.lastAttemptTime = Date.now();\n            return op();\n        });\n        // Apply backoff factor to determine next delay and ensure it is within\n        // bounds.\n        this.currentBaseMs *= this.backoffFactor;\n        if (this.currentBaseMs < this.initialDelayMs) {\n            this.currentBaseMs = this.initialDelayMs;\n        }\n        if (this.currentBaseMs > this.maxDelayMs) {\n            this.currentBaseMs = this.maxDelayMs;\n        }\n    }\n    skipBackoff() {\n        if (this.timerPromise !== null) {\n            this.timerPromise.skipDelay();\n            this.timerPromise = null;\n        }\n    }\n    cancel() {\n        if (this.timerPromise !== null) {\n            this.timerPromise.cancel();\n            this.timerPromise = null;\n        }\n    }\n    /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */\n    jitterDelayMs() {\n        return (Math.random() - 0.5) * this.currentBaseMs;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$7 = 'PersistentStream';\n/** The time a stream stays open after it is marked idle. */\nconst IDLE_TIMEOUT_MS = 60 * 1000;\n/** The time a stream stays open until we consider it healthy. */\nconst HEALTHY_TIMEOUT_MS = 10 * 1000;\n/**\n * A PersistentStream is an abstract base class that represents a streaming RPC\n * to the Firestore backend. It's built on top of the connections own support\n * for streaming RPCs, and adds several critical features for our clients:\n *\n *   - Exponential backoff on failure\n *   - Authentication via CredentialsProvider\n *   - Dispatching all callbacks into the shared worker queue\n *   - Closing idle streams after 60 seconds of inactivity\n *\n * Subclasses of PersistentStream implement serialization of models to and\n * from the JSON representation of the protocol buffers for a specific\n * streaming RPC.\n *\n * ## Starting and Stopping\n *\n * Streaming RPCs are stateful and need to be start()ed before messages can\n * be sent and received. The PersistentStream will call the onOpen() function\n * of the listener once the stream is ready to accept requests.\n *\n * Should a start() fail, PersistentStream will call the registered onClose()\n * listener with a FirestoreError indicating what went wrong.\n *\n * A PersistentStream can be started and stopped repeatedly.\n *\n * Generic types:\n *  SendType: The type of the outgoing message of the underlying\n *    connection stream\n *  ReceiveType: The type of the incoming message of the underlying\n *    connection stream\n *  ListenerType: The type of the listener that will be used for callbacks\n */\nclass PersistentStream {\n    constructor(queue, connectionTimerId, idleTimerId, healthTimerId, connection, authCredentialsProvider, appCheckCredentialsProvider, listener) {\n        this.queue = queue;\n        this.idleTimerId = idleTimerId;\n        this.healthTimerId = healthTimerId;\n        this.connection = connection;\n        this.authCredentialsProvider = authCredentialsProvider;\n        this.appCheckCredentialsProvider = appCheckCredentialsProvider;\n        this.listener = listener;\n        this.state = 0 /* PersistentStreamState.Initial */;\n        /**\n         * A close count that's incremented every time the stream is closed; used by\n         * getCloseGuardedDispatcher() to invalidate callbacks that happen after\n         * close.\n         */\n        this.closeCount = 0;\n        this.idleTimer = null;\n        this.healthCheck = null;\n        this.stream = null;\n        /**\n         * Count of response messages received.\n         */\n        this.responseCount = 0;\n        this.backoff = new ExponentialBackoff(queue, connectionTimerId);\n    }\n    /**\n     * Returns true if start() has been called and no error has occurred. True\n     * indicates the stream is open or in the process of opening (which\n     * encompasses respecting backoff, getting auth tokens, and starting the\n     * actual RPC). Use isOpen() to determine if the stream is open and ready for\n     * outbound requests.\n     */\n    isStarted() {\n        return (this.state === 1 /* PersistentStreamState.Starting */ ||\n            this.state === 5 /* PersistentStreamState.Backoff */ ||\n            this.isOpen());\n    }\n    /**\n     * Returns true if the underlying RPC is open (the onOpen() listener has been\n     * called) and the stream is ready for outbound requests.\n     */\n    isOpen() {\n        return (this.state === 2 /* PersistentStreamState.Open */ ||\n            this.state === 3 /* PersistentStreamState.Healthy */);\n    }\n    /**\n     * Starts the RPC. Only allowed if isStarted() returns false. The stream is\n     * not immediately ready for use: onOpen() will be invoked when the RPC is\n     * ready for outbound requests, at which point isOpen() will return true.\n     *\n     * When start returns, isStarted() will return true.\n     */\n    start() {\n        this.responseCount = 0;\n        if (this.state === 4 /* PersistentStreamState.Error */) {\n            this.performBackoff();\n            return;\n        }\n        this.auth();\n    }\n    /**\n     * Stops the RPC. This call is idempotent and allowed regardless of the\n     * current isStarted() state.\n     *\n     * When stop returns, isStarted() and isOpen() will both return false.\n     */\n    async stop() {\n        if (this.isStarted()) {\n            await this.close(0 /* PersistentStreamState.Initial */);\n        }\n    }\n    /**\n     * After an error the stream will usually back off on the next attempt to\n     * start it. If the error warrants an immediate restart of the stream, the\n     * sender can use this to indicate that the receiver should not back off.\n     *\n     * Each error will call the onClose() listener. That function can decide to\n     * inhibit backoff if required.\n     */\n    inhibitBackoff() {\n        this.state = 0 /* PersistentStreamState.Initial */;\n        this.backoff.reset();\n    }\n    /**\n     * Marks this stream as idle. If no further actions are performed on the\n     * stream for one minute, the stream will automatically close itself and\n     * notify the stream's onClose() handler with Status.OK. The stream will then\n     * be in a !isStarted() state, requiring the caller to start the stream again\n     * before further use.\n     *\n     * Only streams that are in state 'Open' can be marked idle, as all other\n     * states imply pending network operations.\n     */\n    markIdle() {\n        // Starts the idle time if we are in state 'Open' and are not yet already\n        // running a timer (in which case the previous idle timeout still applies).\n        if (this.isOpen() && this.idleTimer === null) {\n            this.idleTimer = this.queue.enqueueAfterDelay(this.idleTimerId, IDLE_TIMEOUT_MS, () => this.handleIdleCloseTimer());\n        }\n    }\n    /** Sends a message to the underlying stream. */\n    sendRequest(msg) {\n        this.cancelIdleCheck();\n        this.stream.send(msg);\n    }\n    /** Called by the idle timer when the stream should close due to inactivity. */\n    async handleIdleCloseTimer() {\n        if (this.isOpen()) {\n            // When timing out an idle stream there's no reason to force the stream into backoff when\n            // it restarts so set the stream state to Initial instead of Error.\n            return this.close(0 /* PersistentStreamState.Initial */);\n        }\n    }\n    /** Marks the stream as active again. */\n    cancelIdleCheck() {\n        if (this.idleTimer) {\n            this.idleTimer.cancel();\n            this.idleTimer = null;\n        }\n    }\n    /** Cancels the health check delayed operation. */\n    cancelHealthCheck() {\n        if (this.healthCheck) {\n            this.healthCheck.cancel();\n            this.healthCheck = null;\n        }\n    }\n    /**\n     * Closes the stream and cleans up as necessary:\n     *\n     * * closes the underlying GRPC stream;\n     * * calls the onClose handler with the given 'error';\n     * * sets internal stream state to 'finalState';\n     * * adjusts the backoff timer based on the error\n     *\n     * A new stream can be opened by calling start().\n     *\n     * @param finalState - the intended state of the stream after closing.\n     * @param error - the error the connection was closed with.\n     */\n    async close(finalState, error) {\n        // Cancel any outstanding timers (they're guaranteed not to execute).\n        this.cancelIdleCheck();\n        this.cancelHealthCheck();\n        this.backoff.cancel();\n        // Invalidates any stream-related callbacks (e.g. from auth or the\n        // underlying stream), guaranteeing they won't execute.\n        this.closeCount++;\n        if (finalState !== 4 /* PersistentStreamState.Error */) {\n            // If this is an intentional close ensure we don't delay our next connection attempt.\n            this.backoff.reset();\n        }\n        else if (error && error.code === Code.RESOURCE_EXHAUSTED) {\n            // Log the error. (Probably either 'quota exceeded' or 'max queue length reached'.)\n            logError(error.toString());\n            logError('Using maximum backoff delay to prevent overloading the backend.');\n            this.backoff.resetToMax();\n        }\n        else if (error &&\n            error.code === Code.UNAUTHENTICATED &&\n            this.state !== 3 /* PersistentStreamState.Healthy */) {\n            // \"unauthenticated\" error means the token was rejected. This should rarely\n            // happen since both Auth and AppCheck ensure a sufficient TTL when we\n            // request a token. If a user manually resets their system clock this can\n            // fail, however. In this case, we should get a Code.UNAUTHENTICATED error\n            // before we received the first message and we need to invalidate the token\n            // to ensure that we fetch a new token.\n            this.authCredentialsProvider.invalidateToken();\n            this.appCheckCredentialsProvider.invalidateToken();\n        }\n        // Clean up the underlying stream because we are no longer interested in events.\n        if (this.stream !== null) {\n            this.tearDown();\n            this.stream.close();\n            this.stream = null;\n        }\n        // This state must be assigned before calling onClose() to allow the callback to\n        // inhibit backoff or otherwise manipulate the state in its non-started state.\n        this.state = finalState;\n        // Notify the listener that the stream closed.\n        await this.listener.onClose(error);\n    }\n    /**\n     * Can be overridden to perform additional cleanup before the stream is closed.\n     * Calling super.tearDown() is not required.\n     */\n    tearDown() { }\n    auth() {\n        this.state = 1 /* PersistentStreamState.Starting */;\n        const dispatchIfNotClosed = this.getCloseGuardedDispatcher(this.closeCount);\n        // TODO(mikelehen): Just use dispatchIfNotClosed, but see TODO below.\n        const closeCount = this.closeCount;\n        Promise.all([\n            this.authCredentialsProvider.getToken(),\n            this.appCheckCredentialsProvider.getToken()\n        ]).then(([authToken, appCheckToken]) => {\n            // Stream can be stopped while waiting for authentication.\n            // TODO(mikelehen): We really should just use dispatchIfNotClosed\n            // and let this dispatch onto the queue, but that opened a spec test can\n            // of worms that I don't want to deal with in this PR.\n            if (this.closeCount === closeCount) {\n                // Normally we'd have to schedule the callback on the AsyncQueue.\n                // However, the following calls are safe to be called outside the\n                // AsyncQueue since they don't chain asynchronous calls\n                this.startStream(authToken, appCheckToken);\n            }\n        }, (error) => {\n            dispatchIfNotClosed(() => {\n                const rpcError = new FirestoreError(Code.UNKNOWN, 'Fetching auth token failed: ' + error.message);\n                return this.handleStreamClose(rpcError);\n            });\n        });\n    }\n    startStream(authToken, appCheckToken) {\n        const dispatchIfNotClosed = this.getCloseGuardedDispatcher(this.closeCount);\n        this.stream = this.startRpc(authToken, appCheckToken);\n        this.stream.onConnected(() => {\n            dispatchIfNotClosed(() => this.listener.onConnected());\n        });\n        this.stream.onOpen(() => {\n            dispatchIfNotClosed(() => {\n                this.state = 2 /* PersistentStreamState.Open */;\n                this.healthCheck = this.queue.enqueueAfterDelay(this.healthTimerId, HEALTHY_TIMEOUT_MS, () => {\n                    if (this.isOpen()) {\n                        this.state = 3 /* PersistentStreamState.Healthy */;\n                    }\n                    return Promise.resolve();\n                });\n                return this.listener.onOpen();\n            });\n        });\n        this.stream.onClose((error) => {\n            dispatchIfNotClosed(() => {\n                return this.handleStreamClose(error);\n            });\n        });\n        this.stream.onMessage((msg) => {\n            dispatchIfNotClosed(() => {\n                if (++this.responseCount === 1) {\n                    return this.onFirst(msg);\n                }\n                else {\n                    return this.onNext(msg);\n                }\n            });\n        });\n    }\n    performBackoff() {\n        this.state = 5 /* PersistentStreamState.Backoff */;\n        this.backoff.backoffAndRun(async () => {\n            this.state = 0 /* PersistentStreamState.Initial */;\n            this.start();\n        });\n    }\n    // Visible for tests\n    handleStreamClose(error) {\n        logDebug(LOG_TAG$7, `close with error: ${error}`);\n        this.stream = null;\n        // In theory the stream could close cleanly, however, in our current model\n        // we never expect this to happen because if we stop a stream ourselves,\n        // this callback will never be called. To prevent cases where we retry\n        // without a backoff accidentally, we set the stream to error in all cases.\n        return this.close(4 /* PersistentStreamState.Error */, error);\n    }\n    /**\n     * Returns a \"dispatcher\" function that dispatches operations onto the\n     * AsyncQueue but only runs them if closeCount remains unchanged. This allows\n     * us to turn auth / stream callbacks into no-ops if the stream is closed /\n     * re-opened, etc.\n     */\n    getCloseGuardedDispatcher(startCloseCount) {\n        return (fn) => {\n            this.queue.enqueueAndForget(() => {\n                if (this.closeCount === startCloseCount) {\n                    return fn();\n                }\n                else {\n                    logDebug(LOG_TAG$7, 'stream callback skipped by getCloseGuardedDispatcher.');\n                    return Promise.resolve();\n                }\n            });\n        };\n    }\n}\n/**\n * A PersistentStream that implements the Listen RPC.\n *\n * Once the Listen stream has called the onOpen() listener, any number of\n * listen() and unlisten() calls can be made to control what changes will be\n * sent from the server for ListenResponses.\n */\nclass PersistentListenStream extends PersistentStream {\n    constructor(queue, connection, authCredentials, appCheckCredentials, serializer, listener) {\n        super(queue, \"listen_stream_connection_backoff\" /* TimerId.ListenStreamConnectionBackoff */, \"listen_stream_idle\" /* TimerId.ListenStreamIdle */, \"health_check_timeout\" /* TimerId.HealthCheckTimeout */, connection, authCredentials, appCheckCredentials, listener);\n        this.serializer = serializer;\n    }\n    startRpc(authToken, appCheckToken) {\n        return this.connection.openStream('Listen', authToken, appCheckToken);\n    }\n    onFirst(watchChangeProto) {\n        return this.onNext(watchChangeProto);\n    }\n    onNext(watchChangeProto) {\n        // A successful response means the stream is healthy\n        this.backoff.reset();\n        const watchChange = fromWatchChange(this.serializer, watchChangeProto);\n        const snapshot = versionFromListenResponse(watchChangeProto);\n        return this.listener.onWatchChange(watchChange, snapshot);\n    }\n    /**\n     * Registers interest in the results of the given target. If the target\n     * includes a resumeToken it will be included in the request. Results that\n     * affect the target will be streamed back as WatchChange messages that\n     * reference the targetId.\n     */\n    watch(targetData) {\n        const request = {};\n        request.database = getEncodedDatabaseId(this.serializer);\n        request.addTarget = toTarget(this.serializer, targetData);\n        const labels = toListenRequestLabels(this.serializer, targetData);\n        if (labels) {\n            request.labels = labels;\n        }\n        this.sendRequest(request);\n    }\n    /**\n     * Unregisters interest in the results of the target associated with the\n     * given targetId.\n     */\n    unwatch(targetId) {\n        const request = {};\n        request.database = getEncodedDatabaseId(this.serializer);\n        request.removeTarget = targetId;\n        this.sendRequest(request);\n    }\n}\n/**\n * A Stream that implements the Write RPC.\n *\n * The Write RPC requires the caller to maintain special streamToken\n * state in between calls, to help the server understand which responses the\n * client has processed by the time the next request is made. Every response\n * will contain a streamToken; this value must be passed to the next\n * request.\n *\n * After calling start() on this stream, the next request must be a handshake,\n * containing whatever streamToken is on hand. Once a response to this\n * request is received, all pending mutations may be submitted. When\n * submitting multiple batches of mutations at the same time, it's\n * okay to use the same streamToken for the calls to writeMutations.\n *\n * TODO(b/33271235): Use proto types\n */\nclass PersistentWriteStream extends PersistentStream {\n    constructor(queue, connection, authCredentials, appCheckCredentials, serializer, listener) {\n        super(queue, \"write_stream_connection_backoff\" /* TimerId.WriteStreamConnectionBackoff */, \"write_stream_idle\" /* TimerId.WriteStreamIdle */, \"health_check_timeout\" /* TimerId.HealthCheckTimeout */, connection, authCredentials, appCheckCredentials, listener);\n        this.serializer = serializer;\n    }\n    /**\n     * Tracks whether or not a handshake has been successfully exchanged and\n     * the stream is ready to accept mutations.\n     */\n    get handshakeComplete() {\n        return this.responseCount > 0;\n    }\n    // Override of PersistentStream.start\n    start() {\n        this.lastStreamToken = undefined;\n        super.start();\n    }\n    tearDown() {\n        if (this.handshakeComplete) {\n            this.writeMutations([]);\n        }\n    }\n    startRpc(authToken, appCheckToken) {\n        return this.connection.openStream('Write', authToken, appCheckToken);\n    }\n    onFirst(responseProto) {\n        // Always capture the last stream token.\n        hardAssert(!!responseProto.streamToken);\n        this.lastStreamToken = responseProto.streamToken;\n        // The first response is always the handshake response\n        hardAssert(!responseProto.writeResults || responseProto.writeResults.length === 0);\n        return this.listener.onHandshakeComplete();\n    }\n    onNext(responseProto) {\n        // Always capture the last stream token.\n        hardAssert(!!responseProto.streamToken);\n        this.lastStreamToken = responseProto.streamToken;\n        // A successful first write response means the stream is healthy,\n        // Note, that we could consider a successful handshake healthy, however,\n        // the write itself might be causing an error we want to back off from.\n        this.backoff.reset();\n        const results = fromWriteResults(responseProto.writeResults, responseProto.commitTime);\n        const commitVersion = fromVersion(responseProto.commitTime);\n        return this.listener.onMutationResult(commitVersion, results);\n    }\n    /**\n     * Sends an initial streamToken to the server, performing the handshake\n     * required to make the StreamingWrite RPC work. Subsequent\n     * calls should wait until onHandshakeComplete was called.\n     */\n    writeHandshake() {\n        // TODO(dimond): Support stream resumption. We intentionally do not set the\n        // stream token on the handshake, ignoring any stream token we might have.\n        const request = {};\n        request.database = getEncodedDatabaseId(this.serializer);\n        this.sendRequest(request);\n    }\n    /** Sends a group of mutations to the Firestore backend to apply. */\n    writeMutations(mutations) {\n        const request = {\n            streamToken: this.lastStreamToken,\n            writes: mutations.map(mutation => toMutation(this.serializer, mutation))\n        };\n        this.sendRequest(request);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Datastore and its related methods are a wrapper around the external Google\n * Cloud Datastore grpc API, which provides an interface that is more convenient\n * for the rest of the client SDK architecture to consume.\n */\nclass Datastore {\n}\n/**\n * An implementation of Datastore that exposes additional state for internal\n * consumption.\n */\nclass DatastoreImpl extends Datastore {\n    constructor(authCredentials, appCheckCredentials, connection, serializer) {\n        super();\n        this.authCredentials = authCredentials;\n        this.appCheckCredentials = appCheckCredentials;\n        this.connection = connection;\n        this.serializer = serializer;\n        this.terminated = false;\n    }\n    verifyInitialized() {\n        if (this.terminated) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'The client has already been terminated.');\n        }\n    }\n    /** Invokes the provided RPC with auth and AppCheck tokens. */\n    invokeRPC(rpcName, databaseId, resourcePath, request) {\n        this.verifyInitialized();\n        return Promise.all([\n            this.authCredentials.getToken(),\n            this.appCheckCredentials.getToken()\n        ])\n            .then(([authToken, appCheckToken]) => {\n            return this.connection.invokeRPC(rpcName, toResourcePath(databaseId, resourcePath), request, authToken, appCheckToken);\n        })\n            .catch((error) => {\n            if (error.name === 'FirebaseError') {\n                if (error.code === Code.UNAUTHENTICATED) {\n                    this.authCredentials.invalidateToken();\n                    this.appCheckCredentials.invalidateToken();\n                }\n                throw error;\n            }\n            else {\n                throw new FirestoreError(Code.UNKNOWN, error.toString());\n            }\n        });\n    }\n    /** Invokes the provided RPC with streamed results with auth and AppCheck tokens. */\n    invokeStreamingRPC(rpcName, databaseId, resourcePath, request, expectedResponseCount) {\n        this.verifyInitialized();\n        return Promise.all([\n            this.authCredentials.getToken(),\n            this.appCheckCredentials.getToken()\n        ])\n            .then(([authToken, appCheckToken]) => {\n            return this.connection.invokeStreamingRPC(rpcName, toResourcePath(databaseId, resourcePath), request, authToken, appCheckToken, expectedResponseCount);\n        })\n            .catch((error) => {\n            if (error.name === 'FirebaseError') {\n                if (error.code === Code.UNAUTHENTICATED) {\n                    this.authCredentials.invalidateToken();\n                    this.appCheckCredentials.invalidateToken();\n                }\n                throw error;\n            }\n            else {\n                throw new FirestoreError(Code.UNKNOWN, error.toString());\n            }\n        });\n    }\n    terminate() {\n        this.terminated = true;\n        this.connection.terminate();\n    }\n}\n// TODO(firestorexp): Make sure there is only one Datastore instance per\n// firestore-exp client.\nfunction newDatastore(authCredentials, appCheckCredentials, connection, serializer) {\n    return new DatastoreImpl(authCredentials, appCheckCredentials, connection, serializer);\n}\nasync function invokeCommitRpc(datastore, mutations) {\n    const datastoreImpl = debugCast(datastore);\n    const request = {\n        writes: mutations.map(m => toMutation(datastoreImpl.serializer, m))\n    };\n    await datastoreImpl.invokeRPC('Commit', datastoreImpl.serializer.databaseId, ResourcePath.emptyPath(), request);\n}\nasync function invokeBatchGetDocumentsRpc(datastore, keys) {\n    const datastoreImpl = debugCast(datastore);\n    const request = {\n        documents: keys.map(k => toName(datastoreImpl.serializer, k))\n    };\n    const response = await datastoreImpl.invokeStreamingRPC('BatchGetDocuments', datastoreImpl.serializer.databaseId, ResourcePath.emptyPath(), request, keys.length);\n    const docs = new Map();\n    response.forEach(proto => {\n        const doc = fromBatchGetDocumentsResponse(datastoreImpl.serializer, proto);\n        docs.set(doc.key.toString(), doc);\n    });\n    const result = [];\n    keys.forEach(key => {\n        const doc = docs.get(key.toString());\n        hardAssert(!!doc);\n        result.push(doc);\n    });\n    return result;\n}\nasync function invokeRunAggregationQueryRpc(datastore, query, aggregates) {\n    var _a;\n    const datastoreImpl = debugCast(datastore);\n    const { request, aliasMap, parent } = toRunAggregationQueryRequest(datastoreImpl.serializer, queryToAggregateTarget(query), aggregates);\n    if (!datastoreImpl.connection.shouldResourcePathBeIncludedInRequest) {\n        delete request.parent;\n    }\n    const response = await datastoreImpl.invokeStreamingRPC('RunAggregationQuery', datastoreImpl.serializer.databaseId, parent, request, \n    /*expectedResponseCount=*/ 1);\n    // Omit RunAggregationQueryResponse that only contain readTimes.\n    const filteredResult = response.filter(proto => !!proto.result);\n    hardAssert(filteredResult.length === 1);\n    // Remap the short-form aliases that were sent to the server\n    // to the client-side aliases. Users will access the results\n    // using the client-side alias.\n    const unmappedAggregateFields = (_a = filteredResult[0].result) === null || _a === void 0 ? void 0 : _a.aggregateFields;\n    const remappedFields = Object.keys(unmappedAggregateFields).reduce((accumulator, key) => {\n        accumulator[aliasMap[key]] = unmappedAggregateFields[key];\n        return accumulator;\n    }, {});\n    return remappedFields;\n}\nfunction newPersistentWriteStream(datastore, queue, listener) {\n    const datastoreImpl = debugCast(datastore);\n    datastoreImpl.verifyInitialized();\n    return new PersistentWriteStream(queue, datastoreImpl.connection, datastoreImpl.authCredentials, datastoreImpl.appCheckCredentials, datastoreImpl.serializer, listener);\n}\nfunction newPersistentWatchStream(datastore, queue, listener) {\n    const datastoreImpl = debugCast(datastore);\n    datastoreImpl.verifyInitialized();\n    return new PersistentListenStream(queue, datastoreImpl.connection, datastoreImpl.authCredentials, datastoreImpl.appCheckCredentials, datastoreImpl.serializer, listener);\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$6 = 'OnlineStateTracker';\n// To deal with transient failures, we allow multiple stream attempts before\n// giving up and transitioning from OnlineState.Unknown to Offline.\n// TODO(mikelehen): This used to be set to 2 as a mitigation for b/66228394.\n// @jdimond thinks that bug is sufficiently fixed so that we can set this back\n// to 1. If that works okay, we could potentially remove this logic entirely.\nconst MAX_WATCH_STREAM_FAILURES = 1;\n// To deal with stream attempts that don't succeed or fail in a timely manner,\n// we have a timeout for OnlineState to reach Online or Offline.\n// If the timeout is reached, we transition to Offline rather than waiting\n// indefinitely.\nconst ONLINE_STATE_TIMEOUT_MS = 10 * 1000;\n/**\n * A component used by the RemoteStore to track the OnlineState (that is,\n * whether or not the client as a whole should be considered to be online or\n * offline), implementing the appropriate heuristics.\n *\n * In particular, when the client is trying to connect to the backend, we\n * allow up to MAX_WATCH_STREAM_FAILURES within ONLINE_STATE_TIMEOUT_MS for\n * a connection to succeed. If we have too many failures or the timeout elapses,\n * then we set the OnlineState to Offline, and the client will behave as if\n * it is offline (get()s will return cached data, etc.).\n */\nclass OnlineStateTracker {\n    constructor(asyncQueue, onlineStateHandler) {\n        this.asyncQueue = asyncQueue;\n        this.onlineStateHandler = onlineStateHandler;\n        /** The current OnlineState. */\n        this.state = \"Unknown\" /* OnlineState.Unknown */;\n        /**\n         * A count of consecutive failures to open the stream. If it reaches the\n         * maximum defined by MAX_WATCH_STREAM_FAILURES, we'll set the OnlineState to\n         * Offline.\n         */\n        this.watchStreamFailures = 0;\n        /**\n         * A timer that elapses after ONLINE_STATE_TIMEOUT_MS, at which point we\n         * transition from OnlineState.Unknown to OnlineState.Offline without waiting\n         * for the stream to actually fail (MAX_WATCH_STREAM_FAILURES times).\n         */\n        this.onlineStateTimer = null;\n        /**\n         * Whether the client should log a warning message if it fails to connect to\n         * the backend (initially true, cleared after a successful stream, or if we've\n         * logged the message already).\n         */\n        this.shouldWarnClientIsOffline = true;\n    }\n    /**\n     * Called by RemoteStore when a watch stream is started (including on each\n     * backoff attempt).\n     *\n     * If this is the first attempt, it sets the OnlineState to Unknown and starts\n     * the onlineStateTimer.\n     */\n    handleWatchStreamStart() {\n        if (this.watchStreamFailures === 0) {\n            this.setAndBroadcast(\"Unknown\" /* OnlineState.Unknown */);\n            this.onlineStateTimer = this.asyncQueue.enqueueAfterDelay(\"online_state_timeout\" /* TimerId.OnlineStateTimeout */, ONLINE_STATE_TIMEOUT_MS, () => {\n                this.onlineStateTimer = null;\n                this.logClientOfflineWarningIfNecessary(`Backend didn't respond within ${ONLINE_STATE_TIMEOUT_MS / 1000} ` +\n                    `seconds.`);\n                this.setAndBroadcast(\"Offline\" /* OnlineState.Offline */);\n                // NOTE: handleWatchStreamFailure() will continue to increment\n                // watchStreamFailures even though we are already marked Offline,\n                // but this is non-harmful.\n                return Promise.resolve();\n            });\n        }\n    }\n    /**\n     * Updates our OnlineState as appropriate after the watch stream reports a\n     * failure. The first failure moves us to the 'Unknown' state. We then may\n     * allow multiple failures (based on MAX_WATCH_STREAM_FAILURES) before we\n     * actually transition to the 'Offline' state.\n     */\n    handleWatchStreamFailure(error) {\n        if (this.state === \"Online\" /* OnlineState.Online */) {\n            this.setAndBroadcast(\"Unknown\" /* OnlineState.Unknown */);\n        }\n        else {\n            this.watchStreamFailures++;\n            if (this.watchStreamFailures >= MAX_WATCH_STREAM_FAILURES) {\n                this.clearOnlineStateTimer();\n                this.logClientOfflineWarningIfNecessary(`Connection failed ${MAX_WATCH_STREAM_FAILURES} ` +\n                    `times. Most recent error: ${error.toString()}`);\n                this.setAndBroadcast(\"Offline\" /* OnlineState.Offline */);\n            }\n        }\n    }\n    /**\n     * Explicitly sets the OnlineState to the specified state.\n     *\n     * Note that this resets our timers / failure counters, etc. used by our\n     * Offline heuristics, so must not be used in place of\n     * handleWatchStreamStart() and handleWatchStreamFailure().\n     */\n    set(newState) {\n        this.clearOnlineStateTimer();\n        this.watchStreamFailures = 0;\n        if (newState === \"Online\" /* OnlineState.Online */) {\n            // We've connected to watch at least once. Don't warn the developer\n            // about being offline going forward.\n            this.shouldWarnClientIsOffline = false;\n        }\n        this.setAndBroadcast(newState);\n    }\n    setAndBroadcast(newState) {\n        if (newState !== this.state) {\n            this.state = newState;\n            this.onlineStateHandler(newState);\n        }\n    }\n    logClientOfflineWarningIfNecessary(details) {\n        const message = `Could not reach Cloud Firestore backend. ${details}\\n` +\n            `This typically indicates that your device does not have a healthy ` +\n            `Internet connection at the moment. The client will operate in offline ` +\n            `mode until it is able to successfully connect to the backend.`;\n        if (this.shouldWarnClientIsOffline) {\n            logError(message);\n            this.shouldWarnClientIsOffline = false;\n        }\n        else {\n            logDebug(LOG_TAG$6, message);\n        }\n    }\n    clearOnlineStateTimer() {\n        if (this.onlineStateTimer !== null) {\n            this.onlineStateTimer.cancel();\n            this.onlineStateTimer = null;\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$5 = 'RemoteStore';\n// TODO(b/35853402): Negotiate this with the stream.\nconst MAX_PENDING_WRITES = 10;\nclass RemoteStoreImpl {\n    constructor(\n    /**\n     * The local store, used to fill the write pipeline with outbound mutations.\n     */\n    localStore, \n    /** The client-side proxy for interacting with the backend. */\n    datastore, asyncQueue, onlineStateHandler, connectivityMonitor) {\n        this.localStore = localStore;\n        this.datastore = datastore;\n        this.asyncQueue = asyncQueue;\n        this.remoteSyncer = {};\n        /**\n         * A list of up to MAX_PENDING_WRITES writes that we have fetched from the\n         * LocalStore via fillWritePipeline() and have or will send to the write\n         * stream.\n         *\n         * Whenever writePipeline.length > 0 the RemoteStore will attempt to start or\n         * restart the write stream. When the stream is established the writes in the\n         * pipeline will be sent in order.\n         *\n         * Writes remain in writePipeline until they are acknowledged by the backend\n         * and thus will automatically be re-sent if the stream is interrupted /\n         * restarted before they're acknowledged.\n         *\n         * Write responses from the backend are linked to their originating request\n         * purely based on order, and so we can just shift() writes from the front of\n         * the writePipeline as we receive responses.\n         */\n        this.writePipeline = [];\n        /**\n         * A mapping of watched targets that the client cares about tracking and the\n         * user has explicitly called a 'listen' for this target.\n         *\n         * These targets may or may not have been sent to or acknowledged by the\n         * server. On re-establishing the listen stream, these targets should be sent\n         * to the server. The targets removed with unlistens are removed eagerly\n         * without waiting for confirmation from the listen stream.\n         */\n        this.listenTargets = new Map();\n        /**\n         * A set of reasons for why the RemoteStore may be offline. If empty, the\n         * RemoteStore may start its network connections.\n         */\n        this.offlineCauses = new Set();\n        /**\n         * Event handlers that get called when the network is disabled or enabled.\n         *\n         * PORTING NOTE: These functions are used on the Web client to create the\n         * underlying streams (to support tree-shakeable streams). On Android and iOS,\n         * the streams are created during construction of RemoteStore.\n         */\n        this.onNetworkStatusChange = [];\n        this.connectivityMonitor = connectivityMonitor;\n        this.connectivityMonitor.addCallback((_) => {\n            asyncQueue.enqueueAndForget(async () => {\n                // Porting Note: Unlike iOS, `restartNetwork()` is called even when the\n                // network becomes unreachable as we don't have any other way to tear\n                // down our streams.\n                if (canUseNetwork(this)) {\n                    logDebug(LOG_TAG$5, 'Restarting streams for network reachability change.');\n                    await restartNetwork(this);\n                }\n            });\n        });\n        this.onlineStateTracker = new OnlineStateTracker(asyncQueue, onlineStateHandler);\n    }\n}\nfunction newRemoteStore(localStore, datastore, asyncQueue, onlineStateHandler, connectivityMonitor) {\n    return new RemoteStoreImpl(localStore, datastore, asyncQueue, onlineStateHandler, connectivityMonitor);\n}\n/** Re-enables the network. Idempotent. */\nfunction remoteStoreEnableNetwork(remoteStore) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    remoteStoreImpl.offlineCauses.delete(0 /* OfflineCause.UserDisabled */);\n    return enableNetworkInternal(remoteStoreImpl);\n}\nasync function enableNetworkInternal(remoteStoreImpl) {\n    if (canUseNetwork(remoteStoreImpl)) {\n        for (const networkStatusHandler of remoteStoreImpl.onNetworkStatusChange) {\n            await networkStatusHandler(/* enabled= */ true);\n        }\n    }\n}\n/**\n * Temporarily disables the network. The network can be re-enabled using\n * enableNetwork().\n */\nasync function remoteStoreDisableNetwork(remoteStore) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    remoteStoreImpl.offlineCauses.add(0 /* OfflineCause.UserDisabled */);\n    await disableNetworkInternal(remoteStoreImpl);\n    // Set the OnlineState to Offline so get()s return from cache, etc.\n    remoteStoreImpl.onlineStateTracker.set(\"Offline\" /* OnlineState.Offline */);\n}\nasync function disableNetworkInternal(remoteStoreImpl) {\n    for (const networkStatusHandler of remoteStoreImpl.onNetworkStatusChange) {\n        await networkStatusHandler(/* enabled= */ false);\n    }\n}\nasync function remoteStoreShutdown(remoteStore) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    logDebug(LOG_TAG$5, 'RemoteStore shutting down.');\n    remoteStoreImpl.offlineCauses.add(5 /* OfflineCause.Shutdown */);\n    await disableNetworkInternal(remoteStoreImpl);\n    remoteStoreImpl.connectivityMonitor.shutdown();\n    // Set the OnlineState to Unknown (rather than Offline) to avoid potentially\n    // triggering spurious listener events with cached data, etc.\n    remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\n}\n/**\n * Starts new listen for the given target. Uses resume token if provided. It\n * is a no-op if the target of given `TargetData` is already being listened to.\n */\nfunction remoteStoreListen(remoteStore, targetData) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    if (remoteStoreImpl.listenTargets.has(targetData.targetId)) {\n        return;\n    }\n    // Mark this as something the client is currently listening for.\n    remoteStoreImpl.listenTargets.set(targetData.targetId, targetData);\n    if (shouldStartWatchStream(remoteStoreImpl)) {\n        // The listen will be sent in onWatchStreamOpen\n        startWatchStream(remoteStoreImpl);\n    }\n    else if (ensureWatchStream(remoteStoreImpl).isOpen()) {\n        sendWatchRequest(remoteStoreImpl, targetData);\n    }\n}\n/**\n * Removes the listen from server. It is a no-op if the given target id is\n * not being listened to.\n */\nfunction remoteStoreUnlisten(remoteStore, targetId) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    const watchStream = ensureWatchStream(remoteStoreImpl);\n    remoteStoreImpl.listenTargets.delete(targetId);\n    if (watchStream.isOpen()) {\n        sendUnwatchRequest(remoteStoreImpl, targetId);\n    }\n    if (remoteStoreImpl.listenTargets.size === 0) {\n        if (watchStream.isOpen()) {\n            watchStream.markIdle();\n        }\n        else if (canUseNetwork(remoteStoreImpl)) {\n            // Revert to OnlineState.Unknown if the watch stream is not open and we\n            // have no listeners, since without any listens to send we cannot\n            // confirm if the stream is healthy and upgrade to OnlineState.Online.\n            remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\n        }\n    }\n}\n/**\n * We need to increment the expected number of pending responses we're due\n * from watch so we wait for the ack to process any messages from this target.\n */\nfunction sendWatchRequest(remoteStoreImpl, targetData) {\n    remoteStoreImpl.watchChangeAggregator.recordPendingTargetRequest(targetData.targetId);\n    if (targetData.resumeToken.approximateByteSize() > 0 ||\n        targetData.snapshotVersion.compareTo(SnapshotVersion.min()) > 0) {\n        const expectedCount = remoteStoreImpl.remoteSyncer.getRemoteKeysForTarget(targetData.targetId).size;\n        targetData = targetData.withExpectedCount(expectedCount);\n    }\n    ensureWatchStream(remoteStoreImpl).watch(targetData);\n}\n/**\n * We need to increment the expected number of pending responses we're due\n * from watch so we wait for the removal on the server before we process any\n * messages from this target.\n */\nfunction sendUnwatchRequest(remoteStoreImpl, targetId) {\n    remoteStoreImpl.watchChangeAggregator.recordPendingTargetRequest(targetId);\n    ensureWatchStream(remoteStoreImpl).unwatch(targetId);\n}\nfunction startWatchStream(remoteStoreImpl) {\n    remoteStoreImpl.watchChangeAggregator = new WatchChangeAggregator({\n        getRemoteKeysForTarget: targetId => remoteStoreImpl.remoteSyncer.getRemoteKeysForTarget(targetId),\n        getTargetDataForTarget: targetId => remoteStoreImpl.listenTargets.get(targetId) || null,\n        getDatabaseId: () => remoteStoreImpl.datastore.serializer.databaseId\n    });\n    ensureWatchStream(remoteStoreImpl).start();\n    remoteStoreImpl.onlineStateTracker.handleWatchStreamStart();\n}\n/**\n * Returns whether the watch stream should be started because it's necessary\n * and has not yet been started.\n */\nfunction shouldStartWatchStream(remoteStoreImpl) {\n    return (canUseNetwork(remoteStoreImpl) &&\n        !ensureWatchStream(remoteStoreImpl).isStarted() &&\n        remoteStoreImpl.listenTargets.size > 0);\n}\nfunction canUseNetwork(remoteStore) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    return remoteStoreImpl.offlineCauses.size === 0;\n}\nfunction cleanUpWatchStreamState(remoteStoreImpl) {\n    remoteStoreImpl.watchChangeAggregator = undefined;\n}\nasync function onWatchStreamConnected(remoteStoreImpl) {\n    // Mark the client as online since we got a \"connected\" notification.\n    remoteStoreImpl.onlineStateTracker.set(\"Online\" /* OnlineState.Online */);\n}\nasync function onWatchStreamOpen(remoteStoreImpl) {\n    remoteStoreImpl.listenTargets.forEach((targetData, targetId) => {\n        sendWatchRequest(remoteStoreImpl, targetData);\n    });\n}\nasync function onWatchStreamClose(remoteStoreImpl, error) {\n    cleanUpWatchStreamState(remoteStoreImpl);\n    // If we still need the watch stream, retry the connection.\n    if (shouldStartWatchStream(remoteStoreImpl)) {\n        remoteStoreImpl.onlineStateTracker.handleWatchStreamFailure(error);\n        startWatchStream(remoteStoreImpl);\n    }\n    else {\n        // No need to restart watch stream because there are no active targets.\n        // The online state is set to unknown because there is no active attempt\n        // at establishing a connection\n        remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\n    }\n}\nasync function onWatchStreamChange(remoteStoreImpl, watchChange, snapshotVersion) {\n    // Mark the client as online since we got a message from the server\n    remoteStoreImpl.onlineStateTracker.set(\"Online\" /* OnlineState.Online */);\n    if (watchChange instanceof WatchTargetChange &&\n        watchChange.state === 2 /* WatchTargetChangeState.Removed */ &&\n        watchChange.cause) {\n        // There was an error on a target, don't wait for a consistent snapshot\n        // to raise events\n        try {\n            await handleTargetError(remoteStoreImpl, watchChange);\n        }\n        catch (e) {\n            logDebug(LOG_TAG$5, 'Failed to remove targets %s: %s ', watchChange.targetIds.join(','), e);\n            await disableNetworkUntilRecovery(remoteStoreImpl, e);\n        }\n        return;\n    }\n    if (watchChange instanceof DocumentWatchChange) {\n        remoteStoreImpl.watchChangeAggregator.handleDocumentChange(watchChange);\n    }\n    else if (watchChange instanceof ExistenceFilterChange) {\n        remoteStoreImpl.watchChangeAggregator.handleExistenceFilter(watchChange);\n    }\n    else {\n        remoteStoreImpl.watchChangeAggregator.handleTargetChange(watchChange);\n    }\n    if (!snapshotVersion.isEqual(SnapshotVersion.min())) {\n        try {\n            const lastRemoteSnapshotVersion = await localStoreGetLastRemoteSnapshotVersion(remoteStoreImpl.localStore);\n            if (snapshotVersion.compareTo(lastRemoteSnapshotVersion) >= 0) {\n                // We have received a target change with a global snapshot if the snapshot\n                // version is not equal to SnapshotVersion.min().\n                await raiseWatchSnapshot(remoteStoreImpl, snapshotVersion);\n            }\n        }\n        catch (e) {\n            logDebug(LOG_TAG$5, 'Failed to raise snapshot:', e);\n            await disableNetworkUntilRecovery(remoteStoreImpl, e);\n        }\n    }\n}\n/**\n * Recovery logic for IndexedDB errors that takes the network offline until\n * `op` succeeds. Retries are scheduled with backoff using\n * `enqueueRetryable()`. If `op()` is not provided, IndexedDB access is\n * validated via a generic operation.\n *\n * The returned Promise is resolved once the network is disabled and before\n * any retry attempt.\n */\nasync function disableNetworkUntilRecovery(remoteStoreImpl, e, op) {\n    if (isIndexedDbTransactionError(e)) {\n        remoteStoreImpl.offlineCauses.add(1 /* OfflineCause.IndexedDbFailed */);\n        // Disable network and raise offline snapshots\n        await disableNetworkInternal(remoteStoreImpl);\n        remoteStoreImpl.onlineStateTracker.set(\"Offline\" /* OnlineState.Offline */);\n        if (!op) {\n            // Use a simple read operation to determine if IndexedDB recovered.\n            // Ideally, we would expose a health check directly on SimpleDb, but\n            // RemoteStore only has access to persistence through LocalStore.\n            op = () => localStoreGetLastRemoteSnapshotVersion(remoteStoreImpl.localStore);\n        }\n        // Probe IndexedDB periodically and re-enable network\n        remoteStoreImpl.asyncQueue.enqueueRetryable(async () => {\n            logDebug(LOG_TAG$5, 'Retrying IndexedDB access');\n            await op();\n            remoteStoreImpl.offlineCauses.delete(1 /* OfflineCause.IndexedDbFailed */);\n            await enableNetworkInternal(remoteStoreImpl);\n        });\n    }\n    else {\n        throw e;\n    }\n}\n/**\n * Executes `op`. If `op` fails, takes the network offline until `op`\n * succeeds. Returns after the first attempt.\n */\nfunction executeWithRecovery(remoteStoreImpl, op) {\n    return op().catch(e => disableNetworkUntilRecovery(remoteStoreImpl, e, op));\n}\n/**\n * Takes a batch of changes from the Datastore, repackages them as a\n * RemoteEvent, and passes that on to the listener, which is typically the\n * SyncEngine.\n */\nfunction raiseWatchSnapshot(remoteStoreImpl, snapshotVersion) {\n    const remoteEvent = remoteStoreImpl.watchChangeAggregator.createRemoteEvent(snapshotVersion);\n    // Update in-memory resume tokens. LocalStore will update the\n    // persistent view of these when applying the completed RemoteEvent.\n    remoteEvent.targetChanges.forEach((change, targetId) => {\n        if (change.resumeToken.approximateByteSize() > 0) {\n            const targetData = remoteStoreImpl.listenTargets.get(targetId);\n            // A watched target might have been removed already.\n            if (targetData) {\n                remoteStoreImpl.listenTargets.set(targetId, targetData.withResumeToken(change.resumeToken, snapshotVersion));\n            }\n        }\n    });\n    // Re-establish listens for the targets that have been invalidated by\n    // existence filter mismatches.\n    remoteEvent.targetMismatches.forEach((targetId, targetPurpose) => {\n        const targetData = remoteStoreImpl.listenTargets.get(targetId);\n        if (!targetData) {\n            // A watched target might have been removed already.\n            return;\n        }\n        // Clear the resume token for the target, since we're in a known mismatch\n        // state.\n        remoteStoreImpl.listenTargets.set(targetId, targetData.withResumeToken(ByteString.EMPTY_BYTE_STRING, targetData.snapshotVersion));\n        // Cause a hard reset by unwatching and rewatching immediately, but\n        // deliberately don't send a resume token so that we get a full update.\n        sendUnwatchRequest(remoteStoreImpl, targetId);\n        // Mark the target we send as being on behalf of an existence filter\n        // mismatch, but don't actually retain that in listenTargets. This ensures\n        // that we flag the first re-listen this way without impacting future\n        // listens of this target (that might happen e.g. on reconnect).\n        const requestTargetData = new TargetData(targetData.target, targetId, targetPurpose, targetData.sequenceNumber);\n        sendWatchRequest(remoteStoreImpl, requestTargetData);\n    });\n    return remoteStoreImpl.remoteSyncer.applyRemoteEvent(remoteEvent);\n}\n/** Handles an error on a target */\nasync function handleTargetError(remoteStoreImpl, watchChange) {\n    const error = watchChange.cause;\n    for (const targetId of watchChange.targetIds) {\n        // A watched target might have been removed already.\n        if (remoteStoreImpl.listenTargets.has(targetId)) {\n            await remoteStoreImpl.remoteSyncer.rejectListen(targetId, error);\n            remoteStoreImpl.listenTargets.delete(targetId);\n            remoteStoreImpl.watchChangeAggregator.removeTarget(targetId);\n        }\n    }\n}\n/**\n * Attempts to fill our write pipeline with writes from the LocalStore.\n *\n * Called internally to bootstrap or refill the write pipeline and by\n * SyncEngine whenever there are new mutations to process.\n *\n * Starts the write stream if necessary.\n */\nasync function fillWritePipeline(remoteStore) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    const writeStream = ensureWriteStream(remoteStoreImpl);\n    let lastBatchIdRetrieved = remoteStoreImpl.writePipeline.length > 0\n        ? remoteStoreImpl.writePipeline[remoteStoreImpl.writePipeline.length - 1]\n            .batchId\n        : BATCHID_UNKNOWN;\n    while (canAddToWritePipeline(remoteStoreImpl)) {\n        try {\n            const batch = await localStoreGetNextMutationBatch(remoteStoreImpl.localStore, lastBatchIdRetrieved);\n            if (batch === null) {\n                if (remoteStoreImpl.writePipeline.length === 0) {\n                    writeStream.markIdle();\n                }\n                break;\n            }\n            else {\n                lastBatchIdRetrieved = batch.batchId;\n                addToWritePipeline(remoteStoreImpl, batch);\n            }\n        }\n        catch (e) {\n            await disableNetworkUntilRecovery(remoteStoreImpl, e);\n        }\n    }\n    if (shouldStartWriteStream(remoteStoreImpl)) {\n        startWriteStream(remoteStoreImpl);\n    }\n}\n/**\n * Returns true if we can add to the write pipeline (i.e. the network is\n * enabled and the write pipeline is not full).\n */\nfunction canAddToWritePipeline(remoteStoreImpl) {\n    return (canUseNetwork(remoteStoreImpl) &&\n        remoteStoreImpl.writePipeline.length < MAX_PENDING_WRITES);\n}\n/**\n * Queues additional writes to be sent to the write stream, sending them\n * immediately if the write stream is established.\n */\nfunction addToWritePipeline(remoteStoreImpl, batch) {\n    remoteStoreImpl.writePipeline.push(batch);\n    const writeStream = ensureWriteStream(remoteStoreImpl);\n    if (writeStream.isOpen() && writeStream.handshakeComplete) {\n        writeStream.writeMutations(batch.mutations);\n    }\n}\nfunction shouldStartWriteStream(remoteStoreImpl) {\n    return (canUseNetwork(remoteStoreImpl) &&\n        !ensureWriteStream(remoteStoreImpl).isStarted() &&\n        remoteStoreImpl.writePipeline.length > 0);\n}\nfunction startWriteStream(remoteStoreImpl) {\n    ensureWriteStream(remoteStoreImpl).start();\n}\nasync function onWriteStreamOpen(remoteStoreImpl) {\n    ensureWriteStream(remoteStoreImpl).writeHandshake();\n}\nasync function onWriteHandshakeComplete(remoteStoreImpl) {\n    const writeStream = ensureWriteStream(remoteStoreImpl);\n    // Send the write pipeline now that the stream is established.\n    for (const batch of remoteStoreImpl.writePipeline) {\n        writeStream.writeMutations(batch.mutations);\n    }\n}\nasync function onMutationResult(remoteStoreImpl, commitVersion, results) {\n    const batch = remoteStoreImpl.writePipeline.shift();\n    const success = MutationBatchResult.from(batch, commitVersion, results);\n    await executeWithRecovery(remoteStoreImpl, () => remoteStoreImpl.remoteSyncer.applySuccessfulWrite(success));\n    // It's possible that with the completion of this mutation another\n    // slot has freed up.\n    await fillWritePipeline(remoteStoreImpl);\n}\nasync function onWriteStreamClose(remoteStoreImpl, error) {\n    // If the write stream closed after the write handshake completes, a write\n    // operation failed and we fail the pending operation.\n    if (error && ensureWriteStream(remoteStoreImpl).handshakeComplete) {\n        // This error affects the actual write.\n        await handleWriteError(remoteStoreImpl, error);\n    }\n    // The write stream might have been started by refilling the write\n    // pipeline for failed writes\n    if (shouldStartWriteStream(remoteStoreImpl)) {\n        startWriteStream(remoteStoreImpl);\n    }\n}\nasync function handleWriteError(remoteStoreImpl, error) {\n    // Only handle permanent errors here. If it's transient, just let the retry\n    // logic kick in.\n    if (isPermanentWriteError(error.code)) {\n        // This was a permanent error, the request itself was the problem\n        // so it's not going to succeed if we resend it.\n        const batch = remoteStoreImpl.writePipeline.shift();\n        // In this case it's also unlikely that the server itself is melting\n        // down -- this was just a bad request so inhibit backoff on the next\n        // restart.\n        ensureWriteStream(remoteStoreImpl).inhibitBackoff();\n        await executeWithRecovery(remoteStoreImpl, () => remoteStoreImpl.remoteSyncer.rejectFailedWrite(batch.batchId, error));\n        // It's possible that with the completion of this mutation\n        // another slot has freed up.\n        await fillWritePipeline(remoteStoreImpl);\n    }\n}\nasync function restartNetwork(remoteStore) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    remoteStoreImpl.offlineCauses.add(4 /* OfflineCause.ConnectivityChange */);\n    await disableNetworkInternal(remoteStoreImpl);\n    remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\n    remoteStoreImpl.offlineCauses.delete(4 /* OfflineCause.ConnectivityChange */);\n    await enableNetworkInternal(remoteStoreImpl);\n}\nasync function remoteStoreHandleCredentialChange(remoteStore, user) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    remoteStoreImpl.asyncQueue.verifyOperationInProgress();\n    logDebug(LOG_TAG$5, 'RemoteStore received new credentials');\n    const usesNetwork = canUseNetwork(remoteStoreImpl);\n    // Tear down and re-create our network streams. This will ensure we get a\n    // fresh auth token for the new user and re-fill the write pipeline with\n    // new mutations from the LocalStore (since mutations are per-user).\n    remoteStoreImpl.offlineCauses.add(3 /* OfflineCause.CredentialChange */);\n    await disableNetworkInternal(remoteStoreImpl);\n    if (usesNetwork) {\n        // Don't set the network status to Unknown if we are offline.\n        remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\n    }\n    await remoteStoreImpl.remoteSyncer.handleCredentialChange(user);\n    remoteStoreImpl.offlineCauses.delete(3 /* OfflineCause.CredentialChange */);\n    await enableNetworkInternal(remoteStoreImpl);\n}\n/**\n * Toggles the network state when the client gains or loses its primary lease.\n */\nasync function remoteStoreApplyPrimaryState(remoteStore, isPrimary) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    if (isPrimary) {\n        remoteStoreImpl.offlineCauses.delete(2 /* OfflineCause.IsSecondary */);\n        await enableNetworkInternal(remoteStoreImpl);\n    }\n    else if (!isPrimary) {\n        remoteStoreImpl.offlineCauses.add(2 /* OfflineCause.IsSecondary */);\n        await disableNetworkInternal(remoteStoreImpl);\n        remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\n    }\n}\n/**\n * If not yet initialized, registers the WatchStream and its network state\n * callback with `remoteStoreImpl`. Returns the existing stream if one is\n * already available.\n *\n * PORTING NOTE: On iOS and Android, the WatchStream gets registered on startup.\n * This is not done on Web to allow it to be tree-shaken.\n */\nfunction ensureWatchStream(remoteStoreImpl) {\n    if (!remoteStoreImpl.watchStream) {\n        // Create stream (but note that it is not started yet).\n        remoteStoreImpl.watchStream = newPersistentWatchStream(remoteStoreImpl.datastore, remoteStoreImpl.asyncQueue, {\n            onConnected: onWatchStreamConnected.bind(null, remoteStoreImpl),\n            onOpen: onWatchStreamOpen.bind(null, remoteStoreImpl),\n            onClose: onWatchStreamClose.bind(null, remoteStoreImpl),\n            onWatchChange: onWatchStreamChange.bind(null, remoteStoreImpl)\n        });\n        remoteStoreImpl.onNetworkStatusChange.push(async (enabled) => {\n            if (enabled) {\n                remoteStoreImpl.watchStream.inhibitBackoff();\n                if (shouldStartWatchStream(remoteStoreImpl)) {\n                    startWatchStream(remoteStoreImpl);\n                }\n                else {\n                    remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\n                }\n            }\n            else {\n                await remoteStoreImpl.watchStream.stop();\n                cleanUpWatchStreamState(remoteStoreImpl);\n            }\n        });\n    }\n    return remoteStoreImpl.watchStream;\n}\n/**\n * If not yet initialized, registers the WriteStream and its network state\n * callback with `remoteStoreImpl`. Returns the existing stream if one is\n * already available.\n *\n * PORTING NOTE: On iOS and Android, the WriteStream gets registered on startup.\n * This is not done on Web to allow it to be tree-shaken.\n */\nfunction ensureWriteStream(remoteStoreImpl) {\n    if (!remoteStoreImpl.writeStream) {\n        // Create stream (but note that it is not started yet).\n        remoteStoreImpl.writeStream = newPersistentWriteStream(remoteStoreImpl.datastore, remoteStoreImpl.asyncQueue, {\n            onConnected: () => Promise.resolve(),\n            onOpen: onWriteStreamOpen.bind(null, remoteStoreImpl),\n            onClose: onWriteStreamClose.bind(null, remoteStoreImpl),\n            onHandshakeComplete: onWriteHandshakeComplete.bind(null, remoteStoreImpl),\n            onMutationResult: onMutationResult.bind(null, remoteStoreImpl)\n        });\n        remoteStoreImpl.onNetworkStatusChange.push(async (enabled) => {\n            if (enabled) {\n                remoteStoreImpl.writeStream.inhibitBackoff();\n                // This will start the write stream if necessary.\n                await fillWritePipeline(remoteStoreImpl);\n            }\n            else {\n                await remoteStoreImpl.writeStream.stop();\n                if (remoteStoreImpl.writePipeline.length > 0) {\n                    logDebug(LOG_TAG$5, `Stopping write stream with ${remoteStoreImpl.writePipeline.length} pending writes`);\n                    remoteStoreImpl.writePipeline = [];\n                }\n            }\n        });\n    }\n    return remoteStoreImpl.writeStream;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$4 = 'AsyncQueue';\n/**\n * Represents an operation scheduled to be run in the future on an AsyncQueue.\n *\n * It is created via DelayedOperation.createAndSchedule().\n *\n * Supports cancellation (via cancel()) and early execution (via skipDelay()).\n *\n * Note: We implement `PromiseLike` instead of `Promise`, as the `Promise` type\n * in newer versions of TypeScript defines `finally`, which is not available in\n * IE.\n */\nclass DelayedOperation {\n    constructor(asyncQueue, timerId, targetTimeMs, op, removalCallback) {\n        this.asyncQueue = asyncQueue;\n        this.timerId = timerId;\n        this.targetTimeMs = targetTimeMs;\n        this.op = op;\n        this.removalCallback = removalCallback;\n        this.deferred = new Deferred();\n        this.then = this.deferred.promise.then.bind(this.deferred.promise);\n        // It's normal for the deferred promise to be canceled (due to cancellation)\n        // and so we attach a dummy catch callback to avoid\n        // 'UnhandledPromiseRejectionWarning' log spam.\n        this.deferred.promise.catch(err => { });\n    }\n    get promise() {\n        return this.deferred.promise;\n    }\n    /**\n     * Creates and returns a DelayedOperation that has been scheduled to be\n     * executed on the provided asyncQueue after the provided delayMs.\n     *\n     * @param asyncQueue - The queue to schedule the operation on.\n     * @param id - A Timer ID identifying the type of operation this is.\n     * @param delayMs - The delay (ms) before the operation should be scheduled.\n     * @param op - The operation to run.\n     * @param removalCallback - A callback to be called synchronously once the\n     *   operation is executed or canceled, notifying the AsyncQueue to remove it\n     *   from its delayedOperations list.\n     *   PORTING NOTE: This exists to prevent making removeDelayedOperation() and\n     *   the DelayedOperation class public.\n     */\n    static createAndSchedule(asyncQueue, timerId, delayMs, op, removalCallback) {\n        const targetTime = Date.now() + delayMs;\n        const delayedOp = new DelayedOperation(asyncQueue, timerId, targetTime, op, removalCallback);\n        delayedOp.start(delayMs);\n        return delayedOp;\n    }\n    /**\n     * Starts the timer. This is called immediately after construction by\n     * createAndSchedule().\n     */\n    start(delayMs) {\n        this.timerHandle = setTimeout(() => this.handleDelayElapsed(), delayMs);\n    }\n    /**\n     * Queues the operation to run immediately (if it hasn't already been run or\n     * canceled).\n     */\n    skipDelay() {\n        return this.handleDelayElapsed();\n    }\n    /**\n     * Cancels the operation if it hasn't already been executed or canceled. The\n     * promise will be rejected.\n     *\n     * As long as the operation has not yet been run, calling cancel() provides a\n     * guarantee that the operation will not be run.\n     */\n    cancel(reason) {\n        if (this.timerHandle !== null) {\n            this.clearTimeout();\n            this.deferred.reject(new FirestoreError(Code.CANCELLED, 'Operation cancelled' + (reason ? ': ' + reason : '')));\n        }\n    }\n    handleDelayElapsed() {\n        this.asyncQueue.enqueueAndForget(() => {\n            if (this.timerHandle !== null) {\n                this.clearTimeout();\n                return this.op().then(result => {\n                    return this.deferred.resolve(result);\n                });\n            }\n            else {\n                return Promise.resolve();\n            }\n        });\n    }\n    clearTimeout() {\n        if (this.timerHandle !== null) {\n            this.removalCallback(this);\n            clearTimeout(this.timerHandle);\n            this.timerHandle = null;\n        }\n    }\n}\n/**\n * Returns a FirestoreError that can be surfaced to the user if the provided\n * error is an IndexedDbTransactionError. Re-throws the error otherwise.\n */\nfunction wrapInUserErrorIfRecoverable(e, msg) {\n    logError(LOG_TAG$4, `${msg}: ${e}`);\n    if (isIndexedDbTransactionError(e)) {\n        return new FirestoreError(Code.UNAVAILABLE, `${msg}: ${e}`);\n    }\n    else {\n        throw e;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * DocumentSet is an immutable (copy-on-write) collection that holds documents\n * in order specified by the provided comparator. We always add a document key\n * comparator on top of what is provided to guarantee document equality based on\n * the key.\n */\nclass DocumentSet {\n    /**\n     * Returns an empty copy of the existing DocumentSet, using the same\n     * comparator.\n     */\n    static emptySet(oldSet) {\n        return new DocumentSet(oldSet.comparator);\n    }\n    /** The default ordering is by key if the comparator is omitted */\n    constructor(comp) {\n        // We are adding document key comparator to the end as it's the only\n        // guaranteed unique property of a document.\n        if (comp) {\n            this.comparator = (d1, d2) => comp(d1, d2) || DocumentKey.comparator(d1.key, d2.key);\n        }\n        else {\n            this.comparator = (d1, d2) => DocumentKey.comparator(d1.key, d2.key);\n        }\n        this.keyedMap = documentMap();\n        this.sortedSet = new SortedMap(this.comparator);\n    }\n    has(key) {\n        return this.keyedMap.get(key) != null;\n    }\n    get(key) {\n        return this.keyedMap.get(key);\n    }\n    first() {\n        return this.sortedSet.minKey();\n    }\n    last() {\n        return this.sortedSet.maxKey();\n    }\n    isEmpty() {\n        return this.sortedSet.isEmpty();\n    }\n    /**\n     * Returns the index of the provided key in the document set, or -1 if the\n     * document key is not present in the set;\n     */\n    indexOf(key) {\n        const doc = this.keyedMap.get(key);\n        return doc ? this.sortedSet.indexOf(doc) : -1;\n    }\n    get size() {\n        return this.sortedSet.size;\n    }\n    /** Iterates documents in order defined by \"comparator\" */\n    forEach(cb) {\n        this.sortedSet.inorderTraversal((k, v) => {\n            cb(k);\n            return false;\n        });\n    }\n    /** Inserts or updates a document with the same key */\n    add(doc) {\n        // First remove the element if we have it.\n        const set = this.delete(doc.key);\n        return set.copy(set.keyedMap.insert(doc.key, doc), set.sortedSet.insert(doc, null));\n    }\n    /** Deletes a document with a given key */\n    delete(key) {\n        const doc = this.get(key);\n        if (!doc) {\n            return this;\n        }\n        return this.copy(this.keyedMap.remove(key), this.sortedSet.remove(doc));\n    }\n    isEqual(other) {\n        if (!(other instanceof DocumentSet)) {\n            return false;\n        }\n        if (this.size !== other.size) {\n            return false;\n        }\n        const thisIt = this.sortedSet.getIterator();\n        const otherIt = other.sortedSet.getIterator();\n        while (thisIt.hasNext()) {\n            const thisDoc = thisIt.getNext().key;\n            const otherDoc = otherIt.getNext().key;\n            if (!thisDoc.isEqual(otherDoc)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    toString() {\n        const docStrings = [];\n        this.forEach(doc => {\n            docStrings.push(doc.toString());\n        });\n        if (docStrings.length === 0) {\n            return 'DocumentSet ()';\n        }\n        else {\n            return 'DocumentSet (\\n  ' + docStrings.join('  \\n') + '\\n)';\n        }\n    }\n    copy(keyedMap, sortedSet) {\n        const newSet = new DocumentSet();\n        newSet.comparator = this.comparator;\n        newSet.keyedMap = keyedMap;\n        newSet.sortedSet = sortedSet;\n        return newSet;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * DocumentChangeSet keeps track of a set of changes to docs in a query, merging\n * duplicate events for the same doc.\n */\nclass DocumentChangeSet {\n    constructor() {\n        this.changeMap = new SortedMap(DocumentKey.comparator);\n    }\n    track(change) {\n        const key = change.doc.key;\n        const oldChange = this.changeMap.get(key);\n        if (!oldChange) {\n            this.changeMap = this.changeMap.insert(key, change);\n            return;\n        }\n        // Merge the new change with the existing change.\n        if (change.type !== 0 /* ChangeType.Added */ &&\n            oldChange.type === 3 /* ChangeType.Metadata */) {\n            this.changeMap = this.changeMap.insert(key, change);\n        }\n        else if (change.type === 3 /* ChangeType.Metadata */ &&\n            oldChange.type !== 1 /* ChangeType.Removed */) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: oldChange.type,\n                doc: change.doc\n            });\n        }\n        else if (change.type === 2 /* ChangeType.Modified */ &&\n            oldChange.type === 2 /* ChangeType.Modified */) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: 2 /* ChangeType.Modified */,\n                doc: change.doc\n            });\n        }\n        else if (change.type === 2 /* ChangeType.Modified */ &&\n            oldChange.type === 0 /* ChangeType.Added */) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: 0 /* ChangeType.Added */,\n                doc: change.doc\n            });\n        }\n        else if (change.type === 1 /* ChangeType.Removed */ &&\n            oldChange.type === 0 /* ChangeType.Added */) {\n            this.changeMap = this.changeMap.remove(key);\n        }\n        else if (change.type === 1 /* ChangeType.Removed */ &&\n            oldChange.type === 2 /* ChangeType.Modified */) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: 1 /* ChangeType.Removed */,\n                doc: oldChange.doc\n            });\n        }\n        else if (change.type === 0 /* ChangeType.Added */ &&\n            oldChange.type === 1 /* ChangeType.Removed */) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: 2 /* ChangeType.Modified */,\n                doc: change.doc\n            });\n        }\n        else {\n            // This includes these cases, which don't make sense:\n            // Added->Added\n            // Removed->Removed\n            // Modified->Added\n            // Removed->Modified\n            // Metadata->Added\n            // Removed->Metadata\n            fail();\n        }\n    }\n    getChanges() {\n        const changes = [];\n        this.changeMap.inorderTraversal((key, change) => {\n            changes.push(change);\n        });\n        return changes;\n    }\n}\nclass ViewSnapshot {\n    constructor(query, docs, oldDocs, docChanges, mutatedKeys, fromCache, syncStateChanged, excludesMetadataChanges, hasCachedResults) {\n        this.query = query;\n        this.docs = docs;\n        this.oldDocs = oldDocs;\n        this.docChanges = docChanges;\n        this.mutatedKeys = mutatedKeys;\n        this.fromCache = fromCache;\n        this.syncStateChanged = syncStateChanged;\n        this.excludesMetadataChanges = excludesMetadataChanges;\n        this.hasCachedResults = hasCachedResults;\n    }\n    /** Returns a view snapshot as if all documents in the snapshot were added. */\n    static fromInitialDocuments(query, documents, mutatedKeys, fromCache, hasCachedResults) {\n        const changes = [];\n        documents.forEach(doc => {\n            changes.push({ type: 0 /* ChangeType.Added */, doc });\n        });\n        return new ViewSnapshot(query, documents, DocumentSet.emptySet(documents), changes, mutatedKeys, fromCache, \n        /* syncStateChanged= */ true, \n        /* excludesMetadataChanges= */ false, hasCachedResults);\n    }\n    get hasPendingWrites() {\n        return !this.mutatedKeys.isEmpty();\n    }\n    isEqual(other) {\n        if (this.fromCache !== other.fromCache ||\n            this.hasCachedResults !== other.hasCachedResults ||\n            this.syncStateChanged !== other.syncStateChanged ||\n            !this.mutatedKeys.isEqual(other.mutatedKeys) ||\n            !queryEquals(this.query, other.query) ||\n            !this.docs.isEqual(other.docs) ||\n            !this.oldDocs.isEqual(other.oldDocs)) {\n            return false;\n        }\n        const changes = this.docChanges;\n        const otherChanges = other.docChanges;\n        if (changes.length !== otherChanges.length) {\n            return false;\n        }\n        for (let i = 0; i < changes.length; i++) {\n            if (changes[i].type !== otherChanges[i].type ||\n                !changes[i].doc.isEqual(otherChanges[i].doc)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Holds the listeners and the last received ViewSnapshot for a query being\n * tracked by EventManager.\n */\nclass QueryListenersInfo {\n    constructor() {\n        this.viewSnap = undefined;\n        this.listeners = [];\n    }\n    // Helper methods that checks if the query has listeners that listening to remote store\n    hasRemoteListeners() {\n        return this.listeners.some(listener => listener.listensToRemoteStore());\n    }\n}\nfunction newEventManager() {\n    return new EventManagerImpl();\n}\nclass EventManagerImpl {\n    constructor() {\n        this.queries = newQueriesObjectMap();\n        this.onlineState = \"Unknown\" /* OnlineState.Unknown */;\n        this.snapshotsInSyncListeners = new Set();\n    }\n    terminate() {\n        errorAllTargets(this, new FirestoreError(Code.ABORTED, 'Firestore shutting down'));\n    }\n}\nfunction newQueriesObjectMap() {\n    return new ObjectMap(q => canonifyQuery(q), queryEquals);\n}\nasync function eventManagerListen(eventManager, listener) {\n    const eventManagerImpl = debugCast(eventManager);\n    let listenerAction = 3 /* ListenerSetupAction.NoActionRequired */;\n    const query = listener.query;\n    let queryInfo = eventManagerImpl.queries.get(query);\n    if (!queryInfo) {\n        queryInfo = new QueryListenersInfo();\n        listenerAction = listener.listensToRemoteStore()\n            ? 0 /* ListenerSetupAction.InitializeLocalListenAndRequireWatchConnection */\n            : 1 /* ListenerSetupAction.InitializeLocalListenOnly */;\n    }\n    else if (!queryInfo.hasRemoteListeners() &&\n        listener.listensToRemoteStore()) {\n        // Query has been listening to local cache, and tries to add a new listener sourced from watch.\n        listenerAction = 2 /* ListenerSetupAction.RequireWatchConnectionOnly */;\n    }\n    try {\n        switch (listenerAction) {\n            case 0 /* ListenerSetupAction.InitializeLocalListenAndRequireWatchConnection */:\n                queryInfo.viewSnap = await eventManagerImpl.onListen(query, \n                /** enableRemoteListen= */ true);\n                break;\n            case 1 /* ListenerSetupAction.InitializeLocalListenOnly */:\n                queryInfo.viewSnap = await eventManagerImpl.onListen(query, \n                /** enableRemoteListen= */ false);\n                break;\n            case 2 /* ListenerSetupAction.RequireWatchConnectionOnly */:\n                await eventManagerImpl.onFirstRemoteStoreListen(query);\n                break;\n            default:\n                break;\n        }\n    }\n    catch (e) {\n        const firestoreError = wrapInUserErrorIfRecoverable(e, `Initialization of query '${stringifyQuery(listener.query)}' failed`);\n        listener.onError(firestoreError);\n        return;\n    }\n    eventManagerImpl.queries.set(query, queryInfo);\n    queryInfo.listeners.push(listener);\n    // Run global snapshot listeners if a consistent snapshot has been emitted.\n    listener.applyOnlineStateChange(eventManagerImpl.onlineState);\n    if (queryInfo.viewSnap) {\n        const raisedEvent = listener.onViewSnapshot(queryInfo.viewSnap);\n        if (raisedEvent) {\n            raiseSnapshotsInSyncEvent(eventManagerImpl);\n        }\n    }\n}\nasync function eventManagerUnlisten(eventManager, listener) {\n    const eventManagerImpl = debugCast(eventManager);\n    const query = listener.query;\n    let listenerAction = 3 /* ListenerRemovalAction.NoActionRequired */;\n    const queryInfo = eventManagerImpl.queries.get(query);\n    if (queryInfo) {\n        const i = queryInfo.listeners.indexOf(listener);\n        if (i >= 0) {\n            queryInfo.listeners.splice(i, 1);\n            if (queryInfo.listeners.length === 0) {\n                listenerAction = listener.listensToRemoteStore()\n                    ? 0 /* ListenerRemovalAction.TerminateLocalListenAndRequireWatchDisconnection */\n                    : 1 /* ListenerRemovalAction.TerminateLocalListenOnly */;\n            }\n            else if (!queryInfo.hasRemoteListeners() &&\n                listener.listensToRemoteStore()) {\n                // The removed listener is the last one that sourced from watch.\n                listenerAction = 2 /* ListenerRemovalAction.RequireWatchDisconnectionOnly */;\n            }\n        }\n    }\n    switch (listenerAction) {\n        case 0 /* ListenerRemovalAction.TerminateLocalListenAndRequireWatchDisconnection */:\n            eventManagerImpl.queries.delete(query);\n            return eventManagerImpl.onUnlisten(query, \n            /** disableRemoteListen= */ true);\n        case 1 /* ListenerRemovalAction.TerminateLocalListenOnly */:\n            eventManagerImpl.queries.delete(query);\n            return eventManagerImpl.onUnlisten(query, \n            /** disableRemoteListen= */ false);\n        case 2 /* ListenerRemovalAction.RequireWatchDisconnectionOnly */:\n            return eventManagerImpl.onLastRemoteStoreUnlisten(query);\n        default:\n            return;\n    }\n}\nfunction eventManagerOnWatchChange(eventManager, viewSnaps) {\n    const eventManagerImpl = debugCast(eventManager);\n    let raisedEvent = false;\n    for (const viewSnap of viewSnaps) {\n        const query = viewSnap.query;\n        const queryInfo = eventManagerImpl.queries.get(query);\n        if (queryInfo) {\n            for (const listener of queryInfo.listeners) {\n                if (listener.onViewSnapshot(viewSnap)) {\n                    raisedEvent = true;\n                }\n            }\n            queryInfo.viewSnap = viewSnap;\n        }\n    }\n    if (raisedEvent) {\n        raiseSnapshotsInSyncEvent(eventManagerImpl);\n    }\n}\nfunction eventManagerOnWatchError(eventManager, query, error) {\n    const eventManagerImpl = debugCast(eventManager);\n    const queryInfo = eventManagerImpl.queries.get(query);\n    if (queryInfo) {\n        for (const listener of queryInfo.listeners) {\n            listener.onError(error);\n        }\n    }\n    // Remove all listeners. NOTE: We don't need to call syncEngine.unlisten()\n    // after an error.\n    eventManagerImpl.queries.delete(query);\n}\nfunction eventManagerOnOnlineStateChange(eventManager, onlineState) {\n    const eventManagerImpl = debugCast(eventManager);\n    eventManagerImpl.onlineState = onlineState;\n    let raisedEvent = false;\n    eventManagerImpl.queries.forEach((_, queryInfo) => {\n        for (const listener of queryInfo.listeners) {\n            // Run global snapshot listeners if a consistent snapshot has been emitted.\n            if (listener.applyOnlineStateChange(onlineState)) {\n                raisedEvent = true;\n            }\n        }\n    });\n    if (raisedEvent) {\n        raiseSnapshotsInSyncEvent(eventManagerImpl);\n    }\n}\nfunction addSnapshotsInSyncListener(eventManager, observer) {\n    const eventManagerImpl = debugCast(eventManager);\n    eventManagerImpl.snapshotsInSyncListeners.add(observer);\n    // Immediately fire an initial event, indicating all existing listeners\n    // are in-sync.\n    observer.next();\n}\nfunction removeSnapshotsInSyncListener(eventManager, observer) {\n    const eventManagerImpl = debugCast(eventManager);\n    eventManagerImpl.snapshotsInSyncListeners.delete(observer);\n}\nfunction errorAllTargets(eventManager, error) {\n    const eventManagerImpl = debugCast(eventManager);\n    const queries = eventManagerImpl.queries;\n    // Prevent further access by clearing ObjectMap.\n    eventManagerImpl.queries = newQueriesObjectMap();\n    queries.forEach((_, queryInfo) => {\n        for (const listener of queryInfo.listeners) {\n            listener.onError(error);\n        }\n    });\n}\n// Call all global snapshot listeners that have been set.\nfunction raiseSnapshotsInSyncEvent(eventManagerImpl) {\n    eventManagerImpl.snapshotsInSyncListeners.forEach(observer => {\n        observer.next();\n    });\n}\nvar ListenerDataSource;\n(function (ListenerDataSource) {\n    /** Listen to both cache and server changes */\n    ListenerDataSource[\"Default\"] = \"default\";\n    /** Listen to changes in cache only */\n    ListenerDataSource[\"Cache\"] = \"cache\";\n})(ListenerDataSource || (ListenerDataSource = {}));\n/**\n * QueryListener takes a series of internal view snapshots and determines\n * when to raise the event.\n *\n * It uses an Observer to dispatch events.\n */\nclass QueryListener {\n    constructor(query, queryObserver, options) {\n        this.query = query;\n        this.queryObserver = queryObserver;\n        /**\n         * Initial snapshots (e.g. from cache) may not be propagated to the wrapped\n         * observer. This flag is set to true once we've actually raised an event.\n         */\n        this.raisedInitialEvent = false;\n        this.snap = null;\n        this.onlineState = \"Unknown\" /* OnlineState.Unknown */;\n        this.options = options || {};\n    }\n    /**\n     * Applies the new ViewSnapshot to this listener, raising a user-facing event\n     * if applicable (depending on what changed, whether the user has opted into\n     * metadata-only changes, etc.). Returns true if a user-facing event was\n     * indeed raised.\n     */\n    onViewSnapshot(snap) {\n        if (!this.options.includeMetadataChanges) {\n            // Remove the metadata only changes.\n            const docChanges = [];\n            for (const docChange of snap.docChanges) {\n                if (docChange.type !== 3 /* ChangeType.Metadata */) {\n                    docChanges.push(docChange);\n                }\n            }\n            snap = new ViewSnapshot(snap.query, snap.docs, snap.oldDocs, docChanges, snap.mutatedKeys, snap.fromCache, snap.syncStateChanged, \n            /* excludesMetadataChanges= */ true, snap.hasCachedResults);\n        }\n        let raisedEvent = false;\n        if (!this.raisedInitialEvent) {\n            if (this.shouldRaiseInitialEvent(snap, this.onlineState)) {\n                this.raiseInitialEvent(snap);\n                raisedEvent = true;\n            }\n        }\n        else if (this.shouldRaiseEvent(snap)) {\n            this.queryObserver.next(snap);\n            raisedEvent = true;\n        }\n        this.snap = snap;\n        return raisedEvent;\n    }\n    onError(error) {\n        this.queryObserver.error(error);\n    }\n    /** Returns whether a snapshot was raised. */\n    applyOnlineStateChange(onlineState) {\n        this.onlineState = onlineState;\n        let raisedEvent = false;\n        if (this.snap &&\n            !this.raisedInitialEvent &&\n            this.shouldRaiseInitialEvent(this.snap, onlineState)) {\n            this.raiseInitialEvent(this.snap);\n            raisedEvent = true;\n        }\n        return raisedEvent;\n    }\n    shouldRaiseInitialEvent(snap, onlineState) {\n        // Always raise the first event when we're synced\n        if (!snap.fromCache) {\n            return true;\n        }\n        // Always raise event if listening to cache\n        if (!this.listensToRemoteStore()) {\n            return true;\n        }\n        // NOTE: We consider OnlineState.Unknown as online (it should become Offline\n        // or Online if we wait long enough).\n        const maybeOnline = onlineState !== \"Offline\" /* OnlineState.Offline */;\n        // Don't raise the event if we're online, aren't synced yet (checked\n        // above) and are waiting for a sync.\n        if (this.options.waitForSyncWhenOnline && maybeOnline) {\n            return false;\n        }\n        // Raise data from cache if we have any documents, have cached results before,\n        // or we are offline.\n        return (!snap.docs.isEmpty() ||\n            snap.hasCachedResults ||\n            onlineState === \"Offline\" /* OnlineState.Offline */);\n    }\n    shouldRaiseEvent(snap) {\n        // We don't need to handle includeDocumentMetadataChanges here because\n        // the Metadata only changes have already been stripped out if needed.\n        // At this point the only changes we will see are the ones we should\n        // propagate.\n        if (snap.docChanges.length > 0) {\n            return true;\n        }\n        const hasPendingWritesChanged = this.snap && this.snap.hasPendingWrites !== snap.hasPendingWrites;\n        if (snap.syncStateChanged || hasPendingWritesChanged) {\n            return this.options.includeMetadataChanges === true;\n        }\n        // Generally we should have hit one of the cases above, but it's possible\n        // to get here if there were only metadata docChanges and they got\n        // stripped out.\n        return false;\n    }\n    raiseInitialEvent(snap) {\n        snap = ViewSnapshot.fromInitialDocuments(snap.query, snap.docs, snap.mutatedKeys, snap.fromCache, snap.hasCachedResults);\n        this.raisedInitialEvent = true;\n        this.queryObserver.next(snap);\n    }\n    listensToRemoteStore() {\n        return this.options.source !== ListenerDataSource.Cache;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A set of changes to what documents are currently in view and out of view for\n * a given query. These changes are sent to the LocalStore by the View (via\n * the SyncEngine) and are used to pin / unpin documents as appropriate.\n */\nclass LocalViewChanges {\n    constructor(targetId, fromCache, addedKeys, removedKeys) {\n        this.targetId = targetId;\n        this.fromCache = fromCache;\n        this.addedKeys = addedKeys;\n        this.removedKeys = removedKeys;\n    }\n    static fromSnapshot(targetId, viewSnapshot) {\n        let addedKeys = documentKeySet();\n        let removedKeys = documentKeySet();\n        for (const docChange of viewSnapshot.docChanges) {\n            switch (docChange.type) {\n                case 0 /* ChangeType.Added */:\n                    addedKeys = addedKeys.add(docChange.doc.key);\n                    break;\n                case 1 /* ChangeType.Removed */:\n                    removedKeys = removedKeys.add(docChange.doc.key);\n                    break;\n                // do nothing\n            }\n        }\n        return new LocalViewChanges(targetId, viewSnapshot.fromCache, addedKeys, removedKeys);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Helper to convert objects from bundles to model objects in the SDK.\n */\nclass BundleConverterImpl {\n    constructor(serializer) {\n        this.serializer = serializer;\n    }\n    toDocumentKey(name) {\n        return fromName(this.serializer, name);\n    }\n    /**\n     * Converts a BundleDocument to a MutableDocument.\n     */\n    toMutableDocument(bundledDoc) {\n        if (bundledDoc.metadata.exists) {\n            return fromDocument(this.serializer, bundledDoc.document, false);\n        }\n        else {\n            return MutableDocument.newNoDocument(this.toDocumentKey(bundledDoc.metadata.name), this.toSnapshotVersion(bundledDoc.metadata.readTime));\n        }\n    }\n    toSnapshotVersion(time) {\n        return fromVersion(time);\n    }\n}\n/**\n * A class to process the elements from a bundle, load them into local\n * storage and provide progress update while loading.\n */\nclass BundleLoader {\n    constructor(bundleMetadata, localStore, serializer) {\n        this.bundleMetadata = bundleMetadata;\n        this.localStore = localStore;\n        this.serializer = serializer;\n        /** Batched queries to be saved into storage */\n        this.queries = [];\n        /** Batched documents to be saved into storage */\n        this.documents = [];\n        /** The collection groups affected by this bundle. */\n        this.collectionGroups = new Set();\n        this.progress = bundleInitialProgress(bundleMetadata);\n    }\n    /**\n     * Adds an element from the bundle to the loader.\n     *\n     * Returns a new progress if adding the element leads to a new progress,\n     * otherwise returns null.\n     */\n    addSizedElement(element) {\n        this.progress.bytesLoaded += element.byteLength;\n        let documentsLoaded = this.progress.documentsLoaded;\n        if (element.payload.namedQuery) {\n            this.queries.push(element.payload.namedQuery);\n        }\n        else if (element.payload.documentMetadata) {\n            this.documents.push({ metadata: element.payload.documentMetadata });\n            if (!element.payload.documentMetadata.exists) {\n                ++documentsLoaded;\n            }\n            const path = ResourcePath.fromString(element.payload.documentMetadata.name);\n            this.collectionGroups.add(path.get(path.length - 2));\n        }\n        else if (element.payload.document) {\n            this.documents[this.documents.length - 1].document =\n                element.payload.document;\n            ++documentsLoaded;\n        }\n        if (documentsLoaded !== this.progress.documentsLoaded) {\n            this.progress.documentsLoaded = documentsLoaded;\n            return Object.assign({}, this.progress);\n        }\n        return null;\n    }\n    getQueryDocumentMapping(documents) {\n        const queryDocumentMap = new Map();\n        const bundleConverter = new BundleConverterImpl(this.serializer);\n        for (const bundleDoc of documents) {\n            if (bundleDoc.metadata.queries) {\n                const documentKey = bundleConverter.toDocumentKey(bundleDoc.metadata.name);\n                for (const queryName of bundleDoc.metadata.queries) {\n                    const documentKeys = (queryDocumentMap.get(queryName) || documentKeySet()).add(documentKey);\n                    queryDocumentMap.set(queryName, documentKeys);\n                }\n            }\n        }\n        return queryDocumentMap;\n    }\n    /**\n     * Update the progress to 'Success' and return the updated progress.\n     */\n    async complete() {\n        const changedDocs = await localStoreApplyBundledDocuments(this.localStore, new BundleConverterImpl(this.serializer), this.documents, this.bundleMetadata.id);\n        const queryDocumentMap = this.getQueryDocumentMapping(this.documents);\n        for (const q of this.queries) {\n            await localStoreSaveNamedQuery(this.localStore, q, queryDocumentMap.get(q.name));\n        }\n        this.progress.taskState = 'Success';\n        return {\n            progress: this.progress,\n            changedCollectionGroups: this.collectionGroups,\n            changedDocs\n        };\n    }\n}\n/**\n * Returns a `LoadBundleTaskProgress` representing the initial progress of\n * loading a bundle.\n */\nfunction bundleInitialProgress(metadata) {\n    return {\n        taskState: 'Running',\n        documentsLoaded: 0,\n        bytesLoaded: 0,\n        totalDocuments: metadata.totalDocuments,\n        totalBytes: metadata.totalBytes\n    };\n}\n/**\n * Returns a `LoadBundleTaskProgress` representing the progress that the loading\n * has succeeded.\n */\nfunction bundleSuccessProgress(metadata) {\n    return {\n        taskState: 'Success',\n        documentsLoaded: metadata.totalDocuments,\n        bytesLoaded: metadata.totalBytes,\n        totalDocuments: metadata.totalDocuments,\n        totalBytes: metadata.totalBytes\n    };\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass AddedLimboDocument {\n    constructor(key) {\n        this.key = key;\n    }\n}\nclass RemovedLimboDocument {\n    constructor(key) {\n        this.key = key;\n    }\n}\n/**\n * View is responsible for computing the final merged truth of what docs are in\n * a query. It gets notified of local and remote changes to docs, and applies\n * the query filters and limits to determine the most correct possible results.\n */\nclass View {\n    constructor(query, \n    /** Documents included in the remote target */\n    _syncedDocuments) {\n        this.query = query;\n        this._syncedDocuments = _syncedDocuments;\n        this.syncState = null;\n        this.hasCachedResults = false;\n        /**\n         * A flag whether the view is current with the backend. A view is considered\n         * current after it has seen the current flag from the backend and did not\n         * lose consistency within the watch stream (e.g. because of an existence\n         * filter mismatch).\n         */\n        this.current = false;\n        /** Documents in the view but not in the remote target */\n        this.limboDocuments = documentKeySet();\n        /** Document Keys that have local changes */\n        this.mutatedKeys = documentKeySet();\n        this.docComparator = newQueryComparator(query);\n        this.documentSet = new DocumentSet(this.docComparator);\n    }\n    /**\n     * The set of remote documents that the server has told us belongs to the target associated with\n     * this view.\n     */\n    get syncedDocuments() {\n        return this._syncedDocuments;\n    }\n    /**\n     * Iterates over a set of doc changes, applies the query limit, and computes\n     * what the new results should be, what the changes were, and whether we may\n     * need to go back to the local cache for more results. Does not make any\n     * changes to the view.\n     * @param docChanges - The doc changes to apply to this view.\n     * @param previousChanges - If this is being called with a refill, then start\n     *        with this set of docs and changes instead of the current view.\n     * @returns a new set of docs, changes, and refill flag.\n     */\n    computeDocChanges(docChanges, previousChanges) {\n        const changeSet = previousChanges\n            ? previousChanges.changeSet\n            : new DocumentChangeSet();\n        const oldDocumentSet = previousChanges\n            ? previousChanges.documentSet\n            : this.documentSet;\n        let newMutatedKeys = previousChanges\n            ? previousChanges.mutatedKeys\n            : this.mutatedKeys;\n        let newDocumentSet = oldDocumentSet;\n        let needsRefill = false;\n        // Track the last doc in a (full) limit. This is necessary, because some\n        // update (a delete, or an update moving a doc past the old limit) might\n        // mean there is some other document in the local cache that either should\n        // come (1) between the old last limit doc and the new last document, in the\n        // case of updates, or (2) after the new last document, in the case of\n        // deletes. So we keep this doc at the old limit to compare the updates to.\n        //\n        // Note that this should never get used in a refill (when previousChanges is\n        // set), because there will only be adds -- no deletes or updates.\n        const lastDocInLimit = this.query.limitType === \"F\" /* LimitType.First */ &&\n            oldDocumentSet.size === this.query.limit\n            ? oldDocumentSet.last()\n            : null;\n        const firstDocInLimit = this.query.limitType === \"L\" /* LimitType.Last */ &&\n            oldDocumentSet.size === this.query.limit\n            ? oldDocumentSet.first()\n            : null;\n        docChanges.inorderTraversal((key, entry) => {\n            const oldDoc = oldDocumentSet.get(key);\n            const newDoc = queryMatches(this.query, entry) ? entry : null;\n            const oldDocHadPendingMutations = oldDoc\n                ? this.mutatedKeys.has(oldDoc.key)\n                : false;\n            const newDocHasPendingMutations = newDoc\n                ? newDoc.hasLocalMutations ||\n                    // We only consider committed mutations for documents that were\n                    // mutated during the lifetime of the view.\n                    (this.mutatedKeys.has(newDoc.key) && newDoc.hasCommittedMutations)\n                : false;\n            let changeApplied = false;\n            // Calculate change\n            if (oldDoc && newDoc) {\n                const docsEqual = oldDoc.data.isEqual(newDoc.data);\n                if (!docsEqual) {\n                    if (!this.shouldWaitForSyncedDocument(oldDoc, newDoc)) {\n                        changeSet.track({\n                            type: 2 /* ChangeType.Modified */,\n                            doc: newDoc\n                        });\n                        changeApplied = true;\n                        if ((lastDocInLimit &&\n                            this.docComparator(newDoc, lastDocInLimit) > 0) ||\n                            (firstDocInLimit &&\n                                this.docComparator(newDoc, firstDocInLimit) < 0)) {\n                            // This doc moved from inside the limit to outside the limit.\n                            // That means there may be some other doc in the local cache\n                            // that should be included instead.\n                            needsRefill = true;\n                        }\n                    }\n                }\n                else if (oldDocHadPendingMutations !== newDocHasPendingMutations) {\n                    changeSet.track({ type: 3 /* ChangeType.Metadata */, doc: newDoc });\n                    changeApplied = true;\n                }\n            }\n            else if (!oldDoc && newDoc) {\n                changeSet.track({ type: 0 /* ChangeType.Added */, doc: newDoc });\n                changeApplied = true;\n            }\n            else if (oldDoc && !newDoc) {\n                changeSet.track({ type: 1 /* ChangeType.Removed */, doc: oldDoc });\n                changeApplied = true;\n                if (lastDocInLimit || firstDocInLimit) {\n                    // A doc was removed from a full limit query. We'll need to\n                    // requery from the local cache to see if we know about some other\n                    // doc that should be in the results.\n                    needsRefill = true;\n                }\n            }\n            if (changeApplied) {\n                if (newDoc) {\n                    newDocumentSet = newDocumentSet.add(newDoc);\n                    if (newDocHasPendingMutations) {\n                        newMutatedKeys = newMutatedKeys.add(key);\n                    }\n                    else {\n                        newMutatedKeys = newMutatedKeys.delete(key);\n                    }\n                }\n                else {\n                    newDocumentSet = newDocumentSet.delete(key);\n                    newMutatedKeys = newMutatedKeys.delete(key);\n                }\n            }\n        });\n        // Drop documents out to meet limit/limitToLast requirement.\n        if (this.query.limit !== null) {\n            while (newDocumentSet.size > this.query.limit) {\n                const oldDoc = this.query.limitType === \"F\" /* LimitType.First */\n                    ? newDocumentSet.last()\n                    : newDocumentSet.first();\n                newDocumentSet = newDocumentSet.delete(oldDoc.key);\n                newMutatedKeys = newMutatedKeys.delete(oldDoc.key);\n                changeSet.track({ type: 1 /* ChangeType.Removed */, doc: oldDoc });\n            }\n        }\n        return {\n            documentSet: newDocumentSet,\n            changeSet,\n            needsRefill,\n            mutatedKeys: newMutatedKeys\n        };\n    }\n    shouldWaitForSyncedDocument(oldDoc, newDoc) {\n        // We suppress the initial change event for documents that were modified as\n        // part of a write acknowledgment (e.g. when the value of a server transform\n        // is applied) as Watch will send us the same document again.\n        // By suppressing the event, we only raise two user visible events (one with\n        // `hasPendingWrites` and the final state of the document) instead of three\n        // (one with `hasPendingWrites`, the modified document with\n        // `hasPendingWrites` and the final state of the document).\n        return (oldDoc.hasLocalMutations &&\n            newDoc.hasCommittedMutations &&\n            !newDoc.hasLocalMutations);\n    }\n    /**\n     * Updates the view with the given ViewDocumentChanges and optionally updates\n     * limbo docs and sync state from the provided target change.\n     * @param docChanges - The set of changes to make to the view's docs.\n     * @param limboResolutionEnabled - Whether to update limbo documents based on\n     *        this change.\n     * @param targetChange - A target change to apply for computing limbo docs and\n     *        sync state.\n     * @param targetIsPendingReset - Whether the target is pending to reset due to\n     *        existence filter mismatch. If not explicitly specified, it is treated\n     *        equivalently to `false`.\n     * @returns A new ViewChange with the given docs, changes, and sync state.\n     */\n    // PORTING NOTE: The iOS/Android clients always compute limbo document changes.\n    applyChanges(docChanges, limboResolutionEnabled, targetChange, targetIsPendingReset) {\n        const oldDocs = this.documentSet;\n        this.documentSet = docChanges.documentSet;\n        this.mutatedKeys = docChanges.mutatedKeys;\n        // Sort changes based on type and query comparator\n        const changes = docChanges.changeSet.getChanges();\n        changes.sort((c1, c2) => {\n            return (compareChangeType(c1.type, c2.type) ||\n                this.docComparator(c1.doc, c2.doc));\n        });\n        this.applyTargetChange(targetChange);\n        targetIsPendingReset = targetIsPendingReset !== null && targetIsPendingReset !== void 0 ? targetIsPendingReset : false;\n        const limboChanges = limboResolutionEnabled && !targetIsPendingReset\n            ? this.updateLimboDocuments()\n            : [];\n        // We are at synced state if there is no limbo docs are waiting to be resolved, view is current\n        // with the backend, and the query is not pending to reset due to existence filter mismatch.\n        const synced = this.limboDocuments.size === 0 && this.current && !targetIsPendingReset;\n        const newSyncState = synced ? 1 /* SyncState.Synced */ : 0 /* SyncState.Local */;\n        const syncStateChanged = newSyncState !== this.syncState;\n        this.syncState = newSyncState;\n        if (changes.length === 0 && !syncStateChanged) {\n            // no changes\n            return { limboChanges };\n        }\n        else {\n            const snap = new ViewSnapshot(this.query, docChanges.documentSet, oldDocs, changes, docChanges.mutatedKeys, newSyncState === 0 /* SyncState.Local */, syncStateChanged, \n            /* excludesMetadataChanges= */ false, targetChange\n                ? targetChange.resumeToken.approximateByteSize() > 0\n                : false);\n            return {\n                snapshot: snap,\n                limboChanges\n            };\n        }\n    }\n    /**\n     * Applies an OnlineState change to the view, potentially generating a\n     * ViewChange if the view's syncState changes as a result.\n     */\n    applyOnlineStateChange(onlineState) {\n        if (this.current && onlineState === \"Offline\" /* OnlineState.Offline */) {\n            // If we're offline, set `current` to false and then call applyChanges()\n            // to refresh our syncState and generate a ViewChange as appropriate. We\n            // are guaranteed to get a new TargetChange that sets `current` back to\n            // true once the client is back online.\n            this.current = false;\n            return this.applyChanges({\n                documentSet: this.documentSet,\n                changeSet: new DocumentChangeSet(),\n                mutatedKeys: this.mutatedKeys,\n                needsRefill: false\n            }, \n            /* limboResolutionEnabled= */ false);\n        }\n        else {\n            // No effect, just return a no-op ViewChange.\n            return { limboChanges: [] };\n        }\n    }\n    /**\n     * Returns whether the doc for the given key should be in limbo.\n     */\n    shouldBeInLimbo(key) {\n        // If the remote end says it's part of this query, it's not in limbo.\n        if (this._syncedDocuments.has(key)) {\n            return false;\n        }\n        // The local store doesn't think it's a result, so it shouldn't be in limbo.\n        if (!this.documentSet.has(key)) {\n            return false;\n        }\n        // If there are local changes to the doc, they might explain why the server\n        // doesn't know that it's part of the query. So don't put it in limbo.\n        // TODO(klimt): Ideally, we would only consider changes that might actually\n        // affect this specific query.\n        if (this.documentSet.get(key).hasLocalMutations) {\n            return false;\n        }\n        // Everything else is in limbo.\n        return true;\n    }\n    /**\n     * Updates syncedDocuments, current, and limbo docs based on the given change.\n     * Returns the list of changes to which docs are in limbo.\n     */\n    applyTargetChange(targetChange) {\n        if (targetChange) {\n            targetChange.addedDocuments.forEach(key => (this._syncedDocuments = this._syncedDocuments.add(key)));\n            targetChange.modifiedDocuments.forEach(key => {\n            });\n            targetChange.removedDocuments.forEach(key => (this._syncedDocuments = this._syncedDocuments.delete(key)));\n            this.current = targetChange.current;\n        }\n    }\n    updateLimboDocuments() {\n        // We can only determine limbo documents when we're in-sync with the server.\n        if (!this.current) {\n            return [];\n        }\n        // TODO(klimt): Do this incrementally so that it's not quadratic when\n        // updating many documents.\n        const oldLimboDocuments = this.limboDocuments;\n        this.limboDocuments = documentKeySet();\n        this.documentSet.forEach(doc => {\n            if (this.shouldBeInLimbo(doc.key)) {\n                this.limboDocuments = this.limboDocuments.add(doc.key);\n            }\n        });\n        // Diff the new limbo docs with the old limbo docs.\n        const changes = [];\n        oldLimboDocuments.forEach(key => {\n            if (!this.limboDocuments.has(key)) {\n                changes.push(new RemovedLimboDocument(key));\n            }\n        });\n        this.limboDocuments.forEach(key => {\n            if (!oldLimboDocuments.has(key)) {\n                changes.push(new AddedLimboDocument(key));\n            }\n        });\n        return changes;\n    }\n    /**\n     * Update the in-memory state of the current view with the state read from\n     * persistence.\n     *\n     * We update the query view whenever a client's primary status changes:\n     * - When a client transitions from primary to secondary, it can miss\n     *   LocalStorage updates and its query views may temporarily not be\n     *   synchronized with the state on disk.\n     * - For secondary to primary transitions, the client needs to update the list\n     *   of `syncedDocuments` since secondary clients update their query views\n     *   based purely on synthesized RemoteEvents.\n     *\n     * @param queryResult.documents - The documents that match the query according\n     * to the LocalStore.\n     * @param queryResult.remoteKeys - The keys of the documents that match the\n     * query according to the backend.\n     *\n     * @returns The ViewChange that resulted from this synchronization.\n     */\n    // PORTING NOTE: Multi-tab only.\n    synchronizeWithPersistedState(queryResult) {\n        this._syncedDocuments = queryResult.remoteKeys;\n        this.limboDocuments = documentKeySet();\n        const docChanges = this.computeDocChanges(queryResult.documents);\n        return this.applyChanges(docChanges, /* limboResolutionEnabled= */ true);\n    }\n    /**\n     * Returns a view snapshot as if this query was just listened to. Contains\n     * a document add for every existing document and the `fromCache` and\n     * `hasPendingWrites` status of the already established view.\n     */\n    // PORTING NOTE: Multi-tab only.\n    computeInitialSnapshot() {\n        return ViewSnapshot.fromInitialDocuments(this.query, this.documentSet, this.mutatedKeys, this.syncState === 0 /* SyncState.Local */, this.hasCachedResults);\n    }\n}\nfunction compareChangeType(c1, c2) {\n    const order = (change) => {\n        switch (change) {\n            case 0 /* ChangeType.Added */:\n                return 1;\n            case 2 /* ChangeType.Modified */:\n                return 2;\n            case 3 /* ChangeType.Metadata */:\n                // A metadata change is converted to a modified change at the public\n                // api layer.  Since we sort by document key and then change type,\n                // metadata and modified changes must be sorted equivalently.\n                return 2;\n            case 1 /* ChangeType.Removed */:\n                return 0;\n            default:\n                return fail();\n        }\n    };\n    return order(c1) - order(c2);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$3 = 'SyncEngine';\n/**\n * QueryView contains all of the data that SyncEngine needs to keep track of for\n * a particular query.\n */\nclass QueryView {\n    constructor(\n    /**\n     * The query itself.\n     */\n    query, \n    /**\n     * The target number created by the client that is used in the watch\n     * stream to identify this query.\n     */\n    targetId, \n    /**\n     * The view is responsible for computing the final merged truth of what\n     * docs are in the query. It gets notified of local and remote changes,\n     * and applies the query filters and limits to determine the most correct\n     * possible results.\n     */\n    view) {\n        this.query = query;\n        this.targetId = targetId;\n        this.view = view;\n    }\n}\n/** Tracks a limbo resolution. */\nclass LimboResolution {\n    constructor(key) {\n        this.key = key;\n        /**\n         * Set to true once we've received a document. This is used in\n         * getRemoteKeysForTarget() and ultimately used by WatchChangeAggregator to\n         * decide whether it needs to manufacture a delete event for the target once\n         * the target is CURRENT.\n         */\n        this.receivedDocument = false;\n    }\n}\n/**\n * An implementation of `SyncEngine` coordinating with other parts of SDK.\n *\n * The parts of SyncEngine that act as a callback to RemoteStore need to be\n * registered individually. This is done in `syncEngineWrite()` and\n * `syncEngineListen()` (as well as `applyPrimaryState()`) as these methods\n * serve as entry points to RemoteStore's functionality.\n *\n * Note: some field defined in this class might have public access level, but\n * the class is not exported so they are only accessible from this module.\n * This is useful to implement optional features (like bundles) in free\n * functions, such that they are tree-shakeable.\n */\nclass SyncEngineImpl {\n    constructor(localStore, remoteStore, eventManager, \n    // PORTING NOTE: Manages state synchronization in multi-tab environments.\n    sharedClientState, currentUser, maxConcurrentLimboResolutions) {\n        this.localStore = localStore;\n        this.remoteStore = remoteStore;\n        this.eventManager = eventManager;\n        this.sharedClientState = sharedClientState;\n        this.currentUser = currentUser;\n        this.maxConcurrentLimboResolutions = maxConcurrentLimboResolutions;\n        this.syncEngineListener = {};\n        this.queryViewsByQuery = new ObjectMap(q => canonifyQuery(q), queryEquals);\n        this.queriesByTarget = new Map();\n        /**\n         * The keys of documents that are in limbo for which we haven't yet started a\n         * limbo resolution query. The strings in this set are the result of calling\n         * `key.path.canonicalString()` where `key` is a `DocumentKey` object.\n         *\n         * The `Set` type was chosen because it provides efficient lookup and removal\n         * of arbitrary elements and it also maintains insertion order, providing the\n         * desired queue-like FIFO semantics.\n         */\n        this.enqueuedLimboResolutions = new Set();\n        /**\n         * Keeps track of the target ID for each document that is in limbo with an\n         * active target.\n         */\n        this.activeLimboTargetsByKey = new SortedMap(DocumentKey.comparator);\n        /**\n         * Keeps track of the information about an active limbo resolution for each\n         * active target ID that was started for the purpose of limbo resolution.\n         */\n        this.activeLimboResolutionsByTarget = new Map();\n        this.limboDocumentRefs = new ReferenceSet();\n        /** Stores user completion handlers, indexed by User and BatchId. */\n        this.mutationUserCallbacks = {};\n        /** Stores user callbacks waiting for all pending writes to be acknowledged. */\n        this.pendingWritesCallbacks = new Map();\n        this.limboTargetIdGenerator = TargetIdGenerator.forSyncEngine();\n        this.onlineState = \"Unknown\" /* OnlineState.Unknown */;\n        // The primary state is set to `true` or `false` immediately after Firestore\n        // startup. In the interim, a client should only be considered primary if\n        // `isPrimary` is true.\n        this._isPrimaryClient = undefined;\n    }\n    get isPrimaryClient() {\n        return this._isPrimaryClient === true;\n    }\n}\nfunction newSyncEngine(localStore, remoteStore, eventManager, \n// PORTING NOTE: Manages state synchronization in multi-tab environments.\nsharedClientState, currentUser, maxConcurrentLimboResolutions, isPrimary) {\n    const syncEngine = new SyncEngineImpl(localStore, remoteStore, eventManager, sharedClientState, currentUser, maxConcurrentLimboResolutions);\n    if (isPrimary) {\n        syncEngine._isPrimaryClient = true;\n    }\n    return syncEngine;\n}\n/**\n * Initiates the new listen, resolves promise when listen enqueued to the\n * server. All the subsequent view snapshots or errors are sent to the\n * subscribed handlers. Returns the initial snapshot.\n */\nasync function syncEngineListen(syncEngine, query, shouldListenToRemote = true) {\n    const syncEngineImpl = ensureWatchCallbacks(syncEngine);\n    let viewSnapshot;\n    const queryView = syncEngineImpl.queryViewsByQuery.get(query);\n    if (queryView) {\n        // PORTING NOTE: With Multi-Tab Web, it is possible that a query view\n        // already exists when EventManager calls us for the first time. This\n        // happens when the primary tab is already listening to this query on\n        // behalf of another tab and the user of the primary also starts listening\n        // to the query. EventManager will not have an assigned target ID in this\n        // case and calls `listen` to obtain this ID.\n        syncEngineImpl.sharedClientState.addLocalQueryTarget(queryView.targetId);\n        viewSnapshot = queryView.view.computeInitialSnapshot();\n    }\n    else {\n        viewSnapshot = await allocateTargetAndMaybeListen(syncEngineImpl, query, shouldListenToRemote, \n        /** shouldInitializeView= */ true);\n    }\n    return viewSnapshot;\n}\n/** Query has been listening to the cache, and tries to initiate the remote store listen */\nasync function triggerRemoteStoreListen(syncEngine, query) {\n    const syncEngineImpl = ensureWatchCallbacks(syncEngine);\n    await allocateTargetAndMaybeListen(syncEngineImpl, query, \n    /** shouldListenToRemote= */ true, \n    /** shouldInitializeView= */ false);\n}\nasync function allocateTargetAndMaybeListen(syncEngineImpl, query, shouldListenToRemote, shouldInitializeView) {\n    const targetData = await localStoreAllocateTarget(syncEngineImpl.localStore, queryToTarget(query));\n    const targetId = targetData.targetId;\n    // PORTING NOTE: When the query is listening to cache only, we skip sending it over to Watch by\n    // not registering it in shared client state, and directly calculate initial snapshots and\n    // subsequent updates from cache. Otherwise, register the target ID with local Firestore client\n    // as active watch target.\n    const status = syncEngineImpl.sharedClientState.addLocalQueryTarget(targetId, \n    /* addToActiveTargetIds= */ shouldListenToRemote);\n    let viewSnapshot;\n    if (shouldInitializeView) {\n        viewSnapshot = await initializeViewAndComputeSnapshot(syncEngineImpl, query, targetId, status === 'current', targetData.resumeToken);\n    }\n    if (syncEngineImpl.isPrimaryClient && shouldListenToRemote) {\n        remoteStoreListen(syncEngineImpl.remoteStore, targetData);\n    }\n    return viewSnapshot;\n}\n/**\n * Registers a view for a previously unknown query and computes its initial\n * snapshot.\n */\nasync function initializeViewAndComputeSnapshot(syncEngineImpl, query, targetId, current, resumeToken) {\n    // PORTING NOTE: On Web only, we inject the code that registers new Limbo\n    // targets based on view changes. This allows us to only depend on Limbo\n    // changes when user code includes queries.\n    syncEngineImpl.applyDocChanges = (queryView, changes, remoteEvent) => applyDocChanges(syncEngineImpl, queryView, changes, remoteEvent);\n    const queryResult = await localStoreExecuteQuery(syncEngineImpl.localStore, query, \n    /* usePreviousResults= */ true);\n    const view = new View(query, queryResult.remoteKeys);\n    const viewDocChanges = view.computeDocChanges(queryResult.documents);\n    const synthesizedTargetChange = TargetChange.createSynthesizedTargetChangeForCurrentChange(targetId, current && syncEngineImpl.onlineState !== \"Offline\" /* OnlineState.Offline */, resumeToken);\n    const viewChange = view.applyChanges(viewDocChanges, \n    /* limboResolutionEnabled= */ syncEngineImpl.isPrimaryClient, synthesizedTargetChange);\n    updateTrackedLimbos(syncEngineImpl, targetId, viewChange.limboChanges);\n    const data = new QueryView(query, targetId, view);\n    syncEngineImpl.queryViewsByQuery.set(query, data);\n    if (syncEngineImpl.queriesByTarget.has(targetId)) {\n        syncEngineImpl.queriesByTarget.get(targetId).push(query);\n    }\n    else {\n        syncEngineImpl.queriesByTarget.set(targetId, [query]);\n    }\n    return viewChange.snapshot;\n}\n/** Stops listening to the query. */\nasync function syncEngineUnlisten(syncEngine, query, shouldUnlistenToRemote) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const queryView = syncEngineImpl.queryViewsByQuery.get(query);\n    // Only clean up the query view and target if this is the only query mapped\n    // to the target.\n    const queries = syncEngineImpl.queriesByTarget.get(queryView.targetId);\n    if (queries.length > 1) {\n        syncEngineImpl.queriesByTarget.set(queryView.targetId, queries.filter(q => !queryEquals(q, query)));\n        syncEngineImpl.queryViewsByQuery.delete(query);\n        return;\n    }\n    // No other queries are mapped to the target, clean up the query and the target.\n    if (syncEngineImpl.isPrimaryClient) {\n        // We need to remove the local query target first to allow us to verify\n        // whether any other client is still interested in this target.\n        syncEngineImpl.sharedClientState.removeLocalQueryTarget(queryView.targetId);\n        const targetRemainsActive = syncEngineImpl.sharedClientState.isActiveQueryTarget(queryView.targetId);\n        if (!targetRemainsActive) {\n            await localStoreReleaseTarget(syncEngineImpl.localStore, queryView.targetId, \n            /*keepPersistedTargetData=*/ false)\n                .then(() => {\n                syncEngineImpl.sharedClientState.clearQueryState(queryView.targetId);\n                if (shouldUnlistenToRemote) {\n                    remoteStoreUnlisten(syncEngineImpl.remoteStore, queryView.targetId);\n                }\n                removeAndCleanupTarget(syncEngineImpl, queryView.targetId);\n            })\n                .catch(ignoreIfPrimaryLeaseLoss);\n        }\n    }\n    else {\n        removeAndCleanupTarget(syncEngineImpl, queryView.targetId);\n        await localStoreReleaseTarget(syncEngineImpl.localStore, queryView.targetId, \n        /*keepPersistedTargetData=*/ true);\n    }\n}\n/** Unlistens to the remote store while still listening to the cache. */\nasync function triggerRemoteStoreUnlisten(syncEngine, query) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const queryView = syncEngineImpl.queryViewsByQuery.get(query);\n    const queries = syncEngineImpl.queriesByTarget.get(queryView.targetId);\n    if (syncEngineImpl.isPrimaryClient && queries.length === 1) {\n        // PORTING NOTE: Unregister the target ID with local Firestore client as\n        // watch target.\n        syncEngineImpl.sharedClientState.removeLocalQueryTarget(queryView.targetId);\n        remoteStoreUnlisten(syncEngineImpl.remoteStore, queryView.targetId);\n    }\n}\n/**\n * Initiates the write of local mutation batch which involves adding the\n * writes to the mutation queue, notifying the remote store about new\n * mutations and raising events for any changes this write caused.\n *\n * The promise returned by this call is resolved when the above steps\n * have completed, *not* when the write was acked by the backend. The\n * userCallback is resolved once the write was acked/rejected by the\n * backend (or failed locally for any other reason).\n */\nasync function syncEngineWrite(syncEngine, batch, userCallback) {\n    const syncEngineImpl = syncEngineEnsureWriteCallbacks(syncEngine);\n    try {\n        const result = await localStoreWriteLocally(syncEngineImpl.localStore, batch);\n        syncEngineImpl.sharedClientState.addPendingMutation(result.batchId);\n        addMutationCallback(syncEngineImpl, result.batchId, userCallback);\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, result.changes);\n        await fillWritePipeline(syncEngineImpl.remoteStore);\n    }\n    catch (e) {\n        // If we can't persist the mutation, we reject the user callback and\n        // don't send the mutation. The user can then retry the write.\n        const error = wrapInUserErrorIfRecoverable(e, `Failed to persist write`);\n        userCallback.reject(error);\n    }\n}\n/**\n * Applies one remote event to the sync engine, notifying any views of the\n * changes, and releasing any pending mutation batches that would become\n * visible because of the snapshot version the remote event contains.\n */\nasync function syncEngineApplyRemoteEvent(syncEngine, remoteEvent) {\n    const syncEngineImpl = debugCast(syncEngine);\n    try {\n        const changes = await localStoreApplyRemoteEventToLocalCache(syncEngineImpl.localStore, remoteEvent);\n        // Update `receivedDocument` as appropriate for any limbo targets.\n        remoteEvent.targetChanges.forEach((targetChange, targetId) => {\n            const limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);\n            if (limboResolution) {\n                // Since this is a limbo resolution lookup, it's for a single document\n                // and it could be added, modified, or removed, but not a combination.\n                hardAssert(targetChange.addedDocuments.size +\n                    targetChange.modifiedDocuments.size +\n                    targetChange.removedDocuments.size <=\n                    1);\n                if (targetChange.addedDocuments.size > 0) {\n                    limboResolution.receivedDocument = true;\n                }\n                else if (targetChange.modifiedDocuments.size > 0) {\n                    hardAssert(limboResolution.receivedDocument);\n                }\n                else if (targetChange.removedDocuments.size > 0) {\n                    hardAssert(limboResolution.receivedDocument);\n                    limboResolution.receivedDocument = false;\n                }\n                else {\n                    // This was probably just a CURRENT targetChange or similar.\n                }\n            }\n        });\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes, remoteEvent);\n    }\n    catch (error) {\n        await ignoreIfPrimaryLeaseLoss(error);\n    }\n}\n/**\n * Applies an OnlineState change to the sync engine and notifies any views of\n * the change.\n */\nfunction syncEngineApplyOnlineStateChange(syncEngine, onlineState, source) {\n    const syncEngineImpl = debugCast(syncEngine);\n    // If we are the secondary client, we explicitly ignore the remote store's\n    // online state (the local client may go offline, even though the primary\n    // tab remains online) and only apply the primary tab's online state from\n    // SharedClientState.\n    if ((syncEngineImpl.isPrimaryClient &&\n        source === 0 /* OnlineStateSource.RemoteStore */) ||\n        (!syncEngineImpl.isPrimaryClient &&\n            source === 1 /* OnlineStateSource.SharedClientState */)) {\n        const newViewSnapshots = [];\n        syncEngineImpl.queryViewsByQuery.forEach((query, queryView) => {\n            const viewChange = queryView.view.applyOnlineStateChange(onlineState);\n            if (viewChange.snapshot) {\n                newViewSnapshots.push(viewChange.snapshot);\n            }\n        });\n        eventManagerOnOnlineStateChange(syncEngineImpl.eventManager, onlineState);\n        if (newViewSnapshots.length) {\n            syncEngineImpl.syncEngineListener.onWatchChange(newViewSnapshots);\n        }\n        syncEngineImpl.onlineState = onlineState;\n        if (syncEngineImpl.isPrimaryClient) {\n            syncEngineImpl.sharedClientState.setOnlineState(onlineState);\n        }\n    }\n}\n/**\n * Rejects the listen for the given targetID. This can be triggered by the\n * backend for any active target.\n *\n * @param syncEngine - The sync engine implementation.\n * @param targetId - The targetID corresponds to one previously initiated by the\n * user as part of TargetData passed to listen() on RemoteStore.\n * @param err - A description of the condition that has forced the rejection.\n * Nearly always this will be an indication that the user is no longer\n * authorized to see the data matching the target.\n */\nasync function syncEngineRejectListen(syncEngine, targetId, err) {\n    const syncEngineImpl = debugCast(syncEngine);\n    // PORTING NOTE: Multi-tab only.\n    syncEngineImpl.sharedClientState.updateQueryState(targetId, 'rejected', err);\n    const limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);\n    const limboKey = limboResolution && limboResolution.key;\n    if (limboKey) {\n        // TODO(klimt): We really only should do the following on permission\n        // denied errors, but we don't have the cause code here.\n        // It's a limbo doc. Create a synthetic event saying it was deleted.\n        // This is kind of a hack. Ideally, we would have a method in the local\n        // store to purge a document. However, it would be tricky to keep all of\n        // the local store's invariants with another method.\n        let documentUpdates = new SortedMap(DocumentKey.comparator);\n        // TODO(b/217189216): This limbo document should ideally have a read time,\n        // so that it is picked up by any read-time based scans. The backend,\n        // however, does not send a read time for target removals.\n        documentUpdates = documentUpdates.insert(limboKey, MutableDocument.newNoDocument(limboKey, SnapshotVersion.min()));\n        const resolvedLimboDocuments = documentKeySet().add(limboKey);\n        const event = new RemoteEvent(SnapshotVersion.min(), \n        /* targetChanges= */ new Map(), \n        /* targetMismatches= */ new SortedMap(primitiveComparator), documentUpdates, resolvedLimboDocuments);\n        await syncEngineApplyRemoteEvent(syncEngineImpl, event);\n        // Since this query failed, we won't want to manually unlisten to it.\n        // We only remove it from bookkeeping after we successfully applied the\n        // RemoteEvent. If `applyRemoteEvent()` throws, we want to re-listen to\n        // this query when the RemoteStore restarts the Watch stream, which should\n        // re-trigger the target failure.\n        syncEngineImpl.activeLimboTargetsByKey =\n            syncEngineImpl.activeLimboTargetsByKey.remove(limboKey);\n        syncEngineImpl.activeLimboResolutionsByTarget.delete(targetId);\n        pumpEnqueuedLimboResolutions(syncEngineImpl);\n    }\n    else {\n        await localStoreReleaseTarget(syncEngineImpl.localStore, targetId, \n        /* keepPersistedTargetData */ false)\n            .then(() => removeAndCleanupTarget(syncEngineImpl, targetId, err))\n            .catch(ignoreIfPrimaryLeaseLoss);\n    }\n}\nasync function syncEngineApplySuccessfulWrite(syncEngine, mutationBatchResult) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const batchId = mutationBatchResult.batch.batchId;\n    try {\n        const changes = await localStoreAcknowledgeBatch(syncEngineImpl.localStore, mutationBatchResult);\n        // The local store may or may not be able to apply the write result and\n        // raise events immediately (depending on whether the watcher is caught\n        // up), so we raise user callbacks first so that they consistently happen\n        // before listen events.\n        processUserCallback(syncEngineImpl, batchId, /*error=*/ null);\n        triggerPendingWritesCallbacks(syncEngineImpl, batchId);\n        syncEngineImpl.sharedClientState.updateMutationState(batchId, 'acknowledged');\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes);\n    }\n    catch (error) {\n        await ignoreIfPrimaryLeaseLoss(error);\n    }\n}\nasync function syncEngineRejectFailedWrite(syncEngine, batchId, error) {\n    const syncEngineImpl = debugCast(syncEngine);\n    try {\n        const changes = await localStoreRejectBatch(syncEngineImpl.localStore, batchId);\n        // The local store may or may not be able to apply the write result and\n        // raise events immediately (depending on whether the watcher is caught up),\n        // so we raise user callbacks first so that they consistently happen before\n        // listen events.\n        processUserCallback(syncEngineImpl, batchId, error);\n        triggerPendingWritesCallbacks(syncEngineImpl, batchId);\n        syncEngineImpl.sharedClientState.updateMutationState(batchId, 'rejected', error);\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes);\n    }\n    catch (error) {\n        await ignoreIfPrimaryLeaseLoss(error);\n    }\n}\n/**\n * Registers a user callback that resolves when all pending mutations at the moment of calling\n * are acknowledged .\n */\nasync function syncEngineRegisterPendingWritesCallback(syncEngine, callback) {\n    const syncEngineImpl = debugCast(syncEngine);\n    if (!canUseNetwork(syncEngineImpl.remoteStore)) {\n        logDebug(LOG_TAG$3, 'The network is disabled. The task returned by ' +\n            \"'awaitPendingWrites()' will not complete until the network is enabled.\");\n    }\n    try {\n        const highestBatchId = await localStoreGetHighestUnacknowledgedBatchId(syncEngineImpl.localStore);\n        if (highestBatchId === BATCHID_UNKNOWN) {\n            // Trigger the callback right away if there is no pending writes at the moment.\n            callback.resolve();\n            return;\n        }\n        const callbacks = syncEngineImpl.pendingWritesCallbacks.get(highestBatchId) || [];\n        callbacks.push(callback);\n        syncEngineImpl.pendingWritesCallbacks.set(highestBatchId, callbacks);\n    }\n    catch (e) {\n        const firestoreError = wrapInUserErrorIfRecoverable(e, 'Initialization of waitForPendingWrites() operation failed');\n        callback.reject(firestoreError);\n    }\n}\n/**\n * Triggers the callbacks that are waiting for this batch id to get acknowledged by server,\n * if there are any.\n */\nfunction triggerPendingWritesCallbacks(syncEngineImpl, batchId) {\n    (syncEngineImpl.pendingWritesCallbacks.get(batchId) || []).forEach(callback => {\n        callback.resolve();\n    });\n    syncEngineImpl.pendingWritesCallbacks.delete(batchId);\n}\n/** Reject all outstanding callbacks waiting for pending writes to complete. */\nfunction rejectOutstandingPendingWritesCallbacks(syncEngineImpl, errorMessage) {\n    syncEngineImpl.pendingWritesCallbacks.forEach(callbacks => {\n        callbacks.forEach(callback => {\n            callback.reject(new FirestoreError(Code.CANCELLED, errorMessage));\n        });\n    });\n    syncEngineImpl.pendingWritesCallbacks.clear();\n}\nfunction addMutationCallback(syncEngineImpl, batchId, callback) {\n    let newCallbacks = syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()];\n    if (!newCallbacks) {\n        newCallbacks = new SortedMap(primitiveComparator);\n    }\n    newCallbacks = newCallbacks.insert(batchId, callback);\n    syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()] =\n        newCallbacks;\n}\n/**\n * Resolves or rejects the user callback for the given batch and then discards\n * it.\n */\nfunction processUserCallback(syncEngine, batchId, error) {\n    const syncEngineImpl = debugCast(syncEngine);\n    let newCallbacks = syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()];\n    // NOTE: Mutations restored from persistence won't have callbacks, so it's\n    // okay for there to be no callback for this ID.\n    if (newCallbacks) {\n        const callback = newCallbacks.get(batchId);\n        if (callback) {\n            if (error) {\n                callback.reject(error);\n            }\n            else {\n                callback.resolve();\n            }\n            newCallbacks = newCallbacks.remove(batchId);\n        }\n        syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()] =\n            newCallbacks;\n    }\n}\nfunction removeAndCleanupTarget(syncEngineImpl, targetId, error = null) {\n    syncEngineImpl.sharedClientState.removeLocalQueryTarget(targetId);\n    for (const query of syncEngineImpl.queriesByTarget.get(targetId)) {\n        syncEngineImpl.queryViewsByQuery.delete(query);\n        if (error) {\n            syncEngineImpl.syncEngineListener.onWatchError(query, error);\n        }\n    }\n    syncEngineImpl.queriesByTarget.delete(targetId);\n    if (syncEngineImpl.isPrimaryClient) {\n        const limboKeys = syncEngineImpl.limboDocumentRefs.removeReferencesForId(targetId);\n        limboKeys.forEach(limboKey => {\n            const isReferenced = syncEngineImpl.limboDocumentRefs.containsKey(limboKey);\n            if (!isReferenced) {\n                // We removed the last reference for this key\n                removeLimboTarget(syncEngineImpl, limboKey);\n            }\n        });\n    }\n}\nfunction removeLimboTarget(syncEngineImpl, key) {\n    syncEngineImpl.enqueuedLimboResolutions.delete(key.path.canonicalString());\n    // It's possible that the target already got removed because the query failed. In that case,\n    // the key won't exist in `limboTargetsByKey`. Only do the cleanup if we still have the target.\n    const limboTargetId = syncEngineImpl.activeLimboTargetsByKey.get(key);\n    if (limboTargetId === null) {\n        // This target already got removed, because the query failed.\n        return;\n    }\n    remoteStoreUnlisten(syncEngineImpl.remoteStore, limboTargetId);\n    syncEngineImpl.activeLimboTargetsByKey =\n        syncEngineImpl.activeLimboTargetsByKey.remove(key);\n    syncEngineImpl.activeLimboResolutionsByTarget.delete(limboTargetId);\n    pumpEnqueuedLimboResolutions(syncEngineImpl);\n}\nfunction updateTrackedLimbos(syncEngineImpl, targetId, limboChanges) {\n    for (const limboChange of limboChanges) {\n        if (limboChange instanceof AddedLimboDocument) {\n            syncEngineImpl.limboDocumentRefs.addReference(limboChange.key, targetId);\n            trackLimboChange(syncEngineImpl, limboChange);\n        }\n        else if (limboChange instanceof RemovedLimboDocument) {\n            logDebug(LOG_TAG$3, 'Document no longer in limbo: ' + limboChange.key);\n            syncEngineImpl.limboDocumentRefs.removeReference(limboChange.key, targetId);\n            const isReferenced = syncEngineImpl.limboDocumentRefs.containsKey(limboChange.key);\n            if (!isReferenced) {\n                // We removed the last reference for this key\n                removeLimboTarget(syncEngineImpl, limboChange.key);\n            }\n        }\n        else {\n            fail();\n        }\n    }\n}\nfunction trackLimboChange(syncEngineImpl, limboChange) {\n    const key = limboChange.key;\n    const keyString = key.path.canonicalString();\n    if (!syncEngineImpl.activeLimboTargetsByKey.get(key) &&\n        !syncEngineImpl.enqueuedLimboResolutions.has(keyString)) {\n        logDebug(LOG_TAG$3, 'New document in limbo: ' + key);\n        syncEngineImpl.enqueuedLimboResolutions.add(keyString);\n        pumpEnqueuedLimboResolutions(syncEngineImpl);\n    }\n}\n/**\n * Starts listens for documents in limbo that are enqueued for resolution,\n * subject to a maximum number of concurrent resolutions.\n *\n * Without bounding the number of concurrent resolutions, the server can fail\n * with \"resource exhausted\" errors which can lead to pathological client\n * behavior as seen in https://github.com/firebase/firebase-js-sdk/issues/2683.\n */\nfunction pumpEnqueuedLimboResolutions(syncEngineImpl) {\n    while (syncEngineImpl.enqueuedLimboResolutions.size > 0 &&\n        syncEngineImpl.activeLimboTargetsByKey.size <\n            syncEngineImpl.maxConcurrentLimboResolutions) {\n        const keyString = syncEngineImpl.enqueuedLimboResolutions\n            .values()\n            .next().value;\n        syncEngineImpl.enqueuedLimboResolutions.delete(keyString);\n        const key = new DocumentKey(ResourcePath.fromString(keyString));\n        const limboTargetId = syncEngineImpl.limboTargetIdGenerator.next();\n        syncEngineImpl.activeLimboResolutionsByTarget.set(limboTargetId, new LimboResolution(key));\n        syncEngineImpl.activeLimboTargetsByKey =\n            syncEngineImpl.activeLimboTargetsByKey.insert(key, limboTargetId);\n        remoteStoreListen(syncEngineImpl.remoteStore, new TargetData(queryToTarget(newQueryForPath(key.path)), limboTargetId, \"TargetPurposeLimboResolution\" /* TargetPurpose.LimboResolution */, ListenSequence.INVALID));\n    }\n}\nasync function syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngine, changes, remoteEvent) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const newSnaps = [];\n    const docChangesInAllViews = [];\n    const queriesProcessed = [];\n    if (syncEngineImpl.queryViewsByQuery.isEmpty()) {\n        // Return early since `onWatchChange()` might not have been assigned yet.\n        return;\n    }\n    syncEngineImpl.queryViewsByQuery.forEach((_, queryView) => {\n        queriesProcessed.push(syncEngineImpl\n            .applyDocChanges(queryView, changes, remoteEvent)\n            .then(viewSnapshot => {\n            var _a;\n            // If there are changes, or we are handling a global snapshot, notify\n            // secondary clients to update query state.\n            if (viewSnapshot || remoteEvent) {\n                if (syncEngineImpl.isPrimaryClient) {\n                    // Query state is set to `current` if:\n                    // - There is a view change and it is up-to-date, or,\n                    // - There is a global snapshot, the Target is current, and no changes to be resolved\n                    const isCurrent = viewSnapshot\n                        ? !viewSnapshot.fromCache\n                        : (_a = remoteEvent === null || remoteEvent === void 0 ? void 0 : remoteEvent.targetChanges.get(queryView.targetId)) === null || _a === void 0 ? void 0 : _a.current;\n                    syncEngineImpl.sharedClientState.updateQueryState(queryView.targetId, isCurrent ? 'current' : 'not-current');\n                }\n            }\n            // Update views if there are actual changes.\n            if (!!viewSnapshot) {\n                newSnaps.push(viewSnapshot);\n                const docChanges = LocalViewChanges.fromSnapshot(queryView.targetId, viewSnapshot);\n                docChangesInAllViews.push(docChanges);\n            }\n        }));\n    });\n    await Promise.all(queriesProcessed);\n    syncEngineImpl.syncEngineListener.onWatchChange(newSnaps);\n    await localStoreNotifyLocalViewChanges(syncEngineImpl.localStore, docChangesInAllViews);\n}\nasync function applyDocChanges(syncEngineImpl, queryView, changes, remoteEvent) {\n    let viewDocChanges = queryView.view.computeDocChanges(changes);\n    if (viewDocChanges.needsRefill) {\n        // The query has a limit and some docs were removed, so we need\n        // to re-run the query against the local store to make sure we\n        // didn't lose any good docs that had been past the limit.\n        viewDocChanges = await localStoreExecuteQuery(syncEngineImpl.localStore, queryView.query, \n        /* usePreviousResults= */ false).then(({ documents }) => {\n            return queryView.view.computeDocChanges(documents, viewDocChanges);\n        });\n    }\n    const targetChange = remoteEvent && remoteEvent.targetChanges.get(queryView.targetId);\n    const targetIsPendingReset = remoteEvent && remoteEvent.targetMismatches.get(queryView.targetId) != null;\n    const viewChange = queryView.view.applyChanges(viewDocChanges, \n    /* limboResolutionEnabled= */ syncEngineImpl.isPrimaryClient, targetChange, targetIsPendingReset);\n    updateTrackedLimbos(syncEngineImpl, queryView.targetId, viewChange.limboChanges);\n    return viewChange.snapshot;\n}\nasync function syncEngineHandleCredentialChange(syncEngine, user) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const userChanged = !syncEngineImpl.currentUser.isEqual(user);\n    if (userChanged) {\n        logDebug(LOG_TAG$3, 'User change. New user:', user.toKey());\n        const result = await localStoreHandleUserChange(syncEngineImpl.localStore, user);\n        syncEngineImpl.currentUser = user;\n        // Fails tasks waiting for pending writes requested by previous user.\n        rejectOutstandingPendingWritesCallbacks(syncEngineImpl, \"'waitForPendingWrites' promise is rejected due to a user change.\");\n        // TODO(b/114226417): Consider calling this only in the primary tab.\n        syncEngineImpl.sharedClientState.handleUserChange(user, result.removedBatchIds, result.addedBatchIds);\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, result.affectedDocuments);\n    }\n}\nfunction syncEngineGetRemoteKeysForTarget(syncEngine, targetId) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);\n    if (limboResolution && limboResolution.receivedDocument) {\n        return documentKeySet().add(limboResolution.key);\n    }\n    else {\n        let keySet = documentKeySet();\n        const queries = syncEngineImpl.queriesByTarget.get(targetId);\n        if (!queries) {\n            return keySet;\n        }\n        for (const query of queries) {\n            const queryView = syncEngineImpl.queryViewsByQuery.get(query);\n            keySet = keySet.unionWith(queryView.view.syncedDocuments);\n        }\n        return keySet;\n    }\n}\n/**\n * Reconcile the list of synced documents in an existing view with those\n * from persistence.\n */\nasync function synchronizeViewAndComputeSnapshot(syncEngine, queryView) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const queryResult = await localStoreExecuteQuery(syncEngineImpl.localStore, queryView.query, \n    /* usePreviousResults= */ true);\n    const viewSnapshot = queryView.view.synchronizeWithPersistedState(queryResult);\n    if (syncEngineImpl.isPrimaryClient) {\n        updateTrackedLimbos(syncEngineImpl, queryView.targetId, viewSnapshot.limboChanges);\n    }\n    return viewSnapshot;\n}\n/**\n * Retrieves newly changed documents from remote document cache and raises\n * snapshots if needed.\n */\n// PORTING NOTE: Multi-Tab only.\nasync function syncEngineSynchronizeWithChangedDocuments(syncEngine, collectionGroup) {\n    const syncEngineImpl = debugCast(syncEngine);\n    return localStoreGetNewDocumentChanges(syncEngineImpl.localStore, collectionGroup).then(changes => syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes));\n}\n/** Applies a mutation state to an existing batch.  */\n// PORTING NOTE: Multi-Tab only.\nasync function syncEngineApplyBatchState(syncEngine, batchId, batchState, error) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const documents = await localStoreLookupMutationDocuments(syncEngineImpl.localStore, batchId);\n    if (documents === null) {\n        // A throttled tab may not have seen the mutation before it was completed\n        // and removed from the mutation queue, in which case we won't have cached\n        // the affected documents. In this case we can safely ignore the update\n        // since that means we didn't apply the mutation locally at all (if we\n        // had, we would have cached the affected documents), and so we will just\n        // see any resulting document changes via normal remote document updates\n        // as applicable.\n        logDebug(LOG_TAG$3, 'Cannot apply mutation batch with id: ' + batchId);\n        return;\n    }\n    if (batchState === 'pending') {\n        // If we are the primary client, we need to send this write to the\n        // backend. Secondary clients will ignore these writes since their remote\n        // connection is disabled.\n        await fillWritePipeline(syncEngineImpl.remoteStore);\n    }\n    else if (batchState === 'acknowledged' || batchState === 'rejected') {\n        // NOTE: Both these methods are no-ops for batches that originated from\n        // other clients.\n        processUserCallback(syncEngineImpl, batchId, error ? error : null);\n        triggerPendingWritesCallbacks(syncEngineImpl, batchId);\n        localStoreRemoveCachedMutationBatchMetadata(syncEngineImpl.localStore, batchId);\n    }\n    else {\n        fail();\n    }\n    await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, documents);\n}\n/** Applies a query target change from a different tab. */\n// PORTING NOTE: Multi-Tab only.\nasync function syncEngineApplyPrimaryState(syncEngine, isPrimary) {\n    const syncEngineImpl = debugCast(syncEngine);\n    ensureWatchCallbacks(syncEngineImpl);\n    syncEngineEnsureWriteCallbacks(syncEngineImpl);\n    if (isPrimary === true && syncEngineImpl._isPrimaryClient !== true) {\n        // Secondary tabs only maintain Views for their local listeners and the\n        // Views internal state may not be 100% populated (in particular\n        // secondary tabs don't track syncedDocuments, the set of documents the\n        // server considers to be in the target). So when a secondary becomes\n        // primary, we need to need to make sure that all views for all targets\n        // match the state on disk.\n        const activeTargets = syncEngineImpl.sharedClientState.getAllActiveQueryTargets();\n        const activeQueries = await synchronizeQueryViewsAndRaiseSnapshots(syncEngineImpl, activeTargets.toArray());\n        syncEngineImpl._isPrimaryClient = true;\n        await remoteStoreApplyPrimaryState(syncEngineImpl.remoteStore, true);\n        for (const targetData of activeQueries) {\n            remoteStoreListen(syncEngineImpl.remoteStore, targetData);\n        }\n    }\n    else if (isPrimary === false && syncEngineImpl._isPrimaryClient !== false) {\n        const activeTargets = [];\n        let p = Promise.resolve();\n        syncEngineImpl.queriesByTarget.forEach((_, targetId) => {\n            if (syncEngineImpl.sharedClientState.isLocalQueryTarget(targetId)) {\n                activeTargets.push(targetId);\n            }\n            else {\n                p = p.then(() => {\n                    removeAndCleanupTarget(syncEngineImpl, targetId);\n                    return localStoreReleaseTarget(syncEngineImpl.localStore, targetId, \n                    /*keepPersistedTargetData=*/ true);\n                });\n            }\n            remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId);\n        });\n        await p;\n        await synchronizeQueryViewsAndRaiseSnapshots(syncEngineImpl, activeTargets);\n        resetLimboDocuments(syncEngineImpl);\n        syncEngineImpl._isPrimaryClient = false;\n        await remoteStoreApplyPrimaryState(syncEngineImpl.remoteStore, false);\n    }\n}\n// PORTING NOTE: Multi-Tab only.\nfunction resetLimboDocuments(syncEngine) {\n    const syncEngineImpl = debugCast(syncEngine);\n    syncEngineImpl.activeLimboResolutionsByTarget.forEach((_, targetId) => {\n        remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId);\n    });\n    syncEngineImpl.limboDocumentRefs.removeAllReferences();\n    syncEngineImpl.activeLimboResolutionsByTarget = new Map();\n    syncEngineImpl.activeLimboTargetsByKey = new SortedMap(DocumentKey.comparator);\n}\n/**\n * Reconcile the query views of the provided query targets with the state from\n * persistence. Raises snapshots for any changes that affect the local\n * client and returns the updated state of all target's query data.\n *\n * @param syncEngine - The sync engine implementation\n * @param targets - the list of targets with views that need to be recomputed\n * @param transitionToPrimary - `true` iff the tab transitions from a secondary\n * tab to a primary tab\n */\n// PORTING NOTE: Multi-Tab only.\nasync function synchronizeQueryViewsAndRaiseSnapshots(syncEngine, targets, transitionToPrimary) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const activeQueries = [];\n    const newViewSnapshots = [];\n    for (const targetId of targets) {\n        let targetData;\n        const queries = syncEngineImpl.queriesByTarget.get(targetId);\n        if (queries && queries.length !== 0) {\n            // For queries that have a local View, we fetch their current state\n            // from LocalStore (as the resume token and the snapshot version\n            // might have changed) and reconcile their views with the persisted\n            // state (the list of syncedDocuments may have gotten out of sync).\n            targetData = await localStoreAllocateTarget(syncEngineImpl.localStore, queryToTarget(queries[0]));\n            for (const query of queries) {\n                const queryView = syncEngineImpl.queryViewsByQuery.get(query);\n                const viewChange = await synchronizeViewAndComputeSnapshot(syncEngineImpl, queryView);\n                if (viewChange.snapshot) {\n                    newViewSnapshots.push(viewChange.snapshot);\n                }\n            }\n        }\n        else {\n            // For queries that never executed on this client, we need to\n            // allocate the target in LocalStore and initialize a new View.\n            const target = await localStoreGetCachedTarget(syncEngineImpl.localStore, targetId);\n            targetData = await localStoreAllocateTarget(syncEngineImpl.localStore, target);\n            await initializeViewAndComputeSnapshot(syncEngineImpl, synthesizeTargetToQuery(target), targetId, \n            /*current=*/ false, targetData.resumeToken);\n        }\n        activeQueries.push(targetData);\n    }\n    syncEngineImpl.syncEngineListener.onWatchChange(newViewSnapshots);\n    return activeQueries;\n}\n/**\n * Creates a `Query` object from the specified `Target`. There is no way to\n * obtain the original `Query`, so we synthesize a `Query` from the `Target`\n * object.\n *\n * The synthesized result might be different from the original `Query`, but\n * since the synthesized `Query` should return the same results as the\n * original one (only the presentation of results might differ), the potential\n * difference will not cause issues.\n */\n// PORTING NOTE: Multi-Tab only.\nfunction synthesizeTargetToQuery(target) {\n    return newQuery(target.path, target.collectionGroup, target.orderBy, target.filters, target.limit, \"F\" /* LimitType.First */, target.startAt, target.endAt);\n}\n/** Returns the IDs of the clients that are currently active. */\n// PORTING NOTE: Multi-Tab only.\nfunction syncEngineGetActiveClients(syncEngine) {\n    const syncEngineImpl = debugCast(syncEngine);\n    return localStoreGetActiveClients(syncEngineImpl.localStore);\n}\n/** Applies a query target change from a different tab. */\n// PORTING NOTE: Multi-Tab only.\nasync function syncEngineApplyTargetState(syncEngine, targetId, state, error) {\n    const syncEngineImpl = debugCast(syncEngine);\n    if (syncEngineImpl._isPrimaryClient) {\n        // If we receive a target state notification via WebStorage, we are\n        // either already secondary or another tab has taken the primary lease.\n        logDebug(LOG_TAG$3, 'Ignoring unexpected query state notification.');\n        return;\n    }\n    const query = syncEngineImpl.queriesByTarget.get(targetId);\n    if (query && query.length > 0) {\n        switch (state) {\n            case 'current':\n            case 'not-current': {\n                const changes = await localStoreGetNewDocumentChanges(syncEngineImpl.localStore, queryCollectionGroup(query[0]));\n                const synthesizedRemoteEvent = RemoteEvent.createSynthesizedRemoteEventForCurrentChange(targetId, state === 'current', ByteString.EMPTY_BYTE_STRING);\n                await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes, synthesizedRemoteEvent);\n                break;\n            }\n            case 'rejected': {\n                await localStoreReleaseTarget(syncEngineImpl.localStore, targetId, \n                /* keepPersistedTargetData */ true);\n                removeAndCleanupTarget(syncEngineImpl, targetId, error);\n                break;\n            }\n            default:\n                fail();\n        }\n    }\n}\n/** Adds or removes Watch targets for queries from different tabs. */\nasync function syncEngineApplyActiveTargetsChange(syncEngine, added, removed) {\n    const syncEngineImpl = ensureWatchCallbacks(syncEngine);\n    if (!syncEngineImpl._isPrimaryClient) {\n        return;\n    }\n    for (const targetId of added) {\n        // A target is already listening to remote store if it is already registered to\n        // sharedClientState.\n        const targetAlreadyListeningToRemoteStore = syncEngineImpl.queriesByTarget.has(targetId) &&\n            syncEngineImpl.sharedClientState.isActiveQueryTarget(targetId);\n        if (targetAlreadyListeningToRemoteStore) {\n            logDebug(LOG_TAG$3, 'Adding an already active target ' + targetId);\n            continue;\n        }\n        const target = await localStoreGetCachedTarget(syncEngineImpl.localStore, targetId);\n        const targetData = await localStoreAllocateTarget(syncEngineImpl.localStore, target);\n        await initializeViewAndComputeSnapshot(syncEngineImpl, synthesizeTargetToQuery(target), targetData.targetId, \n        /*current=*/ false, targetData.resumeToken);\n        remoteStoreListen(syncEngineImpl.remoteStore, targetData);\n    }\n    for (const targetId of removed) {\n        // Check that the target is still active since the target might have been\n        // removed if it has been rejected by the backend.\n        if (!syncEngineImpl.queriesByTarget.has(targetId)) {\n            continue;\n        }\n        // Release queries that are still active.\n        await localStoreReleaseTarget(syncEngineImpl.localStore, targetId, \n        /* keepPersistedTargetData */ false)\n            .then(() => {\n            remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId);\n            removeAndCleanupTarget(syncEngineImpl, targetId);\n        })\n            .catch(ignoreIfPrimaryLeaseLoss);\n    }\n}\nfunction ensureWatchCallbacks(syncEngine) {\n    const syncEngineImpl = debugCast(syncEngine);\n    syncEngineImpl.remoteStore.remoteSyncer.applyRemoteEvent =\n        syncEngineApplyRemoteEvent.bind(null, syncEngineImpl);\n    syncEngineImpl.remoteStore.remoteSyncer.getRemoteKeysForTarget =\n        syncEngineGetRemoteKeysForTarget.bind(null, syncEngineImpl);\n    syncEngineImpl.remoteStore.remoteSyncer.rejectListen =\n        syncEngineRejectListen.bind(null, syncEngineImpl);\n    syncEngineImpl.syncEngineListener.onWatchChange =\n        eventManagerOnWatchChange.bind(null, syncEngineImpl.eventManager);\n    syncEngineImpl.syncEngineListener.onWatchError =\n        eventManagerOnWatchError.bind(null, syncEngineImpl.eventManager);\n    return syncEngineImpl;\n}\nfunction syncEngineEnsureWriteCallbacks(syncEngine) {\n    const syncEngineImpl = debugCast(syncEngine);\n    syncEngineImpl.remoteStore.remoteSyncer.applySuccessfulWrite =\n        syncEngineApplySuccessfulWrite.bind(null, syncEngineImpl);\n    syncEngineImpl.remoteStore.remoteSyncer.rejectFailedWrite =\n        syncEngineRejectFailedWrite.bind(null, syncEngineImpl);\n    return syncEngineImpl;\n}\n/**\n * Loads a Firestore bundle into the SDK. The returned promise resolves when\n * the bundle finished loading.\n *\n * @param syncEngine - SyncEngine to use.\n * @param bundleReader - Bundle to load into the SDK.\n * @param task - LoadBundleTask used to update the loading progress to public API.\n */\nfunction syncEngineLoadBundle(syncEngine, bundleReader, task) {\n    const syncEngineImpl = debugCast(syncEngine);\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    loadBundleImpl(syncEngineImpl, bundleReader, task).then(collectionGroups => {\n        syncEngineImpl.sharedClientState.notifyBundleLoaded(collectionGroups);\n    });\n}\n/** Loads a bundle and returns the list of affected collection groups. */\nasync function loadBundleImpl(syncEngine, reader, task) {\n    try {\n        const metadata = await reader.getMetadata();\n        const skip = await localStoreHasNewerBundle(syncEngine.localStore, metadata);\n        if (skip) {\n            await reader.close();\n            task._completeWith(bundleSuccessProgress(metadata));\n            return Promise.resolve(new Set());\n        }\n        task._updateProgress(bundleInitialProgress(metadata));\n        const loader = new BundleLoader(metadata, syncEngine.localStore, reader.serializer);\n        let element = await reader.nextElement();\n        while (element) {\n            ;\n            const progress = await loader.addSizedElement(element);\n            if (progress) {\n                task._updateProgress(progress);\n            }\n            element = await reader.nextElement();\n        }\n        const result = await loader.complete();\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngine, result.changedDocs, \n        /* remoteEvent */ undefined);\n        // Save metadata, so loading the same bundle will skip.\n        await localStoreSaveBundle(syncEngine.localStore, metadata);\n        task._completeWith(result.progress);\n        return Promise.resolve(result.changedCollectionGroups);\n    }\n    catch (e) {\n        logWarn(LOG_TAG$3, `Loading bundle failed with ${e}`);\n        task._failWith(e);\n        return Promise.resolve(new Set());\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provides all components needed for Firestore with in-memory persistence.\n * Uses EagerGC garbage collection.\n */\nclass MemoryOfflineComponentProvider {\n    constructor() {\n        this.kind = 'memory';\n        this.synchronizeTabs = false;\n    }\n    async initialize(cfg) {\n        this.serializer = newSerializer(cfg.databaseInfo.databaseId);\n        this.sharedClientState = this.createSharedClientState(cfg);\n        this.persistence = this.createPersistence(cfg);\n        await this.persistence.start();\n        this.localStore = this.createLocalStore(cfg);\n        this.gcScheduler = this.createGarbageCollectionScheduler(cfg, this.localStore);\n        this.indexBackfillerScheduler = this.createIndexBackfillerScheduler(cfg, this.localStore);\n    }\n    createGarbageCollectionScheduler(cfg, localStore) {\n        return null;\n    }\n    createIndexBackfillerScheduler(cfg, localStore) {\n        return null;\n    }\n    createLocalStore(cfg) {\n        return newLocalStore(this.persistence, new QueryEngine(), cfg.initialUser, this.serializer);\n    }\n    createPersistence(cfg) {\n        return new MemoryPersistence(MemoryEagerDelegate.factory, this.serializer);\n    }\n    createSharedClientState(cfg) {\n        return new MemorySharedClientState();\n    }\n    async terminate() {\n        var _a, _b;\n        (_a = this.gcScheduler) === null || _a === void 0 ? void 0 : _a.stop();\n        (_b = this.indexBackfillerScheduler) === null || _b === void 0 ? void 0 : _b.stop();\n        this.sharedClientState.shutdown();\n        await this.persistence.shutdown();\n    }\n}\nMemoryOfflineComponentProvider.provider = {\n    build: () => new MemoryOfflineComponentProvider()\n};\nclass LruGcMemoryOfflineComponentProvider extends MemoryOfflineComponentProvider {\n    constructor(cacheSizeBytes) {\n        super();\n        this.cacheSizeBytes = cacheSizeBytes;\n    }\n    createGarbageCollectionScheduler(cfg, localStore) {\n        hardAssert(this.persistence.referenceDelegate instanceof MemoryLruDelegate);\n        const garbageCollector = this.persistence.referenceDelegate.garbageCollector;\n        return new LruScheduler(garbageCollector, cfg.asyncQueue, localStore);\n    }\n    createPersistence(cfg) {\n        const lruParams = this.cacheSizeBytes !== undefined\n            ? LruParams.withCacheSize(this.cacheSizeBytes)\n            : LruParams.DEFAULT;\n        return new MemoryPersistence(p => MemoryLruDelegate.factory(p, lruParams), this.serializer);\n    }\n}\n/**\n * Provides all components needed for Firestore with IndexedDB persistence.\n */\nclass IndexedDbOfflineComponentProvider extends MemoryOfflineComponentProvider {\n    constructor(onlineComponentProvider, cacheSizeBytes, forceOwnership) {\n        super();\n        this.onlineComponentProvider = onlineComponentProvider;\n        this.cacheSizeBytes = cacheSizeBytes;\n        this.forceOwnership = forceOwnership;\n        this.kind = 'persistent';\n        this.synchronizeTabs = false;\n    }\n    async initialize(cfg) {\n        await super.initialize(cfg);\n        await this.onlineComponentProvider.initialize(this, cfg);\n        // Enqueue writes from a previous session\n        await syncEngineEnsureWriteCallbacks(this.onlineComponentProvider.syncEngine);\n        await fillWritePipeline(this.onlineComponentProvider.remoteStore);\n        // NOTE: This will immediately call the listener, so we make sure to\n        // set it after localStore / remoteStore are started.\n        await this.persistence.setPrimaryStateListener(() => {\n            if (this.gcScheduler && !this.gcScheduler.started) {\n                this.gcScheduler.start();\n            }\n            if (this.indexBackfillerScheduler &&\n                !this.indexBackfillerScheduler.started) {\n                this.indexBackfillerScheduler.start();\n            }\n            return Promise.resolve();\n        });\n    }\n    createLocalStore(cfg) {\n        return newLocalStore(this.persistence, new QueryEngine(), cfg.initialUser, this.serializer);\n    }\n    createGarbageCollectionScheduler(cfg, localStore) {\n        const garbageCollector = this.persistence.referenceDelegate.garbageCollector;\n        return new LruScheduler(garbageCollector, cfg.asyncQueue, localStore);\n    }\n    createIndexBackfillerScheduler(cfg, localStore) {\n        const indexBackfiller = new IndexBackfiller(localStore, this.persistence);\n        return new IndexBackfillerScheduler(cfg.asyncQueue, indexBackfiller);\n    }\n    createPersistence(cfg) {\n        const persistenceKey = indexedDbStoragePrefix(cfg.databaseInfo.databaseId, cfg.databaseInfo.persistenceKey);\n        const lruParams = this.cacheSizeBytes !== undefined\n            ? LruParams.withCacheSize(this.cacheSizeBytes)\n            : LruParams.DEFAULT;\n        return new IndexedDbPersistence(this.synchronizeTabs, persistenceKey, cfg.clientId, lruParams, cfg.asyncQueue, getWindow(), getDocument(), this.serializer, this.sharedClientState, !!this.forceOwnership);\n    }\n    createSharedClientState(cfg) {\n        return new MemorySharedClientState();\n    }\n}\n/**\n * Provides all components needed for Firestore with multi-tab IndexedDB\n * persistence.\n *\n * In the legacy client, this provider is used to provide both multi-tab and\n * non-multi-tab persistence since we cannot tell at build time whether\n * `synchronizeTabs` will be enabled.\n */\nclass MultiTabOfflineComponentProvider extends IndexedDbOfflineComponentProvider {\n    constructor(onlineComponentProvider, cacheSizeBytes) {\n        super(onlineComponentProvider, cacheSizeBytes, /* forceOwnership= */ false);\n        this.onlineComponentProvider = onlineComponentProvider;\n        this.cacheSizeBytes = cacheSizeBytes;\n        this.synchronizeTabs = true;\n    }\n    async initialize(cfg) {\n        await super.initialize(cfg);\n        const syncEngine = this.onlineComponentProvider.syncEngine;\n        if (this.sharedClientState instanceof WebStorageSharedClientState) {\n            this.sharedClientState.syncEngine = {\n                applyBatchState: syncEngineApplyBatchState.bind(null, syncEngine),\n                applyTargetState: syncEngineApplyTargetState.bind(null, syncEngine),\n                applyActiveTargetsChange: syncEngineApplyActiveTargetsChange.bind(null, syncEngine),\n                getActiveClients: syncEngineGetActiveClients.bind(null, syncEngine),\n                synchronizeWithChangedDocuments: syncEngineSynchronizeWithChangedDocuments.bind(null, syncEngine)\n            };\n            await this.sharedClientState.start();\n        }\n        // NOTE: This will immediately call the listener, so we make sure to\n        // set it after localStore / remoteStore are started.\n        await this.persistence.setPrimaryStateListener(async (isPrimary) => {\n            await syncEngineApplyPrimaryState(this.onlineComponentProvider.syncEngine, isPrimary);\n            if (this.gcScheduler) {\n                if (isPrimary && !this.gcScheduler.started) {\n                    this.gcScheduler.start();\n                }\n                else if (!isPrimary) {\n                    this.gcScheduler.stop();\n                }\n            }\n            if (this.indexBackfillerScheduler) {\n                if (isPrimary && !this.indexBackfillerScheduler.started) {\n                    this.indexBackfillerScheduler.start();\n                }\n                else if (!isPrimary) {\n                    this.indexBackfillerScheduler.stop();\n                }\n            }\n        });\n    }\n    createSharedClientState(cfg) {\n        const window = getWindow();\n        if (!WebStorageSharedClientState.isAvailable(window)) {\n            throw new FirestoreError(Code.UNIMPLEMENTED, 'IndexedDB persistence is only available on platforms that support LocalStorage.');\n        }\n        const persistenceKey = indexedDbStoragePrefix(cfg.databaseInfo.databaseId, cfg.databaseInfo.persistenceKey);\n        return new WebStorageSharedClientState(window, cfg.asyncQueue, persistenceKey, cfg.clientId, cfg.initialUser);\n    }\n}\n/**\n * Initializes and wires the components that are needed to interface with the\n * network.\n */\nclass OnlineComponentProvider {\n    async initialize(offlineComponentProvider, cfg) {\n        if (this.localStore) {\n            // OnlineComponentProvider may get initialized multiple times if\n            // multi-tab persistence is used.\n            return;\n        }\n        this.localStore = offlineComponentProvider.localStore;\n        this.sharedClientState = offlineComponentProvider.sharedClientState;\n        this.datastore = this.createDatastore(cfg);\n        this.remoteStore = this.createRemoteStore(cfg);\n        this.eventManager = this.createEventManager(cfg);\n        this.syncEngine = this.createSyncEngine(cfg, \n        /* startAsPrimary=*/ !offlineComponentProvider.synchronizeTabs);\n        this.sharedClientState.onlineStateHandler = onlineState => syncEngineApplyOnlineStateChange(this.syncEngine, onlineState, 1 /* OnlineStateSource.SharedClientState */);\n        this.remoteStore.remoteSyncer.handleCredentialChange =\n            syncEngineHandleCredentialChange.bind(null, this.syncEngine);\n        await remoteStoreApplyPrimaryState(this.remoteStore, this.syncEngine.isPrimaryClient);\n    }\n    createEventManager(cfg) {\n        return newEventManager();\n    }\n    createDatastore(cfg) {\n        const serializer = newSerializer(cfg.databaseInfo.databaseId);\n        const connection = newConnection(cfg.databaseInfo);\n        return newDatastore(cfg.authCredentials, cfg.appCheckCredentials, connection, serializer);\n    }\n    createRemoteStore(cfg) {\n        return newRemoteStore(this.localStore, this.datastore, cfg.asyncQueue, onlineState => syncEngineApplyOnlineStateChange(this.syncEngine, onlineState, 0 /* OnlineStateSource.RemoteStore */), newConnectivityMonitor());\n    }\n    createSyncEngine(cfg, startAsPrimary) {\n        return newSyncEngine(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, cfg.initialUser, cfg.maxConcurrentLimboResolutions, startAsPrimary);\n    }\n    async terminate() {\n        var _a, _b;\n        await remoteStoreShutdown(this.remoteStore);\n        (_a = this.datastore) === null || _a === void 0 ? void 0 : _a.terminate();\n        (_b = this.eventManager) === null || _b === void 0 ? void 0 : _b.terminate();\n    }\n}\nOnlineComponentProvider.provider = {\n    build: () => new OnlineComponentProvider()\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * How many bytes to read each time when `ReadableStreamReader.read()` is\n * called. Only applicable for byte streams that we control (e.g. those backed\n * by an UInt8Array).\n */\nconst DEFAULT_BYTES_PER_READ = 10240;\n/**\n * Builds a `ByteStreamReader` from a UInt8Array.\n * @param source - The data source to use.\n * @param bytesPerRead - How many bytes each `read()` from the returned reader\n *        will read.\n */\nfunction toByteStreamReaderHelper(source, bytesPerRead = DEFAULT_BYTES_PER_READ) {\n    let readFrom = 0;\n    // The TypeScript definition for ReadableStreamReader changed. We use\n    // `any` here to allow this code to compile with different versions.\n    // See https://github.com/microsoft/TypeScript/issues/42970\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const reader = {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        async read() {\n            if (readFrom < source.byteLength) {\n                const result = {\n                    value: source.slice(readFrom, readFrom + bytesPerRead),\n                    done: false\n                };\n                readFrom += bytesPerRead;\n                return result;\n            }\n            return { done: true };\n        },\n        async cancel() { },\n        releaseLock() { },\n        closed: Promise.resolve()\n    };\n    return reader;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction validateNonEmptyArgument(functionName, argumentName, argument) {\n    if (!argument) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${functionName}() cannot be called with an empty ${argumentName}.`);\n    }\n}\n/**\n * Validates that two boolean options are not set at the same time.\n * @internal\n */\nfunction validateIsNotUsedTogether(optionName1, argument1, optionName2, argument2) {\n    if (argument1 === true && argument2 === true) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `${optionName1} and ${optionName2} cannot be used together.`);\n    }\n}\n/**\n * Validates that `path` refers to a document (indicated by the fact it contains\n * an even numbers of segments).\n */\nfunction validateDocumentPath(path) {\n    if (!DocumentKey.isDocumentKey(path)) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${path} has ${path.length}.`);\n    }\n}\n/**\n * Validates that `path` refers to a collection (indicated by the fact it\n * contains an odd numbers of segments).\n */\nfunction validateCollectionPath(path) {\n    if (DocumentKey.isDocumentKey(path)) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${path} has ${path.length}.`);\n    }\n}\n/**\n * Returns true if it's a non-null object without a custom prototype\n * (i.e. excludes Array, Date, etc.).\n */\nfunction isPlainObject(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        (Object.getPrototypeOf(input) === Object.prototype ||\n            Object.getPrototypeOf(input) === null));\n}\n/** Returns a string describing the type / value of the provided input. */\nfunction valueDescription(input) {\n    if (input === undefined) {\n        return 'undefined';\n    }\n    else if (input === null) {\n        return 'null';\n    }\n    else if (typeof input === 'string') {\n        if (input.length > 20) {\n            input = `${input.substring(0, 20)}...`;\n        }\n        return JSON.stringify(input);\n    }\n    else if (typeof input === 'number' || typeof input === 'boolean') {\n        return '' + input;\n    }\n    else if (typeof input === 'object') {\n        if (input instanceof Array) {\n            return 'an array';\n        }\n        else {\n            const customObjectName = tryGetCustomObjectType(input);\n            if (customObjectName) {\n                return `a custom ${customObjectName} object`;\n            }\n            else {\n                return 'an object';\n            }\n        }\n    }\n    else if (typeof input === 'function') {\n        return 'a function';\n    }\n    else {\n        return fail();\n    }\n}\n/** try to get the constructor name for an object. */\nfunction tryGetCustomObjectType(input) {\n    if (input.constructor) {\n        return input.constructor.name;\n    }\n    return null;\n}\n/**\n * Casts `obj` to `T`, optionally unwrapping Compat types to expose the\n * underlying instance. Throws if  `obj` is not an instance of `T`.\n *\n * This cast is used in the Lite and Full SDK to verify instance types for\n * arguments passed to the public API.\n * @internal\n */\nfunction cast(obj, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconstructor) {\n    if ('_delegate' in obj) {\n        // Unwrap Compat types\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        obj = obj._delegate;\n    }\n    if (!(obj instanceof constructor)) {\n        if (constructor.name === obj.constructor.name) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Type does not match the expected instance. Did you pass a ' +\n                `reference from a different Firestore SDK?`);\n        }\n        else {\n            const description = valueDescription(obj);\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Expected type '${constructor.name}', but it was: ${description}`);\n        }\n    }\n    return obj;\n}\nfunction validatePositiveNumber(functionName, n) {\n    if (n <= 0) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${functionName}() requires a positive number, but it was: ${n}.`);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * On Node, only supported data source is a `Uint8Array` for now.\n */\nfunction toByteStreamReader(source, bytesPerRead) {\n    if (!(source instanceof Uint8Array)) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `NodePlatform.toByteStreamReader expects source to be Uint8Array, got ${valueDescription(source)}`);\n    }\n    return toByteStreamReaderHelper(source, bytesPerRead);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * A wrapper implementation of Observer<T> that will dispatch events\n * asynchronously. To allow immediate silencing, a mute call is added which\n * causes events scheduled to no longer be raised.\n */\nclass AsyncObserver {\n    constructor(observer) {\n        this.observer = observer;\n        /**\n         * When set to true, will not raise future events. Necessary to deal with\n         * async detachment of listener.\n         */\n        this.muted = false;\n    }\n    next(value) {\n        if (this.muted) {\n            return;\n        }\n        if (this.observer.next) {\n            this.scheduleEvent(this.observer.next, value);\n        }\n    }\n    error(error) {\n        if (this.muted) {\n            return;\n        }\n        if (this.observer.error) {\n            this.scheduleEvent(this.observer.error, error);\n        }\n        else {\n            logError('Uncaught Error in snapshot listener:', error.toString());\n        }\n    }\n    mute() {\n        this.muted = true;\n    }\n    scheduleEvent(eventHandler, event) {\n        setTimeout(() => {\n            if (!this.muted) {\n                eventHandler(event);\n            }\n        }, 0);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A complete element in the bundle stream, together with the byte length it\n * occupies in the stream.\n */\nclass SizedBundleElement {\n    constructor(payload, \n    // How many bytes this element takes to store in the bundle.\n    byteLength) {\n        this.payload = payload;\n        this.byteLength = byteLength;\n    }\n    isBundleMetadata() {\n        return 'metadata' in this.payload;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A class representing a bundle.\n *\n * Takes a bundle stream or buffer, and presents abstractions to read bundled\n * elements out of the underlying content.\n */\nclass BundleReaderImpl {\n    constructor(\n    /** The reader to read from underlying binary bundle data source. */\n    reader, serializer) {\n        this.reader = reader;\n        this.serializer = serializer;\n        /** Cached bundle metadata. */\n        this.metadata = new Deferred();\n        /**\n         * Internal buffer to hold bundle content, accumulating incomplete element\n         * content.\n         */\n        this.buffer = new Uint8Array();\n        this.textDecoder = newTextDecoder();\n        // Read the metadata (which is the first element).\n        this.nextElementImpl().then(element => {\n            if (element && element.isBundleMetadata()) {\n                this.metadata.resolve(element.payload.metadata);\n            }\n            else {\n                this.metadata.reject(new Error(`The first element of the bundle is not a metadata, it is\n             ${JSON.stringify(element === null || element === void 0 ? void 0 : element.payload)}`));\n            }\n        }, error => this.metadata.reject(error));\n    }\n    close() {\n        return this.reader.cancel();\n    }\n    async getMetadata() {\n        return this.metadata.promise;\n    }\n    async nextElement() {\n        // Makes sure metadata is read before proceeding.\n        await this.getMetadata();\n        return this.nextElementImpl();\n    }\n    /**\n     * Reads from the head of internal buffer, and pulling more data from\n     * underlying stream if a complete element cannot be found, until an\n     * element(including the prefixed length and the JSON string) is found.\n     *\n     * Once a complete element is read, it is dropped from internal buffer.\n     *\n     * Returns either the bundled element, or null if we have reached the end of\n     * the stream.\n     */\n    async nextElementImpl() {\n        const lengthBuffer = await this.readLength();\n        if (lengthBuffer === null) {\n            return null;\n        }\n        const lengthString = this.textDecoder.decode(lengthBuffer);\n        const length = Number(lengthString);\n        if (isNaN(length)) {\n            this.raiseError(`length string (${lengthString}) is not valid number`);\n        }\n        const jsonString = await this.readJsonString(length);\n        return new SizedBundleElement(JSON.parse(jsonString), lengthBuffer.length + length);\n    }\n    /** First index of '{' from the underlying buffer. */\n    indexOfOpenBracket() {\n        return this.buffer.findIndex(v => v === '{'.charCodeAt(0));\n    }\n    /**\n     * Reads from the beginning of the internal buffer, until the first '{', and\n     * return the content.\n     *\n     * If reached end of the stream, returns a null.\n     */\n    async readLength() {\n        while (this.indexOfOpenBracket() < 0) {\n            const done = await this.pullMoreDataToBuffer();\n            if (done) {\n                break;\n            }\n        }\n        // Broke out of the loop because underlying stream is closed, and there\n        // happens to be no more data to process.\n        if (this.buffer.length === 0) {\n            return null;\n        }\n        const position = this.indexOfOpenBracket();\n        // Broke out of the loop because underlying stream is closed, but still\n        // cannot find an open bracket.\n        if (position < 0) {\n            this.raiseError('Reached the end of bundle when a length string is expected.');\n        }\n        const result = this.buffer.slice(0, position);\n        // Update the internal buffer to drop the read length.\n        this.buffer = this.buffer.slice(position);\n        return result;\n    }\n    /**\n     * Reads from a specified position from the internal buffer, for a specified\n     * number of bytes, pulling more data from the underlying stream if needed.\n     *\n     * Returns a string decoded from the read bytes.\n     */\n    async readJsonString(length) {\n        while (this.buffer.length < length) {\n            const done = await this.pullMoreDataToBuffer();\n            if (done) {\n                this.raiseError('Reached the end of bundle when more is expected.');\n            }\n        }\n        const result = this.textDecoder.decode(this.buffer.slice(0, length));\n        // Update the internal buffer to drop the read json string.\n        this.buffer = this.buffer.slice(length);\n        return result;\n    }\n    raiseError(message) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.reader.cancel();\n        throw new Error(`Invalid bundle format: ${message}`);\n    }\n    /**\n     * Pulls more data from underlying stream to internal buffer.\n     * Returns a boolean indicating whether the stream is finished.\n     */\n    async pullMoreDataToBuffer() {\n        const result = await this.reader.read();\n        if (!result.done) {\n            const newBuffer = new Uint8Array(this.buffer.length + result.value.length);\n            newBuffer.set(this.buffer);\n            newBuffer.set(result.value, this.buffer.length);\n            this.buffer = newBuffer;\n        }\n        return result.done;\n    }\n}\nfunction newBundleReader(reader, serializer) {\n    return new BundleReaderImpl(reader, serializer);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Internal transaction object responsible for accumulating the mutations to\n * perform and the base versions for any documents read.\n */\nclass Transaction$2 {\n    constructor(datastore) {\n        this.datastore = datastore;\n        // The version of each document that was read during this transaction.\n        this.readVersions = new Map();\n        this.mutations = [];\n        this.committed = false;\n        /**\n         * A deferred usage error that occurred previously in this transaction that\n         * will cause the transaction to fail once it actually commits.\n         */\n        this.lastTransactionError = null;\n        /**\n         * Set of documents that have been written in the transaction.\n         *\n         * When there's more than one write to the same key in a transaction, any\n         * writes after the first are handled differently.\n         */\n        this.writtenDocs = new Set();\n    }\n    async lookup(keys) {\n        this.ensureCommitNotCalled();\n        if (this.mutations.length > 0) {\n            this.lastTransactionError = new FirestoreError(Code.INVALID_ARGUMENT, 'Firestore transactions require all reads to be executed before all writes.');\n            throw this.lastTransactionError;\n        }\n        const docs = await invokeBatchGetDocumentsRpc(this.datastore, keys);\n        docs.forEach(doc => this.recordVersion(doc));\n        return docs;\n    }\n    set(key, data) {\n        this.write(data.toMutation(key, this.precondition(key)));\n        this.writtenDocs.add(key.toString());\n    }\n    update(key, data) {\n        try {\n            this.write(data.toMutation(key, this.preconditionForUpdate(key)));\n        }\n        catch (e) {\n            this.lastTransactionError = e;\n        }\n        this.writtenDocs.add(key.toString());\n    }\n    delete(key) {\n        this.write(new DeleteMutation(key, this.precondition(key)));\n        this.writtenDocs.add(key.toString());\n    }\n    async commit() {\n        this.ensureCommitNotCalled();\n        if (this.lastTransactionError) {\n            throw this.lastTransactionError;\n        }\n        const unwritten = this.readVersions;\n        // For each mutation, note that the doc was written.\n        this.mutations.forEach(mutation => {\n            unwritten.delete(mutation.key.toString());\n        });\n        // For each document that was read but not written to, we want to perform\n        // a `verify` operation.\n        unwritten.forEach((_, path) => {\n            const key = DocumentKey.fromPath(path);\n            this.mutations.push(new VerifyMutation(key, this.precondition(key)));\n        });\n        await invokeCommitRpc(this.datastore, this.mutations);\n        this.committed = true;\n    }\n    recordVersion(doc) {\n        let docVersion;\n        if (doc.isFoundDocument()) {\n            docVersion = doc.version;\n        }\n        else if (doc.isNoDocument()) {\n            // Represent a deleted doc using SnapshotVersion.min().\n            docVersion = SnapshotVersion.min();\n        }\n        else {\n            throw fail();\n        }\n        const existingVersion = this.readVersions.get(doc.key.toString());\n        if (existingVersion) {\n            if (!docVersion.isEqual(existingVersion)) {\n                // This transaction will fail no matter what.\n                throw new FirestoreError(Code.ABORTED, 'Document version changed between two reads.');\n            }\n        }\n        else {\n            this.readVersions.set(doc.key.toString(), docVersion);\n        }\n    }\n    /**\n     * Returns the version of this document when it was read in this transaction,\n     * as a precondition, or no precondition if it was not read.\n     */\n    precondition(key) {\n        const version = this.readVersions.get(key.toString());\n        if (!this.writtenDocs.has(key.toString()) && version) {\n            if (version.isEqual(SnapshotVersion.min())) {\n                return Precondition.exists(false);\n            }\n            else {\n                return Precondition.updateTime(version);\n            }\n        }\n        else {\n            return Precondition.none();\n        }\n    }\n    /**\n     * Returns the precondition for a document if the operation is an update.\n     */\n    preconditionForUpdate(key) {\n        const version = this.readVersions.get(key.toString());\n        // The first time a document is written, we want to take into account the\n        // read time and existence\n        if (!this.writtenDocs.has(key.toString()) && version) {\n            if (version.isEqual(SnapshotVersion.min())) {\n                // The document doesn't exist, so fail the transaction.\n                // This has to be validated locally because you can't send a\n                // precondition that a document does not exist without changing the\n                // semantics of the backend write to be an insert. This is the reverse\n                // of what we want, since we want to assert that the document doesn't\n                // exist but then send the update and have it fail. Since we can't\n                // express that to the backend, we have to validate locally.\n                // Note: this can change once we can send separate verify writes in the\n                // transaction.\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Can't update a document that doesn't exist.\");\n            }\n            // Document exists, base precondition on document update time.\n            return Precondition.updateTime(version);\n        }\n        else {\n            // Document was not read, so we just use the preconditions for a blind\n            // update.\n            return Precondition.exists(true);\n        }\n    }\n    write(mutation) {\n        this.ensureCommitNotCalled();\n        this.mutations.push(mutation);\n    }\n    ensureCommitNotCalled() {\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * TransactionRunner encapsulates the logic needed to run and retry transactions\n * with backoff.\n */\nclass TransactionRunner {\n    constructor(asyncQueue, datastore, options, updateFunction, deferred) {\n        this.asyncQueue = asyncQueue;\n        this.datastore = datastore;\n        this.options = options;\n        this.updateFunction = updateFunction;\n        this.deferred = deferred;\n        this.attemptsRemaining = options.maxAttempts;\n        this.backoff = new ExponentialBackoff(this.asyncQueue, \"transaction_retry\" /* TimerId.TransactionRetry */);\n    }\n    /** Runs the transaction and sets the result on deferred. */\n    run() {\n        this.attemptsRemaining -= 1;\n        this.runWithBackOff();\n    }\n    runWithBackOff() {\n        this.backoff.backoffAndRun(async () => {\n            const transaction = new Transaction$2(this.datastore);\n            const userPromise = this.tryRunUpdateFunction(transaction);\n            if (userPromise) {\n                userPromise\n                    .then(result => {\n                    this.asyncQueue.enqueueAndForget(() => {\n                        return transaction\n                            .commit()\n                            .then(() => {\n                            this.deferred.resolve(result);\n                        })\n                            .catch(commitError => {\n                            this.handleTransactionError(commitError);\n                        });\n                    });\n                })\n                    .catch(userPromiseError => {\n                    this.handleTransactionError(userPromiseError);\n                });\n            }\n        });\n    }\n    tryRunUpdateFunction(transaction) {\n        try {\n            const userPromise = this.updateFunction(transaction);\n            if (isNullOrUndefined(userPromise) ||\n                !userPromise.catch ||\n                !userPromise.then) {\n                this.deferred.reject(Error('Transaction callback must return a Promise'));\n                return null;\n            }\n            return userPromise;\n        }\n        catch (error) {\n            // Do not retry errors thrown by user provided updateFunction.\n            this.deferred.reject(error);\n            return null;\n        }\n    }\n    handleTransactionError(error) {\n        if (this.attemptsRemaining > 0 && this.isRetryableTransactionError(error)) {\n            this.attemptsRemaining -= 1;\n            this.asyncQueue.enqueueAndForget(() => {\n                this.runWithBackOff();\n                return Promise.resolve();\n            });\n        }\n        else {\n            this.deferred.reject(error);\n        }\n    }\n    isRetryableTransactionError(error) {\n        if (error.name === 'FirebaseError') {\n            // In transactions, the backend will fail outdated reads with FAILED_PRECONDITION and\n            // non-matching document versions with ABORTED. These errors should be retried.\n            const code = error.code;\n            return (code === 'aborted' ||\n                code === 'failed-precondition' ||\n                code === 'already-exists' ||\n                !isPermanentError(code));\n        }\n        return false;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$2 = 'FirestoreClient';\nconst MAX_CONCURRENT_LIMBO_RESOLUTIONS = 100;\n/** DOMException error code constants. */\nconst DOM_EXCEPTION_INVALID_STATE = 11;\nconst DOM_EXCEPTION_ABORTED = 20;\nconst DOM_EXCEPTION_QUOTA_EXCEEDED = 22;\n/**\n * FirestoreClient is a top-level class that constructs and owns all of the //\n * pieces of the client SDK architecture. It is responsible for creating the //\n * async queue that is shared by all of the other components in the system. //\n */\nclass FirestoreClient {\n    constructor(authCredentials, appCheckCredentials, \n    /**\n     * Asynchronous queue responsible for all of our internal processing. When\n     * we get incoming work from the user (via public API) or the network\n     * (incoming GRPC messages), we should always schedule onto this queue.\n     * This ensures all of our work is properly serialized (e.g. we don't\n     * start processing a new operation while the previous one is waiting for\n     * an async I/O to complete).\n     */\n    asyncQueue, databaseInfo, componentProvider) {\n        this.authCredentials = authCredentials;\n        this.appCheckCredentials = appCheckCredentials;\n        this.asyncQueue = asyncQueue;\n        this.databaseInfo = databaseInfo;\n        this.user = User.UNAUTHENTICATED;\n        this.clientId = AutoId.newId();\n        this.authCredentialListener = () => Promise.resolve();\n        this.appCheckCredentialListener = () => Promise.resolve();\n        this._uninitializedComponentsProvider = componentProvider;\n        this.authCredentials.start(asyncQueue, async (user) => {\n            logDebug(LOG_TAG$2, 'Received user=', user.uid);\n            await this.authCredentialListener(user);\n            this.user = user;\n        });\n        this.appCheckCredentials.start(asyncQueue, newAppCheckToken => {\n            logDebug(LOG_TAG$2, 'Received new app check token=', newAppCheckToken);\n            return this.appCheckCredentialListener(newAppCheckToken, this.user);\n        });\n    }\n    get configuration() {\n        return {\n            asyncQueue: this.asyncQueue,\n            databaseInfo: this.databaseInfo,\n            clientId: this.clientId,\n            authCredentials: this.authCredentials,\n            appCheckCredentials: this.appCheckCredentials,\n            initialUser: this.user,\n            maxConcurrentLimboResolutions: MAX_CONCURRENT_LIMBO_RESOLUTIONS\n        };\n    }\n    setCredentialChangeListener(listener) {\n        this.authCredentialListener = listener;\n    }\n    setAppCheckTokenChangeListener(listener) {\n        this.appCheckCredentialListener = listener;\n    }\n    terminate() {\n        this.asyncQueue.enterRestrictedMode();\n        const deferred = new Deferred();\n        this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {\n            try {\n                if (this._onlineComponents) {\n                    await this._onlineComponents.terminate();\n                }\n                if (this._offlineComponents) {\n                    await this._offlineComponents.terminate();\n                }\n                // The credentials provider must be terminated after shutting down the\n                // RemoteStore as it will prevent the RemoteStore from retrieving auth\n                // tokens.\n                this.authCredentials.shutdown();\n                this.appCheckCredentials.shutdown();\n                deferred.resolve();\n            }\n            catch (e) {\n                const firestoreError = wrapInUserErrorIfRecoverable(e, `Failed to shutdown persistence`);\n                deferred.reject(firestoreError);\n            }\n        });\n        return deferred.promise;\n    }\n}\nasync function setOfflineComponentProvider(client, offlineComponentProvider) {\n    client.asyncQueue.verifyOperationInProgress();\n    logDebug(LOG_TAG$2, 'Initializing OfflineComponentProvider');\n    const configuration = client.configuration;\n    await offlineComponentProvider.initialize(configuration);\n    let currentUser = configuration.initialUser;\n    client.setCredentialChangeListener(async (user) => {\n        if (!currentUser.isEqual(user)) {\n            await localStoreHandleUserChange(offlineComponentProvider.localStore, user);\n            currentUser = user;\n        }\n    });\n    // When a user calls clearPersistence() in one client, all other clients\n    // need to be terminated to allow the delete to succeed.\n    offlineComponentProvider.persistence.setDatabaseDeletedListener(() => client.terminate());\n    client._offlineComponents = offlineComponentProvider;\n}\nasync function setOnlineComponentProvider(client, onlineComponentProvider) {\n    client.asyncQueue.verifyOperationInProgress();\n    const offlineComponents = await ensureOfflineComponents(client);\n    logDebug(LOG_TAG$2, 'Initializing OnlineComponentProvider');\n    await onlineComponentProvider.initialize(offlineComponents, client.configuration);\n    // The CredentialChangeListener of the online component provider takes\n    // precedence over the offline component provider.\n    client.setCredentialChangeListener(user => remoteStoreHandleCredentialChange(onlineComponentProvider.remoteStore, user));\n    client.setAppCheckTokenChangeListener((_, user) => remoteStoreHandleCredentialChange(onlineComponentProvider.remoteStore, user));\n    client._onlineComponents = onlineComponentProvider;\n}\n/**\n * Decides whether the provided error allows us to gracefully disable\n * persistence (as opposed to crashing the client).\n */\nfunction canFallbackFromIndexedDbError(error) {\n    if (error.name === 'FirebaseError') {\n        return (error.code === Code.FAILED_PRECONDITION ||\n            error.code === Code.UNIMPLEMENTED);\n    }\n    else if (typeof DOMException !== 'undefined' &&\n        error instanceof DOMException) {\n        // There are a few known circumstances where we can open IndexedDb but\n        // trying to read/write will fail (e.g. quota exceeded). For\n        // well-understood cases, we attempt to detect these and then gracefully\n        // fall back to memory persistence.\n        // NOTE: Rather than continue to add to this list, we could decide to\n        // always fall back, with the risk that we might accidentally hide errors\n        // representing actual SDK bugs.\n        return (\n        // When the browser is out of quota we could get either quota exceeded\n        // or an aborted error depending on whether the error happened during\n        // schema migration.\n        error.code === DOM_EXCEPTION_QUOTA_EXCEEDED ||\n            error.code === DOM_EXCEPTION_ABORTED ||\n            // Firefox Private Browsing mode disables IndexedDb and returns\n            // INVALID_STATE for any usage.\n            error.code === DOM_EXCEPTION_INVALID_STATE);\n    }\n    return true;\n}\nasync function ensureOfflineComponents(client) {\n    if (!client._offlineComponents) {\n        if (client._uninitializedComponentsProvider) {\n            logDebug(LOG_TAG$2, 'Using user provided OfflineComponentProvider');\n            try {\n                await setOfflineComponentProvider(client, client._uninitializedComponentsProvider._offline);\n            }\n            catch (e) {\n                const error = e;\n                if (!canFallbackFromIndexedDbError(error)) {\n                    throw error;\n                }\n                logWarn('Error using user provided cache. Falling back to ' +\n                    'memory cache: ' +\n                    error);\n                await setOfflineComponentProvider(client, new MemoryOfflineComponentProvider());\n            }\n        }\n        else {\n            logDebug(LOG_TAG$2, 'Using default OfflineComponentProvider');\n            await setOfflineComponentProvider(client, new LruGcMemoryOfflineComponentProvider(undefined));\n        }\n    }\n    return client._offlineComponents;\n}\nasync function ensureOnlineComponents(client) {\n    if (!client._onlineComponents) {\n        if (client._uninitializedComponentsProvider) {\n            logDebug(LOG_TAG$2, 'Using user provided OnlineComponentProvider');\n            await setOnlineComponentProvider(client, client._uninitializedComponentsProvider._online);\n        }\n        else {\n            logDebug(LOG_TAG$2, 'Using default OnlineComponentProvider');\n            await setOnlineComponentProvider(client, new OnlineComponentProvider());\n        }\n    }\n    return client._onlineComponents;\n}\nfunction getPersistence(client) {\n    return ensureOfflineComponents(client).then(c => c.persistence);\n}\nfunction getLocalStore(client) {\n    return ensureOfflineComponents(client).then(c => c.localStore);\n}\nfunction getRemoteStore(client) {\n    return ensureOnlineComponents(client).then(c => c.remoteStore);\n}\nfunction getSyncEngine(client) {\n    return ensureOnlineComponents(client).then(c => c.syncEngine);\n}\nfunction getDatastore(client) {\n    return ensureOnlineComponents(client).then(c => c.datastore);\n}\nasync function getEventManager(client) {\n    const onlineComponentProvider = await ensureOnlineComponents(client);\n    const eventManager = onlineComponentProvider.eventManager;\n    eventManager.onListen = syncEngineListen.bind(null, onlineComponentProvider.syncEngine);\n    eventManager.onUnlisten = syncEngineUnlisten.bind(null, onlineComponentProvider.syncEngine);\n    eventManager.onFirstRemoteStoreListen = triggerRemoteStoreListen.bind(null, onlineComponentProvider.syncEngine);\n    eventManager.onLastRemoteStoreUnlisten = triggerRemoteStoreUnlisten.bind(null, onlineComponentProvider.syncEngine);\n    return eventManager;\n}\n/** Enables the network connection and re-enqueues all pending operations. */\nfunction firestoreClientEnableNetwork(client) {\n    return client.asyncQueue.enqueue(async () => {\n        const persistence = await getPersistence(client);\n        const remoteStore = await getRemoteStore(client);\n        persistence.setNetworkEnabled(true);\n        return remoteStoreEnableNetwork(remoteStore);\n    });\n}\n/** Disables the network connection. Pending operations will not complete. */\nfunction firestoreClientDisableNetwork(client) {\n    return client.asyncQueue.enqueue(async () => {\n        const persistence = await getPersistence(client);\n        const remoteStore = await getRemoteStore(client);\n        persistence.setNetworkEnabled(false);\n        return remoteStoreDisableNetwork(remoteStore);\n    });\n}\n/**\n * Returns a Promise that resolves when all writes that were pending at the time\n * this method was called received server acknowledgement. An acknowledgement\n * can be either acceptance or rejection.\n */\nfunction firestoreClientWaitForPendingWrites(client) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        const syncEngine = await getSyncEngine(client);\n        return syncEngineRegisterPendingWritesCallback(syncEngine, deferred);\n    });\n    return deferred.promise;\n}\nfunction firestoreClientListen(client, query, options, observer) {\n    const wrappedObserver = new AsyncObserver(observer);\n    const listener = new QueryListener(query, wrappedObserver, options);\n    client.asyncQueue.enqueueAndForget(async () => {\n        const eventManager = await getEventManager(client);\n        return eventManagerListen(eventManager, listener);\n    });\n    return () => {\n        wrappedObserver.mute();\n        client.asyncQueue.enqueueAndForget(async () => {\n            const eventManager = await getEventManager(client);\n            return eventManagerUnlisten(eventManager, listener);\n        });\n    };\n}\nfunction firestoreClientGetDocumentFromLocalCache(client, docKey) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        const localStore = await getLocalStore(client);\n        return readDocumentFromCache(localStore, docKey, deferred);\n    });\n    return deferred.promise;\n}\nfunction firestoreClientGetDocumentViaSnapshotListener(client, key, options = {}) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        const eventManager = await getEventManager(client);\n        return readDocumentViaSnapshotListener(eventManager, client.asyncQueue, key, options, deferred);\n    });\n    return deferred.promise;\n}\nfunction firestoreClientGetDocumentsFromLocalCache(client, query) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        const localStore = await getLocalStore(client);\n        return executeQueryFromCache(localStore, query, deferred);\n    });\n    return deferred.promise;\n}\nfunction firestoreClientGetDocumentsViaSnapshotListener(client, query, options = {}) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        const eventManager = await getEventManager(client);\n        return executeQueryViaSnapshotListener(eventManager, client.asyncQueue, query, options, deferred);\n    });\n    return deferred.promise;\n}\nfunction firestoreClientRunAggregateQuery(client, query, aggregates) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        // Implement and call executeAggregateQueryViaSnapshotListener, similar\n        // to the implementation in firestoreClientGetDocumentsViaSnapshotListener\n        // above\n        try {\n            // TODO(b/277628384): check `canUseNetwork()` and handle multi-tab.\n            const datastore = await getDatastore(client);\n            deferred.resolve(invokeRunAggregationQueryRpc(datastore, query, aggregates));\n        }\n        catch (e) {\n            deferred.reject(e);\n        }\n    });\n    return deferred.promise;\n}\nfunction firestoreClientWrite(client, mutations) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        const syncEngine = await getSyncEngine(client);\n        return syncEngineWrite(syncEngine, mutations, deferred);\n    });\n    return deferred.promise;\n}\nfunction firestoreClientAddSnapshotsInSyncListener(client, observer) {\n    const wrappedObserver = new AsyncObserver(observer);\n    client.asyncQueue.enqueueAndForget(async () => {\n        const eventManager = await getEventManager(client);\n        return addSnapshotsInSyncListener(eventManager, wrappedObserver);\n    });\n    return () => {\n        wrappedObserver.mute();\n        client.asyncQueue.enqueueAndForget(async () => {\n            const eventManager = await getEventManager(client);\n            return removeSnapshotsInSyncListener(eventManager, wrappedObserver);\n        });\n    };\n}\n/**\n * Takes an updateFunction in which a set of reads and writes can be performed\n * atomically. In the updateFunction, the client can read and write values\n * using the supplied transaction object. After the updateFunction, all\n * changes will be committed. If a retryable error occurs (ex: some other\n * client has changed any of the data referenced), then the updateFunction\n * will be called again after a backoff. If the updateFunction still fails\n * after all retries, then the transaction will be rejected.\n *\n * The transaction object passed to the updateFunction contains methods for\n * accessing documents and collections. Unlike other datastore access, data\n * accessed with the transaction will not reflect local changes that have not\n * been committed. For this reason, it is required that all reads are\n * performed before any writes. Transactions must be performed while online.\n */\nfunction firestoreClientTransaction(client, updateFunction, options) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        const datastore = await getDatastore(client);\n        new TransactionRunner(client.asyncQueue, datastore, options, updateFunction, deferred).run();\n    });\n    return deferred.promise;\n}\nasync function readDocumentFromCache(localStore, docKey, result) {\n    try {\n        const document = await localStoreReadDocument(localStore, docKey);\n        if (document.isFoundDocument()) {\n            result.resolve(document);\n        }\n        else if (document.isNoDocument()) {\n            result.resolve(null);\n        }\n        else {\n            result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get document from cache. (However, this document may ' +\n                \"exist on the server. Run again without setting 'source' in \" +\n                'the GetOptions to attempt to retrieve the document from the ' +\n                'server.)'));\n        }\n    }\n    catch (e) {\n        const firestoreError = wrapInUserErrorIfRecoverable(e, `Failed to get document '${docKey} from cache`);\n        result.reject(firestoreError);\n    }\n}\n/**\n * Retrieves a latency-compensated document from the backend via a\n * SnapshotListener.\n */\nfunction readDocumentViaSnapshotListener(eventManager, asyncQueue, key, options, result) {\n    const wrappedObserver = new AsyncObserver({\n        next: (snap) => {\n            // Mute and remove query first before passing event to user to avoid\n            // user actions affecting the now stale query.\n            wrappedObserver.mute();\n            asyncQueue.enqueueAndForget(() => eventManagerUnlisten(eventManager, listener));\n            const exists = snap.docs.has(key);\n            if (!exists && snap.fromCache) {\n                // TODO(dimond): If we're online and the document doesn't\n                // exist then we resolve with a doc.exists set to false. If\n                // we're offline however, we reject the Promise in this\n                // case. Two options: 1) Cache the negative response from\n                // the server so we can deliver that even when you're\n                // offline 2) Actually reject the Promise in the online case\n                // if the document doesn't exist.\n                result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get document because the client is offline.'));\n            }\n            else if (exists &&\n                snap.fromCache &&\n                options &&\n                options.source === 'server') {\n                result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get document from server. (However, this ' +\n                    'document does exist in the local cache. Run again ' +\n                    'without setting source to \"server\" to ' +\n                    'retrieve the cached document.)'));\n            }\n            else {\n                result.resolve(snap);\n            }\n        },\n        error: e => result.reject(e)\n    });\n    const listener = new QueryListener(newQueryForPath(key.path), wrappedObserver, {\n        includeMetadataChanges: true,\n        waitForSyncWhenOnline: true\n    });\n    return eventManagerListen(eventManager, listener);\n}\nasync function executeQueryFromCache(localStore, query, result) {\n    try {\n        const queryResult = await localStoreExecuteQuery(localStore, query, \n        /* usePreviousResults= */ true);\n        const view = new View(query, queryResult.remoteKeys);\n        const viewDocChanges = view.computeDocChanges(queryResult.documents);\n        const viewChange = view.applyChanges(viewDocChanges, \n        /* limboResolutionEnabled= */ false);\n        result.resolve(viewChange.snapshot);\n    }\n    catch (e) {\n        const firestoreError = wrapInUserErrorIfRecoverable(e, `Failed to execute query '${query} against cache`);\n        result.reject(firestoreError);\n    }\n}\n/**\n * Retrieves a latency-compensated query snapshot from the backend via a\n * SnapshotListener.\n */\nfunction executeQueryViaSnapshotListener(eventManager, asyncQueue, query, options, result) {\n    const wrappedObserver = new AsyncObserver({\n        next: snapshot => {\n            // Mute and remove query first before passing event to user to avoid\n            // user actions affecting the now stale query.\n            wrappedObserver.mute();\n            asyncQueue.enqueueAndForget(() => eventManagerUnlisten(eventManager, listener));\n            if (snapshot.fromCache && options.source === 'server') {\n                result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get documents from server. (However, these ' +\n                    'documents may exist in the local cache. Run again ' +\n                    'without setting source to \"server\" to ' +\n                    'retrieve the cached documents.)'));\n            }\n            else {\n                result.resolve(snapshot);\n            }\n        },\n        error: e => result.reject(e)\n    });\n    const listener = new QueryListener(query, wrappedObserver, {\n        includeMetadataChanges: true,\n        waitForSyncWhenOnline: true\n    });\n    return eventManagerListen(eventManager, listener);\n}\nfunction firestoreClientLoadBundle(client, databaseId, data, resultTask) {\n    const reader = createBundleReader(data, newSerializer(databaseId));\n    client.asyncQueue.enqueueAndForget(async () => {\n        syncEngineLoadBundle(await getSyncEngine(client), reader, resultTask);\n    });\n}\nfunction firestoreClientGetNamedQuery(client, queryName) {\n    return client.asyncQueue.enqueue(async () => localStoreGetNamedQuery(await getLocalStore(client), queryName));\n}\nfunction createBundleReader(data, serializer) {\n    let content;\n    if (typeof data === 'string') {\n        content = newTextEncoder().encode(data);\n    }\n    else {\n        content = data;\n    }\n    return newBundleReader(toByteStreamReader(content), serializer);\n}\nfunction firestoreClientSetIndexConfiguration(client, indexes) {\n    return client.asyncQueue.enqueue(async () => {\n        return localStoreConfigureFieldIndexes(await getLocalStore(client), indexes);\n    });\n}\nfunction firestoreClientSetPersistentCacheIndexAutoCreationEnabled(client, isEnabled) {\n    return client.asyncQueue.enqueue(async () => {\n        return localStoreSetIndexAutoCreationEnabled(await getLocalStore(client), isEnabled);\n    });\n}\nfunction firestoreClientDeleteAllFieldIndexes(client) {\n    return client.asyncQueue.enqueue(async () => {\n        return localStoreDeleteAllFieldIndexes(await getLocalStore(client));\n    });\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Compares two `ExperimentalLongPollingOptions` objects for equality.\n */\nfunction longPollingOptionsEqual(options1, options2) {\n    return options1.timeoutSeconds === options2.timeoutSeconds;\n}\n/**\n * Creates and returns a new `ExperimentalLongPollingOptions` with the same\n * option values as the given instance.\n */\nfunction cloneLongPollingOptions(options) {\n    const clone = {};\n    if (options.timeoutSeconds !== undefined) {\n        clone.timeoutSeconds = options.timeoutSeconds;\n    }\n    return clone;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$1 = 'ComponentProvider';\n/**\n * An instance map that ensures only one Datastore exists per Firestore\n * instance.\n */\nconst datastoreInstances = new Map();\n/**\n * Removes all components associated with the provided instance. Must be called\n * when the `Firestore` instance is terminated.\n */\nfunction removeComponents(firestore) {\n    const datastore = datastoreInstances.get(firestore);\n    if (datastore) {\n        logDebug(LOG_TAG$1, 'Removing Datastore');\n        datastoreInstances.delete(firestore);\n        datastore.terminate();\n    }\n}\nfunction makeDatabaseInfo(databaseId, appId, persistenceKey, settings) {\n    return new DatabaseInfo(databaseId, appId, persistenceKey, settings.host, settings.ssl, settings.experimentalForceLongPolling, settings.experimentalAutoDetectLongPolling, cloneLongPollingOptions(settings.experimentalLongPollingOptions), settings.useFetchStreams);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// settings() defaults:\nconst DEFAULT_HOST = 'firestore.googleapis.com';\nconst DEFAULT_SSL = true;\n// The minimum long-polling timeout is hardcoded on the server. The value here\n// should be kept in sync with the value used by the server, as the server will\n// silently ignore a value below the minimum and fall back to the default.\n// Googlers see b/266868871 for relevant discussion.\nconst MIN_LONG_POLLING_TIMEOUT_SECONDS = 5;\n// No maximum long-polling timeout is configured in the server, and defaults to\n// 30 seconds, which is what Watch appears to use.\n// Googlers see b/266868871 for relevant discussion.\nconst MAX_LONG_POLLING_TIMEOUT_SECONDS = 30;\n// Whether long-polling auto-detected is enabled by default.\nconst DEFAULT_AUTO_DETECT_LONG_POLLING = true;\n/**\n * A concrete type describing all the values that can be applied via a\n * user-supplied `FirestoreSettings` object. This is a separate type so that\n * defaults can be supplied and the value can be checked for equality.\n */\nclass FirestoreSettingsImpl {\n    constructor(settings) {\n        var _a, _b;\n        if (settings.host === undefined) {\n            if (settings.ssl !== undefined) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Can't provide ssl option if host option is not set\");\n            }\n            this.host = DEFAULT_HOST;\n            this.ssl = DEFAULT_SSL;\n        }\n        else {\n            this.host = settings.host;\n            this.ssl = (_a = settings.ssl) !== null && _a !== void 0 ? _a : DEFAULT_SSL;\n        }\n        this.credentials = settings.credentials;\n        this.ignoreUndefinedProperties = !!settings.ignoreUndefinedProperties;\n        this.localCache = settings.localCache;\n        if (settings.cacheSizeBytes === undefined) {\n            this.cacheSizeBytes = LRU_DEFAULT_CACHE_SIZE_BYTES;\n        }\n        else {\n            if (settings.cacheSizeBytes !== LRU_COLLECTION_DISABLED &&\n                settings.cacheSizeBytes < LRU_MINIMUM_CACHE_SIZE_BYTES) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `cacheSizeBytes must be at least ${LRU_MINIMUM_CACHE_SIZE_BYTES}`);\n            }\n            else {\n                this.cacheSizeBytes = settings.cacheSizeBytes;\n            }\n        }\n        validateIsNotUsedTogether('experimentalForceLongPolling', settings.experimentalForceLongPolling, 'experimentalAutoDetectLongPolling', settings.experimentalAutoDetectLongPolling);\n        this.experimentalForceLongPolling = !!settings.experimentalForceLongPolling;\n        if (this.experimentalForceLongPolling) {\n            this.experimentalAutoDetectLongPolling = false;\n        }\n        else if (settings.experimentalAutoDetectLongPolling === undefined) {\n            this.experimentalAutoDetectLongPolling = DEFAULT_AUTO_DETECT_LONG_POLLING;\n        }\n        else {\n            // For backwards compatibility, coerce the value to boolean even though\n            // the TypeScript compiler has narrowed the type to boolean already.\n            // noinspection PointlessBooleanExpressionJS\n            this.experimentalAutoDetectLongPolling =\n                !!settings.experimentalAutoDetectLongPolling;\n        }\n        this.experimentalLongPollingOptions = cloneLongPollingOptions((_b = settings.experimentalLongPollingOptions) !== null && _b !== void 0 ? _b : {});\n        validateLongPollingOptions(this.experimentalLongPollingOptions);\n        this.useFetchStreams = !!settings.useFetchStreams;\n    }\n    isEqual(other) {\n        return (this.host === other.host &&\n            this.ssl === other.ssl &&\n            this.credentials === other.credentials &&\n            this.cacheSizeBytes === other.cacheSizeBytes &&\n            this.experimentalForceLongPolling ===\n                other.experimentalForceLongPolling &&\n            this.experimentalAutoDetectLongPolling ===\n                other.experimentalAutoDetectLongPolling &&\n            longPollingOptionsEqual(this.experimentalLongPollingOptions, other.experimentalLongPollingOptions) &&\n            this.ignoreUndefinedProperties === other.ignoreUndefinedProperties &&\n            this.useFetchStreams === other.useFetchStreams);\n    }\n}\nfunction validateLongPollingOptions(options) {\n    if (options.timeoutSeconds !== undefined) {\n        if (isNaN(options.timeoutSeconds)) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `invalid long polling timeout: ` +\n                `${options.timeoutSeconds} (must not be NaN)`);\n        }\n        if (options.timeoutSeconds < MIN_LONG_POLLING_TIMEOUT_SECONDS) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `invalid long polling timeout: ${options.timeoutSeconds} ` +\n                `(minimum allowed value is ${MIN_LONG_POLLING_TIMEOUT_SECONDS})`);\n        }\n        if (options.timeoutSeconds > MAX_LONG_POLLING_TIMEOUT_SECONDS) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `invalid long polling timeout: ${options.timeoutSeconds} ` +\n                `(maximum allowed value is ${MAX_LONG_POLLING_TIMEOUT_SECONDS})`);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The Cloud Firestore service interface.\n *\n * Do not call this constructor directly. Instead, use {@link (getFirestore:1)}.\n */\nclass Firestore$1 {\n    /** @hideconstructor */\n    constructor(_authCredentials, _appCheckCredentials, _databaseId, _app) {\n        this._authCredentials = _authCredentials;\n        this._appCheckCredentials = _appCheckCredentials;\n        this._databaseId = _databaseId;\n        this._app = _app;\n        /**\n         * Whether it's a Firestore or Firestore Lite instance.\n         */\n        this.type = 'firestore-lite';\n        this._persistenceKey = '(lite)';\n        this._settings = new FirestoreSettingsImpl({});\n        this._settingsFrozen = false;\n        // A task that is assigned when the terminate() is invoked and resolved when\n        // all components have shut down. Otherwise, Firestore is not terminated,\n        // which can mean either the FirestoreClient is in the process of starting,\n        // or restarting.\n        this._terminateTask = 'notTerminated';\n    }\n    /**\n     * The {@link @firebase/app#FirebaseApp} associated with this `Firestore` service\n     * instance.\n     */\n    get app() {\n        if (!this._app) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, \"Firestore was not initialized using the Firebase SDK. 'app' is \" +\n                'not available');\n        }\n        return this._app;\n    }\n    get _initialized() {\n        return this._settingsFrozen;\n    }\n    get _terminated() {\n        return this._terminateTask !== 'notTerminated';\n    }\n    _setSettings(settings) {\n        if (this._settingsFrozen) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and its settings can no longer ' +\n                'be changed. You can only modify settings before calling any other ' +\n                'methods on a Firestore object.');\n        }\n        this._settings = new FirestoreSettingsImpl(settings);\n        if (settings.credentials !== undefined) {\n            this._authCredentials = makeAuthCredentialsProvider(settings.credentials);\n        }\n    }\n    _getSettings() {\n        return this._settings;\n    }\n    _freezeSettings() {\n        this._settingsFrozen = true;\n        return this._settings;\n    }\n    _delete() {\n        // The `_terminateTask` must be assigned future that completes when\n        // terminate is complete. The existence of this future puts SDK in state\n        // that will not accept further API interaction.\n        if (this._terminateTask === 'notTerminated') {\n            this._terminateTask = this._terminate();\n        }\n        return this._terminateTask;\n    }\n    async _restart() {\n        // The `_terminateTask` must equal 'notTerminated' after restart to\n        // signal that client is in a state that accepts API calls.\n        if (this._terminateTask === 'notTerminated') {\n            await this._terminate();\n        }\n        else {\n            this._terminateTask = 'notTerminated';\n        }\n    }\n    /** Returns a JSON-serializable representation of this `Firestore` instance. */\n    toJSON() {\n        return {\n            app: this._app,\n            databaseId: this._databaseId,\n            settings: this._settings\n        };\n    }\n    /**\n     * Terminates all components used by this client. Subclasses can override\n     * this method to clean up their own dependencies, but must also call this\n     * method.\n     *\n     * Only ever called once.\n     */\n    _terminate() {\n        removeComponents(this);\n        return Promise.resolve();\n    }\n}\n/**\n * Modify this instance to communicate with the Cloud Firestore emulator.\n *\n * Note: This must be called before this instance has been used to do any\n * operations.\n *\n * @param firestore - The `Firestore` instance to configure to connect to the\n * emulator.\n * @param host - the emulator host (ex: localhost).\n * @param port - the emulator port (ex: 9000).\n * @param options.mockUserToken - the mock auth token to use for unit testing\n * Security Rules.\n */\nfunction connectFirestoreEmulator(firestore, host, port, options = {}) {\n    var _a;\n    firestore = cast(firestore, Firestore$1);\n    const settings = firestore._getSettings();\n    const newHostSetting = `${host}:${port}`;\n    if (settings.host !== DEFAULT_HOST && settings.host !== newHostSetting) {\n        logWarn('Host has been set in both settings() and connectFirestoreEmulator(), emulator host ' +\n            'will be used.');\n    }\n    firestore._setSettings(Object.assign(Object.assign({}, settings), { host: newHostSetting, ssl: false }));\n    if (options.mockUserToken) {\n        let token;\n        let user;\n        if (typeof options.mockUserToken === 'string') {\n            token = options.mockUserToken;\n            user = User.MOCK_USER;\n        }\n        else {\n            // Let createMockUserToken validate first (catches common mistakes like\n            // invalid field \"uid\" and missing field \"sub\" / \"user_id\".)\n            token = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.createMockUserToken)(options.mockUserToken, (_a = firestore._app) === null || _a === void 0 ? void 0 : _a.options.projectId);\n            const uid = options.mockUserToken.sub || options.mockUserToken.user_id;\n            if (!uid) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"mockUserToken must contain 'sub' or 'user_id' field!\");\n            }\n            user = new User(uid);\n        }\n        firestore._authCredentials = new EmulatorAuthCredentialsProvider(new OAuthToken(token, user));\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A `Query` refers to a query which you can read or listen to. You can also\n * construct refined `Query` objects by adding filters and ordering.\n */\nclass Query {\n    // This is the lite version of the Query class in the main SDK.\n    /** @hideconstructor protected */\n    constructor(firestore, \n    /**\n     * If provided, the `FirestoreDataConverter` associated with this instance.\n     */\n    converter, _query) {\n        this.converter = converter;\n        this._query = _query;\n        /** The type of this Firestore reference. */\n        this.type = 'query';\n        this.firestore = firestore;\n    }\n    withConverter(converter) {\n        return new Query(this.firestore, converter, this._query);\n    }\n}\n/**\n * A `DocumentReference` refers to a document location in a Firestore database\n * and can be used to write, read, or listen to the location. The document at\n * the referenced location may or may not exist.\n */\nclass DocumentReference {\n    /** @hideconstructor */\n    constructor(firestore, \n    /**\n     * If provided, the `FirestoreDataConverter` associated with this instance.\n     */\n    converter, _key) {\n        this.converter = converter;\n        this._key = _key;\n        /** The type of this Firestore reference. */\n        this.type = 'document';\n        this.firestore = firestore;\n    }\n    get _path() {\n        return this._key.path;\n    }\n    /**\n     * The document's identifier within its collection.\n     */\n    get id() {\n        return this._key.path.lastSegment();\n    }\n    /**\n     * A string representing the path of the referenced document (relative\n     * to the root of the database).\n     */\n    get path() {\n        return this._key.path.canonicalString();\n    }\n    /**\n     * The collection this `DocumentReference` belongs to.\n     */\n    get parent() {\n        return new CollectionReference(this.firestore, this.converter, this._key.path.popLast());\n    }\n    withConverter(converter) {\n        return new DocumentReference(this.firestore, converter, this._key);\n    }\n}\n/**\n * A `CollectionReference` object can be used for adding documents, getting\n * document references, and querying for documents (using {@link (query:1)}).\n */\nclass CollectionReference extends Query {\n    /** @hideconstructor */\n    constructor(firestore, converter, _path) {\n        super(firestore, converter, newQueryForPath(_path));\n        this._path = _path;\n        /** The type of this Firestore reference. */\n        this.type = 'collection';\n    }\n    /** The collection's identifier. */\n    get id() {\n        return this._query.path.lastSegment();\n    }\n    /**\n     * A string representing the path of the referenced collection (relative\n     * to the root of the database).\n     */\n    get path() {\n        return this._query.path.canonicalString();\n    }\n    /**\n     * A reference to the containing `DocumentReference` if this is a\n     * subcollection. If this isn't a subcollection, the reference is null.\n     */\n    get parent() {\n        const parentPath = this._path.popLast();\n        if (parentPath.isEmpty()) {\n            return null;\n        }\n        else {\n            return new DocumentReference(this.firestore, \n            /* converter= */ null, new DocumentKey(parentPath));\n        }\n    }\n    withConverter(converter) {\n        return new CollectionReference(this.firestore, converter, this._path);\n    }\n}\nfunction collection(parent, path, ...pathSegments) {\n    parent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(parent);\n    validateNonEmptyArgument('collection', 'path', path);\n    if (parent instanceof Firestore$1) {\n        const absolutePath = ResourcePath.fromString(path, ...pathSegments);\n        validateCollectionPath(absolutePath);\n        return new CollectionReference(parent, /* converter= */ null, absolutePath);\n    }\n    else {\n        if (!(parent instanceof DocumentReference) &&\n            !(parent instanceof CollectionReference)) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Expected first argument to collection() to be a CollectionReference, ' +\n                'a DocumentReference or FirebaseFirestore');\n        }\n        const absolutePath = parent._path.child(ResourcePath.fromString(path, ...pathSegments));\n        validateCollectionPath(absolutePath);\n        return new CollectionReference(parent.firestore, \n        /* converter= */ null, absolutePath);\n    }\n}\n// TODO(firestorelite): Consider using ErrorFactory -\n// https://github.com/firebase/firebase-js-sdk/blob/0131e1f/packages/util/src/errors.ts#L106\n/**\n * Creates and returns a new `Query` instance that includes all documents in the\n * database that are contained in a collection or subcollection with the\n * given `collectionId`.\n *\n * @param firestore - A reference to the root `Firestore` instance.\n * @param collectionId - Identifies the collections to query over. Every\n * collection or subcollection with this ID as the last segment of its path\n * will be included. Cannot contain a slash.\n * @returns The created `Query`.\n */\nfunction collectionGroup(firestore, collectionId) {\n    firestore = cast(firestore, Firestore$1);\n    validateNonEmptyArgument('collectionGroup', 'collection id', collectionId);\n    if (collectionId.indexOf('/') >= 0) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid collection ID '${collectionId}' passed to function ` +\n            `collectionGroup(). Collection IDs must not contain '/'.`);\n    }\n    return new Query(firestore, \n    /* converter= */ null, newQueryForCollectionGroup(collectionId));\n}\nfunction doc(parent, path, ...pathSegments) {\n    parent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(parent);\n    // We allow omission of 'pathString' but explicitly prohibit passing in both\n    // 'undefined' and 'null'.\n    if (arguments.length === 1) {\n        path = AutoId.newId();\n    }\n    validateNonEmptyArgument('doc', 'path', path);\n    if (parent instanceof Firestore$1) {\n        const absolutePath = ResourcePath.fromString(path, ...pathSegments);\n        validateDocumentPath(absolutePath);\n        return new DocumentReference(parent, \n        /* converter= */ null, new DocumentKey(absolutePath));\n    }\n    else {\n        if (!(parent instanceof DocumentReference) &&\n            !(parent instanceof CollectionReference)) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Expected first argument to collection() to be a CollectionReference, ' +\n                'a DocumentReference or FirebaseFirestore');\n        }\n        const absolutePath = parent._path.child(ResourcePath.fromString(path, ...pathSegments));\n        validateDocumentPath(absolutePath);\n        return new DocumentReference(parent.firestore, parent instanceof CollectionReference ? parent.converter : null, new DocumentKey(absolutePath));\n    }\n}\n/**\n * Returns true if the provided references are equal.\n *\n * @param left - A reference to compare.\n * @param right - A reference to compare.\n * @returns true if the references point to the same location in the same\n * Firestore database.\n */\nfunction refEqual(left, right) {\n    left = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(left);\n    right = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(right);\n    if ((left instanceof DocumentReference ||\n        left instanceof CollectionReference) &&\n        (right instanceof DocumentReference || right instanceof CollectionReference)) {\n        return (left.firestore === right.firestore &&\n            left.path === right.path &&\n            left.converter === right.converter);\n    }\n    return false;\n}\n/**\n * Returns true if the provided queries point to the same collection and apply\n * the same constraints.\n *\n * @param left - A `Query` to compare.\n * @param right - A `Query` to compare.\n * @returns true if the references point to the same location in the same\n * Firestore database.\n */\nfunction queryEqual(left, right) {\n    left = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(left);\n    right = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(right);\n    if (left instanceof Query && right instanceof Query) {\n        return (left.firestore === right.firestore &&\n            queryEquals(left._query, right._query) &&\n            left.converter === right.converter);\n    }\n    return false;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG = 'AsyncQueue';\nclass AsyncQueueImpl {\n    constructor(tail = Promise.resolve()) {\n        // A list of retryable operations. Retryable operations are run in order and\n        // retried with backoff.\n        this.retryableOps = [];\n        // Is this AsyncQueue being shut down? Once it is set to true, it will not\n        // be changed again.\n        this._isShuttingDown = false;\n        // Operations scheduled to be queued in the future. Operations are\n        // automatically removed after they are run or canceled.\n        this.delayedOperations = [];\n        // visible for testing\n        this.failure = null;\n        // Flag set while there's an outstanding AsyncQueue operation, used for\n        // assertion sanity-checks.\n        this.operationInProgress = false;\n        // Enabled during shutdown on Safari to prevent future access to IndexedDB.\n        this.skipNonRestrictedTasks = false;\n        // List of TimerIds to fast-forward delays for.\n        this.timerIdsToSkip = [];\n        // Backoff timer used to schedule retries for retryable operations\n        this.backoff = new ExponentialBackoff(this, \"async_queue_retry\" /* TimerId.AsyncQueueRetry */);\n        // Visibility handler that triggers an immediate retry of all retryable\n        // operations. Meant to speed up recovery when we regain file system access\n        // after page comes into foreground.\n        this.visibilityHandler = () => {\n            this.backoff.skipBackoff();\n        };\n        this.tail = tail;\n    }\n    get isShuttingDown() {\n        return this._isShuttingDown;\n    }\n    /**\n     * Adds a new operation to the queue without waiting for it to complete (i.e.\n     * we ignore the Promise result).\n     */\n    enqueueAndForget(op) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.enqueue(op);\n    }\n    enqueueAndForgetEvenWhileRestricted(op) {\n        this.verifyNotFailed();\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.enqueueInternal(op);\n    }\n    enterRestrictedMode(purgeExistingTasks) {\n        if (!this._isShuttingDown) {\n            this._isShuttingDown = true;\n            this.skipNonRestrictedTasks = purgeExistingTasks || false;\n        }\n    }\n    enqueue(op) {\n        this.verifyNotFailed();\n        if (this._isShuttingDown) {\n            // Return a Promise which never resolves.\n            return new Promise(() => { });\n        }\n        // Create a deferred Promise that we can return to the callee. This\n        // allows us to return a \"hanging Promise\" only to the callee and still\n        // advance the queue even when the operation is not run.\n        const task = new Deferred();\n        return this.enqueueInternal(() => {\n            if (this._isShuttingDown && this.skipNonRestrictedTasks) {\n                // We do not resolve 'task'\n                return Promise.resolve();\n            }\n            op().then(task.resolve, task.reject);\n            return task.promise;\n        }).then(() => task.promise);\n    }\n    enqueueRetryable(op) {\n        this.enqueueAndForget(() => {\n            this.retryableOps.push(op);\n            return this.retryNextOp();\n        });\n    }\n    /**\n     * Runs the next operation from the retryable queue. If the operation fails,\n     * reschedules with backoff.\n     */\n    async retryNextOp() {\n        if (this.retryableOps.length === 0) {\n            return;\n        }\n        try {\n            await this.retryableOps[0]();\n            this.retryableOps.shift();\n            this.backoff.reset();\n        }\n        catch (e) {\n            if (isIndexedDbTransactionError(e)) {\n                logDebug(LOG_TAG, 'Operation failed with retryable error: ' + e);\n            }\n            else {\n                throw e; // Failure will be handled by AsyncQueue\n            }\n        }\n        if (this.retryableOps.length > 0) {\n            // If there are additional operations, we re-schedule `retryNextOp()`.\n            // This is necessary to run retryable operations that failed during\n            // their initial attempt since we don't know whether they are already\n            // enqueued. If, for example, `op1`, `op2`, `op3` are enqueued and `op1`\n            // needs to  be re-run, we will run `op1`, `op1`, `op2` using the\n            // already enqueued calls to `retryNextOp()`. `op3()` will then run in the\n            // call scheduled here.\n            // Since `backoffAndRun()` cancels an existing backoff and schedules a\n            // new backoff on every call, there is only ever a single additional\n            // operation in the queue.\n            this.backoff.backoffAndRun(() => this.retryNextOp());\n        }\n    }\n    enqueueInternal(op) {\n        const newTail = this.tail.then(() => {\n            this.operationInProgress = true;\n            return op()\n                .catch((error) => {\n                this.failure = error;\n                this.operationInProgress = false;\n                const message = getMessageOrStack(error);\n                logError('INTERNAL UNHANDLED ERROR: ', message);\n                // Re-throw the error so that this.tail becomes a rejected Promise and\n                // all further attempts to chain (via .then) will just short-circuit\n                // and return the rejected Promise.\n                throw error;\n            })\n                .then(result => {\n                this.operationInProgress = false;\n                return result;\n            });\n        });\n        this.tail = newTail;\n        return newTail;\n    }\n    enqueueAfterDelay(timerId, delayMs, op) {\n        this.verifyNotFailed();\n        // Fast-forward delays for timerIds that have been overridden.\n        if (this.timerIdsToSkip.indexOf(timerId) > -1) {\n            delayMs = 0;\n        }\n        const delayedOp = DelayedOperation.createAndSchedule(this, timerId, delayMs, op, removedOp => this.removeDelayedOperation(removedOp));\n        this.delayedOperations.push(delayedOp);\n        return delayedOp;\n    }\n    verifyNotFailed() {\n        if (this.failure) {\n            fail();\n        }\n    }\n    verifyOperationInProgress() {\n    }\n    /**\n     * Waits until all currently queued tasks are finished executing. Delayed\n     * operations are not run.\n     */\n    async drain() {\n        // Operations in the queue prior to draining may have enqueued additional\n        // operations. Keep draining the queue until the tail is no longer advanced,\n        // which indicates that no more new operations were enqueued and that all\n        // operations were executed.\n        let currentTail;\n        do {\n            currentTail = this.tail;\n            await currentTail;\n        } while (currentTail !== this.tail);\n    }\n    /**\n     * For Tests: Determine if a delayed operation with a particular TimerId\n     * exists.\n     */\n    containsDelayedOperation(timerId) {\n        for (const op of this.delayedOperations) {\n            if (op.timerId === timerId) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * For Tests: Runs some or all delayed operations early.\n     *\n     * @param lastTimerId - Delayed operations up to and including this TimerId\n     * will be drained. Pass TimerId.All to run all delayed operations.\n     * @returns a Promise that resolves once all operations have been run.\n     */\n    runAllDelayedOperationsUntil(lastTimerId) {\n        // Note that draining may generate more delayed ops, so we do that first.\n        return this.drain().then(() => {\n            // Run ops in the same order they'd run if they ran naturally.\n            /* eslint-disable-next-line @typescript-eslint/no-floating-promises */\n            this.delayedOperations.sort((a, b) => a.targetTimeMs - b.targetTimeMs);\n            for (const op of this.delayedOperations) {\n                op.skipDelay();\n                if (lastTimerId !== \"all\" /* TimerId.All */ && op.timerId === lastTimerId) {\n                    break;\n                }\n            }\n            return this.drain();\n        });\n    }\n    /**\n     * For Tests: Skip all subsequent delays for a timer id.\n     */\n    skipDelaysForTimerId(timerId) {\n        this.timerIdsToSkip.push(timerId);\n    }\n    /** Called once a DelayedOperation is run or canceled. */\n    removeDelayedOperation(op) {\n        // NOTE: indexOf / slice are O(n), but delayedOperations is expected to be small.\n        const index = this.delayedOperations.indexOf(op);\n        /* eslint-disable-next-line @typescript-eslint/no-floating-promises */\n        this.delayedOperations.splice(index, 1);\n    }\n}\n/**\n * Chrome includes Error.message in Error.stack. Other browsers do not.\n * This returns expected output of message + stack when available.\n * @param error - Error or FirestoreError\n */\nfunction getMessageOrStack(error) {\n    let message = error.message || '';\n    if (error.stack) {\n        if (error.stack.includes(error.message)) {\n            message = error.stack;\n        }\n        else {\n            message = error.message + '\\n' + error.stack;\n        }\n    }\n    return message;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents the task of loading a Firestore bundle. It provides progress of bundle\n * loading, as well as task completion and error events.\n *\n * The API is compatible with `Promise<LoadBundleTaskProgress>`.\n */\nclass LoadBundleTask {\n    constructor() {\n        this._progressObserver = {};\n        this._taskCompletionResolver = new Deferred();\n        this._lastProgress = {\n            taskState: 'Running',\n            totalBytes: 0,\n            totalDocuments: 0,\n            bytesLoaded: 0,\n            documentsLoaded: 0\n        };\n    }\n    /**\n     * Registers functions to listen to bundle loading progress events.\n     * @param next - Called when there is a progress update from bundle loading. Typically `next` calls occur\n     *   each time a Firestore document is loaded from the bundle.\n     * @param error - Called when an error occurs during bundle loading. The task aborts after reporting the\n     *   error, and there should be no more updates after this.\n     * @param complete - Called when the loading task is complete.\n     */\n    onProgress(next, error, complete) {\n        this._progressObserver = {\n            next,\n            error,\n            complete\n        };\n    }\n    /**\n     * Implements the `Promise<LoadBundleTaskProgress>.catch` interface.\n     *\n     * @param onRejected - Called when an error occurs during bundle loading.\n     */\n    catch(onRejected) {\n        return this._taskCompletionResolver.promise.catch(onRejected);\n    }\n    /**\n     * Implements the `Promise<LoadBundleTaskProgress>.then` interface.\n     *\n     * @param onFulfilled - Called on the completion of the loading task with a final `LoadBundleTaskProgress` update.\n     *   The update will always have its `taskState` set to `\"Success\"`.\n     * @param onRejected - Called when an error occurs during bundle loading.\n     */\n    then(onFulfilled, onRejected) {\n        return this._taskCompletionResolver.promise.then(onFulfilled, onRejected);\n    }\n    /**\n     * Notifies all observers that bundle loading has completed, with a provided\n     * `LoadBundleTaskProgress` object.\n     *\n     * @private\n     */\n    _completeWith(progress) {\n        this._updateProgress(progress);\n        if (this._progressObserver.complete) {\n            this._progressObserver.complete();\n        }\n        this._taskCompletionResolver.resolve(progress);\n    }\n    /**\n     * Notifies all observers that bundle loading has failed, with a provided\n     * `Error` as the reason.\n     *\n     * @private\n     */\n    _failWith(error) {\n        this._lastProgress.taskState = 'Error';\n        if (this._progressObserver.next) {\n            this._progressObserver.next(this._lastProgress);\n        }\n        if (this._progressObserver.error) {\n            this._progressObserver.error(error);\n        }\n        this._taskCompletionResolver.reject(error);\n    }\n    /**\n     * Notifies a progress update of loading a bundle.\n     * @param progress - The new progress.\n     *\n     * @private\n     */\n    _updateProgress(progress) {\n        this._lastProgress = progress;\n        if (this._progressObserver.next) {\n            this._progressObserver.next(progress);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Constant used to indicate the LRU garbage collection should be disabled.\n * Set this value as the `cacheSizeBytes` on the settings passed to the\n * {@link Firestore} instance.\n */\nconst CACHE_SIZE_UNLIMITED = LRU_COLLECTION_DISABLED;\n/**\n * The Cloud Firestore service interface.\n *\n * Do not call this constructor directly. Instead, use {@link (getFirestore:1)}.\n */\nclass Firestore extends Firestore$1 {\n    /** @hideconstructor */\n    constructor(authCredentialsProvider, appCheckCredentialsProvider, databaseId, app) {\n        super(authCredentialsProvider, appCheckCredentialsProvider, databaseId, app);\n        /**\n         * Whether it's a {@link Firestore} or Firestore Lite instance.\n         */\n        this.type = 'firestore';\n        this._queue = new AsyncQueueImpl();\n        this._persistenceKey = (app === null || app === void 0 ? void 0 : app.name) || '[DEFAULT]';\n    }\n    async _terminate() {\n        if (this._firestoreClient) {\n            const terminate = this._firestoreClient.terminate();\n            this._queue = new AsyncQueueImpl(terminate);\n            this._firestoreClient = undefined;\n            await terminate;\n        }\n    }\n}\n/**\n * Initializes a new instance of {@link Firestore} with the provided settings.\n * Can only be called before any other function, including\n * {@link (getFirestore:1)}. If the custom settings are empty, this function is\n * equivalent to calling {@link (getFirestore:1)}.\n *\n * @param app - The {@link @firebase/app#FirebaseApp} with which the {@link Firestore} instance will\n * be associated.\n * @param settings - A settings object to configure the {@link Firestore} instance.\n * @param databaseId - The name of the database.\n * @returns A newly initialized {@link Firestore} instance.\n */\nfunction initializeFirestore(app, settings, databaseId) {\n    if (!databaseId) {\n        databaseId = DEFAULT_DATABASE_NAME;\n    }\n    const provider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, 'firestore');\n    if (provider.isInitialized(databaseId)) {\n        const existingInstance = provider.getImmediate({\n            identifier: databaseId\n        });\n        const initialSettings = provider.getOptions(databaseId);\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(initialSettings, settings)) {\n            return existingInstance;\n        }\n        else {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'initializeFirestore() has already been called with ' +\n                'different options. To avoid this error, call initializeFirestore() with the ' +\n                'same options as when it was originally called, or call getFirestore() to return the' +\n                ' already initialized instance.');\n        }\n    }\n    if (settings.cacheSizeBytes !== undefined &&\n        settings.localCache !== undefined) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `cache and cacheSizeBytes cannot be specified at the same time as cacheSizeBytes will` +\n            `be deprecated. Instead, specify the cache size in the cache object`);\n    }\n    if (settings.cacheSizeBytes !== undefined &&\n        settings.cacheSizeBytes !== CACHE_SIZE_UNLIMITED &&\n        settings.cacheSizeBytes < LRU_MINIMUM_CACHE_SIZE_BYTES) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `cacheSizeBytes must be at least ${LRU_MINIMUM_CACHE_SIZE_BYTES}`);\n    }\n    return provider.initialize({\n        options: settings,\n        instanceIdentifier: databaseId\n    });\n}\nfunction getFirestore(appOrDatabaseId, optionalDatabaseId) {\n    const app = typeof appOrDatabaseId === 'object' ? appOrDatabaseId : (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)();\n    const databaseId = typeof appOrDatabaseId === 'string'\n        ? appOrDatabaseId\n        : optionalDatabaseId || DEFAULT_DATABASE_NAME;\n    const db = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, 'firestore').getImmediate({\n        identifier: databaseId\n    });\n    if (!db._initialized) {\n        const emulator = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getDefaultEmulatorHostnameAndPort)('firestore');\n        if (emulator) {\n            connectFirestoreEmulator(db, ...emulator);\n        }\n    }\n    return db;\n}\n/**\n * @internal\n */\nfunction ensureFirestoreConfigured(firestore) {\n    if (firestore._terminated) {\n        throw new FirestoreError(Code.FAILED_PRECONDITION, 'The client has already been terminated.');\n    }\n    if (!firestore._firestoreClient) {\n        configureFirestore(firestore);\n    }\n    return firestore._firestoreClient;\n}\nfunction configureFirestore(firestore) {\n    var _a, _b, _c;\n    const settings = firestore._freezeSettings();\n    const databaseInfo = makeDatabaseInfo(firestore._databaseId, ((_a = firestore._app) === null || _a === void 0 ? void 0 : _a.options.appId) || '', firestore._persistenceKey, settings);\n    if (!firestore._componentsProvider) {\n        if (((_b = settings.localCache) === null || _b === void 0 ? void 0 : _b._offlineComponentProvider) &&\n            ((_c = settings.localCache) === null || _c === void 0 ? void 0 : _c._onlineComponentProvider)) {\n            firestore._componentsProvider = {\n                _offline: settings.localCache._offlineComponentProvider,\n                _online: settings.localCache._onlineComponentProvider\n            };\n        }\n    }\n    firestore._firestoreClient = new FirestoreClient(firestore._authCredentials, firestore._appCheckCredentials, firestore._queue, databaseInfo, firestore._componentsProvider &&\n        buildComponentProvider(firestore._componentsProvider));\n}\nfunction buildComponentProvider(componentsProvider) {\n    const online = componentsProvider === null || componentsProvider === void 0 ? void 0 : componentsProvider._online.build();\n    return {\n        _offline: componentsProvider === null || componentsProvider === void 0 ? void 0 : componentsProvider._offline.build(online),\n        _online: online\n    };\n}\n/**\n * Attempts to enable persistent storage, if possible.\n *\n * On failure, `enableIndexedDbPersistence()` will reject the promise or\n * throw an exception. There are several reasons why this can fail, which can be\n * identified by the `code` on the error.\n *\n *   * failed-precondition: The app is already open in another browser tab.\n *   * unimplemented: The browser is incompatible with the offline persistence\n *     implementation.\n *\n * Note that even after a failure, the {@link Firestore} instance will remain\n * usable, however offline persistence will be disabled.\n *\n * Note: `enableIndexedDbPersistence()` must be called before any other functions\n * (other than {@link initializeFirestore}, {@link (getFirestore:1)} or\n * {@link clearIndexedDbPersistence}.\n *\n * Persistence cannot be used in a Node.js environment.\n *\n * @param firestore - The {@link Firestore} instance to enable persistence for.\n * @param persistenceSettings - Optional settings object to configure\n * persistence.\n * @returns A `Promise` that represents successfully enabling persistent storage.\n * @deprecated This function will be removed in a future major release. Instead, set\n * `FirestoreSettings.localCache` to an instance of `PersistentLocalCache` to\n * turn on IndexedDb cache. Calling this function when `FirestoreSettings.localCache`\n * is already specified will throw an exception.\n */\nfunction enableIndexedDbPersistence(firestore, persistenceSettings) {\n    logWarn('enableIndexedDbPersistence() will be deprecated in the future, ' +\n        'you can use `FirestoreSettings.cache` instead.');\n    const settings = firestore._freezeSettings();\n    setPersistenceProviders(firestore, OnlineComponentProvider.provider, {\n        build: (onlineComponents) => new IndexedDbOfflineComponentProvider(onlineComponents, settings.cacheSizeBytes, persistenceSettings === null || persistenceSettings === void 0 ? void 0 : persistenceSettings.forceOwnership)\n    });\n    return Promise.resolve();\n}\n/**\n * Attempts to enable multi-tab persistent storage, if possible. If enabled\n * across all tabs, all operations share access to local persistence, including\n * shared execution of queries and latency-compensated local document updates\n * across all connected instances.\n *\n * On failure, `enableMultiTabIndexedDbPersistence()` will reject the promise or\n * throw an exception. There are several reasons why this can fail, which can be\n * identified by the `code` on the error.\n *\n *   * failed-precondition: The app is already open in another browser tab and\n *     multi-tab is not enabled.\n *   * unimplemented: The browser is incompatible with the offline persistence\n *     implementation.\n *\n * Note that even after a failure, the {@link Firestore} instance will remain\n * usable, however offline persistence will be disabled.\n *\n * @param firestore - The {@link Firestore} instance to enable persistence for.\n * @returns A `Promise` that represents successfully enabling persistent\n * storage.\n * @deprecated This function will be removed in a future major release. Instead, set\n * `FirestoreSettings.localCache` to an instance of `PersistentLocalCache` to\n * turn on indexeddb cache. Calling this function when `FirestoreSettings.localCache`\n * is already specified will throw an exception.\n */\nasync function enableMultiTabIndexedDbPersistence(firestore) {\n    logWarn('enableMultiTabIndexedDbPersistence() will be deprecated in the future, ' +\n        'you can use `FirestoreSettings.cache` instead.');\n    const settings = firestore._freezeSettings();\n    setPersistenceProviders(firestore, OnlineComponentProvider.provider, {\n        build: (onlineComponents) => new MultiTabOfflineComponentProvider(onlineComponents, settings.cacheSizeBytes)\n    });\n}\n/**\n * Registers both the `OfflineComponentProvider` and `OnlineComponentProvider`.\n * If the operation fails with a recoverable error (see\n * `canRecoverFromIndexedDbError()` below), the returned Promise is rejected\n * but the client remains usable.\n */\nfunction setPersistenceProviders(firestore, onlineComponentProvider, offlineComponentProvider) {\n    firestore = cast(firestore, Firestore);\n    if (firestore._firestoreClient || firestore._terminated) {\n        throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and persistence can no longer be ' +\n            'enabled. You can only enable persistence before calling any other ' +\n            'methods on a Firestore object.');\n    }\n    if (firestore._componentsProvider || firestore._getSettings().localCache) {\n        throw new FirestoreError(Code.FAILED_PRECONDITION, 'SDK cache is already specified.');\n    }\n    firestore._componentsProvider = {\n        _online: onlineComponentProvider,\n        _offline: offlineComponentProvider\n    };\n    configureFirestore(firestore);\n}\n/**\n * Clears the persistent storage. This includes pending writes and cached\n * documents.\n *\n * Must be called while the {@link Firestore} instance is not started (after the app is\n * terminated or when the app is first initialized). On startup, this function\n * must be called before other functions (other than {@link\n * initializeFirestore} or {@link (getFirestore:1)})). If the {@link Firestore}\n * instance is still running, the promise will be rejected with the error code\n * of `failed-precondition`.\n *\n * Note: `clearIndexedDbPersistence()` is primarily intended to help write\n * reliable tests that use Cloud Firestore. It uses an efficient mechanism for\n * dropping existing data but does not attempt to securely overwrite or\n * otherwise make cached data unrecoverable. For applications that are sensitive\n * to the disclosure of cached data in between user sessions, we strongly\n * recommend not enabling persistence at all.\n *\n * @param firestore - The {@link Firestore} instance to clear persistence for.\n * @returns A `Promise` that is resolved when the persistent storage is\n * cleared. Otherwise, the promise is rejected with an error.\n */\nfunction clearIndexedDbPersistence(firestore) {\n    if (firestore._initialized && !firestore._terminated) {\n        throw new FirestoreError(Code.FAILED_PRECONDITION, 'Persistence can only be cleared before a Firestore instance is ' +\n            'initialized or after it is terminated.');\n    }\n    const deferred = new Deferred();\n    firestore._queue.enqueueAndForgetEvenWhileRestricted(async () => {\n        try {\n            await indexedDbClearPersistence(indexedDbStoragePrefix(firestore._databaseId, firestore._persistenceKey));\n            deferred.resolve();\n        }\n        catch (e) {\n            deferred.reject(e);\n        }\n    });\n    return deferred.promise;\n}\n/**\n * Waits until all currently pending writes for the active user have been\n * acknowledged by the backend.\n *\n * The returned promise resolves immediately if there are no outstanding writes.\n * Otherwise, the promise waits for all previously issued writes (including\n * those written in a previous app session), but it does not wait for writes\n * that were added after the function is called. If you want to wait for\n * additional writes, call `waitForPendingWrites()` again.\n *\n * Any outstanding `waitForPendingWrites()` promises are rejected during user\n * changes.\n *\n * @returns A `Promise` which resolves when all currently pending writes have been\n * acknowledged by the backend.\n */\nfunction waitForPendingWrites(firestore) {\n    firestore = cast(firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientWaitForPendingWrites(client);\n}\n/**\n * Re-enables use of the network for this {@link Firestore} instance after a prior\n * call to {@link disableNetwork}.\n *\n * @returns A `Promise` that is resolved once the network has been enabled.\n */\nfunction enableNetwork(firestore) {\n    firestore = cast(firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientEnableNetwork(client);\n}\n/**\n * Disables network usage for this instance. It can be re-enabled via {@link\n * enableNetwork}. While the network is disabled, any snapshot listeners,\n * `getDoc()` or `getDocs()` calls will return results from cache, and any write\n * operations will be queued until the network is restored.\n *\n * @returns A `Promise` that is resolved once the network has been disabled.\n */\nfunction disableNetwork(firestore) {\n    firestore = cast(firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientDisableNetwork(client);\n}\n/**\n * Terminates the provided {@link Firestore} instance.\n *\n * After calling `terminate()` only the `clearIndexedDbPersistence()` function\n * may be used. Any other function will throw a `FirestoreError`.\n *\n * To restart after termination, create a new instance of FirebaseFirestore with\n * {@link (getFirestore:1)}.\n *\n * Termination does not cancel any pending writes, and any promises that are\n * awaiting a response from the server will not be resolved. If you have\n * persistence enabled, the next time you start this instance, it will resume\n * sending these writes to the server.\n *\n * Note: Under normal circumstances, calling `terminate()` is not required. This\n * function is useful only when you want to force this instance to release all\n * of its resources or in combination with `clearIndexedDbPersistence()` to\n * ensure that all local state is destroyed between test runs.\n *\n * @returns A `Promise` that is resolved when the instance has been successfully\n * terminated.\n */\nfunction terminate(firestore) {\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._removeServiceInstance)(firestore.app, 'firestore', firestore._databaseId.database);\n    return firestore._delete();\n}\n/**\n * Loads a Firestore bundle into the local cache.\n *\n * @param firestore - The {@link Firestore} instance to load bundles for.\n * @param bundleData - An object representing the bundle to be loaded. Valid\n * objects are `ArrayBuffer`, `ReadableStream<Uint8Array>` or `string`.\n *\n * @returns A `LoadBundleTask` object, which notifies callers with progress\n * updates, and completion or error events. It can be used as a\n * `Promise<LoadBundleTaskProgress>`.\n */\nfunction loadBundle(firestore, bundleData) {\n    firestore = cast(firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const resultTask = new LoadBundleTask();\n    firestoreClientLoadBundle(client, firestore._databaseId, bundleData, resultTask);\n    return resultTask;\n}\n/**\n * Reads a Firestore {@link Query} from local cache, identified by the given\n * name.\n *\n * The named queries are packaged  into bundles on the server side (along\n * with resulting documents), and loaded to local cache using `loadBundle`. Once\n * in local cache, use this method to extract a {@link Query} by name.\n *\n * @param firestore - The {@link Firestore} instance to read the query from.\n * @param name - The name of the query.\n * @returns A `Promise` that is resolved with the Query or `null`.\n */\nfunction namedQuery(firestore, name) {\n    firestore = cast(firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientGetNamedQuery(client, name).then(namedQuery => {\n        if (!namedQuery) {\n            return null;\n        }\n        return new Query(firestore, null, namedQuery.query);\n    });\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction registerFirestore(variant, useFetchStreams = true) {\n    setSDKVersion(_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION);\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.Component('firestore', (container, { instanceIdentifier: databaseId, options: settings }) => {\n        const app = container.getProvider('app').getImmediate();\n        const firestoreInstance = new Firestore(new FirebaseAuthCredentialsProvider(container.getProvider('auth-internal')), new FirebaseAppCheckTokenProvider(container.getProvider('app-check-internal')), databaseIdFromApp(app, databaseId), app);\n        settings = Object.assign({ useFetchStreams }, settings);\n        firestoreInstance._setSettings(settings);\n        return firestoreInstance;\n    }, 'PUBLIC').setMultipleInstances(true));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version$1, variant);\n    // BUILD_TARGET will be replaced by values like esm2017, cjs2017, etc during the compilation\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version$1, 'esm2017');\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Concrete implementation of the Aggregate type.\n */\nclass AggregateImpl {\n    constructor(alias, aggregateType, fieldPath) {\n        this.alias = alias;\n        this.aggregateType = aggregateType;\n        this.fieldPath = fieldPath;\n    }\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents an aggregation that can be performed by Firestore.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nclass AggregateField {\n    /**\n     * Create a new AggregateField<T>\n     * @param aggregateType Specifies the type of aggregation operation to perform.\n     * @param _internalFieldPath Optionally specifies the field that is aggregated.\n     * @internal\n     */\n    constructor(aggregateType = 'count', _internalFieldPath) {\n        this._internalFieldPath = _internalFieldPath;\n        /** A type string to uniquely identify instances of this class. */\n        this.type = 'AggregateField';\n        this.aggregateType = aggregateType;\n    }\n}\n/**\n * The results of executing an aggregation query.\n */\nclass AggregateQuerySnapshot {\n    /** @hideconstructor */\n    constructor(query, _userDataWriter, _data) {\n        this._userDataWriter = _userDataWriter;\n        this._data = _data;\n        /** A type string to uniquely identify instances of this class. */\n        this.type = 'AggregateQuerySnapshot';\n        this.query = query;\n    }\n    /**\n     * Returns the results of the aggregations performed over the underlying\n     * query.\n     *\n     * The keys of the returned object will be the same as those of the\n     * `AggregateSpec` object specified to the aggregation method, and the values\n     * will be the corresponding aggregation result.\n     *\n     * @returns The results of the aggregations performed over the underlying\n     * query.\n     */\n    data() {\n        return this._userDataWriter.convertObjectMap(this._data);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An immutable object representing an array of bytes.\n */\nclass Bytes {\n    /** @hideconstructor */\n    constructor(byteString) {\n        this._byteString = byteString;\n    }\n    /**\n     * Creates a new `Bytes` object from the given Base64 string, converting it to\n     * bytes.\n     *\n     * @param base64 - The Base64 string used to create the `Bytes` object.\n     */\n    static fromBase64String(base64) {\n        try {\n            return new Bytes(ByteString.fromBase64String(base64));\n        }\n        catch (e) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Failed to construct data from Base64 string: ' + e);\n        }\n    }\n    /**\n     * Creates a new `Bytes` object from the given Uint8Array.\n     *\n     * @param array - The Uint8Array used to create the `Bytes` object.\n     */\n    static fromUint8Array(array) {\n        return new Bytes(ByteString.fromUint8Array(array));\n    }\n    /**\n     * Returns the underlying bytes as a Base64-encoded string.\n     *\n     * @returns The Base64-encoded string created from the `Bytes` object.\n     */\n    toBase64() {\n        return this._byteString.toBase64();\n    }\n    /**\n     * Returns the underlying bytes in a new `Uint8Array`.\n     *\n     * @returns The Uint8Array created from the `Bytes` object.\n     */\n    toUint8Array() {\n        return this._byteString.toUint8Array();\n    }\n    /**\n     * Returns a string representation of the `Bytes` object.\n     *\n     * @returns A string representation of the `Bytes` object.\n     */\n    toString() {\n        return 'Bytes(base64: ' + this.toBase64() + ')';\n    }\n    /**\n     * Returns true if this `Bytes` object is equal to the provided one.\n     *\n     * @param other - The `Bytes` object to compare against.\n     * @returns true if this `Bytes` object is equal to the provided one.\n     */\n    isEqual(other) {\n        return this._byteString.isEqual(other._byteString);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A `FieldPath` refers to a field in a document. The path may consist of a\n * single field name (referring to a top-level field in the document), or a\n * list of field names (referring to a nested field in the document).\n *\n * Create a `FieldPath` by providing field names. If more than one field\n * name is provided, the path will point to a nested field in a document.\n */\nclass FieldPath {\n    /**\n     * Creates a `FieldPath` from the provided field names. If more than one field\n     * name is provided, the path will point to a nested field in a document.\n     *\n     * @param fieldNames - A list of field names.\n     */\n    constructor(...fieldNames) {\n        for (let i = 0; i < fieldNames.length; ++i) {\n            if (fieldNames[i].length === 0) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid field name at argument $(i + 1). ` +\n                    'Field names must not be empty.');\n            }\n        }\n        this._internalPath = new FieldPath$1(fieldNames);\n    }\n    /**\n     * Returns true if this `FieldPath` is equal to the provided one.\n     *\n     * @param other - The `FieldPath` to compare against.\n     * @returns true if this `FieldPath` is equal to the provided one.\n     */\n    isEqual(other) {\n        return this._internalPath.isEqual(other._internalPath);\n    }\n}\n/**\n * Returns a special sentinel `FieldPath` to refer to the ID of a document.\n * It can be used in queries to sort or filter by the document ID.\n */\nfunction documentId() {\n    return new FieldPath(DOCUMENT_KEY_NAME);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Sentinel values that can be used when writing document fields with `set()`\n * or `update()`.\n */\nclass FieldValue {\n    /**\n     * @param _methodName - The public API endpoint that returns this class.\n     * @hideconstructor\n     */\n    constructor(_methodName) {\n        this._methodName = _methodName;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An immutable object representing a geographic location in Firestore. The\n * location is represented as latitude/longitude pair.\n *\n * Latitude values are in the range of [-90, 90].\n * Longitude values are in the range of [-180, 180].\n */\nclass GeoPoint {\n    /**\n     * Creates a new immutable `GeoPoint` object with the provided latitude and\n     * longitude values.\n     * @param latitude - The latitude as number between -90 and 90.\n     * @param longitude - The longitude as number between -180 and 180.\n     */\n    constructor(latitude, longitude) {\n        if (!isFinite(latitude) || latitude < -90 || latitude > 90) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Latitude must be a number between -90 and 90, but was: ' + latitude);\n        }\n        if (!isFinite(longitude) || longitude < -180 || longitude > 180) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Longitude must be a number between -180 and 180, but was: ' + longitude);\n        }\n        this._lat = latitude;\n        this._long = longitude;\n    }\n    /**\n     * The latitude of this `GeoPoint` instance.\n     */\n    get latitude() {\n        return this._lat;\n    }\n    /**\n     * The longitude of this `GeoPoint` instance.\n     */\n    get longitude() {\n        return this._long;\n    }\n    /**\n     * Returns true if this `GeoPoint` is equal to the provided one.\n     *\n     * @param other - The `GeoPoint` to compare against.\n     * @returns true if this `GeoPoint` is equal to the provided one.\n     */\n    isEqual(other) {\n        return this._lat === other._lat && this._long === other._long;\n    }\n    /** Returns a JSON-serializable representation of this GeoPoint. */\n    toJSON() {\n        return { latitude: this._lat, longitude: this._long };\n    }\n    /**\n     * Actually private to JS consumers of our API, so this function is prefixed\n     * with an underscore.\n     */\n    _compareTo(other) {\n        return (primitiveComparator(this._lat, other._lat) ||\n            primitiveComparator(this._long, other._long));\n    }\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a vector type in Firestore documents.\n * Create an instance with {@link FieldValue.vector}.\n *\n * @class VectorValue\n */\nclass VectorValue {\n    /**\n     * @private\n     * @internal\n     */\n    constructor(values) {\n        // Making a copy of the parameter.\n        this._values = (values || []).map(n => n);\n    }\n    /**\n     * Returns a copy of the raw number array form of the vector.\n     */\n    toArray() {\n        return this._values.map(n => n);\n    }\n    /**\n     * Returns `true` if the two VectorValue has the same raw number arrays, returns `false` otherwise.\n     */\n    isEqual(other) {\n        return isPrimitiveArrayEqual(this._values, other._values);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst RESERVED_FIELD_REGEX = /^__.*__$/;\n/** The result of parsing document data (e.g. for a setData call). */\nclass ParsedSetData {\n    constructor(data, fieldMask, fieldTransforms) {\n        this.data = data;\n        this.fieldMask = fieldMask;\n        this.fieldTransforms = fieldTransforms;\n    }\n    toMutation(key, precondition) {\n        if (this.fieldMask !== null) {\n            return new PatchMutation(key, this.data, this.fieldMask, precondition, this.fieldTransforms);\n        }\n        else {\n            return new SetMutation(key, this.data, precondition, this.fieldTransforms);\n        }\n    }\n}\n/** The result of parsing \"update\" data (i.e. for an updateData call). */\nclass ParsedUpdateData {\n    constructor(data, \n    // The fieldMask does not include document transforms.\n    fieldMask, fieldTransforms) {\n        this.data = data;\n        this.fieldMask = fieldMask;\n        this.fieldTransforms = fieldTransforms;\n    }\n    toMutation(key, precondition) {\n        return new PatchMutation(key, this.data, this.fieldMask, precondition, this.fieldTransforms);\n    }\n}\nfunction isWrite(dataSource) {\n    switch (dataSource) {\n        case 0 /* UserDataSource.Set */: // fall through\n        case 2 /* UserDataSource.MergeSet */: // fall through\n        case 1 /* UserDataSource.Update */:\n            return true;\n        case 3 /* UserDataSource.Argument */:\n        case 4 /* UserDataSource.ArrayArgument */:\n            return false;\n        default:\n            throw fail();\n    }\n}\n/** A \"context\" object passed around while parsing user data. */\nclass ParseContextImpl {\n    /**\n     * Initializes a ParseContext with the given source and path.\n     *\n     * @param settings - The settings for the parser.\n     * @param databaseId - The database ID of the Firestore instance.\n     * @param serializer - The serializer to use to generate the Value proto.\n     * @param ignoreUndefinedProperties - Whether to ignore undefined properties\n     * rather than throw.\n     * @param fieldTransforms - A mutable list of field transforms encountered\n     * while parsing the data.\n     * @param fieldMask - A mutable list of field paths encountered while parsing\n     * the data.\n     *\n     * TODO(b/34871131): We don't support array paths right now, so path can be\n     * null to indicate the context represents any location within an array (in\n     * which case certain features will not work and errors will be somewhat\n     * compromised).\n     */\n    constructor(settings, databaseId, serializer, ignoreUndefinedProperties, fieldTransforms, fieldMask) {\n        this.settings = settings;\n        this.databaseId = databaseId;\n        this.serializer = serializer;\n        this.ignoreUndefinedProperties = ignoreUndefinedProperties;\n        // Minor hack: If fieldTransforms is undefined, we assume this is an\n        // external call and we need to validate the entire path.\n        if (fieldTransforms === undefined) {\n            this.validatePath();\n        }\n        this.fieldTransforms = fieldTransforms || [];\n        this.fieldMask = fieldMask || [];\n    }\n    get path() {\n        return this.settings.path;\n    }\n    get dataSource() {\n        return this.settings.dataSource;\n    }\n    /** Returns a new context with the specified settings overwritten. */\n    contextWith(configuration) {\n        return new ParseContextImpl(Object.assign(Object.assign({}, this.settings), configuration), this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);\n    }\n    childContextForField(field) {\n        var _a;\n        const childPath = (_a = this.path) === null || _a === void 0 ? void 0 : _a.child(field);\n        const context = this.contextWith({ path: childPath, arrayElement: false });\n        context.validatePathSegment(field);\n        return context;\n    }\n    childContextForFieldPath(field) {\n        var _a;\n        const childPath = (_a = this.path) === null || _a === void 0 ? void 0 : _a.child(field);\n        const context = this.contextWith({ path: childPath, arrayElement: false });\n        context.validatePath();\n        return context;\n    }\n    childContextForArray(index) {\n        // TODO(b/34871131): We don't support array paths right now; so make path\n        // undefined.\n        return this.contextWith({ path: undefined, arrayElement: true });\n    }\n    createError(reason) {\n        return createError(reason, this.settings.methodName, this.settings.hasConverter || false, this.path, this.settings.targetDoc);\n    }\n    /** Returns 'true' if 'fieldPath' was traversed when creating this context. */\n    contains(fieldPath) {\n        return (this.fieldMask.find(field => fieldPath.isPrefixOf(field)) !== undefined ||\n            this.fieldTransforms.find(transform => fieldPath.isPrefixOf(transform.field)) !== undefined);\n    }\n    validatePath() {\n        // TODO(b/34871131): Remove null check once we have proper paths for fields\n        // within arrays.\n        if (!this.path) {\n            return;\n        }\n        for (let i = 0; i < this.path.length; i++) {\n            this.validatePathSegment(this.path.get(i));\n        }\n    }\n    validatePathSegment(segment) {\n        if (segment.length === 0) {\n            throw this.createError('Document fields must not be empty');\n        }\n        if (isWrite(this.dataSource) && RESERVED_FIELD_REGEX.test(segment)) {\n            throw this.createError('Document fields cannot begin and end with \"__\"');\n        }\n    }\n}\n/**\n * Helper for parsing raw user input (provided via the API) into internal model\n * classes.\n */\nclass UserDataReader {\n    constructor(databaseId, ignoreUndefinedProperties, serializer) {\n        this.databaseId = databaseId;\n        this.ignoreUndefinedProperties = ignoreUndefinedProperties;\n        this.serializer = serializer || newSerializer(databaseId);\n    }\n    /** Creates a new top-level parse context. */\n    createContext(dataSource, methodName, targetDoc, hasConverter = false) {\n        return new ParseContextImpl({\n            dataSource,\n            methodName,\n            targetDoc,\n            path: FieldPath$1.emptyPath(),\n            arrayElement: false,\n            hasConverter\n        }, this.databaseId, this.serializer, this.ignoreUndefinedProperties);\n    }\n}\nfunction newUserDataReader(firestore) {\n    const settings = firestore._freezeSettings();\n    const serializer = newSerializer(firestore._databaseId);\n    return new UserDataReader(firestore._databaseId, !!settings.ignoreUndefinedProperties, serializer);\n}\n/** Parse document data from a set() call. */\nfunction parseSetData(userDataReader, methodName, targetDoc, input, hasConverter, options = {}) {\n    const context = userDataReader.createContext(options.merge || options.mergeFields\n        ? 2 /* UserDataSource.MergeSet */\n        : 0 /* UserDataSource.Set */, methodName, targetDoc, hasConverter);\n    validatePlainObject('Data must be an object, but it was:', context, input);\n    const updateData = parseObject(input, context);\n    let fieldMask;\n    let fieldTransforms;\n    if (options.merge) {\n        fieldMask = new FieldMask(context.fieldMask);\n        fieldTransforms = context.fieldTransforms;\n    }\n    else if (options.mergeFields) {\n        const validatedFieldPaths = [];\n        for (const stringOrFieldPath of options.mergeFields) {\n            const fieldPath = fieldPathFromArgument$1(methodName, stringOrFieldPath, targetDoc);\n            if (!context.contains(fieldPath)) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Field '${fieldPath}' is specified in your field mask but missing from your input data.`);\n            }\n            if (!fieldMaskContains(validatedFieldPaths, fieldPath)) {\n                validatedFieldPaths.push(fieldPath);\n            }\n        }\n        fieldMask = new FieldMask(validatedFieldPaths);\n        fieldTransforms = context.fieldTransforms.filter(transform => fieldMask.covers(transform.field));\n    }\n    else {\n        fieldMask = null;\n        fieldTransforms = context.fieldTransforms;\n    }\n    return new ParsedSetData(new ObjectValue(updateData), fieldMask, fieldTransforms);\n}\nclass DeleteFieldValueImpl extends FieldValue {\n    _toFieldTransform(context) {\n        if (context.dataSource === 2 /* UserDataSource.MergeSet */) {\n            // No transform to add for a delete, but we need to add it to our\n            // fieldMask so it gets deleted.\n            context.fieldMask.push(context.path);\n        }\n        else if (context.dataSource === 1 /* UserDataSource.Update */) {\n            throw context.createError(`${this._methodName}() can only appear at the top level ` +\n                'of your update data');\n        }\n        else {\n            // We shouldn't encounter delete sentinels for queries or non-merge set() calls.\n            throw context.createError(`${this._methodName}() cannot be used with set() unless you pass ` +\n                '{merge:true}');\n        }\n        return null;\n    }\n    isEqual(other) {\n        return other instanceof DeleteFieldValueImpl;\n    }\n}\n/**\n * Creates a child context for parsing SerializableFieldValues.\n *\n * This is different than calling `ParseContext.contextWith` because it keeps\n * the fieldTransforms and fieldMask separate.\n *\n * The created context has its `dataSource` set to `UserDataSource.Argument`.\n * Although these values are used with writes, any elements in these FieldValues\n * are not considered writes since they cannot contain any FieldValue sentinels,\n * etc.\n *\n * @param fieldValue - The sentinel FieldValue for which to create a child\n *     context.\n * @param context - The parent context.\n * @param arrayElement - Whether or not the FieldValue has an array.\n */\nfunction createSentinelChildContext(fieldValue, context, arrayElement) {\n    return new ParseContextImpl({\n        dataSource: 3 /* UserDataSource.Argument */,\n        targetDoc: context.settings.targetDoc,\n        methodName: fieldValue._methodName,\n        arrayElement\n    }, context.databaseId, context.serializer, context.ignoreUndefinedProperties);\n}\nclass ServerTimestampFieldValueImpl extends FieldValue {\n    _toFieldTransform(context) {\n        return new FieldTransform(context.path, new ServerTimestampTransform());\n    }\n    isEqual(other) {\n        return other instanceof ServerTimestampFieldValueImpl;\n    }\n}\nclass ArrayUnionFieldValueImpl extends FieldValue {\n    constructor(methodName, _elements) {\n        super(methodName);\n        this._elements = _elements;\n    }\n    _toFieldTransform(context) {\n        const parseContext = createSentinelChildContext(this, context, \n        /*array=*/ true);\n        const parsedElements = this._elements.map(element => parseData(element, parseContext));\n        const arrayUnion = new ArrayUnionTransformOperation(parsedElements);\n        return new FieldTransform(context.path, arrayUnion);\n    }\n    isEqual(other) {\n        return (other instanceof ArrayUnionFieldValueImpl &&\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(this._elements, other._elements));\n    }\n}\nclass ArrayRemoveFieldValueImpl extends FieldValue {\n    constructor(methodName, _elements) {\n        super(methodName);\n        this._elements = _elements;\n    }\n    _toFieldTransform(context) {\n        const parseContext = createSentinelChildContext(this, context, \n        /*array=*/ true);\n        const parsedElements = this._elements.map(element => parseData(element, parseContext));\n        const arrayUnion = new ArrayRemoveTransformOperation(parsedElements);\n        return new FieldTransform(context.path, arrayUnion);\n    }\n    isEqual(other) {\n        return (other instanceof ArrayRemoveFieldValueImpl &&\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(this._elements, other._elements));\n    }\n}\nclass NumericIncrementFieldValueImpl extends FieldValue {\n    constructor(methodName, _operand) {\n        super(methodName);\n        this._operand = _operand;\n    }\n    _toFieldTransform(context) {\n        const numericIncrement = new NumericIncrementTransformOperation(context.serializer, toNumber(context.serializer, this._operand));\n        return new FieldTransform(context.path, numericIncrement);\n    }\n    isEqual(other) {\n        return (other instanceof NumericIncrementFieldValueImpl &&\n            this._operand === other._operand);\n    }\n}\n/** Parse update data from an update() call. */\nfunction parseUpdateData(userDataReader, methodName, targetDoc, input) {\n    const context = userDataReader.createContext(1 /* UserDataSource.Update */, methodName, targetDoc);\n    validatePlainObject('Data must be an object, but it was:', context, input);\n    const fieldMaskPaths = [];\n    const updateData = ObjectValue.empty();\n    forEach(input, (key, value) => {\n        const path = fieldPathFromDotSeparatedString(methodName, key, targetDoc);\n        // For Compat types, we have to \"extract\" the underlying types before\n        // performing validation.\n        value = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(value);\n        const childContext = context.childContextForFieldPath(path);\n        if (value instanceof DeleteFieldValueImpl) {\n            // Add it to the field mask, but don't add anything to updateData.\n            fieldMaskPaths.push(path);\n        }\n        else {\n            const parsedValue = parseData(value, childContext);\n            if (parsedValue != null) {\n                fieldMaskPaths.push(path);\n                updateData.set(path, parsedValue);\n            }\n        }\n    });\n    const mask = new FieldMask(fieldMaskPaths);\n    return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\n}\n/** Parse update data from a list of field/value arguments. */\nfunction parseUpdateVarargs(userDataReader, methodName, targetDoc, field, value, moreFieldsAndValues) {\n    const context = userDataReader.createContext(1 /* UserDataSource.Update */, methodName, targetDoc);\n    const keys = [fieldPathFromArgument$1(methodName, field, targetDoc)];\n    const values = [value];\n    if (moreFieldsAndValues.length % 2 !== 0) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${methodName}() needs to be called with an even number ` +\n            'of arguments that alternate between field names and values.');\n    }\n    for (let i = 0; i < moreFieldsAndValues.length; i += 2) {\n        keys.push(fieldPathFromArgument$1(methodName, moreFieldsAndValues[i]));\n        values.push(moreFieldsAndValues[i + 1]);\n    }\n    const fieldMaskPaths = [];\n    const updateData = ObjectValue.empty();\n    // We iterate in reverse order to pick the last value for a field if the\n    // user specified the field multiple times.\n    for (let i = keys.length - 1; i >= 0; --i) {\n        if (!fieldMaskContains(fieldMaskPaths, keys[i])) {\n            const path = keys[i];\n            let value = values[i];\n            // For Compat types, we have to \"extract\" the underlying types before\n            // performing validation.\n            value = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(value);\n            const childContext = context.childContextForFieldPath(path);\n            if (value instanceof DeleteFieldValueImpl) {\n                // Add it to the field mask, but don't add anything to updateData.\n                fieldMaskPaths.push(path);\n            }\n            else {\n                const parsedValue = parseData(value, childContext);\n                if (parsedValue != null) {\n                    fieldMaskPaths.push(path);\n                    updateData.set(path, parsedValue);\n                }\n            }\n        }\n    }\n    const mask = new FieldMask(fieldMaskPaths);\n    return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\n}\n/**\n * Parse a \"query value\" (e.g. value in a where filter or a value in a cursor\n * bound).\n *\n * @param allowArrays - Whether the query value is an array that may directly\n * contain additional arrays (e.g. the operand of an `in` query).\n */\nfunction parseQueryValue(userDataReader, methodName, input, allowArrays = false) {\n    const context = userDataReader.createContext(allowArrays ? 4 /* UserDataSource.ArrayArgument */ : 3 /* UserDataSource.Argument */, methodName);\n    const parsed = parseData(input, context);\n    return parsed;\n}\n/**\n * Parses user data to Protobuf Values.\n *\n * @param input - Data to be parsed.\n * @param context - A context object representing the current path being parsed,\n * the source of the data being parsed, etc.\n * @returns The parsed value, or null if the value was a FieldValue sentinel\n * that should not be included in the resulting parsed data.\n */\nfunction parseData(input, context) {\n    // Unwrap the API type from the Compat SDK. This will return the API type\n    // from firestore-exp.\n    input = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(input);\n    if (looksLikeJsonObject(input)) {\n        validatePlainObject('Unsupported field value:', context, input);\n        return parseObject(input, context);\n    }\n    else if (input instanceof FieldValue) {\n        // FieldValues usually parse into transforms (except deleteField())\n        // in which case we do not want to include this field in our parsed data\n        // (as doing so will overwrite the field directly prior to the transform\n        // trying to transform it). So we don't add this location to\n        // context.fieldMask and we return null as our parsing result.\n        parseSentinelFieldValue(input, context);\n        return null;\n    }\n    else if (input === undefined && context.ignoreUndefinedProperties) {\n        // If the input is undefined it can never participate in the fieldMask, so\n        // don't handle this below. If `ignoreUndefinedProperties` is false,\n        // `parseScalarValue` will reject an undefined value.\n        return null;\n    }\n    else {\n        // If context.path is null we are inside an array and we don't support\n        // field mask paths more granular than the top-level array.\n        if (context.path) {\n            context.fieldMask.push(context.path);\n        }\n        if (input instanceof Array) {\n            // TODO(b/34871131): Include the path containing the array in the error\n            // message.\n            // In the case of IN queries, the parsed data is an array (representing\n            // the set of values to be included for the IN query) that may directly\n            // contain additional arrays (each representing an individual field\n            // value), so we disable this validation.\n            if (context.settings.arrayElement &&\n                context.dataSource !== 4 /* UserDataSource.ArrayArgument */) {\n                throw context.createError('Nested arrays are not supported');\n            }\n            return parseArray(input, context);\n        }\n        else {\n            return parseScalarValue(input, context);\n        }\n    }\n}\nfunction parseObject(obj, context) {\n    const fields = {};\n    if (isEmpty(obj)) {\n        // If we encounter an empty object, we explicitly add it to the update\n        // mask to ensure that the server creates a map entry.\n        if (context.path && context.path.length > 0) {\n            context.fieldMask.push(context.path);\n        }\n    }\n    else {\n        forEach(obj, (key, val) => {\n            const parsedValue = parseData(val, context.childContextForField(key));\n            if (parsedValue != null) {\n                fields[key] = parsedValue;\n            }\n        });\n    }\n    return { mapValue: { fields } };\n}\nfunction parseArray(array, context) {\n    const values = [];\n    let entryIndex = 0;\n    for (const entry of array) {\n        let parsedEntry = parseData(entry, context.childContextForArray(entryIndex));\n        if (parsedEntry == null) {\n            // Just include nulls in the array for fields being replaced with a\n            // sentinel.\n            parsedEntry = { nullValue: 'NULL_VALUE' };\n        }\n        values.push(parsedEntry);\n        entryIndex++;\n    }\n    return { arrayValue: { values } };\n}\n/**\n * \"Parses\" the provided FieldValueImpl, adding any necessary transforms to\n * context.fieldTransforms.\n */\nfunction parseSentinelFieldValue(value, context) {\n    // Sentinels are only supported with writes, and not within arrays.\n    if (!isWrite(context.dataSource)) {\n        throw context.createError(`${value._methodName}() can only be used with update() and set()`);\n    }\n    if (!context.path) {\n        throw context.createError(`${value._methodName}() is not currently supported inside arrays`);\n    }\n    const fieldTransform = value._toFieldTransform(context);\n    if (fieldTransform) {\n        context.fieldTransforms.push(fieldTransform);\n    }\n}\n/**\n * Helper to parse a scalar value (i.e. not an Object, Array, or FieldValue)\n *\n * @returns The parsed value\n */\nfunction parseScalarValue(value, context) {\n    value = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(value);\n    if (value === null) {\n        return { nullValue: 'NULL_VALUE' };\n    }\n    else if (typeof value === 'number') {\n        return toNumber(context.serializer, value);\n    }\n    else if (typeof value === 'boolean') {\n        return { booleanValue: value };\n    }\n    else if (typeof value === 'string') {\n        return { stringValue: value };\n    }\n    else if (value instanceof Date) {\n        const timestamp = Timestamp.fromDate(value);\n        return {\n            timestampValue: toTimestamp(context.serializer, timestamp)\n        };\n    }\n    else if (value instanceof Timestamp) {\n        // Firestore backend truncates precision down to microseconds. To ensure\n        // offline mode works the same with regards to truncation, perform the\n        // truncation immediately without waiting for the backend to do that.\n        const timestamp = new Timestamp(value.seconds, Math.floor(value.nanoseconds / 1000) * 1000);\n        return {\n            timestampValue: toTimestamp(context.serializer, timestamp)\n        };\n    }\n    else if (value instanceof GeoPoint) {\n        return {\n            geoPointValue: {\n                latitude: value.latitude,\n                longitude: value.longitude\n            }\n        };\n    }\n    else if (value instanceof Bytes) {\n        return { bytesValue: toBytes(context.serializer, value._byteString) };\n    }\n    else if (value instanceof DocumentReference) {\n        const thisDb = context.databaseId;\n        const otherDb = value.firestore._databaseId;\n        if (!otherDb.isEqual(thisDb)) {\n            throw context.createError('Document reference is for database ' +\n                `${otherDb.projectId}/${otherDb.database} but should be ` +\n                `for database ${thisDb.projectId}/${thisDb.database}`);\n        }\n        return {\n            referenceValue: toResourceName(value.firestore._databaseId || context.databaseId, value._key.path)\n        };\n    }\n    else if (value instanceof VectorValue) {\n        return parseVectorValue(value, context);\n    }\n    else {\n        throw context.createError(`Unsupported field value: ${valueDescription(value)}`);\n    }\n}\n/**\n * Creates a new VectorValue proto value (using the internal format).\n */\nfunction parseVectorValue(value, context) {\n    const mapValue = {\n        fields: {\n            [TYPE_KEY]: {\n                stringValue: VECTOR_VALUE_SENTINEL\n            },\n            [VECTOR_MAP_VECTORS_KEY]: {\n                arrayValue: {\n                    values: value.toArray().map(value => {\n                        if (typeof value !== 'number') {\n                            throw context.createError('VectorValues must only contain numeric values.');\n                        }\n                        return toDouble(context.serializer, value);\n                    })\n                }\n            }\n        }\n    };\n    return { mapValue };\n}\n/**\n * Checks whether an object looks like a JSON object that should be converted\n * into a struct. Normal class/prototype instances are considered to look like\n * JSON objects since they should be converted to a struct value. Arrays, Dates,\n * GeoPoints, etc. are not considered to look like JSON objects since they map\n * to specific FieldValue types other than ObjectValue.\n */\nfunction looksLikeJsonObject(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        !(input instanceof Array) &&\n        !(input instanceof Date) &&\n        !(input instanceof Timestamp) &&\n        !(input instanceof GeoPoint) &&\n        !(input instanceof Bytes) &&\n        !(input instanceof DocumentReference) &&\n        !(input instanceof FieldValue) &&\n        !(input instanceof VectorValue));\n}\nfunction validatePlainObject(message, context, input) {\n    if (!looksLikeJsonObject(input) || !isPlainObject(input)) {\n        const description = valueDescription(input);\n        if (description === 'an object') {\n            // Massage the error if it was an object.\n            throw context.createError(message + ' a custom object');\n        }\n        else {\n            throw context.createError(message + ' ' + description);\n        }\n    }\n}\n/**\n * Helper that calls fromDotSeparatedString() but wraps any error thrown.\n */\nfunction fieldPathFromArgument$1(methodName, path, targetDoc) {\n    // If required, replace the FieldPath Compat class with the firestore-exp\n    // FieldPath.\n    path = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(path);\n    if (path instanceof FieldPath) {\n        return path._internalPath;\n    }\n    else if (typeof path === 'string') {\n        return fieldPathFromDotSeparatedString(methodName, path);\n    }\n    else {\n        const message = 'Field path arguments must be of type string or ';\n        throw createError(message, methodName, \n        /* hasConverter= */ false, \n        /* path= */ undefined, targetDoc);\n    }\n}\n/**\n * Matches any characters in a field path string that are reserved.\n */\nconst FIELD_PATH_RESERVED = new RegExp('[~\\\\*/\\\\[\\\\]]');\n/**\n * Wraps fromDotSeparatedString with an error message about the method that\n * was thrown.\n * @param methodName - The publicly visible method name\n * @param path - The dot-separated string form of a field path which will be\n * split on dots.\n * @param targetDoc - The document against which the field path will be\n * evaluated.\n */\nfunction fieldPathFromDotSeparatedString(methodName, path, targetDoc) {\n    const found = path.search(FIELD_PATH_RESERVED);\n    if (found >= 0) {\n        throw createError(`Invalid field path (${path}). Paths must not contain ` +\n            `'~', '*', '/', '[', or ']'`, methodName, \n        /* hasConverter= */ false, \n        /* path= */ undefined, targetDoc);\n    }\n    try {\n        return new FieldPath(...path.split('.'))._internalPath;\n    }\n    catch (e) {\n        throw createError(`Invalid field path (${path}). Paths must not be empty, ` +\n            `begin with '.', end with '.', or contain '..'`, methodName, \n        /* hasConverter= */ false, \n        /* path= */ undefined, targetDoc);\n    }\n}\nfunction createError(reason, methodName, hasConverter, path, targetDoc) {\n    const hasPath = path && !path.isEmpty();\n    const hasDocument = targetDoc !== undefined;\n    let message = `Function ${methodName}() called with invalid data`;\n    if (hasConverter) {\n        message += ' (via `toFirestore()`)';\n    }\n    message += '. ';\n    let description = '';\n    if (hasPath || hasDocument) {\n        description += ' (found';\n        if (hasPath) {\n            description += ` in field ${path}`;\n        }\n        if (hasDocument) {\n            description += ` in document ${targetDoc}`;\n        }\n        description += ')';\n    }\n    return new FirestoreError(Code.INVALID_ARGUMENT, message + reason + description);\n}\n/** Checks `haystack` if FieldPath `needle` is present. Runs in O(n). */\nfunction fieldMaskContains(haystack, needle) {\n    return haystack.some(v => v.isEqual(needle));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A `DocumentSnapshot` contains data read from a document in your Firestore\n * database. The data can be extracted with `.data()` or `.get(<field>)` to\n * get a specific field.\n *\n * For a `DocumentSnapshot` that points to a non-existing document, any data\n * access will return 'undefined'. You can use the `exists()` method to\n * explicitly verify a document's existence.\n */\nclass DocumentSnapshot$1 {\n    // Note: This class is stripped down version of the DocumentSnapshot in\n    // the legacy SDK. The changes are:\n    // - No support for SnapshotMetadata.\n    // - No support for SnapshotOptions.\n    /** @hideconstructor protected */\n    constructor(_firestore, _userDataWriter, _key, _document, _converter) {\n        this._firestore = _firestore;\n        this._userDataWriter = _userDataWriter;\n        this._key = _key;\n        this._document = _document;\n        this._converter = _converter;\n    }\n    /** Property of the `DocumentSnapshot` that provides the document's ID. */\n    get id() {\n        return this._key.path.lastSegment();\n    }\n    /**\n     * The `DocumentReference` for the document included in the `DocumentSnapshot`.\n     */\n    get ref() {\n        return new DocumentReference(this._firestore, this._converter, this._key);\n    }\n    /**\n     * Signals whether or not the document at the snapshot's location exists.\n     *\n     * @returns true if the document exists.\n     */\n    exists() {\n        return this._document !== null;\n    }\n    /**\n     * Retrieves all fields in the document as an `Object`. Returns `undefined` if\n     * the document doesn't exist.\n     *\n     * @returns An `Object` containing all fields in the document or `undefined`\n     * if the document doesn't exist.\n     */\n    data() {\n        if (!this._document) {\n            return undefined;\n        }\n        else if (this._converter) {\n            // We only want to use the converter and create a new DocumentSnapshot\n            // if a converter has been provided.\n            const snapshot = new QueryDocumentSnapshot$1(this._firestore, this._userDataWriter, this._key, this._document, \n            /* converter= */ null);\n            return this._converter.fromFirestore(snapshot);\n        }\n        else {\n            return this._userDataWriter.convertValue(this._document.data.value);\n        }\n    }\n    /**\n     * Retrieves the field specified by `fieldPath`. Returns `undefined` if the\n     * document or field doesn't exist.\n     *\n     * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific\n     * field.\n     * @returns The data at the specified field location or undefined if no such\n     * field exists in the document.\n     */\n    // We are using `any` here to avoid an explicit cast by our users.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    get(fieldPath) {\n        if (this._document) {\n            const value = this._document.data.field(fieldPathFromArgument('DocumentSnapshot.get', fieldPath));\n            if (value !== null) {\n                return this._userDataWriter.convertValue(value);\n            }\n        }\n        return undefined;\n    }\n}\n/**\n * A `QueryDocumentSnapshot` contains data read from a document in your\n * Firestore database as part of a query. The document is guaranteed to exist\n * and its data can be extracted with `.data()` or `.get(<field>)` to get a\n * specific field.\n *\n * A `QueryDocumentSnapshot` offers the same API surface as a\n * `DocumentSnapshot`. Since query results contain only existing documents, the\n * `exists` property will always be true and `data()` will never return\n * 'undefined'.\n */\nclass QueryDocumentSnapshot$1 extends DocumentSnapshot$1 {\n    /**\n     * Retrieves all fields in the document as an `Object`.\n     *\n     * @override\n     * @returns An `Object` containing all fields in the document.\n     */\n    data() {\n        return super.data();\n    }\n}\n/**\n * Helper that calls `fromDotSeparatedString()` but wraps any error thrown.\n */\nfunction fieldPathFromArgument(methodName, arg) {\n    if (typeof arg === 'string') {\n        return fieldPathFromDotSeparatedString(methodName, arg);\n    }\n    else if (arg instanceof FieldPath) {\n        return arg._internalPath;\n    }\n    else {\n        return arg._delegate._internalPath;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction validateHasExplicitOrderByForLimitToLast(query) {\n    if (query.limitType === \"L\" /* LimitType.Last */ &&\n        query.explicitOrderBy.length === 0) {\n        throw new FirestoreError(Code.UNIMPLEMENTED, 'limitToLast() queries require specifying at least one orderBy() clause');\n    }\n}\n/**\n * An `AppliableConstraint` is an abstraction of a constraint that can be applied\n * to a Firestore query.\n */\nclass AppliableConstraint {\n}\n/**\n * A `QueryConstraint` is used to narrow the set of documents returned by a\n * Firestore query. `QueryConstraint`s are created by invoking {@link where},\n * {@link orderBy}, {@link (startAt:1)}, {@link (startAfter:1)}, {@link\n * (endBefore:1)}, {@link (endAt:1)}, {@link limit}, {@link limitToLast} and\n * can then be passed to {@link (query:1)} to create a new query instance that\n * also contains this `QueryConstraint`.\n */\nclass QueryConstraint extends AppliableConstraint {\n}\nfunction query(query, queryConstraint, ...additionalQueryConstraints) {\n    let queryConstraints = [];\n    if (queryConstraint instanceof AppliableConstraint) {\n        queryConstraints.push(queryConstraint);\n    }\n    queryConstraints = queryConstraints.concat(additionalQueryConstraints);\n    validateQueryConstraintArray(queryConstraints);\n    for (const constraint of queryConstraints) {\n        query = constraint._apply(query);\n    }\n    return query;\n}\n/**\n * A `QueryFieldFilterConstraint` is used to narrow the set of documents returned by\n * a Firestore query by filtering on one or more document fields.\n * `QueryFieldFilterConstraint`s are created by invoking {@link where} and can then\n * be passed to {@link (query:1)} to create a new query instance that also contains\n * this `QueryFieldFilterConstraint`.\n */\nclass QueryFieldFilterConstraint extends QueryConstraint {\n    /**\n     * @internal\n     */\n    constructor(_field, _op, _value) {\n        super();\n        this._field = _field;\n        this._op = _op;\n        this._value = _value;\n        /** The type of this query constraint */\n        this.type = 'where';\n    }\n    static _create(_field, _op, _value) {\n        return new QueryFieldFilterConstraint(_field, _op, _value);\n    }\n    _apply(query) {\n        const filter = this._parse(query);\n        validateNewFieldFilter(query._query, filter);\n        return new Query(query.firestore, query.converter, queryWithAddedFilter(query._query, filter));\n    }\n    _parse(query) {\n        const reader = newUserDataReader(query.firestore);\n        const filter = newQueryFilter(query._query, 'where', reader, query.firestore._databaseId, this._field, this._op, this._value);\n        return filter;\n    }\n}\n/**\n * Creates a {@link QueryFieldFilterConstraint} that enforces that documents\n * must contain the specified field and that the value should satisfy the\n * relation constraint provided.\n *\n * @param fieldPath - The path to compare\n * @param opStr - The operation string (e.g \"&lt;\", \"&lt;=\", \"==\", \"&lt;\",\n *   \"&lt;=\", \"!=\").\n * @param value - The value for comparison\n * @returns The created {@link QueryFieldFilterConstraint}.\n */\nfunction where(fieldPath, opStr, value) {\n    const op = opStr;\n    const field = fieldPathFromArgument('where', fieldPath);\n    return QueryFieldFilterConstraint._create(field, op, value);\n}\n/**\n * A `QueryCompositeFilterConstraint` is used to narrow the set of documents\n * returned by a Firestore query by performing the logical OR or AND of multiple\n * {@link QueryFieldFilterConstraint}s or {@link QueryCompositeFilterConstraint}s.\n * `QueryCompositeFilterConstraint`s are created by invoking {@link or} or\n * {@link and} and can then be passed to {@link (query:1)} to create a new query\n * instance that also contains the `QueryCompositeFilterConstraint`.\n */\nclass QueryCompositeFilterConstraint extends AppliableConstraint {\n    /**\n     * @internal\n     */\n    constructor(\n    /** The type of this query constraint */\n    type, _queryConstraints) {\n        super();\n        this.type = type;\n        this._queryConstraints = _queryConstraints;\n    }\n    static _create(type, _queryConstraints) {\n        return new QueryCompositeFilterConstraint(type, _queryConstraints);\n    }\n    _parse(query) {\n        const parsedFilters = this._queryConstraints\n            .map(queryConstraint => {\n            return queryConstraint._parse(query);\n        })\n            .filter(parsedFilter => parsedFilter.getFilters().length > 0);\n        if (parsedFilters.length === 1) {\n            return parsedFilters[0];\n        }\n        return CompositeFilter.create(parsedFilters, this._getOperator());\n    }\n    _apply(query) {\n        const parsedFilter = this._parse(query);\n        if (parsedFilter.getFilters().length === 0) {\n            // Return the existing query if not adding any more filters (e.g. an empty\n            // composite filter).\n            return query;\n        }\n        validateNewFilter(query._query, parsedFilter);\n        return new Query(query.firestore, query.converter, queryWithAddedFilter(query._query, parsedFilter));\n    }\n    _getQueryConstraints() {\n        return this._queryConstraints;\n    }\n    _getOperator() {\n        return this.type === 'and' ? \"and\" /* CompositeOperator.AND */ : \"or\" /* CompositeOperator.OR */;\n    }\n}\n/**\n * Creates a new {@link QueryCompositeFilterConstraint} that is a disjunction of\n * the given filter constraints. A disjunction filter includes a document if it\n * satisfies any of the given filters.\n *\n * @param queryConstraints - Optional. The list of\n * {@link QueryFilterConstraint}s to perform a disjunction for. These must be\n * created with calls to {@link where}, {@link or}, or {@link and}.\n * @returns The newly created {@link QueryCompositeFilterConstraint}.\n */\nfunction or(...queryConstraints) {\n    // Only support QueryFilterConstraints\n    queryConstraints.forEach(queryConstraint => validateQueryFilterConstraint('or', queryConstraint));\n    return QueryCompositeFilterConstraint._create(\"or\" /* CompositeOperator.OR */, queryConstraints);\n}\n/**\n * Creates a new {@link QueryCompositeFilterConstraint} that is a conjunction of\n * the given filter constraints. A conjunction filter includes a document if it\n * satisfies all of the given filters.\n *\n * @param queryConstraints - Optional. The list of\n * {@link QueryFilterConstraint}s to perform a conjunction for. These must be\n * created with calls to {@link where}, {@link or}, or {@link and}.\n * @returns The newly created {@link QueryCompositeFilterConstraint}.\n */\nfunction and(...queryConstraints) {\n    // Only support QueryFilterConstraints\n    queryConstraints.forEach(queryConstraint => validateQueryFilterConstraint('and', queryConstraint));\n    return QueryCompositeFilterConstraint._create(\"and\" /* CompositeOperator.AND */, queryConstraints);\n}\n/**\n * A `QueryOrderByConstraint` is used to sort the set of documents returned by a\n * Firestore query. `QueryOrderByConstraint`s are created by invoking\n * {@link orderBy} and can then be passed to {@link (query:1)} to create a new query\n * instance that also contains this `QueryOrderByConstraint`.\n *\n * Note: Documents that do not contain the orderBy field will not be present in\n * the query result.\n */\nclass QueryOrderByConstraint extends QueryConstraint {\n    /**\n     * @internal\n     */\n    constructor(_field, _direction) {\n        super();\n        this._field = _field;\n        this._direction = _direction;\n        /** The type of this query constraint */\n        this.type = 'orderBy';\n    }\n    static _create(_field, _direction) {\n        return new QueryOrderByConstraint(_field, _direction);\n    }\n    _apply(query) {\n        const orderBy = newQueryOrderBy(query._query, this._field, this._direction);\n        return new Query(query.firestore, query.converter, queryWithAddedOrderBy(query._query, orderBy));\n    }\n}\n/**\n * Creates a {@link QueryOrderByConstraint} that sorts the query result by the\n * specified field, optionally in descending order instead of ascending.\n *\n * Note: Documents that do not contain the specified field will not be present\n * in the query result.\n *\n * @param fieldPath - The field to sort by.\n * @param directionStr - Optional direction to sort by ('asc' or 'desc'). If\n * not specified, order will be ascending.\n * @returns The created {@link QueryOrderByConstraint}.\n */\nfunction orderBy(fieldPath, directionStr = 'asc') {\n    const direction = directionStr;\n    const path = fieldPathFromArgument('orderBy', fieldPath);\n    return QueryOrderByConstraint._create(path, direction);\n}\n/**\n * A `QueryLimitConstraint` is used to limit the number of documents returned by\n * a Firestore query.\n * `QueryLimitConstraint`s are created by invoking {@link limit} or\n * {@link limitToLast} and can then be passed to {@link (query:1)} to create a new\n * query instance that also contains this `QueryLimitConstraint`.\n */\nclass QueryLimitConstraint extends QueryConstraint {\n    /**\n     * @internal\n     */\n    constructor(\n    /** The type of this query constraint */\n    type, _limit, _limitType) {\n        super();\n        this.type = type;\n        this._limit = _limit;\n        this._limitType = _limitType;\n    }\n    static _create(type, _limit, _limitType) {\n        return new QueryLimitConstraint(type, _limit, _limitType);\n    }\n    _apply(query) {\n        return new Query(query.firestore, query.converter, queryWithLimit(query._query, this._limit, this._limitType));\n    }\n}\n/**\n * Creates a {@link QueryLimitConstraint} that only returns the first matching\n * documents.\n *\n * @param limit - The maximum number of items to return.\n * @returns The created {@link QueryLimitConstraint}.\n */\nfunction limit(limit) {\n    validatePositiveNumber('limit', limit);\n    return QueryLimitConstraint._create('limit', limit, \"F\" /* LimitType.First */);\n}\n/**\n * Creates a {@link QueryLimitConstraint} that only returns the last matching\n * documents.\n *\n * You must specify at least one `orderBy` clause for `limitToLast` queries,\n * otherwise an exception will be thrown during execution.\n *\n * @param limit - The maximum number of items to return.\n * @returns The created {@link QueryLimitConstraint}.\n */\nfunction limitToLast(limit) {\n    validatePositiveNumber('limitToLast', limit);\n    return QueryLimitConstraint._create('limitToLast', limit, \"L\" /* LimitType.Last */);\n}\n/**\n * A `QueryStartAtConstraint` is used to exclude documents from the start of a\n * result set returned by a Firestore query.\n * `QueryStartAtConstraint`s are created by invoking {@link (startAt:1)} or\n * {@link (startAfter:1)} and can then be passed to {@link (query:1)} to create a\n * new query instance that also contains this `QueryStartAtConstraint`.\n */\nclass QueryStartAtConstraint extends QueryConstraint {\n    /**\n     * @internal\n     */\n    constructor(\n    /** The type of this query constraint */\n    type, _docOrFields, _inclusive) {\n        super();\n        this.type = type;\n        this._docOrFields = _docOrFields;\n        this._inclusive = _inclusive;\n    }\n    static _create(type, _docOrFields, _inclusive) {\n        return new QueryStartAtConstraint(type, _docOrFields, _inclusive);\n    }\n    _apply(query) {\n        const bound = newQueryBoundFromDocOrFields(query, this.type, this._docOrFields, this._inclusive);\n        return new Query(query.firestore, query.converter, queryWithStartAt(query._query, bound));\n    }\n}\nfunction startAt(...docOrFields) {\n    return QueryStartAtConstraint._create('startAt', docOrFields, \n    /*inclusive=*/ true);\n}\nfunction startAfter(...docOrFields) {\n    return QueryStartAtConstraint._create('startAfter', docOrFields, \n    /*inclusive=*/ false);\n}\n/**\n * A `QueryEndAtConstraint` is used to exclude documents from the end of a\n * result set returned by a Firestore query.\n * `QueryEndAtConstraint`s are created by invoking {@link (endAt:1)} or\n * {@link (endBefore:1)} and can then be passed to {@link (query:1)} to create a new\n * query instance that also contains this `QueryEndAtConstraint`.\n */\nclass QueryEndAtConstraint extends QueryConstraint {\n    /**\n     * @internal\n     */\n    constructor(\n    /** The type of this query constraint */\n    type, _docOrFields, _inclusive) {\n        super();\n        this.type = type;\n        this._docOrFields = _docOrFields;\n        this._inclusive = _inclusive;\n    }\n    static _create(type, _docOrFields, _inclusive) {\n        return new QueryEndAtConstraint(type, _docOrFields, _inclusive);\n    }\n    _apply(query) {\n        const bound = newQueryBoundFromDocOrFields(query, this.type, this._docOrFields, this._inclusive);\n        return new Query(query.firestore, query.converter, queryWithEndAt(query._query, bound));\n    }\n}\nfunction endBefore(...docOrFields) {\n    return QueryEndAtConstraint._create('endBefore', docOrFields, \n    /*inclusive=*/ false);\n}\nfunction endAt(...docOrFields) {\n    return QueryEndAtConstraint._create('endAt', docOrFields, \n    /*inclusive=*/ true);\n}\n/** Helper function to create a bound from a document or fields */\nfunction newQueryBoundFromDocOrFields(query, methodName, docOrFields, inclusive) {\n    docOrFields[0] = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(docOrFields[0]);\n    if (docOrFields[0] instanceof DocumentSnapshot$1) {\n        return newQueryBoundFromDocument(query._query, query.firestore._databaseId, methodName, docOrFields[0]._document, inclusive);\n    }\n    else {\n        const reader = newUserDataReader(query.firestore);\n        return newQueryBoundFromFields(query._query, query.firestore._databaseId, reader, methodName, docOrFields, inclusive);\n    }\n}\nfunction newQueryFilter(query, methodName, dataReader, databaseId, fieldPath, op, value) {\n    let fieldValue;\n    if (fieldPath.isKeyField()) {\n        if (op === \"array-contains\" /* Operator.ARRAY_CONTAINS */ || op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid Query. You can't perform '${op}' queries on documentId().`);\n        }\n        else if (op === \"in\" /* Operator.IN */ || op === \"not-in\" /* Operator.NOT_IN */) {\n            validateDisjunctiveFilterElements(value, op);\n            const referenceList = [];\n            for (const arrayValue of value) {\n                referenceList.push(parseDocumentIdValue(databaseId, query, arrayValue));\n            }\n            fieldValue = { arrayValue: { values: referenceList } };\n        }\n        else {\n            fieldValue = parseDocumentIdValue(databaseId, query, value);\n        }\n    }\n    else {\n        if (op === \"in\" /* Operator.IN */ ||\n            op === \"not-in\" /* Operator.NOT_IN */ ||\n            op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */) {\n            validateDisjunctiveFilterElements(value, op);\n        }\n        fieldValue = parseQueryValue(dataReader, methodName, value, \n        /* allowArrays= */ op === \"in\" /* Operator.IN */ || op === \"not-in\" /* Operator.NOT_IN */);\n    }\n    const filter = FieldFilter.create(fieldPath, op, fieldValue);\n    return filter;\n}\nfunction newQueryOrderBy(query, fieldPath, direction) {\n    if (query.startAt !== null) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call startAt() or startAfter() before ' +\n            'calling orderBy().');\n    }\n    if (query.endAt !== null) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call endAt() or endBefore() before ' +\n            'calling orderBy().');\n    }\n    const orderBy = new OrderBy(fieldPath, direction);\n    return orderBy;\n}\n/**\n * Create a `Bound` from a query and a document.\n *\n * Note that the `Bound` will always include the key of the document\n * and so only the provided document will compare equal to the returned\n * position.\n *\n * Will throw if the document does not contain all fields of the order by\n * of the query or if any of the fields in the order by are an uncommitted\n * server timestamp.\n */\nfunction newQueryBoundFromDocument(query, databaseId, methodName, doc, inclusive) {\n    if (!doc) {\n        throw new FirestoreError(Code.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ` +\n            `${methodName}().`);\n    }\n    const components = [];\n    // Because people expect to continue/end a query at the exact document\n    // provided, we need to use the implicit sort order rather than the explicit\n    // sort order, because it's guaranteed to contain the document key. That way\n    // the position becomes unambiguous and the query continues/ends exactly at\n    // the provided document. Without the key (by using the explicit sort\n    // orders), multiple documents could match the position, yielding duplicate\n    // results.\n    for (const orderBy of queryNormalizedOrderBy(query)) {\n        if (orderBy.field.isKeyField()) {\n            components.push(refValue(databaseId, doc.key));\n        }\n        else {\n            const value = doc.data.field(orderBy.field);\n            if (isServerTimestamp(value)) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a ' +\n                    'document for which the field \"' +\n                    orderBy.field +\n                    '\" is an uncommitted server timestamp. (Since the value of ' +\n                    'this field is unknown, you cannot start/end a query with it.)');\n            }\n            else if (value !== null) {\n                components.push(value);\n            }\n            else {\n                const field = orderBy.field.canonicalString();\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a ` +\n                    `document for which the field '${field}' (used as the ` +\n                    `orderBy) does not exist.`);\n            }\n        }\n    }\n    return new Bound(components, inclusive);\n}\n/**\n * Converts a list of field values to a `Bound` for the given query.\n */\nfunction newQueryBoundFromFields(query, databaseId, dataReader, methodName, values, inclusive) {\n    // Use explicit order by's because it has to match the query the user made\n    const orderBy = query.explicitOrderBy;\n    if (values.length > orderBy.length) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Too many arguments provided to ${methodName}(). ` +\n            `The number of arguments must be less than or equal to the ` +\n            `number of orderBy() clauses`);\n    }\n    const components = [];\n    for (let i = 0; i < values.length; i++) {\n        const rawValue = values[i];\n        const orderByComponent = orderBy[i];\n        if (orderByComponent.field.isKeyField()) {\n            if (typeof rawValue !== 'string') {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ` +\n                    `${methodName}(), but got a ${typeof rawValue}`);\n            }\n            if (!isCollectionGroupQuery(query) && rawValue.indexOf('/') !== -1) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by documentId(), ` +\n                    `the value passed to ${methodName}() must be a plain document ID, but ` +\n                    `'${rawValue}' contains a slash.`);\n            }\n            const path = query.path.child(ResourcePath.fromString(rawValue));\n            if (!DocumentKey.isDocumentKey(path)) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by ` +\n                    `documentId(), the value passed to ${methodName}() must result in a ` +\n                    `valid document path, but '${path}' is not because it contains an odd number ` +\n                    `of segments.`);\n            }\n            const key = new DocumentKey(path);\n            components.push(refValue(databaseId, key));\n        }\n        else {\n            const wrapped = parseQueryValue(dataReader, methodName, rawValue);\n            components.push(wrapped);\n        }\n    }\n    return new Bound(components, inclusive);\n}\n/**\n * Parses the given `documentIdValue` into a `ReferenceValue`, throwing\n * appropriate errors if the value is anything other than a `DocumentReference`\n * or `string`, or if the string is malformed.\n */\nfunction parseDocumentIdValue(databaseId, query, documentIdValue) {\n    documentIdValue = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(documentIdValue);\n    if (typeof documentIdValue === 'string') {\n        if (documentIdValue === '') {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. When querying with documentId(), you ' +\n                'must provide a valid document ID, but it was an empty string.');\n        }\n        if (!isCollectionGroupQuery(query) && documentIdValue.indexOf('/') !== -1) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection by ` +\n                `documentId(), you must provide a plain document ID, but ` +\n                `'${documentIdValue}' contains a '/' character.`);\n        }\n        const path = query.path.child(ResourcePath.fromString(documentIdValue));\n        if (!DocumentKey.isDocumentKey(path)) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection group by ` +\n                `documentId(), the value provided must result in a valid document path, ` +\n                `but '${path}' is not because it has an odd number of segments (${path.length}).`);\n        }\n        return refValue(databaseId, new DocumentKey(path));\n    }\n    else if (documentIdValue instanceof DocumentReference) {\n        return refValue(databaseId, documentIdValue._key);\n    }\n    else {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid ` +\n            `string or a DocumentReference, but it was: ` +\n            `${valueDescription(documentIdValue)}.`);\n    }\n}\n/**\n * Validates that the value passed into a disjunctive filter satisfies all\n * array requirements.\n */\nfunction validateDisjunctiveFilterElements(value, operator) {\n    if (!Array.isArray(value) || value.length === 0) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid Query. A non-empty array is required for ' +\n            `'${operator.toString()}' filters.`);\n    }\n}\n/**\n * Given an operator, returns the set of operators that cannot be used with it.\n *\n * This is not a comprehensive check, and this function should be removed in the\n * long term. Validations should occur in the Firestore backend.\n *\n * Operators in a query must adhere to the following set of rules:\n * 1. Only one inequality per query.\n * 2. `NOT_IN` cannot be used with array, disjunctive, or `NOT_EQUAL` operators.\n */\nfunction conflictingOps(op) {\n    switch (op) {\n        case \"!=\" /* Operator.NOT_EQUAL */:\n            return [\"!=\" /* Operator.NOT_EQUAL */, \"not-in\" /* Operator.NOT_IN */];\n        case \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */:\n        case \"in\" /* Operator.IN */:\n            return [\"not-in\" /* Operator.NOT_IN */];\n        case \"not-in\" /* Operator.NOT_IN */:\n            return [\n                \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */,\n                \"in\" /* Operator.IN */,\n                \"not-in\" /* Operator.NOT_IN */,\n                \"!=\" /* Operator.NOT_EQUAL */\n            ];\n        default:\n            return [];\n    }\n}\nfunction validateNewFieldFilter(query, fieldFilter) {\n    const conflictingOp = findOpInsideFilters(query.filters, conflictingOps(fieldFilter.op));\n    if (conflictingOp !== null) {\n        // Special case when it's a duplicate op to give a slightly clearer error message.\n        if (conflictingOp === fieldFilter.op) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You cannot use more than one ' +\n                `'${fieldFilter.op.toString()}' filter.`);\n        }\n        else {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. You cannot use '${fieldFilter.op.toString()}' filters ` +\n                `with '${conflictingOp.toString()}' filters.`);\n        }\n    }\n}\nfunction validateNewFilter(query, filter) {\n    let testQuery = query;\n    const subFilters = filter.getFlattenedFilters();\n    for (const subFilter of subFilters) {\n        validateNewFieldFilter(testQuery, subFilter);\n        testQuery = queryWithAddedFilter(testQuery, subFilter);\n    }\n}\n// Checks if any of the provided filter operators are included in the given list of filters and\n// returns the first one that is, or null if none are.\nfunction findOpInsideFilters(filters, operators) {\n    for (const filter of filters) {\n        for (const fieldFilter of filter.getFlattenedFilters()) {\n            if (operators.indexOf(fieldFilter.op) >= 0) {\n                return fieldFilter.op;\n            }\n        }\n    }\n    return null;\n}\nfunction validateQueryFilterConstraint(functionName, queryConstraint) {\n    if (!(queryConstraint instanceof QueryFieldFilterConstraint) &&\n        !(queryConstraint instanceof QueryCompositeFilterConstraint)) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${functionName}() requires AppliableConstraints created with a call to 'where(...)', 'or(...)', or 'and(...)'.`);\n    }\n}\nfunction validateQueryConstraintArray(queryConstraint) {\n    const compositeFilterCount = queryConstraint.filter(filter => filter instanceof QueryCompositeFilterConstraint).length;\n    const fieldFilterCount = queryConstraint.filter(filter => filter instanceof QueryFieldFilterConstraint).length;\n    if (compositeFilterCount > 1 ||\n        (compositeFilterCount > 0 && fieldFilterCount > 0)) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'InvalidQuery. When using composite filters, you cannot use ' +\n            'more than one filter at the top level. Consider nesting the multiple ' +\n            'filters within an `and(...)` statement. For example: ' +\n            'change `query(query, where(...), or(...))` to ' +\n            '`query(query, and(where(...), or(...)))`.');\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Converts Firestore's internal types to the JavaScript types that we expose\n * to the user.\n *\n * @internal\n */\nclass AbstractUserDataWriter {\n    convertValue(value, serverTimestampBehavior = 'none') {\n        switch (typeOrder(value)) {\n            case 0 /* TypeOrder.NullValue */:\n                return null;\n            case 1 /* TypeOrder.BooleanValue */:\n                return value.booleanValue;\n            case 2 /* TypeOrder.NumberValue */:\n                return normalizeNumber(value.integerValue || value.doubleValue);\n            case 3 /* TypeOrder.TimestampValue */:\n                return this.convertTimestamp(value.timestampValue);\n            case 4 /* TypeOrder.ServerTimestampValue */:\n                return this.convertServerTimestamp(value, serverTimestampBehavior);\n            case 5 /* TypeOrder.StringValue */:\n                return value.stringValue;\n            case 6 /* TypeOrder.BlobValue */:\n                return this.convertBytes(normalizeByteString(value.bytesValue));\n            case 7 /* TypeOrder.RefValue */:\n                return this.convertReference(value.referenceValue);\n            case 8 /* TypeOrder.GeoPointValue */:\n                return this.convertGeoPoint(value.geoPointValue);\n            case 9 /* TypeOrder.ArrayValue */:\n                return this.convertArray(value.arrayValue, serverTimestampBehavior);\n            case 11 /* TypeOrder.ObjectValue */:\n                return this.convertObject(value.mapValue, serverTimestampBehavior);\n            case 10 /* TypeOrder.VectorValue */:\n                return this.convertVectorValue(value.mapValue);\n            default:\n                throw fail();\n        }\n    }\n    convertObject(mapValue, serverTimestampBehavior) {\n        return this.convertObjectMap(mapValue.fields, serverTimestampBehavior);\n    }\n    /**\n     * @internal\n     */\n    convertObjectMap(fields, serverTimestampBehavior = 'none') {\n        const result = {};\n        forEach(fields, (key, value) => {\n            result[key] = this.convertValue(value, serverTimestampBehavior);\n        });\n        return result;\n    }\n    /**\n     * @internal\n     */\n    convertVectorValue(mapValue) {\n        var _a, _b, _c;\n        const values = (_c = (_b = (_a = mapValue.fields) === null || _a === void 0 ? void 0 : _a[VECTOR_MAP_VECTORS_KEY].arrayValue) === null || _b === void 0 ? void 0 : _b.values) === null || _c === void 0 ? void 0 : _c.map(value => {\n            return normalizeNumber(value.doubleValue);\n        });\n        return new VectorValue(values);\n    }\n    convertGeoPoint(value) {\n        return new GeoPoint(normalizeNumber(value.latitude), normalizeNumber(value.longitude));\n    }\n    convertArray(arrayValue, serverTimestampBehavior) {\n        return (arrayValue.values || []).map(value => this.convertValue(value, serverTimestampBehavior));\n    }\n    convertServerTimestamp(value, serverTimestampBehavior) {\n        switch (serverTimestampBehavior) {\n            case 'previous':\n                const previousValue = getPreviousValue(value);\n                if (previousValue == null) {\n                    return null;\n                }\n                return this.convertValue(previousValue, serverTimestampBehavior);\n            case 'estimate':\n                return this.convertTimestamp(getLocalWriteTime(value));\n            default:\n                return null;\n        }\n    }\n    convertTimestamp(value) {\n        const normalizedValue = normalizeTimestamp(value);\n        return new Timestamp(normalizedValue.seconds, normalizedValue.nanos);\n    }\n    convertDocumentKey(name, expectedDatabaseId) {\n        const resourcePath = ResourcePath.fromString(name);\n        hardAssert(isValidResourceName(resourcePath));\n        const databaseId = new DatabaseId(resourcePath.get(1), resourcePath.get(3));\n        const key = new DocumentKey(resourcePath.popFirst(5));\n        if (!databaseId.isEqual(expectedDatabaseId)) {\n            // TODO(b/64130202): Somehow support foreign references.\n            logError(`Document ${key} contains a document ` +\n                `reference within a different database (` +\n                `${databaseId.projectId}/${databaseId.database}) which is not ` +\n                `supported. It will be treated as a reference in the current ` +\n                `database (${expectedDatabaseId.projectId}/${expectedDatabaseId.database}) ` +\n                `instead.`);\n        }\n        return key;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Converts custom model object of type T into `DocumentData` by applying the\n * converter if it exists.\n *\n * This function is used when converting user objects to `DocumentData`\n * because we want to provide the user with a more specific error message if\n * their `set()` or fails due to invalid data originating from a `toFirestore()`\n * call.\n */\nfunction applyFirestoreDataConverter(converter, value, options) {\n    let convertedValue;\n    if (converter) {\n        if (options && (options.merge || options.mergeFields)) {\n            // Cast to `any` in order to satisfy the union type constraint on\n            // toFirestore().\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            convertedValue = converter.toFirestore(value, options);\n        }\n        else {\n            convertedValue = converter.toFirestore(value);\n        }\n    }\n    else {\n        convertedValue = value;\n    }\n    return convertedValue;\n}\nclass LiteUserDataWriter extends AbstractUserDataWriter {\n    constructor(firestore) {\n        super();\n        this.firestore = firestore;\n    }\n    convertBytes(bytes) {\n        return new Bytes(bytes);\n    }\n    convertReference(name) {\n        const key = this.convertDocumentKey(name, this.firestore._databaseId);\n        return new DocumentReference(this.firestore, /* converter= */ null, key);\n    }\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Create an AggregateField object that can be used to compute the sum of\n * a specified field over a range of documents in the result set of a query.\n * @param field Specifies the field to sum across the result set.\n */\nfunction sum(field) {\n    return new AggregateField('sum', fieldPathFromArgument$1('sum', field));\n}\n/**\n * Create an AggregateField object that can be used to compute the average of\n * a specified field over a range of documents in the result set of a query.\n * @param field Specifies the field to average across the result set.\n */\nfunction average(field) {\n    return new AggregateField('avg', fieldPathFromArgument$1('average', field));\n}\n/**\n * Create an AggregateField object that can be used to compute the count of\n * documents in the result set of a query.\n */\nfunction count() {\n    return new AggregateField('count');\n}\n/**\n * Compares two 'AggregateField` instances for equality.\n *\n * @param left Compare this AggregateField to the `right`.\n * @param right Compare this AggregateField to the `left`.\n */\nfunction aggregateFieldEqual(left, right) {\n    var _a, _b;\n    return (left instanceof AggregateField &&\n        right instanceof AggregateField &&\n        left.aggregateType === right.aggregateType &&\n        ((_a = left._internalFieldPath) === null || _a === void 0 ? void 0 : _a.canonicalString()) ===\n            ((_b = right._internalFieldPath) === null || _b === void 0 ? void 0 : _b.canonicalString()));\n}\n/**\n * Compares two `AggregateQuerySnapshot` instances for equality.\n *\n * Two `AggregateQuerySnapshot` instances are considered \"equal\" if they have\n * underlying queries that compare equal, and the same data.\n *\n * @param left - The first `AggregateQuerySnapshot` to compare.\n * @param right - The second `AggregateQuerySnapshot` to compare.\n *\n * @returns `true` if the objects are \"equal\", as defined above, or `false`\n * otherwise.\n */\nfunction aggregateQuerySnapshotEqual(left, right) {\n    return (queryEqual(left.query, right.query) && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(left.data(), right.data()));\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction isPartialObserver(obj) {\n    return implementsAnyMethods(obj, ['next', 'error', 'complete']);\n}\n/**\n * Returns true if obj is an object and contains at least one of the specified\n * methods.\n */\nfunction implementsAnyMethods(obj, methods) {\n    if (typeof obj !== 'object' || obj === null) {\n        return false;\n    }\n    const object = obj;\n    for (const method of methods) {\n        if (method in object && typeof object[method] === 'function') {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Metadata about a snapshot, describing the state of the snapshot.\n */\nclass SnapshotMetadata {\n    /** @hideconstructor */\n    constructor(hasPendingWrites, fromCache) {\n        this.hasPendingWrites = hasPendingWrites;\n        this.fromCache = fromCache;\n    }\n    /**\n     * Returns true if this `SnapshotMetadata` is equal to the provided one.\n     *\n     * @param other - The `SnapshotMetadata` to compare against.\n     * @returns true if this `SnapshotMetadata` is equal to the provided one.\n     */\n    isEqual(other) {\n        return (this.hasPendingWrites === other.hasPendingWrites &&\n            this.fromCache === other.fromCache);\n    }\n}\n/**\n * A `DocumentSnapshot` contains data read from a document in your Firestore\n * database. The data can be extracted with `.data()` or `.get(<field>)` to\n * get a specific field.\n *\n * For a `DocumentSnapshot` that points to a non-existing document, any data\n * access will return 'undefined'. You can use the `exists()` method to\n * explicitly verify a document's existence.\n */\nclass DocumentSnapshot extends DocumentSnapshot$1 {\n    /** @hideconstructor protected */\n    constructor(_firestore, userDataWriter, key, document, metadata, converter) {\n        super(_firestore, userDataWriter, key, document, converter);\n        this._firestore = _firestore;\n        this._firestoreImpl = _firestore;\n        this.metadata = metadata;\n    }\n    /**\n     * Returns whether or not the data exists. True if the document exists.\n     */\n    exists() {\n        return super.exists();\n    }\n    /**\n     * Retrieves all fields in the document as an `Object`. Returns `undefined` if\n     * the document doesn't exist.\n     *\n     * By default, `serverTimestamp()` values that have not yet been\n     * set to their final value will be returned as `null`. You can override\n     * this by passing an options object.\n     *\n     * @param options - An options object to configure how data is retrieved from\n     * the snapshot (for example the desired behavior for server timestamps that\n     * have not yet been set to their final value).\n     * @returns An `Object` containing all fields in the document or `undefined` if\n     * the document doesn't exist.\n     */\n    data(options = {}) {\n        if (!this._document) {\n            return undefined;\n        }\n        else if (this._converter) {\n            // We only want to use the converter and create a new DocumentSnapshot\n            // if a converter has been provided.\n            const snapshot = new QueryDocumentSnapshot(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, \n            /* converter= */ null);\n            return this._converter.fromFirestore(snapshot, options);\n        }\n        else {\n            return this._userDataWriter.convertValue(this._document.data.value, options.serverTimestamps);\n        }\n    }\n    /**\n     * Retrieves the field specified by `fieldPath`. Returns `undefined` if the\n     * document or field doesn't exist.\n     *\n     * By default, a `serverTimestamp()` that has not yet been set to\n     * its final value will be returned as `null`. You can override this by\n     * passing an options object.\n     *\n     * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific\n     * field.\n     * @param options - An options object to configure how the field is retrieved\n     * from the snapshot (for example the desired behavior for server timestamps\n     * that have not yet been set to their final value).\n     * @returns The data at the specified field location or undefined if no such\n     * field exists in the document.\n     */\n    // We are using `any` here to avoid an explicit cast by our users.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    get(fieldPath, options = {}) {\n        if (this._document) {\n            const value = this._document.data.field(fieldPathFromArgument('DocumentSnapshot.get', fieldPath));\n            if (value !== null) {\n                return this._userDataWriter.convertValue(value, options.serverTimestamps);\n            }\n        }\n        return undefined;\n    }\n}\n/**\n * A `QueryDocumentSnapshot` contains data read from a document in your\n * Firestore database as part of a query. The document is guaranteed to exist\n * and its data can be extracted with `.data()` or `.get(<field>)` to get a\n * specific field.\n *\n * A `QueryDocumentSnapshot` offers the same API surface as a\n * `DocumentSnapshot`. Since query results contain only existing documents, the\n * `exists` property will always be true and `data()` will never return\n * 'undefined'.\n */\nclass QueryDocumentSnapshot extends DocumentSnapshot {\n    /**\n     * Retrieves all fields in the document as an `Object`.\n     *\n     * By default, `serverTimestamp()` values that have not yet been\n     * set to their final value will be returned as `null`. You can override\n     * this by passing an options object.\n     *\n     * @override\n     * @param options - An options object to configure how data is retrieved from\n     * the snapshot (for example the desired behavior for server timestamps that\n     * have not yet been set to their final value).\n     * @returns An `Object` containing all fields in the document.\n     */\n    data(options = {}) {\n        return super.data(options);\n    }\n}\n/**\n * A `QuerySnapshot` contains zero or more `DocumentSnapshot` objects\n * representing the results of a query. The documents can be accessed as an\n * array via the `docs` property or enumerated using the `forEach` method. The\n * number of documents can be determined via the `empty` and `size`\n * properties.\n */\nclass QuerySnapshot {\n    /** @hideconstructor */\n    constructor(_firestore, _userDataWriter, query, _snapshot) {\n        this._firestore = _firestore;\n        this._userDataWriter = _userDataWriter;\n        this._snapshot = _snapshot;\n        this.metadata = new SnapshotMetadata(_snapshot.hasPendingWrites, _snapshot.fromCache);\n        this.query = query;\n    }\n    /** An array of all the documents in the `QuerySnapshot`. */\n    get docs() {\n        const result = [];\n        this.forEach(doc => result.push(doc));\n        return result;\n    }\n    /** The number of documents in the `QuerySnapshot`. */\n    get size() {\n        return this._snapshot.docs.size;\n    }\n    /** True if there are no documents in the `QuerySnapshot`. */\n    get empty() {\n        return this.size === 0;\n    }\n    /**\n     * Enumerates all of the documents in the `QuerySnapshot`.\n     *\n     * @param callback - A callback to be called with a `QueryDocumentSnapshot` for\n     * each document in the snapshot.\n     * @param thisArg - The `this` binding for the callback.\n     */\n    forEach(callback, thisArg) {\n        this._snapshot.docs.forEach(doc => {\n            callback.call(thisArg, new QueryDocumentSnapshot(this._firestore, this._userDataWriter, doc.key, doc, new SnapshotMetadata(this._snapshot.mutatedKeys.has(doc.key), this._snapshot.fromCache), this.query.converter));\n        });\n    }\n    /**\n     * Returns an array of the documents changes since the last snapshot. If this\n     * is the first snapshot, all documents will be in the list as 'added'\n     * changes.\n     *\n     * @param options - `SnapshotListenOptions` that control whether metadata-only\n     * changes (i.e. only `DocumentSnapshot.metadata` changed) should trigger\n     * snapshot events.\n     */\n    docChanges(options = {}) {\n        const includeMetadataChanges = !!options.includeMetadataChanges;\n        if (includeMetadataChanges && this._snapshot.excludesMetadataChanges) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'To include metadata changes with your document changes, you must ' +\n                'also pass { includeMetadataChanges:true } to onSnapshot().');\n        }\n        if (!this._cachedChanges ||\n            this._cachedChangesIncludeMetadataChanges !== includeMetadataChanges) {\n            this._cachedChanges = changesFromSnapshot(this, includeMetadataChanges);\n            this._cachedChangesIncludeMetadataChanges = includeMetadataChanges;\n        }\n        return this._cachedChanges;\n    }\n}\n/** Calculates the array of `DocumentChange`s for a given `ViewSnapshot`. */\nfunction changesFromSnapshot(querySnapshot, includeMetadataChanges) {\n    if (querySnapshot._snapshot.oldDocs.isEmpty()) {\n        let index = 0;\n        return querySnapshot._snapshot.docChanges.map(change => {\n            const doc = new QueryDocumentSnapshot(querySnapshot._firestore, querySnapshot._userDataWriter, change.doc.key, change.doc, new SnapshotMetadata(querySnapshot._snapshot.mutatedKeys.has(change.doc.key), querySnapshot._snapshot.fromCache), querySnapshot.query.converter);\n            change.doc;\n            return {\n                type: 'added',\n                doc,\n                oldIndex: -1,\n                newIndex: index++\n            };\n        });\n    }\n    else {\n        // A `DocumentSet` that is updated incrementally as changes are applied to use\n        // to lookup the index of a document.\n        let indexTracker = querySnapshot._snapshot.oldDocs;\n        return querySnapshot._snapshot.docChanges\n            .filter(change => includeMetadataChanges || change.type !== 3 /* ChangeType.Metadata */)\n            .map(change => {\n            const doc = new QueryDocumentSnapshot(querySnapshot._firestore, querySnapshot._userDataWriter, change.doc.key, change.doc, new SnapshotMetadata(querySnapshot._snapshot.mutatedKeys.has(change.doc.key), querySnapshot._snapshot.fromCache), querySnapshot.query.converter);\n            let oldIndex = -1;\n            let newIndex = -1;\n            if (change.type !== 0 /* ChangeType.Added */) {\n                oldIndex = indexTracker.indexOf(change.doc.key);\n                indexTracker = indexTracker.delete(change.doc.key);\n            }\n            if (change.type !== 1 /* ChangeType.Removed */) {\n                indexTracker = indexTracker.add(change.doc);\n                newIndex = indexTracker.indexOf(change.doc.key);\n            }\n            return {\n                type: resultChangeType(change.type),\n                doc,\n                oldIndex,\n                newIndex\n            };\n        });\n    }\n}\nfunction resultChangeType(type) {\n    switch (type) {\n        case 0 /* ChangeType.Added */:\n            return 'added';\n        case 2 /* ChangeType.Modified */:\n        case 3 /* ChangeType.Metadata */:\n            return 'modified';\n        case 1 /* ChangeType.Removed */:\n            return 'removed';\n        default:\n            return fail();\n    }\n}\n// TODO(firestoreexp): Add tests for snapshotEqual with different snapshot\n// metadata\n/**\n * Returns true if the provided snapshots are equal.\n *\n * @param left - A snapshot to compare.\n * @param right - A snapshot to compare.\n * @returns true if the snapshots are equal.\n */\nfunction snapshotEqual(left, right) {\n    if (left instanceof DocumentSnapshot && right instanceof DocumentSnapshot) {\n        return (left._firestore === right._firestore &&\n            left._key.isEqual(right._key) &&\n            (left._document === null\n                ? right._document === null\n                : left._document.isEqual(right._document)) &&\n            left._converter === right._converter);\n    }\n    else if (left instanceof QuerySnapshot && right instanceof QuerySnapshot) {\n        return (left._firestore === right._firestore &&\n            queryEqual(left.query, right.query) &&\n            left.metadata.isEqual(right.metadata) &&\n            left._snapshot.isEqual(right._snapshot));\n    }\n    return false;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Reads the document referred to by this `DocumentReference`.\n *\n * Note: `getDoc()` attempts to provide up-to-date data when possible by waiting\n * for data from the server, but it may return cached data or fail if you are\n * offline and the server cannot be reached. To specify this behavior, invoke\n * {@link getDocFromCache} or {@link getDocFromServer}.\n *\n * @param reference - The reference of the document to fetch.\n * @returns A Promise resolved with a `DocumentSnapshot` containing the\n * current document contents.\n */\nfunction getDoc(reference) {\n    reference = cast(reference, DocumentReference);\n    const firestore = cast(reference.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientGetDocumentViaSnapshotListener(client, reference._key).then(snapshot => convertToDocSnapshot(firestore, reference, snapshot));\n}\nclass ExpUserDataWriter extends AbstractUserDataWriter {\n    constructor(firestore) {\n        super();\n        this.firestore = firestore;\n    }\n    convertBytes(bytes) {\n        return new Bytes(bytes);\n    }\n    convertReference(name) {\n        const key = this.convertDocumentKey(name, this.firestore._databaseId);\n        return new DocumentReference(this.firestore, /* converter= */ null, key);\n    }\n}\n/**\n * Reads the document referred to by this `DocumentReference` from cache.\n * Returns an error if the document is not currently cached.\n *\n * @returns A `Promise` resolved with a `DocumentSnapshot` containing the\n * current document contents.\n */\nfunction getDocFromCache(reference) {\n    reference = cast(reference, DocumentReference);\n    const firestore = cast(reference.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const userDataWriter = new ExpUserDataWriter(firestore);\n    return firestoreClientGetDocumentFromLocalCache(client, reference._key).then(doc => new DocumentSnapshot(firestore, userDataWriter, reference._key, doc, new SnapshotMetadata(doc !== null && doc.hasLocalMutations, \n    /* fromCache= */ true), reference.converter));\n}\n/**\n * Reads the document referred to by this `DocumentReference` from the server.\n * Returns an error if the network is not available.\n *\n * @returns A `Promise` resolved with a `DocumentSnapshot` containing the\n * current document contents.\n */\nfunction getDocFromServer(reference) {\n    reference = cast(reference, DocumentReference);\n    const firestore = cast(reference.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientGetDocumentViaSnapshotListener(client, reference._key, {\n        source: 'server'\n    }).then(snapshot => convertToDocSnapshot(firestore, reference, snapshot));\n}\n/**\n * Executes the query and returns the results as a `QuerySnapshot`.\n *\n * Note: `getDocs()` attempts to provide up-to-date data when possible by\n * waiting for data from the server, but it may return cached data or fail if\n * you are offline and the server cannot be reached. To specify this behavior,\n * invoke {@link getDocsFromCache} or {@link getDocsFromServer}.\n *\n * @returns A `Promise` that will be resolved with the results of the query.\n */\nfunction getDocs(query) {\n    query = cast(query, Query);\n    const firestore = cast(query.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const userDataWriter = new ExpUserDataWriter(firestore);\n    validateHasExplicitOrderByForLimitToLast(query._query);\n    return firestoreClientGetDocumentsViaSnapshotListener(client, query._query).then(snapshot => new QuerySnapshot(firestore, userDataWriter, query, snapshot));\n}\n/**\n * Executes the query and returns the results as a `QuerySnapshot` from cache.\n * Returns an empty result set if no documents matching the query are currently\n * cached.\n *\n * @returns A `Promise` that will be resolved with the results of the query.\n */\nfunction getDocsFromCache(query) {\n    query = cast(query, Query);\n    const firestore = cast(query.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const userDataWriter = new ExpUserDataWriter(firestore);\n    return firestoreClientGetDocumentsFromLocalCache(client, query._query).then(snapshot => new QuerySnapshot(firestore, userDataWriter, query, snapshot));\n}\n/**\n * Executes the query and returns the results as a `QuerySnapshot` from the\n * server. Returns an error if the network is not available.\n *\n * @returns A `Promise` that will be resolved with the results of the query.\n */\nfunction getDocsFromServer(query) {\n    query = cast(query, Query);\n    const firestore = cast(query.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const userDataWriter = new ExpUserDataWriter(firestore);\n    return firestoreClientGetDocumentsViaSnapshotListener(client, query._query, {\n        source: 'server'\n    }).then(snapshot => new QuerySnapshot(firestore, userDataWriter, query, snapshot));\n}\nfunction setDoc(reference, data, options) {\n    reference = cast(reference, DocumentReference);\n    const firestore = cast(reference.firestore, Firestore);\n    const convertedValue = applyFirestoreDataConverter(reference.converter, data, options);\n    const dataReader = newUserDataReader(firestore);\n    const parsed = parseSetData(dataReader, 'setDoc', reference._key, convertedValue, reference.converter !== null, options);\n    const mutation = parsed.toMutation(reference._key, Precondition.none());\n    return executeWrite(firestore, [mutation]);\n}\nfunction updateDoc(reference, fieldOrUpdateData, value, ...moreFieldsAndValues) {\n    reference = cast(reference, DocumentReference);\n    const firestore = cast(reference.firestore, Firestore);\n    const dataReader = newUserDataReader(firestore);\n    // For Compat types, we have to \"extract\" the underlying types before\n    // performing validation.\n    fieldOrUpdateData = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(fieldOrUpdateData);\n    let parsed;\n    if (typeof fieldOrUpdateData === 'string' ||\n        fieldOrUpdateData instanceof FieldPath) {\n        parsed = parseUpdateVarargs(dataReader, 'updateDoc', reference._key, fieldOrUpdateData, value, moreFieldsAndValues);\n    }\n    else {\n        parsed = parseUpdateData(dataReader, 'updateDoc', reference._key, fieldOrUpdateData);\n    }\n    const mutation = parsed.toMutation(reference._key, Precondition.exists(true));\n    return executeWrite(firestore, [mutation]);\n}\n/**\n * Deletes the document referred to by the specified `DocumentReference`.\n *\n * @param reference - A reference to the document to delete.\n * @returns A Promise resolved once the document has been successfully\n * deleted from the backend (note that it won't resolve while you're offline).\n */\nfunction deleteDoc(reference) {\n    const firestore = cast(reference.firestore, Firestore);\n    const mutations = [new DeleteMutation(reference._key, Precondition.none())];\n    return executeWrite(firestore, mutations);\n}\n/**\n * Add a new document to specified `CollectionReference` with the given data,\n * assigning it a document ID automatically.\n *\n * @param reference - A reference to the collection to add this document to.\n * @param data - An Object containing the data for the new document.\n * @returns A `Promise` resolved with a `DocumentReference` pointing to the\n * newly created document after it has been written to the backend (Note that it\n * won't resolve while you're offline).\n */\nfunction addDoc(reference, data) {\n    const firestore = cast(reference.firestore, Firestore);\n    const docRef = doc(reference);\n    const convertedValue = applyFirestoreDataConverter(reference.converter, data);\n    const dataReader = newUserDataReader(reference.firestore);\n    const parsed = parseSetData(dataReader, 'addDoc', docRef._key, convertedValue, reference.converter !== null, {});\n    const mutation = parsed.toMutation(docRef._key, Precondition.exists(false));\n    return executeWrite(firestore, [mutation]).then(() => docRef);\n}\nfunction onSnapshot(reference, ...args) {\n    var _a, _b, _c;\n    reference = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(reference);\n    let options = {\n        includeMetadataChanges: false,\n        source: 'default'\n    };\n    let currArg = 0;\n    if (typeof args[currArg] === 'object' && !isPartialObserver(args[currArg])) {\n        options = args[currArg];\n        currArg++;\n    }\n    const internalOptions = {\n        includeMetadataChanges: options.includeMetadataChanges,\n        source: options.source\n    };\n    if (isPartialObserver(args[currArg])) {\n        const userObserver = args[currArg];\n        args[currArg] = (_a = userObserver.next) === null || _a === void 0 ? void 0 : _a.bind(userObserver);\n        args[currArg + 1] = (_b = userObserver.error) === null || _b === void 0 ? void 0 : _b.bind(userObserver);\n        args[currArg + 2] = (_c = userObserver.complete) === null || _c === void 0 ? void 0 : _c.bind(userObserver);\n    }\n    let observer;\n    let firestore;\n    let internalQuery;\n    if (reference instanceof DocumentReference) {\n        firestore = cast(reference.firestore, Firestore);\n        internalQuery = newQueryForPath(reference._key.path);\n        observer = {\n            next: snapshot => {\n                if (args[currArg]) {\n                    args[currArg](convertToDocSnapshot(firestore, reference, snapshot));\n                }\n            },\n            error: args[currArg + 1],\n            complete: args[currArg + 2]\n        };\n    }\n    else {\n        const query = cast(reference, Query);\n        firestore = cast(query.firestore, Firestore);\n        internalQuery = query._query;\n        const userDataWriter = new ExpUserDataWriter(firestore);\n        observer = {\n            next: snapshot => {\n                if (args[currArg]) {\n                    args[currArg](new QuerySnapshot(firestore, userDataWriter, query, snapshot));\n                }\n            },\n            error: args[currArg + 1],\n            complete: args[currArg + 2]\n        };\n        validateHasExplicitOrderByForLimitToLast(reference._query);\n    }\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientListen(client, internalQuery, internalOptions, observer);\n}\nfunction onSnapshotsInSync(firestore, arg) {\n    firestore = cast(firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const observer = isPartialObserver(arg)\n        ? arg\n        : {\n            next: arg\n        };\n    return firestoreClientAddSnapshotsInSyncListener(client, observer);\n}\n/**\n * Locally writes `mutations` on the async queue.\n * @internal\n */\nfunction executeWrite(firestore, mutations) {\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientWrite(client, mutations);\n}\n/**\n * Converts a {@link ViewSnapshot} that contains the single document specified by `ref`\n * to a {@link DocumentSnapshot}.\n */\nfunction convertToDocSnapshot(firestore, ref, snapshot) {\n    const doc = snapshot.docs.get(ref._key);\n    const userDataWriter = new ExpUserDataWriter(firestore);\n    return new DocumentSnapshot(firestore, userDataWriter, ref._key, doc, new SnapshotMetadata(snapshot.hasPendingWrites, snapshot.fromCache), ref.converter);\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Calculates the number of documents in the result set of the given query\n * without actually downloading the documents.\n *\n * Using this function to count the documents is efficient because only the\n * final count, not the documents' data, is downloaded. This function can\n * count the documents in cases where the result set is prohibitively large to\n * download entirely (thousands of documents).\n *\n * The result received from the server is presented, unaltered, without\n * considering any local state. That is, documents in the local cache are not\n * taken into consideration, neither are local modifications not yet\n * synchronized with the server. Previously-downloaded results, if any, are not\n * used. Every invocation of this function necessarily involves a round trip to\n * the server.\n *\n * @param query The query whose result set size is calculated.\n * @returns A Promise that will be resolved with the count; the count can be\n * retrieved from `snapshot.data().count`, where `snapshot` is the\n * `AggregateQuerySnapshot` to which the returned Promise resolves.\n */\nfunction getCountFromServer(query) {\n    const countQuerySpec = {\n        count: count()\n    };\n    return getAggregateFromServer(query, countQuerySpec);\n}\n/**\n * Calculates the specified aggregations over the documents in the result\n * set of the given query without actually downloading the documents.\n *\n * Using this function to perform aggregations is efficient because only the\n * final aggregation values, not the documents' data, are downloaded. This\n * function can perform aggregations of the documents in cases where the result\n * set is prohibitively large to download entirely (thousands of documents).\n *\n * The result received from the server is presented, unaltered, without\n * considering any local state. That is, documents in the local cache are not\n * taken into consideration, neither are local modifications not yet\n * synchronized with the server. Previously-downloaded results, if any, are not\n * used. Every invocation of this function necessarily involves a round trip to\n * the server.\n *\n * @param query The query whose result set is aggregated over.\n * @param aggregateSpec An `AggregateSpec` object that specifies the aggregates\n * to perform over the result set. The AggregateSpec specifies aliases for each\n * aggregate, which can be used to retrieve the aggregate result.\n * @example\n * ```typescript\n * const aggregateSnapshot = await getAggregateFromServer(query, {\n *   countOfDocs: count(),\n *   totalHours: sum('hours'),\n *   averageScore: average('score')\n * });\n *\n * const countOfDocs: number = aggregateSnapshot.data().countOfDocs;\n * const totalHours: number = aggregateSnapshot.data().totalHours;\n * const averageScore: number | null = aggregateSnapshot.data().averageScore;\n * ```\n */\nfunction getAggregateFromServer(query, aggregateSpec) {\n    const firestore = cast(query.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const internalAggregates = mapToArray(aggregateSpec, (aggregate, alias) => {\n        return new AggregateImpl(alias, aggregate.aggregateType, aggregate._internalFieldPath);\n    });\n    // Run the aggregation and convert the results\n    return firestoreClientRunAggregateQuery(client, query._query, internalAggregates).then(aggregateResult => convertToAggregateQuerySnapshot(firestore, query, aggregateResult));\n}\n/**\n * Converts the core aggregation result to an `AggregateQuerySnapshot`\n * that can be returned to the consumer.\n * @param query\n * @param aggregateResult Core aggregation result\n * @internal\n */\nfunction convertToAggregateQuerySnapshot(firestore, query, aggregateResult) {\n    const userDataWriter = new ExpUserDataWriter(firestore);\n    const querySnapshot = new AggregateQuerySnapshot(query, userDataWriter, aggregateResult);\n    return querySnapshot;\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MemoryLocalCacheImpl {\n    constructor(settings) {\n        this.kind = 'memory';\n        this._onlineComponentProvider = OnlineComponentProvider.provider;\n        if (settings === null || settings === void 0 ? void 0 : settings.garbageCollector) {\n            this._offlineComponentProvider =\n                settings.garbageCollector._offlineComponentProvider;\n        }\n        else {\n            this._offlineComponentProvider = {\n                build: () => new LruGcMemoryOfflineComponentProvider(undefined)\n            };\n        }\n    }\n    toJSON() {\n        return { kind: this.kind };\n    }\n}\nclass PersistentLocalCacheImpl {\n    constructor(settings) {\n        this.kind = 'persistent';\n        let tabManager;\n        if (settings === null || settings === void 0 ? void 0 : settings.tabManager) {\n            settings.tabManager._initialize(settings);\n            tabManager = settings.tabManager;\n        }\n        else {\n            tabManager = persistentSingleTabManager(undefined);\n            tabManager._initialize(settings);\n        }\n        this._onlineComponentProvider = tabManager._onlineComponentProvider;\n        this._offlineComponentProvider = tabManager._offlineComponentProvider;\n    }\n    toJSON() {\n        return { kind: this.kind };\n    }\n}\nclass MemoryEagerGarbageCollectorImpl {\n    constructor() {\n        this.kind = 'memoryEager';\n        this._offlineComponentProvider = MemoryOfflineComponentProvider.provider;\n    }\n    toJSON() {\n        return { kind: this.kind };\n    }\n}\nclass MemoryLruGarbageCollectorImpl {\n    constructor(cacheSize) {\n        this.kind = 'memoryLru';\n        this._offlineComponentProvider = {\n            build: () => new LruGcMemoryOfflineComponentProvider(cacheSize)\n        };\n    }\n    toJSON() {\n        return { kind: this.kind };\n    }\n}\n/**\n * Creates an instance of `MemoryEagerGarbageCollector`. This is also the\n * default garbage collector unless it is explicitly specified otherwise.\n */\nfunction memoryEagerGarbageCollector() {\n    return new MemoryEagerGarbageCollectorImpl();\n}\n/**\n * Creates an instance of `MemoryLruGarbageCollector`.\n *\n * A target size can be specified as part of the setting parameter. The\n * collector will start deleting documents once the cache size exceeds\n * the given size. The default cache size is 40MB (40 * 1024 * 1024 bytes).\n */\nfunction memoryLruGarbageCollector(settings) {\n    return new MemoryLruGarbageCollectorImpl(settings === null || settings === void 0 ? void 0 : settings.cacheSizeBytes);\n}\n/**\n * Creates an instance of `MemoryLocalCache`. The instance can be set to\n * `FirestoreSettings.cache` to tell the SDK which cache layer to use.\n */\nfunction memoryLocalCache(settings) {\n    return new MemoryLocalCacheImpl(settings);\n}\n/**\n * Creates an instance of `PersistentLocalCache`. The instance can be set to\n * `FirestoreSettings.cache` to tell the SDK which cache layer to use.\n *\n * Persistent cache cannot be used in a Node.js environment.\n */\nfunction persistentLocalCache(settings) {\n    return new PersistentLocalCacheImpl(settings);\n}\nclass SingleTabManagerImpl {\n    constructor(forceOwnership) {\n        this.forceOwnership = forceOwnership;\n        this.kind = 'persistentSingleTab';\n    }\n    toJSON() {\n        return { kind: this.kind };\n    }\n    /**\n     * @internal\n     */\n    _initialize(settings) {\n        this._onlineComponentProvider = OnlineComponentProvider.provider;\n        this._offlineComponentProvider = {\n            build: (onlineComponents) => new IndexedDbOfflineComponentProvider(onlineComponents, settings === null || settings === void 0 ? void 0 : settings.cacheSizeBytes, this.forceOwnership)\n        };\n    }\n}\nclass MultiTabManagerImpl {\n    constructor() {\n        this.kind = 'PersistentMultipleTab';\n    }\n    toJSON() {\n        return { kind: this.kind };\n    }\n    /**\n     * @internal\n     */\n    _initialize(settings) {\n        this._onlineComponentProvider = OnlineComponentProvider.provider;\n        this._offlineComponentProvider = {\n            build: (onlineComponents) => new MultiTabOfflineComponentProvider(onlineComponents, settings === null || settings === void 0 ? void 0 : settings.cacheSizeBytes)\n        };\n    }\n}\n/**\n * Creates an instance of `PersistentSingleTabManager`.\n *\n * @param settings Configures the created tab manager.\n */\nfunction persistentSingleTabManager(settings) {\n    return new SingleTabManagerImpl(settings === null || settings === void 0 ? void 0 : settings.forceOwnership);\n}\n/**\n * Creates an instance of `PersistentMultipleTabManager`.\n */\nfunction persistentMultipleTabManager() {\n    return new MultiTabManagerImpl();\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DEFAULT_TRANSACTION_OPTIONS = {\n    maxAttempts: 5\n};\nfunction validateTransactionOptions(options) {\n    if (options.maxAttempts < 1) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Max attempts must be at least 1');\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A write batch, used to perform multiple writes as a single atomic unit.\n *\n * A `WriteBatch` object can be acquired by calling {@link writeBatch}. It\n * provides methods for adding writes to the write batch. None of the writes\n * will be committed (or visible locally) until {@link WriteBatch.commit} is\n * called.\n */\nclass WriteBatch {\n    /** @hideconstructor */\n    constructor(_firestore, _commitHandler) {\n        this._firestore = _firestore;\n        this._commitHandler = _commitHandler;\n        this._mutations = [];\n        this._committed = false;\n        this._dataReader = newUserDataReader(_firestore);\n    }\n    set(documentRef, data, options) {\n        this._verifyNotCommitted();\n        const ref = validateReference(documentRef, this._firestore);\n        const convertedValue = applyFirestoreDataConverter(ref.converter, data, options);\n        const parsed = parseSetData(this._dataReader, 'WriteBatch.set', ref._key, convertedValue, ref.converter !== null, options);\n        this._mutations.push(parsed.toMutation(ref._key, Precondition.none()));\n        return this;\n    }\n    update(documentRef, fieldOrUpdateData, value, ...moreFieldsAndValues) {\n        this._verifyNotCommitted();\n        const ref = validateReference(documentRef, this._firestore);\n        // For Compat types, we have to \"extract\" the underlying types before\n        // performing validation.\n        fieldOrUpdateData = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(fieldOrUpdateData);\n        let parsed;\n        if (typeof fieldOrUpdateData === 'string' ||\n            fieldOrUpdateData instanceof FieldPath) {\n            parsed = parseUpdateVarargs(this._dataReader, 'WriteBatch.update', ref._key, fieldOrUpdateData, value, moreFieldsAndValues);\n        }\n        else {\n            parsed = parseUpdateData(this._dataReader, 'WriteBatch.update', ref._key, fieldOrUpdateData);\n        }\n        this._mutations.push(parsed.toMutation(ref._key, Precondition.exists(true)));\n        return this;\n    }\n    /**\n     * Deletes the document referred to by the provided {@link DocumentReference}.\n     *\n     * @param documentRef - A reference to the document to be deleted.\n     * @returns This `WriteBatch` instance. Used for chaining method calls.\n     */\n    delete(documentRef) {\n        this._verifyNotCommitted();\n        const ref = validateReference(documentRef, this._firestore);\n        this._mutations = this._mutations.concat(new DeleteMutation(ref._key, Precondition.none()));\n        return this;\n    }\n    /**\n     * Commits all of the writes in this write batch as a single atomic unit.\n     *\n     * The result of these writes will only be reflected in document reads that\n     * occur after the returned promise resolves. If the client is offline, the\n     * write fails. If you would like to see local modifications or buffer writes\n     * until the client is online, use the full Firestore SDK.\n     *\n     * @returns A `Promise` resolved once all of the writes in the batch have been\n     * successfully written to the backend as an atomic unit (note that it won't\n     * resolve while you're offline).\n     */\n    commit() {\n        this._verifyNotCommitted();\n        this._committed = true;\n        if (this._mutations.length > 0) {\n            return this._commitHandler(this._mutations);\n        }\n        return Promise.resolve();\n    }\n    _verifyNotCommitted() {\n        if (this._committed) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'A write batch can no longer be used after commit() ' +\n                'has been called.');\n        }\n    }\n}\nfunction validateReference(documentRef, firestore) {\n    documentRef = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(documentRef);\n    if (documentRef.firestore !== firestore) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Provided document reference is from a different Firestore instance.');\n    }\n    else {\n        return documentRef;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// TODO(mrschmidt) Consider using `BaseTransaction` as the base class in the\n// legacy SDK.\n/**\n * A reference to a transaction.\n *\n * The `Transaction` object passed to a transaction's `updateFunction` provides\n * the methods to read and write data within the transaction context. See\n * {@link runTransaction}.\n */\nclass Transaction$1 {\n    /** @hideconstructor */\n    constructor(_firestore, _transaction) {\n        this._firestore = _firestore;\n        this._transaction = _transaction;\n        this._dataReader = newUserDataReader(_firestore);\n    }\n    /**\n     * Reads the document referenced by the provided {@link DocumentReference}.\n     *\n     * @param documentRef - A reference to the document to be read.\n     * @returns A `DocumentSnapshot` with the read data.\n     */\n    get(documentRef) {\n        const ref = validateReference(documentRef, this._firestore);\n        const userDataWriter = new LiteUserDataWriter(this._firestore);\n        return this._transaction.lookup([ref._key]).then(docs => {\n            if (!docs || docs.length !== 1) {\n                return fail();\n            }\n            const doc = docs[0];\n            if (doc.isFoundDocument()) {\n                return new DocumentSnapshot$1(this._firestore, userDataWriter, doc.key, doc, ref.converter);\n            }\n            else if (doc.isNoDocument()) {\n                return new DocumentSnapshot$1(this._firestore, userDataWriter, ref._key, null, ref.converter);\n            }\n            else {\n                throw fail();\n            }\n        });\n    }\n    set(documentRef, value, options) {\n        const ref = validateReference(documentRef, this._firestore);\n        const convertedValue = applyFirestoreDataConverter(ref.converter, value, options);\n        const parsed = parseSetData(this._dataReader, 'Transaction.set', ref._key, convertedValue, ref.converter !== null, options);\n        this._transaction.set(ref._key, parsed);\n        return this;\n    }\n    update(documentRef, fieldOrUpdateData, value, ...moreFieldsAndValues) {\n        const ref = validateReference(documentRef, this._firestore);\n        // For Compat types, we have to \"extract\" the underlying types before\n        // performing validation.\n        fieldOrUpdateData = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(fieldOrUpdateData);\n        let parsed;\n        if (typeof fieldOrUpdateData === 'string' ||\n            fieldOrUpdateData instanceof FieldPath) {\n            parsed = parseUpdateVarargs(this._dataReader, 'Transaction.update', ref._key, fieldOrUpdateData, value, moreFieldsAndValues);\n        }\n        else {\n            parsed = parseUpdateData(this._dataReader, 'Transaction.update', ref._key, fieldOrUpdateData);\n        }\n        this._transaction.update(ref._key, parsed);\n        return this;\n    }\n    /**\n     * Deletes the document referred to by the provided {@link DocumentReference}.\n     *\n     * @param documentRef - A reference to the document to be deleted.\n     * @returns This `Transaction` instance. Used for chaining method calls.\n     */\n    delete(documentRef) {\n        const ref = validateReference(documentRef, this._firestore);\n        this._transaction.delete(ref._key);\n        return this;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A reference to a transaction.\n *\n * The `Transaction` object passed to a transaction's `updateFunction` provides\n * the methods to read and write data within the transaction context. See\n * {@link runTransaction}.\n */\nclass Transaction extends Transaction$1 {\n    // This class implements the same logic as the Transaction API in the Lite SDK\n    // but is subclassed in order to return its own DocumentSnapshot types.\n    /** @hideconstructor */\n    constructor(_firestore, _transaction) {\n        super(_firestore, _transaction);\n        this._firestore = _firestore;\n    }\n    /**\n     * Reads the document referenced by the provided {@link DocumentReference}.\n     *\n     * @param documentRef - A reference to the document to be read.\n     * @returns A `DocumentSnapshot` with the read data.\n     */\n    get(documentRef) {\n        const ref = validateReference(documentRef, this._firestore);\n        const userDataWriter = new ExpUserDataWriter(this._firestore);\n        return super\n            .get(documentRef)\n            .then(liteDocumentSnapshot => new DocumentSnapshot(this._firestore, userDataWriter, ref._key, liteDocumentSnapshot._document, new SnapshotMetadata(\n        /* hasPendingWrites= */ false, \n        /* fromCache= */ false), ref.converter));\n    }\n}\n/**\n * Executes the given `updateFunction` and then attempts to commit the changes\n * applied within the transaction. If any document read within the transaction\n * has changed, Cloud Firestore retries the `updateFunction`. If it fails to\n * commit after 5 attempts, the transaction fails.\n *\n * The maximum number of writes allowed in a single transaction is 500.\n *\n * @param firestore - A reference to the Firestore database to run this\n * transaction against.\n * @param updateFunction - The function to execute within the transaction\n * context.\n * @param options - An options object to configure maximum number of attempts to\n * commit.\n * @returns If the transaction completed successfully or was explicitly aborted\n * (the `updateFunction` returned a failed promise), the promise returned by the\n * `updateFunction `is returned here. Otherwise, if the transaction failed, a\n * rejected promise with the corresponding failure error is returned.\n */\nfunction runTransaction(firestore, updateFunction, options) {\n    firestore = cast(firestore, Firestore);\n    const optionsWithDefaults = Object.assign(Object.assign({}, DEFAULT_TRANSACTION_OPTIONS), options);\n    validateTransactionOptions(optionsWithDefaults);\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientTransaction(client, internalTransaction => updateFunction(new Transaction(firestore, internalTransaction)), optionsWithDefaults);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns a sentinel for use with {@link @firebase/firestore/lite#(updateDoc:1)} or\n * {@link @firebase/firestore/lite#(setDoc:1)} with `{merge: true}` to mark a field for deletion.\n */\nfunction deleteField() {\n    return new DeleteFieldValueImpl('deleteField');\n}\n/**\n * Returns a sentinel used with {@link @firebase/firestore/lite#(setDoc:1)} or {@link @firebase/firestore/lite#(updateDoc:1)} to\n * include a server-generated timestamp in the written data.\n */\nfunction serverTimestamp() {\n    return new ServerTimestampFieldValueImpl('serverTimestamp');\n}\n/**\n * Returns a special value that can be used with {@link @firebase/firestore/lite#(setDoc:1)} or {@link\n * @firebase/firestore/lite#(updateDoc:1)} that tells the server to union the given elements with any array\n * value that already exists on the server. Each specified element that doesn't\n * already exist in the array will be added to the end. If the field being\n * modified is not already an array it will be overwritten with an array\n * containing exactly the specified elements.\n *\n * @param elements - The elements to union into the array.\n * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or\n * `updateDoc()`.\n */\nfunction arrayUnion(...elements) {\n    // NOTE: We don't actually parse the data until it's used in set() or\n    // update() since we'd need the Firestore instance to do this.\n    return new ArrayUnionFieldValueImpl('arrayUnion', elements);\n}\n/**\n * Returns a special value that can be used with {@link (setDoc:1)} or {@link\n * updateDoc:1} that tells the server to remove the given elements from any\n * array value that already exists on the server. All instances of each element\n * specified will be removed from the array. If the field being modified is not\n * already an array it will be overwritten with an empty array.\n *\n * @param elements - The elements to remove from the array.\n * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or\n * `updateDoc()`\n */\nfunction arrayRemove(...elements) {\n    // NOTE: We don't actually parse the data until it's used in set() or\n    // update() since we'd need the Firestore instance to do this.\n    return new ArrayRemoveFieldValueImpl('arrayRemove', elements);\n}\n/**\n * Returns a special value that can be used with {@link @firebase/firestore/lite#(setDoc:1)} or {@link\n * @firebase/firestore/lite#(updateDoc:1)} that tells the server to increment the field's current value by\n * the given value.\n *\n * If either the operand or the current field value uses floating point\n * precision, all arithmetic follows IEEE 754 semantics. If both values are\n * integers, values outside of JavaScript's safe number range\n * (`Number.MIN_SAFE_INTEGER` to `Number.MAX_SAFE_INTEGER`) are also subject to\n * precision loss. Furthermore, once processed by the Firestore backend, all\n * integer operations are capped between -2^63 and 2^63-1.\n *\n * If the current field value is not of type `number`, or if the field does not\n * yet exist, the transformation sets the field to the given value.\n *\n * @param n - The value to increment by.\n * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or\n * `updateDoc()`\n */\nfunction increment(n) {\n    return new NumericIncrementFieldValueImpl('increment', n);\n}\n/**\n * Creates a new `VectorValue` constructed with a copy of the given array of numbers.\n *\n * @param values - Create a `VectorValue` instance with a copy of this array of numbers.\n *\n * @returns A new `VectorValue` constructed with a copy of the given array of numbers.\n */\nfunction vector(values) {\n    return new VectorValue(values);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Creates a write batch, used for performing multiple writes as a single\n * atomic operation. The maximum number of writes allowed in a single {@link WriteBatch}\n * is 500.\n *\n * Unlike transactions, write batches are persisted offline and therefore are\n * preferable when you don't need to condition your writes on read data.\n *\n * @returns A {@link WriteBatch} that can be used to atomically execute multiple\n * writes.\n */\nfunction writeBatch(firestore) {\n    firestore = cast(firestore, Firestore);\n    ensureFirestoreConfigured(firestore);\n    return new WriteBatch(firestore, mutations => executeWrite(firestore, mutations));\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction setIndexConfiguration(firestore, jsonOrConfiguration) {\n    firestore = cast(firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    if (!client._uninitializedComponentsProvider ||\n        client._uninitializedComponentsProvider._offline.kind === 'memory') {\n        // PORTING NOTE: We don't return an error if the user has not enabled\n        // persistence since `enableIndexeddbPersistence()` can fail on the Web.\n        logWarn('Cannot enable indexes when persistence is disabled');\n        return Promise.resolve();\n    }\n    const parsedIndexes = parseIndexes(jsonOrConfiguration);\n    return firestoreClientSetIndexConfiguration(client, parsedIndexes);\n}\nfunction parseIndexes(jsonOrConfiguration) {\n    const indexConfiguration = typeof jsonOrConfiguration === 'string'\n        ? tryParseJson(jsonOrConfiguration)\n        : jsonOrConfiguration;\n    const parsedIndexes = [];\n    if (Array.isArray(indexConfiguration.indexes)) {\n        for (const index of indexConfiguration.indexes) {\n            const collectionGroup = tryGetString(index, 'collectionGroup');\n            const segments = [];\n            if (Array.isArray(index.fields)) {\n                for (const field of index.fields) {\n                    const fieldPathString = tryGetString(field, 'fieldPath');\n                    const fieldPath = fieldPathFromDotSeparatedString('setIndexConfiguration', fieldPathString);\n                    if (field.arrayConfig === 'CONTAINS') {\n                        segments.push(new IndexSegment(fieldPath, 2 /* IndexKind.CONTAINS */));\n                    }\n                    else if (field.order === 'ASCENDING') {\n                        segments.push(new IndexSegment(fieldPath, 0 /* IndexKind.ASCENDING */));\n                    }\n                    else if (field.order === 'DESCENDING') {\n                        segments.push(new IndexSegment(fieldPath, 1 /* IndexKind.DESCENDING */));\n                    }\n                }\n            }\n            parsedIndexes.push(new FieldIndex(FieldIndex.UNKNOWN_ID, collectionGroup, segments, IndexState.empty()));\n        }\n    }\n    return parsedIndexes;\n}\nfunction tryParseJson(json) {\n    try {\n        return JSON.parse(json);\n    }\n    catch (e) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Failed to parse JSON: ' + (e === null || e === void 0 ? void 0 : e.message));\n    }\n}\nfunction tryGetString(data, property) {\n    if (typeof data[property] !== 'string') {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Missing string value for: ' + property);\n    }\n    return data[property];\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A `PersistentCacheIndexManager` for configuring persistent cache indexes used\n * for local query execution.\n *\n * To use, call `getPersistentCacheIndexManager()` to get an instance.\n */\nclass PersistentCacheIndexManager {\n    /** @hideconstructor */\n    constructor(_firestore) {\n        this._firestore = _firestore;\n        /** A type string to uniquely identify instances of this class. */\n        this.type = 'PersistentCacheIndexManager';\n    }\n}\n/**\n * Returns the PersistentCache Index Manager used by the given `Firestore`\n * object.\n *\n * @return The `PersistentCacheIndexManager` instance, or `null` if local\n * persistent storage is not in use.\n */\nfunction getPersistentCacheIndexManager(firestore) {\n    var _a;\n    firestore = cast(firestore, Firestore);\n    const cachedInstance = persistentCacheIndexManagerByFirestore.get(firestore);\n    if (cachedInstance) {\n        return cachedInstance;\n    }\n    const client = ensureFirestoreConfigured(firestore);\n    if (((_a = client._uninitializedComponentsProvider) === null || _a === void 0 ? void 0 : _a._offline.kind) !== 'persistent') {\n        return null;\n    }\n    const instance = new PersistentCacheIndexManager(firestore);\n    persistentCacheIndexManagerByFirestore.set(firestore, instance);\n    return instance;\n}\n/**\n * Enables the SDK to create persistent cache indexes automatically for local\n * query execution when the SDK believes cache indexes can help improve\n * performance.\n *\n * This feature is disabled by default.\n */\nfunction enablePersistentCacheIndexAutoCreation(indexManager) {\n    setPersistentCacheIndexAutoCreationEnabled(indexManager, true);\n}\n/**\n * Stops creating persistent cache indexes automatically for local query\n * execution. The indexes which have been created by calling\n * `enablePersistentCacheIndexAutoCreation()` still take effect.\n */\nfunction disablePersistentCacheIndexAutoCreation(indexManager) {\n    setPersistentCacheIndexAutoCreationEnabled(indexManager, false);\n}\n/**\n * Removes all persistent cache indexes.\n *\n * Please note this function will also deletes indexes generated by\n * `setIndexConfiguration()`, which is deprecated.\n */\nfunction deleteAllPersistentCacheIndexes(indexManager) {\n    const client = ensureFirestoreConfigured(indexManager._firestore);\n    const promise = firestoreClientDeleteAllFieldIndexes(client);\n    promise\n        .then(_ => logDebug('deleting all persistent cache indexes succeeded'))\n        .catch(error => logWarn('deleting all persistent cache indexes failed', error));\n}\nfunction setPersistentCacheIndexAutoCreationEnabled(indexManager, isEnabled) {\n    const client = ensureFirestoreConfigured(indexManager._firestore);\n    const promise = firestoreClientSetPersistentCacheIndexAutoCreationEnabled(client, isEnabled);\n    promise\n        .then(_ => logDebug(`setting persistent cache index auto creation ` +\n        `isEnabled=${isEnabled} succeeded`))\n        .catch(error => logWarn(`setting persistent cache index auto creation ` +\n        `isEnabled=${isEnabled} failed`, error));\n}\n/**\n * Maps `Firestore` instances to their corresponding\n * `PersistentCacheIndexManager` instances.\n *\n * Use a `WeakMap` so that the mapping will be automatically dropped when the\n * `Firestore` instance is garbage collected. This emulates a private member\n * as described in https://goo.gle/454yvug.\n */\nconst persistentCacheIndexManagerByFirestore = new WeakMap();\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @internal\n * @private\n *\n * This function is for internal use only.\n *\n * Returns the `QueryTarget` representation of the given query. Returns `null`\n * if the Firestore client associated with the given query has not been\n * initialized or has been terminated.\n *\n * @param query - The Query to convert to proto representation.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _internalQueryToProtoQueryTarget(query) {\n    var _a;\n    const firestore = cast(query.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const serializer = (_a = client._onlineComponents) === null || _a === void 0 ? void 0 : _a.datastore.serializer;\n    if (serializer === undefined) {\n        return null;\n    }\n    return toQueryTarget(serializer, queryToTarget(query._query)).queryTarget;\n}\n/**\n * @internal\n * @private\n *\n * This function is for internal use only.\n *\n * Returns `RunAggregationQueryRequest` which contains the proto representation\n * of the given aggregation query request. Returns null if the Firestore client\n * associated with the given query has not been initialized or has been\n * terminated.\n *\n * @param query - The Query to convert to proto representation.\n * @param aggregateSpec - The set of aggregations and their aliases.\n */\nfunction _internalAggregationQueryToProtoRunAggregationQueryRequest(query, aggregateSpec) {\n    var _a;\n    const aggregates = mapToArray(aggregateSpec, (aggregate, alias) => {\n        return new AggregateImpl(alias, aggregate.aggregateType, aggregate._internalFieldPath);\n    });\n    const firestore = cast(query.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const serializer = (_a = client._onlineComponents) === null || _a === void 0 ? void 0 : _a.datastore.serializer;\n    if (serializer === undefined) {\n        return null;\n    }\n    return toRunAggregationQueryRequest(serializer, queryToAggregateTarget(query._query), aggregates, \n    /* skipAliasing= */ true).request;\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Testing hooks for use by Firestore's integration test suite to reach into the\n * SDK internals to validate logic and behavior that is not visible from the\n * public API surface.\n *\n * @internal\n */\nclass TestingHooks {\n    constructor() {\n        throw new Error('instances of this class should not be created');\n    }\n    /**\n     * Registers a callback to be notified when an existence filter mismatch\n     * occurs in the Watch listen stream.\n     *\n     * The relative order in which callbacks are notified is unspecified; do not\n     * rely on any particular ordering. If a given callback is registered multiple\n     * times then it will be notified multiple times, once per registration.\n     *\n     * @param callback the callback to invoke upon existence filter mismatch.\n     *\n     * @return a function that, when called, unregisters the given callback; only\n     * the first invocation of the returned function does anything; all subsequent\n     * invocations do nothing.\n     */\n    static onExistenceFilterMismatch(callback) {\n        return TestingHooksSpiImpl.instance.onExistenceFilterMismatch(callback);\n    }\n}\n/**\n * The implementation of `TestingHooksSpi`.\n */\nclass TestingHooksSpiImpl {\n    constructor() {\n        this.existenceFilterMismatchCallbacksById = new Map();\n    }\n    static get instance() {\n        if (!testingHooksSpiImplInstance) {\n            testingHooksSpiImplInstance = new TestingHooksSpiImpl();\n            setTestingHooksSpi(testingHooksSpiImplInstance);\n        }\n        return testingHooksSpiImplInstance;\n    }\n    notifyOnExistenceFilterMismatch(info) {\n        this.existenceFilterMismatchCallbacksById.forEach(callback => callback(info));\n    }\n    onExistenceFilterMismatch(callback) {\n        const id = Symbol();\n        const callbacks = this.existenceFilterMismatchCallbacksById;\n        callbacks.set(id, callback);\n        return () => callbacks.delete(id);\n    }\n}\nlet testingHooksSpiImplInstance = null;\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nregisterFirestore('node');\n\n\n//# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2ZpcmVzdG9yZS9kaXN0L2luZGV4Lm5vZGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdKO0FBQ2hHO0FBQ0k7QUFDSztBQUNvSDtBQUN2SDtBQUNpQjtBQUNqQztBQUNZOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkNBQU8sVUFBVSxZQUFZO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9EQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzREFBUTtBQUN0QztBQUNBLHNDQUFzQyxZQUFZLEtBQUssSUFBSTtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0RBQVE7QUFDdEM7QUFDQSxzQ0FBc0MsWUFBWSxLQUFLLElBQUk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNEQUFRO0FBQ3RDO0FBQ0EscUNBQXFDLFlBQVksS0FBSyxJQUFJO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxZQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIseURBQWE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsVUFBVSxVQUFVLFVBQVUsS0FBSyxhQUFhO0FBQ2pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE1BQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGdCQUFnQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLDBDQUEwQywwQkFBMEI7QUFDOUo7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLG1DQUFtQztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxnQkFBZ0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbURBQWE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0hBQWdIO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLEtBQUs7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLEtBQUs7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdURBQXVEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUIsTUFBTSwyQkFBMkIsS0FBSyw4QkFBOEIsWUFBWSxHQUFHLE9BQU8sYUFBYTtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0VBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxREFBSztBQUN4QjtBQUNBLDBDQUEwQyxXQUFXLGdCQUFnQjtBQUNyRTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QscURBQUs7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFdBQVcsWUFBWSxNQUFNO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMscURBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsVUFBVTtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsTUFBTTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxtQkFBbUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGdCQUFnQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFVBQVU7QUFDbEU7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxFQUFFLEdBQUcsRUFBRTtBQUN4QztBQUNBLFNBQVM7QUFDVCxpQkFBaUIsRUFBRSx5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHNEQUFzRCxZQUFZO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEVBQUU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0pBQWtKO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscURBQXFEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtDQUErQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2Q0FBNkM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCLEdBQUcsMEJBQTBCO0FBQzVFO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCLEdBQUcsbUJBQW1CO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLElBQUksR0FBRyxvQ0FBb0M7QUFDaEU7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxQkFBcUIsYUFBYSxvQkFBb0IsYUFBYSwyQkFBMkI7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0pBQWtKO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0JBQStCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQ0FBZ0M7QUFDakQ7QUFDQTtBQUNBLHlCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGNBQWM7QUFDdkMsd0JBQXdCLDZDQUE2QztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSx3REFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0EsbUNBQW1DLGNBQWMsbUJBQW1CO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0NBQW9DO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQsa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUyxJQUFJLGFBQWEsSUFBSSxnQ0FBZ0M7QUFDMUYsY0FBYyxjQUFjLGlCQUFpQjtBQUM3QyxjQUFjLGdCQUFnQixtQkFBbUI7QUFDakQsY0FBYyxpQkFBaUIsb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlDQUFpQyxHQUFHLFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVSxHQUFHLG1CQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjLGdDQUFnQyxFQUFFLFdBQVcsRUFBRSwwQkFBMEI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx5QkFBeUI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixJQUFJO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCLElBQUksZ0RBQWdEO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msa0JBQWtCLElBQUksZ0RBQWdEO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0IsSUFBSSxnREFBZ0Q7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrQkFBa0IsSUFBSSxnREFBZ0Q7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQ0FBcUMsTUFBTSxnQkFBZ0I7QUFDekU7QUFDQTtBQUNBLDJCQUEyQix3Q0FBd0MsWUFBWSxnQkFBZ0I7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFLO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUNBQW1DO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDLGtCQUFrQjtBQUNsQixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkNBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkNBQVc7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNEVBQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdFQUFHO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNEVBQU87QUFDaEMseUJBQXlCLDRFQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsUUFBUTtBQUNuRTtBQUNBO0FBQ0EsOERBQThELFVBQVU7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsOERBQThELFVBQVU7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLFFBQVE7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDRFQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsNEVBQU87QUFDdEQ7QUFDQTtBQUNBLDRCQUE0Qiw0RUFBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRLDBCQUEwQixrQkFBa0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMscUJBQXFCO0FBQ2xFLDhCQUE4QixvQkFBb0I7QUFDbEQsOEJBQThCLDJCQUEyQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCLEdBQUcsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxZQUFZLDJCQUEyQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWSw0QkFBNEI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0QkFBNEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtDQUFrQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQ0FBa0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsd0JBQXdCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEI7QUFDQSx1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRCx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUNBQXFDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQ0FBZ0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0NBQWdDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMkJBQTJCLGFBQWEsdUJBQXVCO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsT0FBTztBQUN6RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpREFBaUQ7QUFDeEU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaURBQWlEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdFQUFnRTtBQUN2RjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsT0FBTztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1DQUFtQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2Q0FBNkM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQjtBQUN0RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxNQUFNO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsYUFBYSxXQUFXO0FBQ3JHLCtDQUErQyx5Q0FBeUM7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsNkNBQTZDO0FBQ3RGLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUNBQWlDLHNEQUFRO0FBQ3pDO0FBQ0EsNENBQTRDLDJCQUEyQjtBQUN2RSx3REFBd0QsMEJBQTBCO0FBQ2xGLHVCQUF1QixxQ0FBcUM7QUFDNUQsaUNBQWlDLGdCQUFnQjtBQUNqRCx1QkFBdUIscUNBQXFDO0FBQzVELGlDQUFpQyxrQkFBa0I7QUFDbkQsdUJBQXVCLHNDQUFzQztBQUM3RCx1Q0FBdUMsNkJBQTZCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlCQUF5QixzQkFBc0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0RBQWdEO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkNBQTZDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsWUFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLFlBQVk7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYyxhQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGO0FBQzNGLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsK0dBQStHLGNBQWM7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNkdBQTZHLGNBQWM7QUFDM0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxSEFBcUgsY0FBYztBQUNuSTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEZBQTBGLGNBQWM7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa0lBQWtJLGVBQWU7QUFDako7QUFDQTtBQUNBLEtBQUs7QUFDTCx3R0FBd0csZUFBZTtBQUN2SDtBQUNBO0FBQ0EsS0FBSztBQUNMLGtHQUFrRyxlQUFlO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHFJQUFxSSxlQUFlO0FBQ3BKLHVJQUF1SSxlQUFlO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLDhDQUE4QyxtQ0FBbUM7QUFDakY7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwrRUFBK0UsT0FBTztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLGNBQWMsSUFBSSxjQUFjO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdEQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTLElBQUksNkJBQTZCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJCQUEyQixHQUFHLG9CQUFvQixHQUFHLFNBQVM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3Q0FBd0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsU0FBUyxJQUFJLEVBQUU7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixXQUFXO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdEQUFRO0FBQ2hCO0FBQ0E7QUFDQSwrQkFBK0IscURBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHNEQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNEQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHNEQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzREFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNEQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3QkFBd0IsR0FBRyxlQUFlLEdBQUcsU0FBUztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDBCQUEwQixHQUFHLGVBQWUsR0FBRyxRQUFRO0FBQ2hGO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCLEdBQUcsZUFBZSxHQUFHLFNBQVM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QixHQUFHLGVBQWU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUJBQXlCLEdBQUcsZUFBZTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJCQUEyQixHQUFHLGVBQWU7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxRQUFRLEtBQUssTUFBTTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxTQUFTLEtBQUssTUFBTTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFEQUFxRDtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxTQUFTLEtBQUssTUFBTTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxNQUFNO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msd0JBQXdCLEdBQUcsc0JBQXNCO0FBQ2hHLGlEQUFpRCwwQkFBMEIsR0FBRyxzQkFBc0I7QUFDcEcsK0NBQStDLHdCQUF3QixHQUFHLHNCQUFzQjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLHVCQUF1QjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHVCQUF1QixPQUFPLGFBQWEsT0FBTyxZQUFZO0FBQ3pHO0FBQ0E7QUFDQSx5QkFBeUIsbURBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msa0NBQWtDLGFBQWEsaUNBQWlDO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0RBQWdCO0FBQ2xDLGtCQUFrQixzREFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw2QkFBNkI7QUFDekU7QUFDQSx3Q0FBd0MsUUFBUSxJQUFJLFVBQVU7QUFDOUQ7QUFDQTtBQUNBLGdEQUFnRCxRQUFRLElBQUksVUFBVTtBQUN0RTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUSxJQUFJLFVBQVU7QUFDdEU7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRLElBQUksVUFBVTtBQUMxRDtBQUNBO0FBQ0EsMERBQTBELGNBQWMsNkJBQTZCO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTLEVBQUUsVUFBVTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3Q0FBd0MsUUFBUSxJQUFJLFVBQVU7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3Q0FBd0MsUUFBUSxJQUFJLFVBQVU7QUFDOUQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRLFdBQVcsVUFBVTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUSxXQUFXLFVBQVU7QUFDN0U7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDRDQUE0QyxRQUFRLFdBQVcsVUFBVTtBQUN6RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRLFdBQVcsVUFBVTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHdDQUF3QyxRQUFRLFdBQVcsVUFBVTtBQUNyRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkNBQTJDLFFBQVEsV0FBVyxVQUFVO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw0Q0FBNEMsUUFBUSxXQUFXLFVBQVU7QUFDekUsa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDJDQUEyQztBQUNyRixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJDQUEyQztBQUNuRTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNkNBQTZDLEVBQUUsY0FBYztBQUN2RyxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZDQUE2QyxFQUFFLGNBQWM7QUFDckY7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG9EQUFvRDtBQUNoRztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvREFBb0Q7QUFDOUU7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywyQ0FBMkM7QUFDeEY7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJDQUEyQztBQUN4RTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdDQUFnQztBQUMzRTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdDQUFnQztBQUMzRTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQ0FBZ0M7QUFDM0U7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0NBQWdDO0FBQzNFO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsd0NBQXdDO0FBQ25GO0FBQ0EsK0RBQStELDZDQUE2QztBQUM1RztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0NBQXdDO0FBQ2pFO0FBQ0E7QUFDQSwwQkFBMEIsNkNBQTZDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx3Q0FBd0M7QUFDbkY7QUFDQSwrREFBK0QsNkNBQTZDO0FBQzVHO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3Q0FBd0M7QUFDakU7QUFDQTtBQUNBLDBCQUEwQiw2Q0FBNkM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx3Q0FBd0M7QUFDbkY7QUFDQSwrREFBK0QsNkNBQTZDO0FBQzVHO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3Q0FBd0M7QUFDakU7QUFDQTtBQUNBLDBCQUEwQiw2Q0FBNkM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0NBQWdDO0FBQzNFO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdDQUFnQztBQUMzRTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHdDQUF3QztBQUNuRjtBQUNBLCtEQUErRCw2Q0FBNkM7QUFDNUc7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0NBQXdDO0FBQ2pFO0FBQ0E7QUFDQSwwQkFBMEIsNkNBQTZDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQ0FBZ0M7QUFDM0U7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywyQ0FBMkMsRUFBRSxjQUFjO0FBQ3RHO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwyQ0FBMkMsRUFBRSxjQUFjO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdEQUFvQjtBQUNsRCxXQUFXLGdFQUEwQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsa0JBQWtCO0FBQ3JFLGdDQUFnQyxvQkFBb0I7QUFDcEQsc0NBQXNDLDBCQUEwQjtBQUNoRSxpQ0FBaUMsY0FBYztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsTUFBTTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixnQ0FBZ0M7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLDJCQUEyQjtBQUN4RyxpREFBaUQsaUJBQWlCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFFBQVE7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxzQ0FBc0M7QUFDNUc7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixJQUFJLElBQUksRUFBRTtBQUNyQztBQUNBLHVEQUF1RCxJQUFJLElBQUksRUFBRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscUNBQXFDO0FBQ2hFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLCtCQUErQjtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0Q7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNENBQTRDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0RBQWdEO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDZDQUE2QztBQUMvRTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsK0NBQStDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywrQ0FBK0M7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsV0FBVztBQUM1RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsRUFBRTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNULDBCQUEwQjtBQUMxQix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGFBQWEsb0NBQW9DLGFBQWE7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxhQUFhLE1BQU0sYUFBYTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUpBQXFKLE1BQU0sTUFBTSxZQUFZO0FBQzdLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SkFBd0osTUFBTSxNQUFNLFlBQVk7QUFDaEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtCQUFrQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxpQkFBaUIsaUJBQWlCLFlBQVk7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGFBQWEsNkNBQTZDLEVBQUU7QUFDaEk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSUFBZ0kseUJBQXlCO0FBQ3pKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0ZBQWtGO0FBQ2pHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFFBQVE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixRQUFRO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRixPQUFPO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyw2QkFBNkI7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdKQUF3SjtBQUN4SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQSw2RkFBNkYsd0JBQXdCO0FBQ3JILDZDQUE2QyxpQ0FBaUM7QUFDOUU7QUFDQTtBQUNBLDZGQUE2Rix3QkFBd0I7QUFDckgsNkNBQTZDLGlDQUFpQztBQUM5RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsdUJBQXVCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlDQUFpQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsS0FBSyxHQUFHLEtBQUs7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZUFBZSxrQ0FBa0M7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUVBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsZ0JBQWdCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0VBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsYUFBYTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtFQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrRUFBa0I7QUFDN0IsWUFBWSxrRUFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtFQUFrQjtBQUM3QixZQUFZLGtFQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpQkFBaUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx1QkFBdUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25EO0FBQ0EsSUFBSSx1QkFBdUI7QUFDM0IsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBLHFCQUFxQixpQ0FBaUMsZ0JBQWdCLGlCQUFpQjtBQUN2RjtBQUNBLHlEQUF5RCxpQkFBaUI7QUFDMUU7QUFDQSxpQ0FBaUMsaUJBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkRBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsWUFBWSx5REFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLDZCQUE2QjtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0VBQXdFLHFEQUFNO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkRBQVk7QUFDM0I7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5QkFBeUIsaUZBQWlDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGlCQUFpQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCLEdBQUcsd0JBQXdCO0FBQ3JFLElBQUksZ0NBQWdDO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGlCQUFpQjtBQUN6RDtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0Esc0RBQXNEO0FBQ3RELHdCQUF3QixJQUFJLHVCQUF1QixZQUFZO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxpQkFBaUI7QUFDNUQsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx1QkFBdUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxRUFBc0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYTtBQUM5RDtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNEQUFhO0FBQy9CLElBQUksaUVBQWtCLEtBQUssMERBQVMsNEJBQTRCLG1EQUFtRDtBQUNuSDtBQUNBO0FBQ0EsbUNBQW1DLGlCQUFpQjtBQUNwRDtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksOERBQWU7QUFDbkI7QUFDQSxJQUFJLDhEQUFlO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxzQ0FBc0M7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHNDQUFzQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBLGtDQUFrQyxxQ0FBcUM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLFVBQVU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsaUJBQWlCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGlCQUFpQjtBQUMxRCxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtFQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFdBQVc7QUFDL0U7QUFDQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtFQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrRUFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZEO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0VBQWtCO0FBQzlCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCLEdBQUcsa0JBQWtCO0FBQzFELGdDQUFnQyxpQkFBaUIsR0FBRyxnQkFBZ0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELHdCQUF3QjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrRUFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsS0FBSztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFdBQVc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxLQUFLO0FBQzdDO0FBQ0E7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxZQUFZO0FBQzVFLElBQUksY0FBYyxHQUFHLGtCQUFrQixHQUFHLHFCQUFxQixHQUFHO0FBQ2xFLGlCQUFpQixHQUFHLGdCQUFnQixHQUFHLFlBQVksR0FBRyxtQkFBbUI7QUFDekUsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxhQUFhO0FBQ3ZFLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0NBQWtDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVEsZUFBZTtBQUN4RSxVQUFVO0FBQ1Y7QUFDQSx5QkFBeUIsaUNBQWlDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaUNBQWlDLE1BQU0scUNBQXFDO0FBQ2hGLDhEQUE4RCxVQUFVO0FBQ3hFLElBQUksV0FBVywyQkFBMkIsaUJBQWlCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNDQUFzQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNEJBQTRCO0FBQ2hDLDBCQUEwQixZQUFZLEdBQUcsU0FBUyxNQUFNLFVBQVU7QUFDbEUsK0JBQStCLHFDQUFxQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQ0FBc0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRCQUE0QjtBQUNoQywwQkFBMEIsWUFBWSxHQUFHLFNBQVMsTUFBTSxVQUFVO0FBQ2xFLCtCQUErQixxQ0FBcUM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxlQUFlLDJCQUEyQixpQkFBaUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhCQUE4QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDZCQUE2QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsYUFBYTtBQUNqRSxJQUFJLG1CQUFtQiwyQkFBMkIsaUJBQWlCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDJCQUEyQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkJBQTJCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsbUJBQW1CO0FBQ3pFLElBQUksc0JBQXNCLDJCQUEyQixpQkFBaUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGlCQUFpQjtBQUNyRSxJQUFJLHFCQUFxQiwyQkFBMkIsaUJBQWlCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0VBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxHQUFHO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsTUFBTTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixXQUFXO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVcsZ0JBQWdCLGdCQUFnQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RCx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxXQUFXO0FBQ3BFLGlEQUFpRCxLQUFLO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrRUFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFLLHFEQUFxRCxZQUFZO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0NBQWtDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0EsOEZBQThGLDBCQUEwQjtBQUN4SCx5QkFBeUIseUJBQXlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsYUFBYTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEtBQUs7QUFDdEM7QUFDQSxtQkFBbUIscUJBQXFCLEdBQUcsb0JBQW9CO0FBQy9EO0FBQ0EsNkJBQTZCLDZCQUE2QixHQUFHLDRCQUE0QjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHlEQUFTO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVCQUF1QixJQUFJLHVCQUF1QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0JBQXdCLElBQUksd0JBQXdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0VBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSEFBbUg7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrRUFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsU0FBUyx1QkFBdUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGlCQUFpQjtBQUN0RTtBQUNBLGlEQUFpRCx5QkFBeUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtFQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsd0JBQXdCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0VBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsd0JBQXdCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0VBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCx3QkFBd0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxQkFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsd0JBQXdCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw4Q0FBOEM7QUFDbEYsSUFBSSwyQ0FBMkMsT0FBTyxZQUFZO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMkNBQTJDLElBQUksOENBQThDO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCwyQ0FBMkMsSUFBSTtBQUNqRywyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGtCQUFrQixJQUFJO0FBQ3hFLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDJDQUEyQyxJQUFJO0FBQ2pHLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0Usb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTRzRTtBQUM1c0UiLCJzb3VyY2VzIjpbIi9Vc2Vycy92dHBhdGVsMDcvUGF0ZWxDTVAyMzNGaW5hbFByb2plY3Qvbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9maXJlc3RvcmUvZGlzdC9pbmRleC5ub2RlLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfZ2V0UHJvdmlkZXIsIGdldEFwcCwgX3JlbW92ZVNlcnZpY2VJbnN0YW5jZSwgX3JlZ2lzdGVyQ29tcG9uZW50LCByZWdpc3RlclZlcnNpb24sIFNES19WRVJTSU9OIGFzIFNES19WRVJTSU9OJDEgfSBmcm9tICdAZmlyZWJhc2UvYXBwJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0BmaXJlYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0IHsgTG9nZ2VyLCBMb2dMZXZlbCB9IGZyb20gJ0BmaXJlYmFzZS9sb2dnZXInO1xuaW1wb3J0IHsgaW5zcGVjdCwgVGV4dEVuY29kZXIsIFRleHREZWNvZGVyIH0gZnJvbSAndXRpbCc7XG5pbXBvcnQgeyBGaXJlYmFzZUVycm9yLCBjcmVhdGVNb2NrVXNlclRva2VuLCBnZXRNb2R1bGFySW5zdGFuY2UsIGRlZXBFcXVhbCwgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0LCBpc0luZGV4ZWREQkF2YWlsYWJsZSwgZ2V0VUEsIGlzU2FmYXJpIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgYXMgcmFuZG9tQnl0ZXMkMSB9IGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgeyBJbnRlZ2VyLCBNZDUgfSBmcm9tICdAZmlyZWJhc2Uvd2ViY2hhbm5lbC13cmFwcGVyL2Jsb29tLWJsb2InO1xuaW1wb3J0ICogYXMgZ3JwYyBmcm9tICdAZ3JwYy9ncnBjLWpzJztcbmltcG9ydCAqIGFzIHByb3RvTG9hZGVyIGZyb20gJ0BncnBjL3Byb3RvLWxvYWRlcic7XG5cbmNvbnN0IG5hbWUgPSBcIkBmaXJlYmFzZS9maXJlc3RvcmVcIjtcbmNvbnN0IHZlcnNpb24kMSA9IFwiNC43LjVcIjtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogU2ltcGxlIHdyYXBwZXIgYXJvdW5kIGEgbnVsbGFibGUgVUlELiBNb3N0bHkgZXhpc3RzIHRvIG1ha2UgY29kZSBtb3JlXG4gKiByZWFkYWJsZS5cbiAqL1xuY2xhc3MgVXNlciB7XG4gICAgY29uc3RydWN0b3IodWlkKSB7XG4gICAgICAgIHRoaXMudWlkID0gdWlkO1xuICAgIH1cbiAgICBpc0F1dGhlbnRpY2F0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVpZCAhPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEga2V5IHJlcHJlc2VudGluZyB0aGlzIHVzZXIsIHN1aXRhYmxlIGZvciBpbmNsdXNpb24gaW4gYVxuICAgICAqIGRpY3Rpb25hcnkuXG4gICAgICovXG4gICAgdG9LZXkoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQXV0aGVudGljYXRlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3VpZDonICsgdGhpcy51aWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ2Fub255bW91cy11c2VyJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyVXNlcikge1xuICAgICAgICByZXR1cm4gb3RoZXJVc2VyLnVpZCA9PT0gdGhpcy51aWQ7XG4gICAgfVxufVxuLyoqIEEgdXNlciB3aXRoIGEgbnVsbCBVSUQuICovXG5Vc2VyLlVOQVVUSEVOVElDQVRFRCA9IG5ldyBVc2VyKG51bGwpO1xuLy8gVE9ETyhtaWtlbGVoZW4pOiBMb29rIGludG8gZ2V0dGluZyBhIHByb3BlciB1aWQtZXF1aXZhbGVudCBmb3Jcbi8vIG5vbi1GaXJlYmFzZUF1dGggcHJvdmlkZXJzLlxuVXNlci5HT09HTEVfQ1JFREVOVElBTFMgPSBuZXcgVXNlcignZ29vZ2xlLWNyZWRlbnRpYWxzLXVpZCcpO1xuVXNlci5GSVJTVF9QQVJUWSA9IG5ldyBVc2VyKCdmaXJzdC1wYXJ0eS11aWQnKTtcblVzZXIuTU9DS19VU0VSID0gbmV3IFVzZXIoJ21vY2stdXNlcicpO1xuXG5jb25zdCB2ZXJzaW9uID0gXCIxMS4wLjJcIjtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmxldCBTREtfVkVSU0lPTiA9IHZlcnNpb247XG5mdW5jdGlvbiBzZXRTREtWZXJzaW9uKHZlcnNpb24pIHtcbiAgICBTREtfVkVSU0lPTiA9IHZlcnNpb247XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogRm9ybWF0cyBhbiBvYmplY3QgYXMgYSBKU09OIHN0cmluZywgc3VpdGFibGUgZm9yIGxvZ2dpbmcuICovXG5mdW5jdGlvbiBmb3JtYXRKU09OKHZhbHVlKSB7XG4gICAgLy8gdXRpbC5pbnNwZWN0KCkgcmVzdWx0cyBpbiBtdWNoIG1vcmUgcmVhZGFibGUgb3V0cHV0IHRoYW4gSlNPTi5zdHJpbmdpZnkoKVxuICAgIHJldHVybiBpbnNwZWN0KHZhbHVlLCB7IGRlcHRoOiAxMDAgfSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBsb2dDbGllbnQgPSBuZXcgTG9nZ2VyKCdAZmlyZWJhc2UvZmlyZXN0b3JlJyk7XG4vLyBIZWxwZXIgbWV0aG9kcyBhcmUgbmVlZGVkIGJlY2F1c2UgdmFyaWFibGVzIGNhbid0IGJlIGV4cG9ydGVkIGFzIHJlYWQvd3JpdGVcbmZ1bmN0aW9uIGdldExvZ0xldmVsKCkge1xuICAgIHJldHVybiBsb2dDbGllbnQubG9nTGV2ZWw7XG59XG4vKipcbiAqIFNldHMgdGhlIHZlcmJvc2l0eSBvZiBDbG91ZCBGaXJlc3RvcmUgbG9ncyAoZGVidWcsIGVycm9yLCBvciBzaWxlbnQpLlxuICpcbiAqIEBwYXJhbSBsb2dMZXZlbCAtIFRoZSB2ZXJib3NpdHkgeW91IHNldCBmb3IgYWN0aXZpdHkgYW5kIGVycm9yIGxvZ2dpbmcuIENhblxuICogICBiZSBhbnkgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4gKlxuICogICA8dWw+XG4gKiAgICAgPGxpPmBkZWJ1Z2AgZm9yIHRoZSBtb3N0IHZlcmJvc2UgbG9nZ2luZyBsZXZlbCwgcHJpbWFyaWx5IGZvclxuICogICAgIGRlYnVnZ2luZy48L2xpPlxuICogICAgIDxsaT5gZXJyb3JgIHRvIGxvZyBlcnJvcnMgb25seS48L2xpPlxuICogICAgIDxsaT48Y29kZT5gc2lsZW50YCB0byB0dXJuIG9mZiBsb2dnaW5nLjwvbGk+XG4gKiAgIDwvdWw+XG4gKi9cbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxvZ0xldmVsKSB7XG4gICAgbG9nQ2xpZW50LnNldExvZ0xldmVsKGxvZ0xldmVsKTtcbn1cbmZ1bmN0aW9uIGxvZ0RlYnVnKG1zZywgLi4ub2JqKSB7XG4gICAgaWYgKGxvZ0NsaWVudC5sb2dMZXZlbCA8PSBMb2dMZXZlbC5ERUJVRykge1xuICAgICAgICBjb25zdCBhcmdzID0gb2JqLm1hcChhcmdUb1N0cmluZyk7XG4gICAgICAgIGxvZ0NsaWVudC5kZWJ1ZyhgRmlyZXN0b3JlICgke1NES19WRVJTSU9OfSk6ICR7bXNnfWAsIC4uLmFyZ3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxvZ0Vycm9yKG1zZywgLi4ub2JqKSB7XG4gICAgaWYgKGxvZ0NsaWVudC5sb2dMZXZlbCA8PSBMb2dMZXZlbC5FUlJPUikge1xuICAgICAgICBjb25zdCBhcmdzID0gb2JqLm1hcChhcmdUb1N0cmluZyk7XG4gICAgICAgIGxvZ0NsaWVudC5lcnJvcihgRmlyZXN0b3JlICgke1NES19WRVJTSU9OfSk6ICR7bXNnfWAsIC4uLmFyZ3MpO1xuICAgIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGxvZ1dhcm4obXNnLCAuLi5vYmopIHtcbiAgICBpZiAobG9nQ2xpZW50LmxvZ0xldmVsIDw9IExvZ0xldmVsLldBUk4pIHtcbiAgICAgICAgY29uc3QgYXJncyA9IG9iai5tYXAoYXJnVG9TdHJpbmcpO1xuICAgICAgICBsb2dDbGllbnQud2FybihgRmlyZXN0b3JlICgke1NES19WRVJTSU9OfSk6ICR7bXNnfWAsIC4uLmFyZ3MpO1xuICAgIH1cbn1cbi8qKlxuICogQ29udmVydHMgYW4gYWRkaXRpb25hbCBsb2cgcGFyYW1ldGVyIHRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICovXG5mdW5jdGlvbiBhcmdUb1N0cmluZyhvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0SlNPTihvYmopO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0aW5nIHRvIEpTT04gZmFpbGVkLCBqdXN0IGxvZyB0aGUgb2JqZWN0IGRpcmVjdGx5XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBVbmNvbmRpdGlvbmFsbHkgZmFpbHMsIHRocm93aW5nIGFuIEVycm9yIHdpdGggdGhlIGdpdmVuIG1lc3NhZ2UuXG4gKiBNZXNzYWdlcyBhcmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMuXG4gKlxuICogUmV0dXJucyBgbmV2ZXJgIGFuZCBjYW4gYmUgdXNlZCBpbiBleHByZXNzaW9uczpcbiAqIEBleGFtcGxlXG4gKiBsZXQgZnV0dXJlVmFyID0gZmFpbCgnbm90IGltcGxlbWVudGVkIHlldCcpO1xuICovXG5mdW5jdGlvbiBmYWlsKGZhaWx1cmUgPSAnVW5leHBlY3RlZCBzdGF0ZScpIHtcbiAgICAvLyBMb2cgdGhlIGZhaWx1cmUgaW4gYWRkaXRpb24gdG8gdGhyb3cgYW4gZXhjZXB0aW9uLCBqdXN0IGluIGNhc2UgdGhlXG4gICAgLy8gZXhjZXB0aW9uIGlzIHN3YWxsb3dlZC5cbiAgICBjb25zdCBtZXNzYWdlID0gYEZJUkVTVE9SRSAoJHtTREtfVkVSU0lPTn0pIElOVEVSTkFMIEFTU0VSVElPTiBGQUlMRUQ6IGAgKyBmYWlsdXJlO1xuICAgIGxvZ0Vycm9yKG1lc3NhZ2UpO1xuICAgIC8vIE5PVEU6IFdlIGRvbid0IHVzZSBGaXJlc3RvcmVFcnJvciBoZXJlIGJlY2F1c2UgdGhlc2UgYXJlIGludGVybmFsIGZhaWx1cmVzXG4gICAgLy8gdGhhdCBjYW5ub3QgYmUgaGFuZGxlZCBieSB0aGUgdXNlci4gKEFsc28gaXQgd291bGQgY3JlYXRlIGEgY2lyY3VsYXJcbiAgICAvLyBkZXBlbmRlbmN5IGJldHdlZW4gdGhlIGVycm9yIGFuZCBhc3NlcnQgbW9kdWxlcyB3aGljaCBkb2Vzbid0IHdvcmsuKVxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cbi8qKlxuICogRmFpbHMgaWYgdGhlIGdpdmVuIGFzc2VydGlvbiBjb25kaXRpb24gaXMgZmFsc2UsIHRocm93aW5nIGFuIEVycm9yIHdpdGggdGhlXG4gKiBnaXZlbiBtZXNzYWdlIGlmIGl0IGRpZC5cbiAqXG4gKiBNZXNzYWdlcyBhcmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMuXG4gKi9cbmZ1bmN0aW9uIGhhcmRBc3NlcnQoYXNzZXJ0aW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFhc3NlcnRpb24pIHtcbiAgICAgICAgZmFpbCgpO1xuICAgIH1cbn1cbi8qKlxuICogRmFpbHMgaWYgdGhlIGdpdmVuIGFzc2VydGlvbiBjb25kaXRpb24gaXMgZmFsc2UsIHRocm93aW5nIGFuIEVycm9yIHdpdGggdGhlXG4gKiBnaXZlbiBtZXNzYWdlIGlmIGl0IGRpZC5cbiAqXG4gKiBUaGUgY29kZSBvZiBjYWxsc2l0ZXMgaW52b2tpbmcgdGhpcyBmdW5jdGlvbiBhcmUgc3RyaXBwZWQgb3V0IGluIHByb2R1Y3Rpb25cbiAqIGJ1aWxkcy4gQW55IHNpZGUtZWZmZWN0cyBvZiBjb2RlIHdpdGhpbiB0aGUgZGVidWdBc3NlcnQoKSBpbnZvY2F0aW9uIHdpbGwgbm90XG4gKiBoYXBwZW4gaW4gdGhpcyBjYXNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBkZWJ1Z0Fzc2VydChhc3NlcnRpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWFzc2VydGlvbikge1xuICAgICAgICBmYWlsKCk7XG4gICAgfVxufVxuLyoqXG4gKiBDYXN0cyBgb2JqYCB0byBgVGAuIEluIG5vbi1wcm9kdWN0aW9uIGJ1aWxkcywgdmVyaWZpZXMgdGhhdCBgb2JqYCBpcyBhblxuICogaW5zdGFuY2Ugb2YgYFRgIGJlZm9yZSBjYXN0aW5nLlxuICovXG5mdW5jdGlvbiBkZWJ1Z0Nhc3Qob2JqLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBDb2RlID0ge1xuICAgIC8vIENhdXNlcyBhcmUgY29waWVkIGZyb206XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy9ibG9iL2JjZWVjOTRlYTRmYzVmMDA4NWQ4MTIzNWQ4ZTFjMDY3OThkYzM0MWEvaW5jbHVkZS9ncnBjJTJCJTJCL2ltcGwvY29kZWdlbi9zdGF0dXNfY29kZV9lbnVtLmhcbiAgICAvKiogTm90IGFuIGVycm9yOyByZXR1cm5lZCBvbiBzdWNjZXNzLiAqL1xuICAgIE9LOiAnb2snLFxuICAgIC8qKiBUaGUgb3BlcmF0aW9uIHdhcyBjYW5jZWxsZWQgKHR5cGljYWxseSBieSB0aGUgY2FsbGVyKS4gKi9cbiAgICBDQU5DRUxMRUQ6ICdjYW5jZWxsZWQnLFxuICAgIC8qKiBVbmtub3duIGVycm9yIG9yIGFuIGVycm9yIGZyb20gYSBkaWZmZXJlbnQgZXJyb3IgZG9tYWluLiAqL1xuICAgIFVOS05PV046ICd1bmtub3duJyxcbiAgICAvKipcbiAgICAgKiBDbGllbnQgc3BlY2lmaWVkIGFuIGludmFsaWQgYXJndW1lbnQuIE5vdGUgdGhhdCB0aGlzIGRpZmZlcnMgZnJvbVxuICAgICAqIEZBSUxFRF9QUkVDT05ESVRJT04uIElOVkFMSURfQVJHVU1FTlQgaW5kaWNhdGVzIGFyZ3VtZW50cyB0aGF0IGFyZVxuICAgICAqIHByb2JsZW1hdGljIHJlZ2FyZGxlc3Mgb2YgdGhlIHN0YXRlIG9mIHRoZSBzeXN0ZW0gKGUuZy4sIGEgbWFsZm9ybWVkIGZpbGVcbiAgICAgKiBuYW1lKS5cbiAgICAgKi9cbiAgICBJTlZBTElEX0FSR1VNRU5UOiAnaW52YWxpZC1hcmd1bWVudCcsXG4gICAgLyoqXG4gICAgICogRGVhZGxpbmUgZXhwaXJlZCBiZWZvcmUgb3BlcmF0aW9uIGNvdWxkIGNvbXBsZXRlLiBGb3Igb3BlcmF0aW9ucyB0aGF0XG4gICAgICogY2hhbmdlIHRoZSBzdGF0ZSBvZiB0aGUgc3lzdGVtLCB0aGlzIGVycm9yIG1heSBiZSByZXR1cm5lZCBldmVuIGlmIHRoZVxuICAgICAqIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS4gRm9yIGV4YW1wbGUsIGEgc3VjY2Vzc2Z1bCByZXNwb25zZVxuICAgICAqIGZyb20gYSBzZXJ2ZXIgY291bGQgaGF2ZSBiZWVuIGRlbGF5ZWQgbG9uZyBlbm91Z2ggZm9yIHRoZSBkZWFkbGluZSB0b1xuICAgICAqIGV4cGlyZS5cbiAgICAgKi9cbiAgICBERUFETElORV9FWENFRURFRDogJ2RlYWRsaW5lLWV4Y2VlZGVkJyxcbiAgICAvKiogU29tZSByZXF1ZXN0ZWQgZW50aXR5IChlLmcuLCBmaWxlIG9yIGRpcmVjdG9yeSkgd2FzIG5vdCBmb3VuZC4gKi9cbiAgICBOT1RfRk9VTkQ6ICdub3QtZm91bmQnLFxuICAgIC8qKlxuICAgICAqIFNvbWUgZW50aXR5IHRoYXQgd2UgYXR0ZW1wdGVkIHRvIGNyZWF0ZSAoZS5nLiwgZmlsZSBvciBkaXJlY3RvcnkpIGFscmVhZHlcbiAgICAgKiBleGlzdHMuXG4gICAgICovXG4gICAgQUxSRUFEWV9FWElTVFM6ICdhbHJlYWR5LWV4aXN0cycsXG4gICAgLyoqXG4gICAgICogVGhlIGNhbGxlciBkb2VzIG5vdCBoYXZlIHBlcm1pc3Npb24gdG8gZXhlY3V0ZSB0aGUgc3BlY2lmaWVkIG9wZXJhdGlvbi5cbiAgICAgKiBQRVJNSVNTSU9OX0RFTklFRCBtdXN0IG5vdCBiZSB1c2VkIGZvciByZWplY3Rpb25zIGNhdXNlZCBieSBleGhhdXN0aW5nXG4gICAgICogc29tZSByZXNvdXJjZSAodXNlIFJFU09VUkNFX0VYSEFVU1RFRCBpbnN0ZWFkIGZvciB0aG9zZSBlcnJvcnMpLlxuICAgICAqIFBFUk1JU1NJT05fREVOSUVEIG11c3Qgbm90IGJlIHVzZWQgaWYgdGhlIGNhbGxlciBjYW5ub3QgYmUgaWRlbnRpZmllZFxuICAgICAqICh1c2UgVU5BVVRIRU5USUNBVEVEIGluc3RlYWQgZm9yIHRob3NlIGVycm9ycykuXG4gICAgICovXG4gICAgUEVSTUlTU0lPTl9ERU5JRUQ6ICdwZXJtaXNzaW9uLWRlbmllZCcsXG4gICAgLyoqXG4gICAgICogVGhlIHJlcXVlc3QgZG9lcyBub3QgaGF2ZSB2YWxpZCBhdXRoZW50aWNhdGlvbiBjcmVkZW50aWFscyBmb3IgdGhlXG4gICAgICogb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIFVOQVVUSEVOVElDQVRFRDogJ3VuYXV0aGVudGljYXRlZCcsXG4gICAgLyoqXG4gICAgICogU29tZSByZXNvdXJjZSBoYXMgYmVlbiBleGhhdXN0ZWQsIHBlcmhhcHMgYSBwZXItdXNlciBxdW90YSwgb3IgcGVyaGFwcyB0aGVcbiAgICAgKiBlbnRpcmUgZmlsZSBzeXN0ZW0gaXMgb3V0IG9mIHNwYWNlLlxuICAgICAqL1xuICAgIFJFU09VUkNFX0VYSEFVU1RFRDogJ3Jlc291cmNlLWV4aGF1c3RlZCcsXG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9uIHdhcyByZWplY3RlZCBiZWNhdXNlIHRoZSBzeXN0ZW0gaXMgbm90IGluIGEgc3RhdGUgcmVxdWlyZWQgZm9yXG4gICAgICogdGhlIG9wZXJhdGlvbidzIGV4ZWN1dGlvbi4gRm9yIGV4YW1wbGUsIGRpcmVjdG9yeSB0byBiZSBkZWxldGVkIG1heSBiZVxuICAgICAqIG5vbi1lbXB0eSwgYW4gcm1kaXIgb3BlcmF0aW9uIGlzIGFwcGxpZWQgdG8gYSBub24tZGlyZWN0b3J5LCBldGMuXG4gICAgICpcbiAgICAgKiBBIGxpdG11cyB0ZXN0IHRoYXQgbWF5IGhlbHAgYSBzZXJ2aWNlIGltcGxlbWVudG9yIGluIGRlY2lkaW5nXG4gICAgICogYmV0d2VlbiBGQUlMRURfUFJFQ09ORElUSU9OLCBBQk9SVEVELCBhbmQgVU5BVkFJTEFCTEU6XG4gICAgICogIChhKSBVc2UgVU5BVkFJTEFCTEUgaWYgdGhlIGNsaWVudCBjYW4gcmV0cnkganVzdCB0aGUgZmFpbGluZyBjYWxsLlxuICAgICAqICAoYikgVXNlIEFCT1JURUQgaWYgdGhlIGNsaWVudCBzaG91bGQgcmV0cnkgYXQgYSBoaWdoZXItbGV2ZWxcbiAgICAgKiAgICAgIChlLmcuLCByZXN0YXJ0aW5nIGEgcmVhZC1tb2RpZnktd3JpdGUgc2VxdWVuY2UpLlxuICAgICAqICAoYykgVXNlIEZBSUxFRF9QUkVDT05ESVRJT04gaWYgdGhlIGNsaWVudCBzaG91bGQgbm90IHJldHJ5IHVudGlsXG4gICAgICogICAgICB0aGUgc3lzdGVtIHN0YXRlIGhhcyBiZWVuIGV4cGxpY2l0bHkgZml4ZWQuIEUuZy4sIGlmIGFuIFwicm1kaXJcIlxuICAgICAqICAgICAgZmFpbHMgYmVjYXVzZSB0aGUgZGlyZWN0b3J5IGlzIG5vbi1lbXB0eSwgRkFJTEVEX1BSRUNPTkRJVElPTlxuICAgICAqICAgICAgc2hvdWxkIGJlIHJldHVybmVkIHNpbmNlIHRoZSBjbGllbnQgc2hvdWxkIG5vdCByZXRyeSB1bmxlc3NcbiAgICAgKiAgICAgIHRoZXkgaGF2ZSBmaXJzdCBmaXhlZCB1cCB0aGUgZGlyZWN0b3J5IGJ5IGRlbGV0aW5nIGZpbGVzIGZyb20gaXQuXG4gICAgICogIChkKSBVc2UgRkFJTEVEX1BSRUNPTkRJVElPTiBpZiB0aGUgY2xpZW50IHBlcmZvcm1zIGNvbmRpdGlvbmFsXG4gICAgICogICAgICBSRVNUIEdldC9VcGRhdGUvRGVsZXRlIG9uIGEgcmVzb3VyY2UgYW5kIHRoZSByZXNvdXJjZSBvbiB0aGVcbiAgICAgKiAgICAgIHNlcnZlciBkb2VzIG5vdCBtYXRjaCB0aGUgY29uZGl0aW9uLiBFLmcuLCBjb25mbGljdGluZ1xuICAgICAqICAgICAgcmVhZC1tb2RpZnktd3JpdGUgb24gdGhlIHNhbWUgcmVzb3VyY2UuXG4gICAgICovXG4gICAgRkFJTEVEX1BSRUNPTkRJVElPTjogJ2ZhaWxlZC1wcmVjb25kaXRpb24nLFxuICAgIC8qKlxuICAgICAqIFRoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQsIHR5cGljYWxseSBkdWUgdG8gYSBjb25jdXJyZW5jeSBpc3N1ZSBsaWtlXG4gICAgICogc2VxdWVuY2VyIGNoZWNrIGZhaWx1cmVzLCB0cmFuc2FjdGlvbiBhYm9ydHMsIGV0Yy5cbiAgICAgKlxuICAgICAqIFNlZSBsaXRtdXMgdGVzdCBhYm92ZSBmb3IgZGVjaWRpbmcgYmV0d2VlbiBGQUlMRURfUFJFQ09ORElUSU9OLCBBQk9SVEVELFxuICAgICAqIGFuZCBVTkFWQUlMQUJMRS5cbiAgICAgKi9cbiAgICBBQk9SVEVEOiAnYWJvcnRlZCcsXG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9uIHdhcyBhdHRlbXB0ZWQgcGFzdCB0aGUgdmFsaWQgcmFuZ2UuIEUuZy4sIHNlZWtpbmcgb3IgcmVhZGluZ1xuICAgICAqIHBhc3QgZW5kIG9mIGZpbGUuXG4gICAgICpcbiAgICAgKiBVbmxpa2UgSU5WQUxJRF9BUkdVTUVOVCwgdGhpcyBlcnJvciBpbmRpY2F0ZXMgYSBwcm9ibGVtIHRoYXQgbWF5IGJlIGZpeGVkXG4gICAgICogaWYgdGhlIHN5c3RlbSBzdGF0ZSBjaGFuZ2VzLiBGb3IgZXhhbXBsZSwgYSAzMi1iaXQgZmlsZSBzeXN0ZW0gd2lsbFxuICAgICAqIGdlbmVyYXRlIElOVkFMSURfQVJHVU1FTlQgaWYgYXNrZWQgdG8gcmVhZCBhdCBhbiBvZmZzZXQgdGhhdCBpcyBub3QgaW4gdGhlXG4gICAgICogcmFuZ2UgWzAsMl4zMi0xXSwgYnV0IGl0IHdpbGwgZ2VuZXJhdGUgT1VUX09GX1JBTkdFIGlmIGFza2VkIHRvIHJlYWQgZnJvbVxuICAgICAqIGFuIG9mZnNldCBwYXN0IHRoZSBjdXJyZW50IGZpbGUgc2l6ZS5cbiAgICAgKlxuICAgICAqIFRoZXJlIGlzIGEgZmFpciBiaXQgb2Ygb3ZlcmxhcCBiZXR3ZWVuIEZBSUxFRF9QUkVDT05ESVRJT04gYW5kXG4gICAgICogT1VUX09GX1JBTkdFLiBXZSByZWNvbW1lbmQgdXNpbmcgT1VUX09GX1JBTkdFICh0aGUgbW9yZSBzcGVjaWZpYyBlcnJvcilcbiAgICAgKiB3aGVuIGl0IGFwcGxpZXMgc28gdGhhdCBjYWxsZXJzIHdobyBhcmUgaXRlcmF0aW5nIHRocm91Z2ggYSBzcGFjZSBjYW5cbiAgICAgKiBlYXNpbHkgbG9vayBmb3IgYW4gT1VUX09GX1JBTkdFIGVycm9yIHRvIGRldGVjdCB3aGVuIHRoZXkgYXJlIGRvbmUuXG4gICAgICovXG4gICAgT1VUX09GX1JBTkdFOiAnb3V0LW9mLXJhbmdlJyxcbiAgICAvKiogT3BlcmF0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBvciBub3Qgc3VwcG9ydGVkL2VuYWJsZWQgaW4gdGhpcyBzZXJ2aWNlLiAqL1xuICAgIFVOSU1QTEVNRU5URUQ6ICd1bmltcGxlbWVudGVkJyxcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBlcnJvcnMuIE1lYW5zIHNvbWUgaW52YXJpYW50cyBleHBlY3RlZCBieSB1bmRlcmx5aW5nIFN5c3RlbSBoYXNcbiAgICAgKiBiZWVuIGJyb2tlbi4gSWYgeW91IHNlZSBvbmUgb2YgdGhlc2UgZXJyb3JzLCBTb21ldGhpbmcgaXMgdmVyeSBicm9rZW4uXG4gICAgICovXG4gICAgSU5URVJOQUw6ICdpbnRlcm5hbCcsXG4gICAgLyoqXG4gICAgICogVGhlIHNlcnZpY2UgaXMgY3VycmVudGx5IHVuYXZhaWxhYmxlLiBUaGlzIGlzIGEgbW9zdCBsaWtlbHkgYSB0cmFuc2llbnRcbiAgICAgKiBjb25kaXRpb24gYW5kIG1heSBiZSBjb3JyZWN0ZWQgYnkgcmV0cnlpbmcgd2l0aCBhIGJhY2tvZmYuXG4gICAgICpcbiAgICAgKiBTZWUgbGl0bXVzIHRlc3QgYWJvdmUgZm9yIGRlY2lkaW5nIGJldHdlZW4gRkFJTEVEX1BSRUNPTkRJVElPTiwgQUJPUlRFRCxcbiAgICAgKiBhbmQgVU5BVkFJTEFCTEUuXG4gICAgICovXG4gICAgVU5BVkFJTEFCTEU6ICd1bmF2YWlsYWJsZScsXG4gICAgLyoqIFVucmVjb3ZlcmFibGUgZGF0YSBsb3NzIG9yIGNvcnJ1cHRpb24uICovXG4gICAgREFUQV9MT1NTOiAnZGF0YS1sb3NzJ1xufTtcbi8qKiBBbiBlcnJvciByZXR1cm5lZCBieSBhIEZpcmVzdG9yZSBvcGVyYXRpb24uICovXG5jbGFzcyBGaXJlc3RvcmVFcnJvciBleHRlbmRzIEZpcmViYXNlRXJyb3Ige1xuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogVGhlIGJhY2tlbmQgZXJyb3IgY29kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBlcnJvci5cbiAgICAgKi9cbiAgICBjb2RlLCBcbiAgICAvKipcbiAgICAgKiBBIGN1c3RvbSBlcnJvciBkZXNjcmlwdGlvbi5cbiAgICAgKi9cbiAgICBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKGNvZGUsIG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAvLyBIQUNLOiBXZSB3cml0ZSBhIHRvU3RyaW5nIHByb3BlcnR5IGRpcmVjdGx5IGJlY2F1c2UgRXJyb3IgaXMgbm90IGEgcmVhbFxuICAgICAgICAvLyBjbGFzcyBhbmQgc28gaW5oZXJpdGFuY2UgZG9lcyBub3Qgd29yayBjb3JyZWN0bHkuIFdlIGNvdWxkIGFsdGVybmF0aXZlbHlcbiAgICAgICAgLy8gZG8gdGhlIHNhbWUgXCJiYWNrLWRvb3IgaW5oZXJpdGFuY2VcIiB0cmljayB0aGF0IEZpcmViYXNlRXJyb3IgZG9lcy5cbiAgICAgICAgdGhpcy50b1N0cmluZyA9ICgpID0+IGAke3RoaXMubmFtZX06IFtjb2RlPSR7dGhpcy5jb2RlfV06ICR7dGhpcy5tZXNzYWdlfWA7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgRGVmZXJyZWQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIE9BdXRoVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCB1c2VyKSB7XG4gICAgICAgIHRoaXMudXNlciA9IHVzZXI7XG4gICAgICAgIHRoaXMudHlwZSA9ICdPQXV0aCc7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsIGBCZWFyZXIgJHt2YWx1ZX1gKTtcbiAgICB9XG59XG4vKipcbiAqIEEgQ3JlZGVudGlhbHNQcm92aWRlciB0aGF0IGFsd2F5cyB5aWVsZHMgYW4gZW1wdHkgdG9rZW4uXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgRW1wdHlBdXRoQ3JlZGVudGlhbHNQcm92aWRlciB7XG4gICAgZ2V0VG9rZW4oKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgfVxuICAgIGludmFsaWRhdGVUb2tlbigpIHsgfVxuICAgIHN0YXJ0KGFzeW5jUXVldWUsIGNoYW5nZUxpc3RlbmVyKSB7XG4gICAgICAgIC8vIEZpcmUgd2l0aCBpbml0aWFsIHVzZXIuXG4gICAgICAgIGFzeW5jUXVldWUuZW5xdWV1ZVJldHJ5YWJsZSgoKSA9PiBjaGFuZ2VMaXN0ZW5lcihVc2VyLlVOQVVUSEVOVElDQVRFRCkpO1xuICAgIH1cbiAgICBzaHV0ZG93bigpIHsgfVxufVxuLyoqXG4gKiBBIENyZWRlbnRpYWxzUHJvdmlkZXIgdGhhdCBhbHdheXMgcmV0dXJucyBhIGNvbnN0YW50IHRva2VuLiBVc2VkIGZvclxuICogZW11bGF0b3IgdG9rZW4gbW9ja2luZy5cbiAqL1xuY2xhc3MgRW11bGF0b3JBdXRoQ3JlZGVudGlhbHNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IodG9rZW4pIHtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcmVzIHRoZSBsaXN0ZW5lciByZWdpc3RlcmVkIHdpdGggc2V0Q2hhbmdlTGlzdGVuZXIoKVxuICAgICAgICAgKiBUaGlzIGlzbid0IGFjdHVhbGx5IG5lY2Vzc2FyeSBzaW5jZSB0aGUgVUlEIG5ldmVyIGNoYW5nZXMsIGJ1dCB3ZSB1c2UgdGhpc1xuICAgICAgICAgKiB0byB2ZXJpZnkgdGhlIGxpc3RlbiBjb250cmFjdCBpcyBhZGhlcmVkIHRvIGluIHRlc3RzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFuZ2VMaXN0ZW5lciA9IG51bGw7XG4gICAgfVxuICAgIGdldFRva2VuKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMudG9rZW4pO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlVG9rZW4oKSB7IH1cbiAgICBzdGFydChhc3luY1F1ZXVlLCBjaGFuZ2VMaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmNoYW5nZUxpc3RlbmVyID0gY2hhbmdlTGlzdGVuZXI7XG4gICAgICAgIC8vIEZpcmUgd2l0aCBpbml0aWFsIHVzZXIuXG4gICAgICAgIGFzeW5jUXVldWUuZW5xdWV1ZVJldHJ5YWJsZSgoKSA9PiBjaGFuZ2VMaXN0ZW5lcih0aGlzLnRva2VuLnVzZXIpKTtcbiAgICB9XG4gICAgc2h1dGRvd24oKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlTGlzdGVuZXIgPSBudWxsO1xuICAgIH1cbn1cbmNsYXNzIEZpcmViYXNlQXV0aENyZWRlbnRpYWxzUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKGF1dGhQcm92aWRlcikge1xuICAgICAgICB0aGlzLmF1dGhQcm92aWRlciA9IGF1dGhQcm92aWRlcjtcbiAgICAgICAgLyoqIFRyYWNrcyB0aGUgY3VycmVudCBVc2VyLiAqL1xuICAgICAgICB0aGlzLmN1cnJlbnRVc2VyID0gVXNlci5VTkFVVEhFTlRJQ0FURUQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb3VudGVyIHVzZWQgdG8gZGV0ZWN0IGlmIHRoZSB0b2tlbiBjaGFuZ2VkIHdoaWxlIGEgZ2V0VG9rZW4gcmVxdWVzdCB3YXNcbiAgICAgICAgICogb3V0c3RhbmRpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRva2VuQ291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuZm9yY2VSZWZyZXNoID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXV0aCA9IG51bGw7XG4gICAgfVxuICAgIHN0YXJ0KGFzeW5jUXVldWUsIGNoYW5nZUxpc3RlbmVyKSB7XG4gICAgICAgIGhhcmRBc3NlcnQodGhpcy50b2tlbkxpc3RlbmVyID09PSB1bmRlZmluZWQpO1xuICAgICAgICBsZXQgbGFzdFRva2VuSWQgPSB0aGlzLnRva2VuQ291bnRlcjtcbiAgICAgICAgLy8gQSBjaGFuZ2UgbGlzdGVuZXIgdGhhdCBwcmV2ZW50cyBkb3VibGUtZmlyaW5nIGZvciB0aGUgc2FtZSB0b2tlbiBjaGFuZ2UuXG4gICAgICAgIGNvbnN0IGd1YXJkZWRDaGFuZ2VMaXN0ZW5lciA9IHVzZXIgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMudG9rZW5Db3VudGVyICE9PSBsYXN0VG9rZW5JZCkge1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbklkID0gdGhpcy50b2tlbkNvdW50ZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5nZUxpc3RlbmVyKHVzZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBBIHByb21pc2UgdGhhdCBjYW4gYmUgd2FpdGVkIG9uIHRvIGJsb2NrIG9uIHRoZSBuZXh0IHRva2VuIGNoYW5nZS5cbiAgICAgICAgLy8gVGhpcyBwcm9taXNlIGlzIHJlLWNyZWF0ZWQgYWZ0ZXIgZWFjaCBjaGFuZ2UuXG4gICAgICAgIGxldCBuZXh0VG9rZW4gPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy50b2tlbkxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50b2tlbkNvdW50ZXIrKztcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFVzZXIgPSB0aGlzLmdldFVzZXIoKTtcbiAgICAgICAgICAgIG5leHRUb2tlbi5yZXNvbHZlKCk7XG4gICAgICAgICAgICBuZXh0VG9rZW4gPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgICAgIGFzeW5jUXVldWUuZW5xdWV1ZVJldHJ5YWJsZSgoKSA9PiBndWFyZGVkQ2hhbmdlTGlzdGVuZXIodGhpcy5jdXJyZW50VXNlcikpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhd2FpdE5leHRUb2tlbiA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUb2tlbkF0dGVtcHQgPSBuZXh0VG9rZW47XG4gICAgICAgICAgICBhc3luY1F1ZXVlLmVucXVldWVSZXRyeWFibGUoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IGN1cnJlbnRUb2tlbkF0dGVtcHQucHJvbWlzZTtcbiAgICAgICAgICAgICAgICBhd2FpdCBndWFyZGVkQ2hhbmdlTGlzdGVuZXIodGhpcy5jdXJyZW50VXNlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJBdXRoID0gKGF1dGgpID0+IHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKCdGaXJlYmFzZUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyJywgJ0F1dGggZGV0ZWN0ZWQnKTtcbiAgICAgICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgICAgICAgICBpZiAodGhpcy50b2tlbkxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRoLmFkZEF1dGhUb2tlbkxpc3RlbmVyKHRoaXMudG9rZW5MaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgYXdhaXROZXh0VG9rZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hdXRoUHJvdmlkZXIub25Jbml0KGF1dGggPT4gcmVnaXN0ZXJBdXRoKGF1dGgpKTtcbiAgICAgICAgLy8gT3VyIHVzZXJzIGNhbiBpbml0aWFsaXplIEF1dGggcmlnaHQgYWZ0ZXIgRmlyZXN0b3JlLCBzbyB3ZSBnaXZlIGl0XG4gICAgICAgIC8vIGEgY2hhbmNlIHRvIHJlZ2lzdGVyIGl0c2VsZiB3aXRoIHRoZSBjb21wb25lbnQgZnJhbWV3b3JrIGJlZm9yZSB3ZVxuICAgICAgICAvLyBkZXRlcm1pbmUgd2hldGhlciB0byBzdGFydCB1cCBpbiB1bmF1dGhlbnRpY2F0ZWQgbW9kZS5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYXV0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF1dGggPSB0aGlzLmF1dGhQcm92aWRlci5nZXRJbW1lZGlhdGUoeyBvcHRpb25hbDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAoYXV0aCkge1xuICAgICAgICAgICAgICAgICAgICByZWdpc3RlckF1dGgoYXV0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhdXRoIGlzIHN0aWxsIG5vdCBhdmFpbGFibGUsIHByb2NlZWQgd2l0aCBgbnVsbGAgdXNlclxuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnRmlyZWJhc2VBdXRoQ3JlZGVudGlhbHNQcm92aWRlcicsICdBdXRoIG5vdCB5ZXQgZGV0ZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRva2VuLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRva2VuID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICAgICAgYXdhaXROZXh0VG9rZW4oKTtcbiAgICB9XG4gICAgZ2V0VG9rZW4oKSB7XG4gICAgICAgIC8vIFRha2Ugbm90ZSBvZiB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgdG9rZW5Db3VudGVyIHNvIHRoYXQgdGhpcyBtZXRob2RcbiAgICAgICAgLy8gY2FuIGZhaWwgKHdpdGggYW4gQUJPUlRFRCBlcnJvcikgaWYgdGhlcmUgaXMgYSB0b2tlbiBjaGFuZ2Ugd2hpbGUgdGhlXG4gICAgICAgIC8vIHJlcXVlc3QgaXMgb3V0c3RhbmRpbmcuXG4gICAgICAgIGNvbnN0IGluaXRpYWxUb2tlbkNvdW50ZXIgPSB0aGlzLnRva2VuQ291bnRlcjtcbiAgICAgICAgY29uc3QgZm9yY2VSZWZyZXNoID0gdGhpcy5mb3JjZVJlZnJlc2g7XG4gICAgICAgIHRoaXMuZm9yY2VSZWZyZXNoID0gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5hdXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmF1dGguZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKS50aGVuKHRva2VuRGF0YSA9PiB7XG4gICAgICAgICAgICAvLyBDYW5jZWwgdGhlIHJlcXVlc3Qgc2luY2UgdGhlIHRva2VuIGNoYW5nZWQgd2hpbGUgdGhlIHJlcXVlc3Qgd2FzXG4gICAgICAgICAgICAvLyBvdXRzdGFuZGluZyBzbyB0aGUgcmVzcG9uc2UgaXMgcG90ZW50aWFsbHkgZm9yIGEgcHJldmlvdXMgdXNlciAod2hpY2hcbiAgICAgICAgICAgIC8vIHVzZXIsIHdlIGNhbid0IGJlIHN1cmUpLlxuICAgICAgICAgICAgaWYgKHRoaXMudG9rZW5Db3VudGVyICE9PSBpbml0aWFsVG9rZW5Db3VudGVyKSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ0ZpcmViYXNlQXV0aENyZWRlbnRpYWxzUHJvdmlkZXInLCAnZ2V0VG9rZW4gYWJvcnRlZCBkdWUgdG8gdG9rZW4gY2hhbmdlLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRva2VuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQodHlwZW9mIHRva2VuRGF0YS5hY2Nlc3NUb2tlbiA9PT0gJ3N0cmluZycpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE9BdXRoVG9rZW4odG9rZW5EYXRhLmFjY2Vzc1Rva2VuLCB0aGlzLmN1cnJlbnRVc2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGludmFsaWRhdGVUb2tlbigpIHtcbiAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2ggPSB0cnVlO1xuICAgIH1cbiAgICBzaHV0ZG93bigpIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0aCAmJiB0aGlzLnRva2VuTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0aC5yZW1vdmVBdXRoVG9rZW5MaXN0ZW5lcih0aGlzLnRva2VuTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9rZW5MaXN0ZW5lciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gQXV0aC5nZXRVaWQoKSBjYW4gcmV0dXJuIG51bGwgZXZlbiB3aXRoIGEgdXNlciBsb2dnZWQgaW4uIEl0IGlzIGJlY2F1c2VcbiAgICAvLyBnZXRVaWQoKSBpcyBzeW5jaHJvbm91cywgYnV0IHRoZSBhdXRoIGNvZGUgcG9wdWxhdGluZyBVaWQgaXMgYXN5bmNocm9ub3VzLlxuICAgIC8vIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBpbiB0aGUgQXV0aFRva2VuTGlzdGVuZXIgY2FsbGJhY2tcbiAgICAvLyB0byBndWFyYW50ZWUgdG8gZ2V0IHRoZSBhY3R1YWwgdXNlci5cbiAgICBnZXRVc2VyKCkge1xuICAgICAgICBjb25zdCBjdXJyZW50VWlkID0gdGhpcy5hdXRoICYmIHRoaXMuYXV0aC5nZXRVaWQoKTtcbiAgICAgICAgaGFyZEFzc2VydChjdXJyZW50VWlkID09PSBudWxsIHx8IHR5cGVvZiBjdXJyZW50VWlkID09PSAnc3RyaW5nJyk7XG4gICAgICAgIHJldHVybiBuZXcgVXNlcihjdXJyZW50VWlkKTtcbiAgICB9XG59XG4vKlxuICogRmlyc3RQYXJ0eVRva2VuIHByb3ZpZGVzIGEgZnJlc2ggdG9rZW4gZWFjaCB0aW1lIGl0cyB2YWx1ZVxuICogaXMgcmVxdWVzdGVkLCBiZWNhdXNlIGlmIHRoZSB0b2tlbiBpcyB0b28gb2xkLCByZXF1ZXN0cyB3aWxsIGJlIHJlamVjdGVkLlxuICogVGVjaG5pY2FsbHkgdGhpcyBtYXkgbm8gbG9uZ2VyIGJlIG5lY2Vzc2FyeSBzaW5jZSB0aGUgU0RLIHNob3VsZCBncmFjZWZ1bGx5XG4gKiByZWNvdmVyIGZyb20gdW5hdXRoZW50aWNhdGVkIGVycm9ycyAoc2VlIGIvMzMxNDc4MTggZm9yIGNvbnRleHQpLCBidXQgaXQnc1xuICogc2FmZXIgdG8ga2VlcCB0aGUgaW1wbGVtZW50YXRpb24gYXMtaXMuXG4gKi9cbmNsYXNzIEZpcnN0UGFydHlUb2tlbiB7XG4gICAgY29uc3RydWN0b3Ioc2Vzc2lvbkluZGV4LCBpYW1Ub2tlbiwgYXV0aFRva2VuRmFjdG9yeSkge1xuICAgICAgICB0aGlzLnNlc3Npb25JbmRleCA9IHNlc3Npb25JbmRleDtcbiAgICAgICAgdGhpcy5pYW1Ub2tlbiA9IGlhbVRva2VuO1xuICAgICAgICB0aGlzLmF1dGhUb2tlbkZhY3RvcnkgPSBhdXRoVG9rZW5GYWN0b3J5O1xuICAgICAgICB0aGlzLnR5cGUgPSAnRmlyc3RQYXJ0eSc7XG4gICAgICAgIHRoaXMudXNlciA9IFVzZXIuRklSU1RfUEFSVFk7XG4gICAgICAgIHRoaXMuX2hlYWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYW4gYXV0aG9yaXphdGlvbiB0b2tlbiwgdXNpbmcgYSBwcm92aWRlZCBmYWN0b3J5IGZ1bmN0aW9uLCBvciByZXR1cm5cbiAgICAgKiBudWxsLlxuICAgICAqL1xuICAgIGdldEF1dGhUb2tlbigpIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0aFRva2VuRmFjdG9yeSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXV0aFRva2VuRmFjdG9yeSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGhlYWRlcnMoKSB7XG4gICAgICAgIHRoaXMuX2hlYWRlcnMuc2V0KCdYLUdvb2ctQXV0aFVzZXInLCB0aGlzLnNlc3Npb25JbmRleCk7XG4gICAgICAgIC8vIFVzZSBhcnJheSBub3RhdGlvbiB0byBwcmV2ZW50IG1pbmlmaWNhdGlvblxuICAgICAgICBjb25zdCBhdXRoSGVhZGVyVG9rZW5WYWx1ZSA9IHRoaXMuZ2V0QXV0aFRva2VuKCk7XG4gICAgICAgIGlmIChhdXRoSGVhZGVyVG9rZW5WYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5faGVhZGVycy5zZXQoJ0F1dGhvcml6YXRpb24nLCBhdXRoSGVhZGVyVG9rZW5WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaWFtVG9rZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlcnMuc2V0KCdYLUdvb2ctSWFtLUF1dGhvcml6YXRpb24tVG9rZW4nLCB0aGlzLmlhbVRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVycztcbiAgICB9XG59XG4vKlxuICogUHJvdmlkZXMgdXNlciBjcmVkZW50aWFscyByZXF1aXJlZCBmb3IgdGhlIEZpcmVzdG9yZSBKYXZhU2NyaXB0IFNES1xuICogdG8gYXV0aGVudGljYXRlIHRoZSB1c2VyLCB1c2luZyB0ZWNobmlxdWUgdGhhdCBpcyBvbmx5IGF2YWlsYWJsZVxuICogdG8gYXBwbGljYXRpb25zIGhvc3RlZCBieSBHb29nbGUuXG4gKi9cbmNsYXNzIEZpcnN0UGFydHlBdXRoQ3JlZGVudGlhbHNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3Ioc2Vzc2lvbkluZGV4LCBpYW1Ub2tlbiwgYXV0aFRva2VuRmFjdG9yeSkge1xuICAgICAgICB0aGlzLnNlc3Npb25JbmRleCA9IHNlc3Npb25JbmRleDtcbiAgICAgICAgdGhpcy5pYW1Ub2tlbiA9IGlhbVRva2VuO1xuICAgICAgICB0aGlzLmF1dGhUb2tlbkZhY3RvcnkgPSBhdXRoVG9rZW5GYWN0b3J5O1xuICAgIH1cbiAgICBnZXRUb2tlbigpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgRmlyc3RQYXJ0eVRva2VuKHRoaXMuc2Vzc2lvbkluZGV4LCB0aGlzLmlhbVRva2VuLCB0aGlzLmF1dGhUb2tlbkZhY3RvcnkpKTtcbiAgICB9XG4gICAgc3RhcnQoYXN5bmNRdWV1ZSwgY2hhbmdlTGlzdGVuZXIpIHtcbiAgICAgICAgLy8gRmlyZSB3aXRoIGluaXRpYWwgdWlkLlxuICAgICAgICBhc3luY1F1ZXVlLmVucXVldWVSZXRyeWFibGUoKCkgPT4gY2hhbmdlTGlzdGVuZXIoVXNlci5GSVJTVF9QQVJUWSkpO1xuICAgIH1cbiAgICBzaHV0ZG93bigpIHsgfVxuICAgIGludmFsaWRhdGVUb2tlbigpIHsgfVxufVxuY2xhc3MgQXBwQ2hlY2tUb2tlbiB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnR5cGUgPSAnQXBwQ2hlY2snO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCd4LWZpcmViYXNlLWFwcGNoZWNrJywgdGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBGaXJlYmFzZUFwcENoZWNrVG9rZW5Qcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoYXBwQ2hlY2tQcm92aWRlcikge1xuICAgICAgICB0aGlzLmFwcENoZWNrUHJvdmlkZXIgPSBhcHBDaGVja1Byb3ZpZGVyO1xuICAgICAgICB0aGlzLmZvcmNlUmVmcmVzaCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFwcENoZWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXRlc3RBcHBDaGVja1Rva2VuID0gbnVsbDtcbiAgICB9XG4gICAgc3RhcnQoYXN5bmNRdWV1ZSwgY2hhbmdlTGlzdGVuZXIpIHtcbiAgICAgICAgaGFyZEFzc2VydCh0aGlzLnRva2VuTGlzdGVuZXIgPT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbnN0IG9uVG9rZW5DaGFuZ2VkID0gdG9rZW5SZXN1bHQgPT4ge1xuICAgICAgICAgICAgaWYgKHRva2VuUmVzdWx0LmVycm9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnRmlyZWJhc2VBcHBDaGVja1Rva2VuUHJvdmlkZXInLCBgRXJyb3IgZ2V0dGluZyBBcHAgQ2hlY2sgdG9rZW47IHVzaW5nIHBsYWNlaG9sZGVyIHRva2VuIGluc3RlYWQuIEVycm9yOiAke3Rva2VuUmVzdWx0LmVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0b2tlblVwZGF0ZWQgPSB0b2tlblJlc3VsdC50b2tlbiAhPT0gdGhpcy5sYXRlc3RBcHBDaGVja1Rva2VuO1xuICAgICAgICAgICAgdGhpcy5sYXRlc3RBcHBDaGVja1Rva2VuID0gdG9rZW5SZXN1bHQudG9rZW47XG4gICAgICAgICAgICBsb2dEZWJ1ZygnRmlyZWJhc2VBcHBDaGVja1Rva2VuUHJvdmlkZXInLCBgUmVjZWl2ZWQgJHt0b2tlblVwZGF0ZWQgPyAnbmV3JyA6ICdleGlzdGluZyd9IHRva2VuLmApO1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuVXBkYXRlZFxuICAgICAgICAgICAgICAgID8gY2hhbmdlTGlzdGVuZXIodG9rZW5SZXN1bHQudG9rZW4pXG4gICAgICAgICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50b2tlbkxpc3RlbmVyID0gKHRva2VuUmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBhc3luY1F1ZXVlLmVucXVldWVSZXRyeWFibGUoKCkgPT4gb25Ub2tlbkNoYW5nZWQodG9rZW5SZXN1bHQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJBcHBDaGVjayA9IChhcHBDaGVjaykgPT4ge1xuICAgICAgICAgICAgbG9nRGVidWcoJ0ZpcmViYXNlQXBwQ2hlY2tUb2tlblByb3ZpZGVyJywgJ0FwcENoZWNrIGRldGVjdGVkJyk7XG4gICAgICAgICAgICB0aGlzLmFwcENoZWNrID0gYXBwQ2hlY2s7XG4gICAgICAgICAgICBpZiAodGhpcy50b2tlbkxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBDaGVjay5hZGRUb2tlbkxpc3RlbmVyKHRoaXMudG9rZW5MaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYXBwQ2hlY2tQcm92aWRlci5vbkluaXQoYXBwQ2hlY2sgPT4gcmVnaXN0ZXJBcHBDaGVjayhhcHBDaGVjaykpO1xuICAgICAgICAvLyBPdXIgdXNlcnMgY2FuIGluaXRpYWxpemUgQXBwQ2hlY2sgYWZ0ZXIgRmlyZXN0b3JlLCBzbyB3ZSBnaXZlIGl0XG4gICAgICAgIC8vIGEgY2hhbmNlIHRvIHJlZ2lzdGVyIGl0c2VsZiB3aXRoIHRoZSBjb21wb25lbnQgZnJhbWV3b3JrLlxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hcHBDaGVjaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFwcENoZWNrID0gdGhpcy5hcHBDaGVja1Byb3ZpZGVyLmdldEltbWVkaWF0ZSh7IG9wdGlvbmFsOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGlmIChhcHBDaGVjaykge1xuICAgICAgICAgICAgICAgICAgICByZWdpc3RlckFwcENoZWNrKGFwcENoZWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIEFwcENoZWNrIGlzIHN0aWxsIG5vdCBhdmFpbGFibGUsIHByb2NlZWQgd2l0aG91dCBpdC5cbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoJ0ZpcmViYXNlQXBwQ2hlY2tUb2tlblByb3ZpZGVyJywgJ0FwcENoZWNrIG5vdCB5ZXQgZGV0ZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgIH1cbiAgICBnZXRUb2tlbigpIHtcbiAgICAgICAgY29uc3QgZm9yY2VSZWZyZXNoID0gdGhpcy5mb3JjZVJlZnJlc2g7XG4gICAgICAgIHRoaXMuZm9yY2VSZWZyZXNoID0gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5hcHBDaGVjaykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hcHBDaGVjay5nZXRUb2tlbihmb3JjZVJlZnJlc2gpLnRoZW4odG9rZW5SZXN1bHQgPT4ge1xuICAgICAgICAgICAgaWYgKHRva2VuUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaGFyZEFzc2VydCh0eXBlb2YgdG9rZW5SZXN1bHQudG9rZW4gPT09ICdzdHJpbmcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdEFwcENoZWNrVG9rZW4gPSB0b2tlblJlc3VsdC50b2tlbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFwcENoZWNrVG9rZW4odG9rZW5SZXN1bHQudG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlVG9rZW4oKSB7XG4gICAgICAgIHRoaXMuZm9yY2VSZWZyZXNoID0gdHJ1ZTtcbiAgICB9XG4gICAgc2h1dGRvd24oKSB7XG4gICAgICAgIGlmICh0aGlzLmFwcENoZWNrICYmIHRoaXMudG9rZW5MaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5hcHBDaGVjay5yZW1vdmVUb2tlbkxpc3RlbmVyKHRoaXMudG9rZW5MaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b2tlbkxpc3RlbmVyID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKlxuICogQW4gQXBwQ2hlY2sgdG9rZW4gcHJvdmlkZXIgdGhhdCBhbHdheXMgeWllbGRzIGFuIGVtcHR5IHRva2VuLlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIEVtcHR5QXBwQ2hlY2tUb2tlblByb3ZpZGVyIHtcbiAgICBnZXRUb2tlbigpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQXBwQ2hlY2tUb2tlbignJykpO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlVG9rZW4oKSB7IH1cbiAgICBzdGFydChhc3luY1F1ZXVlLCBjaGFuZ2VMaXN0ZW5lcikgeyB9XG4gICAgc2h1dGRvd24oKSB7IH1cbn1cbi8qKlxuICogQnVpbGRzIGEgQ3JlZGVudGlhbHNQcm92aWRlciBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2ZcbiAqIHRoZSBjcmVkZW50aWFscyBwYXNzZWQgaW4uXG4gKi9cbmZ1bmN0aW9uIG1ha2VBdXRoQ3JlZGVudGlhbHNQcm92aWRlcihjcmVkZW50aWFscykge1xuICAgIGlmICghY3JlZGVudGlhbHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyKCk7XG4gICAgfVxuICAgIHN3aXRjaCAoY3JlZGVudGlhbHNbJ3R5cGUnXSkge1xuICAgICAgICBjYXNlICdmaXJzdFBhcnR5JzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmlyc3RQYXJ0eUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyKGNyZWRlbnRpYWxzWydzZXNzaW9uSW5kZXgnXSB8fCAnMCcsIGNyZWRlbnRpYWxzWydpYW1Ub2tlbiddIHx8IG51bGwsIGNyZWRlbnRpYWxzWydhdXRoVG9rZW5GYWN0b3J5J10gfHwgbnVsbCk7XG4gICAgICAgIGNhc2UgJ3Byb3ZpZGVyJzpcbiAgICAgICAgICAgIHJldHVybiBjcmVkZW50aWFsc1snY2xpZW50J107XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnbWFrZUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyIGZhaWxlZCBkdWUgdG8gaW52YWxpZCBjcmVkZW50aWFsIHR5cGUnKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEdlbmVyYXRlcyBgbkJ5dGVzYCBvZiByYW5kb20gYnl0ZXMuXG4gKlxuICogSWYgYG5CeXRlcyA8IDBgICwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzKG5CeXRlcykge1xuICAgIHJldHVybiByYW5kb21CeXRlcyQxKG5CeXRlcyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEEgdXRpbGl0eSBjbGFzcyBmb3IgZ2VuZXJhdGluZyB1bmlxdWUgYWxwaGFudW1lcmljIElEcyBvZiBhIHNwZWNpZmllZCBsZW5ndGguXG4gKlxuICogQGludGVybmFsXG4gKiBFeHBvcnRlZCBpbnRlcm5hbGx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuICovXG5jbGFzcyBBdXRvSWQge1xuICAgIHN0YXRpYyBuZXdJZCgpIHtcbiAgICAgICAgLy8gQWxwaGFudW1lcmljIGNoYXJhY3RlcnNcbiAgICAgICAgY29uc3QgY2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODknO1xuICAgICAgICAvLyBUaGUgbGFyZ2VzdCBieXRlIHZhbHVlIHRoYXQgaXMgYSBtdWx0aXBsZSBvZiBgY2hhci5sZW5ndGhgLlxuICAgICAgICBjb25zdCBtYXhNdWx0aXBsZSA9IE1hdGguZmxvb3IoMjU2IC8gY2hhcnMubGVuZ3RoKSAqIGNoYXJzLmxlbmd0aDtcbiAgICAgICAgbGV0IGF1dG9JZCA9ICcnO1xuICAgICAgICBjb25zdCB0YXJnZXRMZW5ndGggPSAyMDtcbiAgICAgICAgd2hpbGUgKGF1dG9JZC5sZW5ndGggPCB0YXJnZXRMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gcmFuZG9tQnl0ZXMoNDApO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgYWNjZXB0IHZhbHVlcyB0aGF0IGFyZSBbMCwgbWF4TXVsdGlwbGUpLCB0aGlzIGVuc3VyZXMgdGhleSBjYW5cbiAgICAgICAgICAgICAgICAvLyBiZSBldmVubHkgbWFwcGVkIHRvIGluZGljZXMgb2YgYGNoYXJzYCB2aWEgYSBtb2R1bG8gb3BlcmF0aW9uLlxuICAgICAgICAgICAgICAgIGlmIChhdXRvSWQubGVuZ3RoIDwgdGFyZ2V0TGVuZ3RoICYmIGJ5dGVzW2ldIDwgbWF4TXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXV0b0lkICs9IGNoYXJzLmNoYXJBdChieXRlc1tpXSAlIGNoYXJzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdXRvSWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0IDwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAobGVmdCA+IHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbi8qKiBIZWxwZXIgdG8gY29tcGFyZSBhcnJheXMgdXNpbmcgaXNFcXVhbCgpLiAqL1xuZnVuY3Rpb24gYXJyYXlFcXVhbHMobGVmdCwgcmlnaHQsIGNvbXBhcmF0b3IpIHtcbiAgICBpZiAobGVmdC5sZW5ndGggIT09IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBsZWZ0LmV2ZXJ5KCh2YWx1ZSwgaW5kZXgpID0+IGNvbXBhcmF0b3IodmFsdWUsIHJpZ2h0W2luZGV4XSkpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbW1lZGlhdGUgbGV4aWNvZ3JhcGhpY2FsbHktZm9sbG93aW5nIHN0cmluZy4gVGhpcyBpcyB1c2VmdWwgdG9cbiAqIGNvbnN0cnVjdCBhbiBpbmNsdXNpdmUgcmFuZ2UgZm9yIGluZGV4ZWRkYiBpdGVyYXRvcnMuXG4gKi9cbmZ1bmN0aW9uIGltbWVkaWF0ZVN1Y2Nlc3NvcihzKSB7XG4gICAgLy8gUmV0dXJuIHRoZSBpbnB1dCBzdHJpbmcsIHdpdGggYW4gYWRkaXRpb25hbCBOVUwgYnl0ZSBhcHBlbmRlZC5cbiAgICByZXR1cm4gcyArICdcXDAnO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gVGhlIGVhcmxpZXN0IGRhdGUgc3VwcG9ydGVkIGJ5IEZpcmVzdG9yZSB0aW1lc3RhbXBzICgwMDAxLTAxLTAxVDAwOjAwOjAwWikuXG5jb25zdCBNSU5fU0VDT05EUyA9IC02MjEzNTU5NjgwMDtcbi8vIE51bWJlciBvZiBuYW5vc2Vjb25kcyBpbiBhIG1pbGxpc2Vjb25kLlxuY29uc3QgTVNfVE9fTkFOT1MgPSAxZTY7XG4vKipcbiAqIEEgYFRpbWVzdGFtcGAgcmVwcmVzZW50cyBhIHBvaW50IGluIHRpbWUgaW5kZXBlbmRlbnQgb2YgYW55IHRpbWUgem9uZSBvclxuICogY2FsZW5kYXIsIHJlcHJlc2VudGVkIGFzIHNlY29uZHMgYW5kIGZyYWN0aW9ucyBvZiBzZWNvbmRzIGF0IG5hbm9zZWNvbmRcbiAqIHJlc29sdXRpb24gaW4gVVRDIEVwb2NoIHRpbWUuXG4gKlxuICogSXQgaXMgZW5jb2RlZCB1c2luZyB0aGUgUHJvbGVwdGljIEdyZWdvcmlhbiBDYWxlbmRhciB3aGljaCBleHRlbmRzIHRoZVxuICogR3JlZ29yaWFuIGNhbGVuZGFyIGJhY2t3YXJkcyB0byB5ZWFyIG9uZS4gSXQgaXMgZW5jb2RlZCBhc3N1bWluZyBhbGwgbWludXRlc1xuICogYXJlIDYwIHNlY29uZHMgbG9uZywgaS5lLiBsZWFwIHNlY29uZHMgYXJlIFwic21lYXJlZFwiIHNvIHRoYXQgbm8gbGVhcCBzZWNvbmRcbiAqIHRhYmxlIGlzIG5lZWRlZCBmb3IgaW50ZXJwcmV0YXRpb24uIFJhbmdlIGlzIGZyb20gMDAwMS0wMS0wMVQwMDowMDowMFogdG9cbiAqIDk5OTktMTItMzFUMjM6NTk6NTkuOTk5OTk5OTk5Wi5cbiAqXG4gKiBGb3IgZXhhbXBsZXMgYW5kIGZ1cnRoZXIgc3BlY2lmaWNhdGlvbnMsIHJlZmVyIHRvIHRoZVxuICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvcHJvdG9idWYvYmxvYi9tYXN0ZXIvc3JjL2dvb2dsZS9wcm90b2J1Zi90aW1lc3RhbXAucHJvdG8gfCBUaW1lc3RhbXAgZGVmaW5pdGlvbn0uXG4gKi9cbmNsYXNzIFRpbWVzdGFtcCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0aW1lc3RhbXAgd2l0aCB0aGUgY3VycmVudCBkYXRlLCB3aXRoIG1pbGxpc2Vjb25kIHByZWNpc2lvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGEgbmV3IHRpbWVzdGFtcCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgZGF0ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgbm93KCkge1xuICAgICAgICByZXR1cm4gVGltZXN0YW1wLmZyb21NaWxsaXMoRGF0ZS5ub3coKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdGltZXN0YW1wIGZyb20gdGhlIGdpdmVuIGRhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGluaXRpYWxpemUgdGhlIGBUaW1lc3RhbXBgIGZyb20uXG4gICAgICogQHJldHVybnMgQSBuZXcgYFRpbWVzdGFtcGAgcmVwcmVzZW50aW5nIHRoZSBzYW1lIHBvaW50IGluIHRpbWUgYXMgdGhlIGdpdmVuXG4gICAgICogICAgIGRhdGUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21EYXRlKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIFRpbWVzdGFtcC5mcm9tTWlsbGlzKGRhdGUuZ2V0VGltZSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0aW1lc3RhbXAgZnJvbSB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtaWxsaXNlY29uZHMgLSBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIFVuaXggZXBvY2hcbiAgICAgKiAgICAgMTk3MC0wMS0wMVQwMDowMDowMFouXG4gICAgICogQHJldHVybnMgQSBuZXcgYFRpbWVzdGFtcGAgcmVwcmVzZW50aW5nIHRoZSBzYW1lIHBvaW50IGluIHRpbWUgYXMgdGhlIGdpdmVuXG4gICAgICogICAgIG51bWJlciBvZiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21NaWxsaXMobWlsbGlzZWNvbmRzKSB7XG4gICAgICAgIGNvbnN0IHNlY29uZHMgPSBNYXRoLmZsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICBjb25zdCBuYW5vcyA9IE1hdGguZmxvb3IoKG1pbGxpc2Vjb25kcyAtIHNlY29uZHMgKiAxMDAwKSAqIE1TX1RPX05BTk9TKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoc2Vjb25kcywgbmFub3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRpbWVzdGFtcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWNvbmRzIC0gVGhlIG51bWJlciBvZiBzZWNvbmRzIG9mIFVUQyB0aW1lIHNpbmNlIFVuaXggZXBvY2hcbiAgICAgKiAgICAgMTk3MC0wMS0wMVQwMDowMDowMFouIE11c3QgYmUgZnJvbSAwMDAxLTAxLTAxVDAwOjAwOjAwWiB0b1xuICAgICAqICAgICA5OTk5LTEyLTMxVDIzOjU5OjU5WiBpbmNsdXNpdmUuXG4gICAgICogQHBhcmFtIG5hbm9zZWNvbmRzIC0gVGhlIG5vbi1uZWdhdGl2ZSBmcmFjdGlvbnMgb2YgYSBzZWNvbmQgYXQgbmFub3NlY29uZFxuICAgICAqICAgICByZXNvbHV0aW9uLiBOZWdhdGl2ZSBzZWNvbmQgdmFsdWVzIHdpdGggZnJhY3Rpb25zIG11c3Qgc3RpbGwgaGF2ZVxuICAgICAqICAgICBub24tbmVnYXRpdmUgbmFub3NlY29uZHMgdmFsdWVzIHRoYXQgY291bnQgZm9yd2FyZCBpbiB0aW1lLiBNdXN0IGJlXG4gICAgICogICAgIGZyb20gMCB0byA5OTksOTk5LDk5OSBpbmNsdXNpdmUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBzZWNvbmRzIG9mIFVUQyB0aW1lIHNpbmNlIFVuaXggZXBvY2ggMTk3MC0wMS0wMVQwMDowMDowMFouXG4gICAgICovXG4gICAgc2Vjb25kcywgXG4gICAgLyoqXG4gICAgICogVGhlIGZyYWN0aW9ucyBvZiBhIHNlY29uZCBhdCBuYW5vc2Vjb25kIHJlc29sdXRpb24uKlxuICAgICAqL1xuICAgIG5hbm9zZWNvbmRzKSB7XG4gICAgICAgIHRoaXMuc2Vjb25kcyA9IHNlY29uZHM7XG4gICAgICAgIHRoaXMubmFub3NlY29uZHMgPSBuYW5vc2Vjb25kcztcbiAgICAgICAgaWYgKG5hbm9zZWNvbmRzIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1RpbWVzdGFtcCBuYW5vc2Vjb25kcyBvdXQgb2YgcmFuZ2U6ICcgKyBuYW5vc2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbm9zZWNvbmRzID49IDFlOSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1RpbWVzdGFtcCBuYW5vc2Vjb25kcyBvdXQgb2YgcmFuZ2U6ICcgKyBuYW5vc2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY29uZHMgPCBNSU5fU0VDT05EUykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1RpbWVzdGFtcCBzZWNvbmRzIG91dCBvZiByYW5nZTogJyArIHNlY29uZHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgd2lsbCBicmVhayBpbiB0aGUgeWVhciAxMCwwMDAuXG4gICAgICAgIGlmIChzZWNvbmRzID49IDI1MzQwMjMwMDgwMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1RpbWVzdGFtcCBzZWNvbmRzIG91dCBvZiByYW5nZTogJyArIHNlY29uZHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgYFRpbWVzdGFtcGAgdG8gYSBKYXZhU2NyaXB0IGBEYXRlYCBvYmplY3QuIFRoaXMgY29udmVyc2lvblxuICAgICAqIGNhdXNlcyBhIGxvc3Mgb2YgcHJlY2lzaW9uIHNpbmNlIGBEYXRlYCBvYmplY3RzIG9ubHkgc3VwcG9ydCBtaWxsaXNlY29uZFxuICAgICAqIHByZWNpc2lvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEphdmFTY3JpcHQgYERhdGVgIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNhbWUgcG9pbnQgaW4gdGltZSBhc1xuICAgICAqICAgICB0aGlzIGBUaW1lc3RhbXBgLCB3aXRoIG1pbGxpc2Vjb25kIHByZWNpc2lvbi5cbiAgICAgKi9cbiAgICB0b0RhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnRvTWlsbGlzKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGBUaW1lc3RhbXBgIHRvIGEgbnVtZXJpYyB0aW1lc3RhbXAgKGluIG1pbGxpc2Vjb25kcyBzaW5jZVxuICAgICAqIGVwb2NoKS4gVGhpcyBvcGVyYXRpb24gY2F1c2VzIGEgbG9zcyBvZiBwcmVjaXNpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcG9pbnQgaW4gdGltZSBjb3JyZXNwb25kaW5nIHRvIHRoaXMgdGltZXN0YW1wLCByZXByZXNlbnRlZCBhc1xuICAgICAqICAgICB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSBVbml4IGVwb2NoIDE5NzAtMDEtMDFUMDA6MDA6MDBaLlxuICAgICAqL1xuICAgIHRvTWlsbGlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWNvbmRzICogMTAwMCArIHRoaXMubmFub3NlY29uZHMgLyBNU19UT19OQU5PUztcbiAgICB9XG4gICAgX2NvbXBhcmVUbyhvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5zZWNvbmRzID09PSBvdGhlci5zZWNvbmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcih0aGlzLm5hbm9zZWNvbmRzLCBvdGhlci5uYW5vc2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IodGhpcy5zZWNvbmRzLCBvdGhlci5zZWNvbmRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgYFRpbWVzdGFtcGAgaXMgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBgVGltZXN0YW1wYCB0byBjb21wYXJlIGFnYWluc3QuXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGlzIGBUaW1lc3RhbXBgIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXG4gICAgICovXG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gKG90aGVyLnNlY29uZHMgPT09IHRoaXMuc2Vjb25kcyAmJiBvdGhlci5uYW5vc2Vjb25kcyA9PT0gdGhpcy5uYW5vc2Vjb25kcyk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGEgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGBUaW1lc3RhbXBgLiAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKCdUaW1lc3RhbXAoc2Vjb25kcz0nICtcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kcyArXG4gICAgICAgICAgICAnLCBuYW5vc2Vjb25kcz0nICtcbiAgICAgICAgICAgIHRoaXMubmFub3NlY29uZHMgK1xuICAgICAgICAgICAgJyknKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGBUaW1lc3RhbXBgLiAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgc2Vjb25kczogdGhpcy5zZWNvbmRzLCBuYW5vc2Vjb25kczogdGhpcy5uYW5vc2Vjb25kcyB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIG9iamVjdCB0byBhIHByaW1pdGl2ZSBzdHJpbmcsIHdoaWNoIGFsbG93cyBgVGltZXN0YW1wYCBvYmplY3RzXG4gICAgICogdG8gYmUgY29tcGFyZWQgdXNpbmcgdGhlIGA+YCwgYDw9YCwgYD49YCBhbmQgYD5gIG9wZXJhdG9ycy5cbiAgICAgKi9cbiAgICB2YWx1ZU9mKCkge1xuICAgICAgICAvLyBUaGlzIG1ldGhvZCByZXR1cm5zIGEgc3RyaW5nIG9mIHRoZSBmb3JtIDxzZWNvbmRzPi48bmFub3NlY29uZHM+IHdoZXJlXG4gICAgICAgIC8vIDxzZWNvbmRzPiBpcyB0cmFuc2xhdGVkIHRvIGhhdmUgYSBub24tbmVnYXRpdmUgdmFsdWUgYW5kIGJvdGggPHNlY29uZHM+XG4gICAgICAgIC8vIGFuZCA8bmFub3NlY29uZHM+IGFyZSBsZWZ0LXBhZGRlZCB3aXRoIHplcm9lcyB0byBiZSBhIGNvbnNpc3RlbnQgbGVuZ3RoLlxuICAgICAgICAvLyBTdHJpbmdzIHdpdGggdGhpcyBmb3JtYXQgdGhlbiBoYXZlIGEgbGV4aWNvZ3JhcGhpY2FsIG9yZGVyaW5nIHRoYXQgbWF0Y2hlc1xuICAgICAgICAvLyB0aGUgZXhwZWN0ZWQgb3JkZXJpbmcuIFRoZSA8c2Vjb25kcz4gdHJhbnNsYXRpb24gaXMgZG9uZSB0byBhdm9pZCBoYXZpbmdcbiAgICAgICAgLy8gYSBsZWFkaW5nIG5lZ2F0aXZlIHNpZ24gKGkuZS4gYSBsZWFkaW5nICctJyBjaGFyYWN0ZXIpIGluIGl0cyBzdHJpbmdcbiAgICAgICAgLy8gcmVwcmVzZW50YXRpb24sIHdoaWNoIHdvdWxkIGFmZmVjdCBpdHMgbGV4aWNvZ3JhcGhpY2FsIG9yZGVyaW5nLlxuICAgICAgICBjb25zdCBhZGp1c3RlZFNlY29uZHMgPSB0aGlzLnNlY29uZHMgLSBNSU5fU0VDT05EUztcbiAgICAgICAgLy8gTm90ZTogVXAgdG8gMTIgZGVjaW1hbCBkaWdpdHMgYXJlIHJlcXVpcmVkIHRvIHJlcHJlc2VudCBhbGwgdmFsaWRcbiAgICAgICAgLy8gJ3NlY29uZHMnIHZhbHVlcy5cbiAgICAgICAgY29uc3QgZm9ybWF0dGVkU2Vjb25kcyA9IFN0cmluZyhhZGp1c3RlZFNlY29uZHMpLnBhZFN0YXJ0KDEyLCAnMCcpO1xuICAgICAgICBjb25zdCBmb3JtYXR0ZWROYW5vc2Vjb25kcyA9IFN0cmluZyh0aGlzLm5hbm9zZWNvbmRzKS5wYWRTdGFydCg5LCAnMCcpO1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVkU2Vjb25kcyArICcuJyArIGZvcm1hdHRlZE5hbm9zZWNvbmRzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSB2ZXJzaW9uIG9mIGEgZG9jdW1lbnQgaW4gRmlyZXN0b3JlLiBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSB2ZXJzaW9uXG4gKiB0aW1lc3RhbXAsIHN1Y2ggYXMgdXBkYXRlX3RpbWUgb3IgcmVhZF90aW1lLlxuICovXG5jbGFzcyBTbmFwc2hvdFZlcnNpb24ge1xuICAgIHN0YXRpYyBmcm9tVGltZXN0YW1wKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU25hcHNob3RWZXJzaW9uKHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIG1pbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTbmFwc2hvdFZlcnNpb24obmV3IFRpbWVzdGFtcCgwLCAwKSk7XG4gICAgfVxuICAgIHN0YXRpYyBtYXgoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU25hcHNob3RWZXJzaW9uKG5ldyBUaW1lc3RhbXAoMjUzNDAyMzAwNzk5LCAxZTkgLSAxKSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHRpbWVzdGFtcCkge1xuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICB9XG4gICAgY29tcGFyZVRvKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVzdGFtcC5fY29tcGFyZVRvKG90aGVyLnRpbWVzdGFtcCk7XG4gICAgfVxuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZXN0YW1wLmlzRXF1YWwob3RoZXIudGltZXN0YW1wKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSBudW1iZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlcnNpb24gZm9yIHVzZSBpbiBzcGVjIHRlc3RzLiAqL1xuICAgIHRvTWljcm9zZWNvbmRzKCkge1xuICAgICAgICAvLyBDb252ZXJ0IHRvIG1pY3Jvc2Vjb25kcy5cbiAgICAgICAgcmV0dXJuIHRoaXMudGltZXN0YW1wLnNlY29uZHMgKiAxZTYgKyB0aGlzLnRpbWVzdGFtcC5uYW5vc2Vjb25kcyAvIDEwMDA7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gJ1NuYXBzaG90VmVyc2lvbignICsgdGhpcy50aW1lc3RhbXAudG9TdHJpbmcoKSArICcpJztcbiAgICB9XG4gICAgdG9UaW1lc3RhbXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVzdGFtcDtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBET0NVTUVOVF9LRVlfTkFNRSA9ICdfX25hbWVfXyc7XG4vKipcbiAqIFBhdGggcmVwcmVzZW50cyBhbiBvcmRlcmVkIHNlcXVlbmNlIG9mIHN0cmluZyBzZWdtZW50cy5cbiAqL1xuY2xhc3MgQmFzZVBhdGgge1xuICAgIGNvbnN0cnVjdG9yKHNlZ21lbnRzLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2Zmc2V0ID4gc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBmYWlsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZW5ndGggPSBzZWdtZW50cy5sZW5ndGggLSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoID4gc2VnbWVudHMubGVuZ3RoIC0gb2Zmc2V0KSB7XG4gICAgICAgICAgICBmYWlsKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWdtZW50cyA9IHNlZ21lbnRzO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5sZW4gPSBsZW5ndGg7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbjtcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gQmFzZVBhdGguY29tcGFyYXRvcih0aGlzLCBvdGhlcikgPT09IDA7XG4gICAgfVxuICAgIGNoaWxkKG5hbWVPclBhdGgpIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzLnNsaWNlKHRoaXMub2Zmc2V0LCB0aGlzLmxpbWl0KCkpO1xuICAgICAgICBpZiAobmFtZU9yUGF0aCBpbnN0YW5jZW9mIEJhc2VQYXRoKSB7XG4gICAgICAgICAgICBuYW1lT3JQYXRoLmZvckVhY2goc2VnbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VnbWVudHMucHVzaChuYW1lT3JQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Qoc2VnbWVudHMpO1xuICAgIH1cbiAgICAvKiogVGhlIGluZGV4IG9mIG9uZSBwYXN0IHRoZSBsYXN0IHNlZ21lbnQgb2YgdGhlIHBhdGguICovXG4gICAgbGltaXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZnNldCArIHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICBwb3BGaXJzdChzaXplKSB7XG4gICAgICAgIHNpemUgPSBzaXplID09PSB1bmRlZmluZWQgPyAxIDogc2l6ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0KHRoaXMuc2VnbWVudHMsIHRoaXMub2Zmc2V0ICsgc2l6ZSwgdGhpcy5sZW5ndGggLSBzaXplKTtcbiAgICB9XG4gICAgcG9wTGFzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0KHRoaXMuc2VnbWVudHMsIHRoaXMub2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICBmaXJzdFNlZ21lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlZ21lbnRzW3RoaXMub2Zmc2V0XTtcbiAgICB9XG4gICAgbGFzdFNlZ21lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldCh0aGlzLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICBnZXQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VnbWVudHNbdGhpcy5vZmZzZXQgKyBpbmRleF07XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgaXNQcmVmaXhPZihvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIubGVuZ3RoIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldChpKSAhPT0gb3RoZXIuZ2V0KGkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpc0ltbWVkaWF0ZVBhcmVudE9mKHBvdGVudGlhbENoaWxkKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCArIDEgIT09IHBvdGVudGlhbENoaWxkLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KGkpICE9PSBwb3RlbnRpYWxDaGlsZC5nZXQoaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvckVhY2goZm4pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMub2Zmc2V0LCBlbmQgPSB0aGlzLmxpbWl0KCk7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgZm4odGhpcy5zZWdtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9BcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VnbWVudHMuc2xpY2UodGhpcy5vZmZzZXQsIHRoaXMubGltaXQoKSk7XG4gICAgfVxuICAgIHN0YXRpYyBjb21wYXJhdG9yKHAxLCBwMikge1xuICAgICAgICBjb25zdCBsZW4gPSBNYXRoLm1pbihwMS5sZW5ndGgsIHAyLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBwMS5nZXQoaSk7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHAyLmdldChpKTtcbiAgICAgICAgICAgIGlmIChsZWZ0IDwgcmlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVmdCA+IHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAxLmxlbmd0aCA8IHAyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwMS5sZW5ndGggPiBwMi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cbi8qKlxuICogQSBzbGFzaC1zZXBhcmF0ZWQgcGF0aCBmb3IgbmF2aWdhdGluZyByZXNvdXJjZXMgKGRvY3VtZW50cyBhbmQgY29sbGVjdGlvbnMpXG4gKiB3aXRoaW4gRmlyZXN0b3JlLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBSZXNvdXJjZVBhdGggZXh0ZW5kcyBCYXNlUGF0aCB7XG4gICAgY29uc3RydWN0KHNlZ21lbnRzLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlc291cmNlUGF0aChzZWdtZW50cywgb2Zmc2V0LCBsZW5ndGgpO1xuICAgIH1cbiAgICBjYW5vbmljYWxTdHJpbmcoKSB7XG4gICAgICAgIC8vIE5PVEU6IFRoZSBjbGllbnQgaXMgaWdub3JhbnQgb2YgYW55IHBhdGggc2VnbWVudHMgY29udGFpbmluZyBlc2NhcGVcbiAgICAgICAgLy8gc2VxdWVuY2VzIChlLmcuIF9faWQxMjNfXykgYW5kIGp1c3QgcGFzc2VzIHRoZW0gdGhyb3VnaCByYXcgKHRoZXkgZXhpc3RcbiAgICAgICAgLy8gZm9yIGxlZ2FjeSByZWFzb25zIGFuZCBzaG91bGQgbm90IGJlIHVzZWQgZnJlcXVlbnRseSkuXG4gICAgICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5qb2luKCcvJyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW5vbmljYWxTdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHBhdGhcbiAgICAgKiB3aGVyZSBlYWNoIHBhdGggc2VnbWVudCBoYXMgYmVlbiBlbmNvZGVkIHdpdGhcbiAgICAgKiBgZW5jb2RlVVJJQ29tcG9uZW50YC5cbiAgICAgKi9cbiAgICB0b1VyaUVuY29kZWRTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5tYXAoZW5jb2RlVVJJQ29tcG9uZW50KS5qb2luKCcvJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSByZXNvdXJjZSBwYXRoIGZyb20gdGhlIGdpdmVuIHNsYXNoLWRlbGltaXRlZCBzdHJpbmcuIElmIG11bHRpcGxlXG4gICAgICogYXJndW1lbnRzIGFyZSBwcm92aWRlZCwgYWxsIGNvbXBvbmVudHMgYXJlIGNvbWJpbmVkLiBMZWFkaW5nIGFuZCB0cmFpbGluZ1xuICAgICAqIHNsYXNoZXMgZnJvbSBhbGwgY29tcG9uZW50cyBhcmUgaWdub3JlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVN0cmluZyguLi5wYXRoQ29tcG9uZW50cykge1xuICAgICAgICAvLyBOT1RFOiBUaGUgY2xpZW50IGlzIGlnbm9yYW50IG9mIGFueSBwYXRoIHNlZ21lbnRzIGNvbnRhaW5pbmcgZXNjYXBlXG4gICAgICAgIC8vIHNlcXVlbmNlcyAoZS5nLiBfX2lkMTIzX18pIGFuZCBqdXN0IHBhc3NlcyB0aGVtIHRocm91Z2ggcmF3ICh0aGV5IGV4aXN0XG4gICAgICAgIC8vIGZvciBsZWdhY3kgcmVhc29ucyBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkIGZyZXF1ZW50bHkpLlxuICAgICAgICBjb25zdCBzZWdtZW50cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aENvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGlmIChwYXRoLmluZGV4T2YoJy8vJykgPj0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHNlZ21lbnQgKCR7cGF0aH0pLiBQYXRocyBtdXN0IG5vdCBjb250YWluIC8vIGluIHRoZW0uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdHJpcCBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVkLlxuICAgICAgICAgICAgc2VnbWVudHMucHVzaCguLi5wYXRoLnNwbGl0KCcvJykuZmlsdGVyKHNlZ21lbnQgPT4gc2VnbWVudC5sZW5ndGggPiAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvdXJjZVBhdGgoc2VnbWVudHMpO1xuICAgIH1cbiAgICBzdGF0aWMgZW1wdHlQYXRoKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlc291cmNlUGF0aChbXSk7XG4gICAgfVxufVxuY29uc3QgaWRlbnRpZmllclJlZ0V4cCA9IC9eW19hLXpBLVpdW19hLXpBLVowLTldKiQvO1xuLyoqXG4gKiBBIGRvdC1zZXBhcmF0ZWQgcGF0aCBmb3IgbmF2aWdhdGluZyBzdWItb2JqZWN0cyB3aXRoaW4gYSBkb2N1bWVudC5cbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBGaWVsZFBhdGgkMSBleHRlbmRzIEJhc2VQYXRoIHtcbiAgICBjb25zdHJ1Y3Qoc2VnbWVudHMsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGRQYXRoJDEoc2VnbWVudHMsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzdHJpbmcgY291bGQgYmUgdXNlZCBhcyBhIHNlZ21lbnQgaW4gYSBmaWVsZCBwYXRoXG4gICAgICogd2l0aG91dCBlc2NhcGluZy5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNWYWxpZElkZW50aWZpZXIoc2VnbWVudCkge1xuICAgICAgICByZXR1cm4gaWRlbnRpZmllclJlZ0V4cC50ZXN0KHNlZ21lbnQpO1xuICAgIH1cbiAgICBjYW5vbmljYWxTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKVxuICAgICAgICAgICAgLm1hcChzdHIgPT4ge1xuICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykucmVwbGFjZSgvYC9nLCAnXFxcXGAnKTtcbiAgICAgICAgICAgIGlmICghRmllbGRQYXRoJDEuaXNWYWxpZElkZW50aWZpZXIoc3RyKSkge1xuICAgICAgICAgICAgICAgIHN0ciA9ICdgJyArIHN0ciArICdgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignLicpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2Fub25pY2FsU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGZpZWxkIHJlZmVyZW5jZXMgdGhlIGtleSBvZiBhIGRvY3VtZW50LlxuICAgICAqL1xuICAgIGlzS2V5RmllbGQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLmdldCgwKSA9PT0gRE9DVU1FTlRfS0VZX05BTUU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmaWVsZCBkZXNpZ25hdGluZyB0aGUga2V5IG9mIGEgZG9jdW1lbnQuXG4gICAgICovXG4gICAgc3RhdGljIGtleUZpZWxkKCkge1xuICAgICAgICByZXR1cm4gbmV3IEZpZWxkUGF0aCQxKFtET0NVTUVOVF9LRVlfTkFNRV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBmaWVsZCBzdHJpbmcgZnJvbSB0aGUgZ2l2ZW4gc2VydmVyLWZvcm1hdHRlZCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiAtIFNwbGl0dGluZyB0aGUgZW1wdHkgc3RyaW5nIGlzIG5vdCBhbGxvd2VkIChmb3Igbm93IGF0IGxlYXN0KS5cbiAgICAgKiAtIEVtcHR5IHNlZ21lbnRzIHdpdGhpbiB0aGUgc3RyaW5nIChlLmcuIGlmIHRoZXJlIGFyZSB0d28gY29uc2VjdXRpdmVcbiAgICAgKiAgIHNlcGFyYXRvcnMpIGFyZSBub3QgYWxsb3dlZC5cbiAgICAgKlxuICAgICAqIFRPRE8oYi8zNzI0NDE1Nyk6IHdlIHNob3VsZCBtYWtlIHRoaXMgbW9yZSBzdHJpY3QuIFJpZ2h0IG5vdywgaXQgYWxsb3dzXG4gICAgICogbm9uLWlkZW50aWZpZXIgcGF0aCBjb21wb25lbnRzLCBldmVuIGlmIHRoZXkgYXJlbid0IGVzY2FwZWQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21TZXJ2ZXJGb3JtYXQocGF0aCkge1xuICAgICAgICBjb25zdCBzZWdtZW50cyA9IFtdO1xuICAgICAgICBsZXQgY3VycmVudCA9ICcnO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGNvbnN0IGFkZEN1cnJlbnRTZWdtZW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgZmllbGQgcGF0aCAoJHtwYXRofSkuIFBhdGhzIG11c3Qgbm90IGJlIGVtcHR5LCBiZWdpbiBgICtcbiAgICAgICAgICAgICAgICAgICAgYHdpdGggJy4nLCBlbmQgd2l0aCAnLicsIG9yIGNvbnRhaW4gJy4uJ2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VnbWVudHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSAnJztcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGluQmFja3RpY2tzID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChpIDwgcGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBwYXRoW2ldO1xuICAgICAgICAgICAgaWYgKGMgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgIGlmIChpICsgMSA9PT0gcGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1BhdGggaGFzIHRyYWlsaW5nIGVzY2FwZSBjaGFyYWN0ZXI6ICcgKyBwYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHBhdGhbaSArIDFdO1xuICAgICAgICAgICAgICAgIGlmICghKG5leHQgPT09ICdcXFxcJyB8fCBuZXh0ID09PSAnLicgfHwgbmV4dCA9PT0gJ2AnKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnUGF0aCBoYXMgaW52YWxpZCBlc2NhcGUgc2VxdWVuY2U6ICcgKyBwYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudCArPSBuZXh0O1xuICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICdgJykge1xuICAgICAgICAgICAgICAgIGluQmFja3RpY2tzID0gIWluQmFja3RpY2tzO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICcuJyAmJiAhaW5CYWNrdGlja3MpIHtcbiAgICAgICAgICAgICAgICBhZGRDdXJyZW50U2VnbWVudCgpO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gYztcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWRkQ3VycmVudFNlZ21lbnQoKTtcbiAgICAgICAgaWYgKGluQmFja3RpY2tzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnVW50ZXJtaW5hdGVkIGAgaW4gcGF0aDogJyArIHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRmllbGRQYXRoJDEoc2VnbWVudHMpO1xuICAgIH1cbiAgICBzdGF0aWMgZW1wdHlQYXRoKCkge1xuICAgICAgICByZXR1cm4gbmV3IEZpZWxkUGF0aCQxKFtdKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBEb2N1bWVudEtleSB7XG4gICAgY29uc3RydWN0b3IocGF0aCkge1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVBhdGgocGF0aCkge1xuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50S2V5KFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKHBhdGgpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21OYW1lKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudEtleShSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhuYW1lKS5wb3BGaXJzdCg1KSk7XG4gICAgfVxuICAgIHN0YXRpYyBlbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudEtleShSZXNvdXJjZVBhdGguZW1wdHlQYXRoKCkpO1xuICAgIH1cbiAgICBnZXQgY29sbGVjdGlvbkdyb3VwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXRoLnBvcExhc3QoKS5sYXN0U2VnbWVudCgpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBkb2N1bWVudCBpcyBpbiB0aGUgc3BlY2lmaWVkIGNvbGxlY3Rpb25JZC4gKi9cbiAgICBoYXNDb2xsZWN0aW9uSWQoY29sbGVjdGlvbklkKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5wYXRoLmxlbmd0aCA+PSAyICYmXG4gICAgICAgICAgICB0aGlzLnBhdGguZ2V0KHRoaXMucGF0aC5sZW5ndGggLSAyKSA9PT0gY29sbGVjdGlvbklkKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdGhlIGNvbGxlY3Rpb24gZ3JvdXAgKGkuZS4gdGhlIG5hbWUgb2YgdGhlIHBhcmVudCBjb2xsZWN0aW9uKSBmb3IgdGhpcyBrZXkuICovXG4gICAgZ2V0Q29sbGVjdGlvbkdyb3VwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXRoLmdldCh0aGlzLnBhdGgubGVuZ3RoIC0gMik7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHRoZSBmdWxseSBxdWFsaWZpZWQgcGF0aCB0byB0aGUgcGFyZW50IGNvbGxlY3Rpb24uICovXG4gICAgZ2V0Q29sbGVjdGlvblBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdGgucG9wTGFzdCgpO1xuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAob3RoZXIgIT09IG51bGwgJiYgUmVzb3VyY2VQYXRoLmNvbXBhcmF0b3IodGhpcy5wYXRoLCBvdGhlci5wYXRoKSA9PT0gMCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXRoLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHN0YXRpYyBjb21wYXJhdG9yKGsxLCBrMikge1xuICAgICAgICByZXR1cm4gUmVzb3VyY2VQYXRoLmNvbXBhcmF0b3IoazEucGF0aCwgazIucGF0aCk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0RvY3VtZW50S2V5KHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGgubGVuZ3RoICUgMiA9PT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyBkb2N1bWVudCBrZXkgd2l0aCB0aGUgZ2l2ZW4gc2VnbWVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2VnbWVudHMgLSBUaGUgc2VnbWVudHMgb2YgdGhlIHBhdGggdG8gdGhlIGRvY3VtZW50XG4gICAgICogQHJldHVybnMgQSBuZXcgaW5zdGFuY2Ugb2YgRG9jdW1lbnRLZXlcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVNlZ21lbnRzKHNlZ21lbnRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRLZXkobmV3IFJlc291cmNlUGF0aChzZWdtZW50cy5zbGljZSgpKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaGUgaW5pdGlhbCBtdXRhdGlvbiBiYXRjaCBpZCBmb3IgZWFjaCBpbmRleC4gR2V0cyB1cGRhdGVkIGR1cmluZyBpbmRleFxuICogYmFja2ZpbGwuXG4gKi9cbmNvbnN0IElOSVRJQUxfTEFSR0VTVF9CQVRDSF9JRCA9IC0xO1xuLyoqXG4gKiBUaGUgaW5pdGlhbCBzZXF1ZW5jZSBudW1iZXIgZm9yIGVhY2ggaW5kZXguIEdldHMgdXBkYXRlZCBkdXJpbmcgaW5kZXhcbiAqIGJhY2tmaWxsLlxuICovXG5jb25zdCBJTklUSUFMX1NFUVVFTkNFX05VTUJFUiA9IDA7XG4vKipcbiAqIEFuIGluZGV4IGRlZmluaXRpb24gZm9yIGZpZWxkIGluZGV4ZXMgaW4gRmlyZXN0b3JlLlxuICpcbiAqIEV2ZXJ5IGluZGV4IGlzIGFzc29jaWF0ZWQgd2l0aCBhIGNvbGxlY3Rpb24uIFRoZSBkZWZpbml0aW9uIGNvbnRhaW5zIGEgbGlzdFxuICogb2YgZmllbGRzIGFuZCB0aGVpciBpbmRleCBraW5kICh3aGljaCBjYW4gYmUgYEFTQ0VORElOR2AsIGBERVNDRU5ESU5HYCBvclxuICogYENPTlRBSU5TYCBmb3IgQXJyYXlDb250YWlucy9BcnJheUNvbnRhaW5zQW55IHF1ZXJpZXMpLlxuICpcbiAqIFVubGlrZSB0aGUgYmFja2VuZCwgdGhlIFNESyBkb2VzIG5vdCBkaWZmZXJlbnRpYXRlIGJldHdlZW4gY29sbGVjdGlvbiBvclxuICogY29sbGVjdGlvbiBncm91cC1zY29wZWQgaW5kaWNlcy4gRXZlcnkgaW5kZXggY2FuIGJlIHVzZWQgZm9yIGJvdGggc2luZ2xlXG4gKiBjb2xsZWN0aW9uIGFuZCBjb2xsZWN0aW9uIGdyb3VwIHF1ZXJpZXMuXG4gKi9cbmNsYXNzIEZpZWxkSW5kZXgge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBJRC4gUmV0dXJucyAtMSBpZiB0aGUgaW5kZXggSUQgaXMgbm90IGF2YWlsYWJsZSAoZS5nLiB0aGUgaW5kZXhcbiAgICAgKiBoYXMgbm90IHlldCBiZWVuIHBlcnNpc3RlZCkuXG4gICAgICovXG4gICAgaW5kZXhJZCwgXG4gICAgLyoqIFRoZSBjb2xsZWN0aW9uIElEIHRoaXMgaW5kZXggYXBwbGllcyB0by4gKi9cbiAgICBjb2xsZWN0aW9uR3JvdXAsIFxuICAgIC8qKiBUaGUgZmllbGQgc2VnbWVudHMgZm9yIHRoaXMgaW5kZXguICovXG4gICAgZmllbGRzLCBcbiAgICAvKiogU2hvd3MgaG93IHVwLXRvLWRhdGUgdGhlIGluZGV4IGlzIGZvciB0aGUgY3VycmVudCB1c2VyLiAqL1xuICAgIGluZGV4U3RhdGUpIHtcbiAgICAgICAgdGhpcy5pbmRleElkID0gaW5kZXhJZDtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uR3JvdXAgPSBjb2xsZWN0aW9uR3JvdXA7XG4gICAgICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xuICAgICAgICB0aGlzLmluZGV4U3RhdGUgPSBpbmRleFN0YXRlO1xuICAgIH1cbn1cbi8qKiBBbiBJRCBmb3IgYW4gaW5kZXggdGhhdCBoYXMgbm90IHlldCBiZWVuIGFkZGVkIHRvIHBlcnNpc3RlbmNlLiAgKi9cbkZpZWxkSW5kZXguVU5LTk9XTl9JRCA9IC0xO1xuLyoqIFJldHVybnMgdGhlIEFycmF5Q29udGFpbnMvQXJyYXlDb250YWluc0FueSBzZWdtZW50IGZvciB0aGlzIGluZGV4LiAqL1xuZnVuY3Rpb24gZmllbGRJbmRleEdldEFycmF5U2VnbWVudChmaWVsZEluZGV4KSB7XG4gICAgcmV0dXJuIGZpZWxkSW5kZXguZmllbGRzLmZpbmQocyA9PiBzLmtpbmQgPT09IDIgLyogSW5kZXhLaW5kLkNPTlRBSU5TICovKTtcbn1cbi8qKiBSZXR1cm5zIGFsbCBkaXJlY3Rpb25hbCAoYXNjZW5kaW5nL2Rlc2NlbmRpbmcpIHNlZ21lbnRzIGZvciB0aGlzIGluZGV4LiAqL1xuZnVuY3Rpb24gZmllbGRJbmRleEdldERpcmVjdGlvbmFsU2VnbWVudHMoZmllbGRJbmRleCkge1xuICAgIHJldHVybiBmaWVsZEluZGV4LmZpZWxkcy5maWx0ZXIocyA9PiBzLmtpbmQgIT09IDIgLyogSW5kZXhLaW5kLkNPTlRBSU5TICovKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgb3JkZXIgb2YgdGhlIGRvY3VtZW50IGtleSBjb21wb25lbnQgZm9yIHRoZSBnaXZlbiBpbmRleC5cbiAqXG4gKiBQT1JUSU5HIE5PVEU6IFRoaXMgaXMgb25seSB1c2VkIGluIHRoZSBXZWIgSW5kZXhlZERiIGltcGxlbWVudGF0aW9uLlxuICovXG5mdW5jdGlvbiBmaWVsZEluZGV4R2V0S2V5T3JkZXIoZmllbGRJbmRleCkge1xuICAgIGNvbnN0IGRpcmVjdGlvbmFsU2VnbWVudHMgPSBmaWVsZEluZGV4R2V0RGlyZWN0aW9uYWxTZWdtZW50cyhmaWVsZEluZGV4KTtcbiAgICByZXR1cm4gZGlyZWN0aW9uYWxTZWdtZW50cy5sZW5ndGggPT09IDBcbiAgICAgICAgPyAwIC8qIEluZGV4S2luZC5BU0NFTkRJTkcgKi9cbiAgICAgICAgOiBkaXJlY3Rpb25hbFNlZ21lbnRzW2RpcmVjdGlvbmFsU2VnbWVudHMubGVuZ3RoIC0gMV0ua2luZDtcbn1cbi8qKlxuICogQ29tcGFyZXMgaW5kZXhlcyBieSBjb2xsZWN0aW9uIGdyb3VwIGFuZCBzZWdtZW50cy4gSWdub3JlcyB1cGRhdGUgdGltZSBhbmRcbiAqIGluZGV4IElELlxuICovXG5mdW5jdGlvbiBmaWVsZEluZGV4U2VtYW50aWNDb21wYXJhdG9yKGxlZnQsIHJpZ2h0KSB7XG4gICAgbGV0IGNtcCA9IHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdC5jb2xsZWN0aW9uR3JvdXAsIHJpZ2h0LmNvbGxlY3Rpb25Hcm91cCk7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gY21wO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWluKGxlZnQuZmllbGRzLmxlbmd0aCwgcmlnaHQuZmllbGRzLmxlbmd0aCk7ICsraSkge1xuICAgICAgICBjbXAgPSBpbmRleFNlZ21lbnRDb21wYXJhdG9yKGxlZnQuZmllbGRzW2ldLCByaWdodC5maWVsZHNbaV0pO1xuICAgICAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQuZmllbGRzLmxlbmd0aCwgcmlnaHQuZmllbGRzLmxlbmd0aCk7XG59XG4vKiogUmV0dXJucyBhIGRlYnVnIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBmaWVsZCBpbmRleCAqL1xuZnVuY3Rpb24gZmllbGRJbmRleFRvU3RyaW5nKGZpZWxkSW5kZXgpIHtcbiAgICByZXR1cm4gYGlkPSR7ZmllbGRJbmRleC5pbmRleElkfXxjZz0ke2ZpZWxkSW5kZXguY29sbGVjdGlvbkdyb3VwfXxmPSR7ZmllbGRJbmRleC5maWVsZHMubWFwKGYgPT4gYCR7Zi5maWVsZFBhdGh9OiR7Zi5raW5kfWApLmpvaW4oJywnKX1gO1xufVxuLyoqIEFuIGluZGV4IGNvbXBvbmVudCBjb25zaXN0aW5nIG9mIGZpZWxkIHBhdGggYW5kIGluZGV4IHR5cGUuICAqL1xuY2xhc3MgSW5kZXhTZWdtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKiogVGhlIGZpZWxkIHBhdGggb2YgdGhlIGNvbXBvbmVudC4gKi9cbiAgICBmaWVsZFBhdGgsIFxuICAgIC8qKiBUaGUgZmllbGRzIHNvcnRpbmcgb3JkZXIuICovXG4gICAga2luZCkge1xuICAgICAgICB0aGlzLmZpZWxkUGF0aCA9IGZpZWxkUGF0aDtcbiAgICAgICAgdGhpcy5raW5kID0ga2luZDtcbiAgICB9XG59XG5mdW5jdGlvbiBpbmRleFNlZ21lbnRDb21wYXJhdG9yKGxlZnQsIHJpZ2h0KSB7XG4gICAgY29uc3QgY21wID0gRmllbGRQYXRoJDEuY29tcGFyYXRvcihsZWZ0LmZpZWxkUGF0aCwgcmlnaHQuZmllbGRQYXRoKTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQua2luZCwgcmlnaHQua2luZCk7XG59XG4vKipcbiAqIFN0b3JlcyB0aGUgXCJoaWdoIHdhdGVyIG1hcmtcIiB0aGF0IGluZGljYXRlcyBob3cgdXBkYXRlZCB0aGUgSW5kZXggaXMgZm9yIHRoZVxuICogY3VycmVudCB1c2VyLlxuICovXG5jbGFzcyBJbmRleFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hlbiB0aGUgaW5kZXggd2FzIGxhc3QgdXBkYXRlZCAocmVsYXRpdmUgdG8gb3RoZXIgaW5kZXhlcykuXG4gICAgICovXG4gICAgc2VxdWVuY2VOdW1iZXIsIFxuICAgIC8qKiBUaGUgdGhlIGxhdGVzdCBpbmRleGVkIHJlYWQgdGltZSwgZG9jdW1lbnQgYW5kIGJhdGNoIGlkLiAqL1xuICAgIG9mZnNldCkge1xuICAgICAgICB0aGlzLnNlcXVlbmNlTnVtYmVyID0gc2VxdWVuY2VOdW1iZXI7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH1cbiAgICAvKiogVGhlIHN0YXRlIG9mIGFuIGluZGV4IHRoYXQgaGFzIG5vdCB5ZXQgYmVlbiBiYWNrZmlsbGVkLiAqL1xuICAgIHN0YXRpYyBlbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleFN0YXRlKElOSVRJQUxfU0VRVUVOQ0VfTlVNQkVSLCBJbmRleE9mZnNldC5taW4oKSk7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGFuIG9mZnNldCB0aGF0IG1hdGNoZXMgYWxsIGRvY3VtZW50cyB3aXRoIGEgcmVhZCB0aW1lIGhpZ2hlciB0aGFuXG4gKiBgcmVhZFRpbWVgLlxuICovXG5mdW5jdGlvbiBuZXdJbmRleE9mZnNldFN1Y2Nlc3NvckZyb21SZWFkVGltZShyZWFkVGltZSwgbGFyZ2VzdEJhdGNoSWQpIHtcbiAgICAvLyBXZSB3YW50IHRvIGNyZWF0ZSBhbiBvZmZzZXQgdGhhdCBtYXRjaGVzIGFsbCBkb2N1bWVudHMgd2l0aCBhIHJlYWQgdGltZVxuICAgIC8vIGdyZWF0ZXIgdGhhbiB0aGUgcHJvdmlkZWQgcmVhZCB0aW1lLiBUbyBkbyBzbywgd2UgdGVjaG5pY2FsbHkgbmVlZCB0b1xuICAgIC8vIGNyZWF0ZSBhbiBvZmZzZXQgZm9yIGAocmVhZFRpbWUsIE1BWF9ET0NVTUVOVF9LRVkpYC4gV2hpbGUgd2UgY291bGQgdXNlXG4gICAgLy8gVW5pY29kZSBjb2RlcG9pbnRzIHRvIGdlbmVyYXRlIE1BWF9ET0NVTUVOVF9LRVksIGl0IGlzIG11Y2ggZWFzaWVyIHRvIHVzZVxuICAgIC8vIGAocmVhZFRpbWUgKyAxLCBEb2N1bWVudEtleS5lbXB0eSgpKWAgc2luY2UgYD4gRG9jdW1lbnRLZXkuZW1wdHkoKWAgbWF0Y2hlc1xuICAgIC8vIGFsbCB2YWxpZCBkb2N1bWVudCBJRHMuXG4gICAgY29uc3Qgc3VjY2Vzc29yU2Vjb25kcyA9IHJlYWRUaW1lLnRvVGltZXN0YW1wKCkuc2Vjb25kcztcbiAgICBjb25zdCBzdWNjZXNzb3JOYW5vcyA9IHJlYWRUaW1lLnRvVGltZXN0YW1wKCkubmFub3NlY29uZHMgKyAxO1xuICAgIGNvbnN0IHN1Y2Nlc3NvciA9IFNuYXBzaG90VmVyc2lvbi5mcm9tVGltZXN0YW1wKHN1Y2Nlc3Nvck5hbm9zID09PSAxZTlcbiAgICAgICAgPyBuZXcgVGltZXN0YW1wKHN1Y2Nlc3NvclNlY29uZHMgKyAxLCAwKVxuICAgICAgICA6IG5ldyBUaW1lc3RhbXAoc3VjY2Vzc29yU2Vjb25kcywgc3VjY2Vzc29yTmFub3MpKTtcbiAgICByZXR1cm4gbmV3IEluZGV4T2Zmc2V0KHN1Y2Nlc3NvciwgRG9jdW1lbnRLZXkuZW1wdHkoKSwgbGFyZ2VzdEJhdGNoSWQpO1xufVxuLyoqIENyZWF0ZXMgYSBuZXcgb2Zmc2V0IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBkb2N1bWVudC4gKi9cbmZ1bmN0aW9uIG5ld0luZGV4T2Zmc2V0RnJvbURvY3VtZW50KGRvY3VtZW50KSB7XG4gICAgcmV0dXJuIG5ldyBJbmRleE9mZnNldChkb2N1bWVudC5yZWFkVGltZSwgZG9jdW1lbnQua2V5LCBJTklUSUFMX0xBUkdFU1RfQkFUQ0hfSUQpO1xufVxuLyoqXG4gKiBTdG9yZXMgdGhlIGxhdGVzdCByZWFkIHRpbWUsIGRvY3VtZW50IGFuZCBiYXRjaCBJRCB0aGF0IHdlcmUgcHJvY2Vzc2VkIGZvciBhblxuICogaW5kZXguXG4gKi9cbmNsYXNzIEluZGV4T2Zmc2V0IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBUaGUgbGF0ZXN0IHJlYWQgdGltZSB2ZXJzaW9uIHRoYXQgaGFzIGJlZW4gaW5kZXhlZCBieSBGaXJlc3RvcmUgZm9yIHRoaXNcbiAgICAgKiBmaWVsZCBpbmRleC5cbiAgICAgKi9cbiAgICByZWFkVGltZSwgXG4gICAgLyoqXG4gICAgICogVGhlIGtleSBvZiB0aGUgbGFzdCBkb2N1bWVudCB0aGF0IHdhcyBpbmRleGVkIGZvciB0aGlzIHF1ZXJ5LiBVc2VcbiAgICAgKiBgRG9jdW1lbnRLZXkuZW1wdHkoKWAgaWYgbm8gZG9jdW1lbnQgaGFzIGJlZW4gaW5kZXhlZC5cbiAgICAgKi9cbiAgICBkb2N1bWVudEtleSwgXG4gICAgLypcbiAgICAgKiBUaGUgbGFyZ2VzdCBtdXRhdGlvbiBiYXRjaCBpZCB0aGF0J3MgYmVlbiBwcm9jZXNzZWQgYnkgRmlyZXN0b3JlLlxuICAgICAqL1xuICAgIGxhcmdlc3RCYXRjaElkKSB7XG4gICAgICAgIHRoaXMucmVhZFRpbWUgPSByZWFkVGltZTtcbiAgICAgICAgdGhpcy5kb2N1bWVudEtleSA9IGRvY3VtZW50S2V5O1xuICAgICAgICB0aGlzLmxhcmdlc3RCYXRjaElkID0gbGFyZ2VzdEJhdGNoSWQ7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGFuIG9mZnNldCB0aGF0IHNvcnRzIGJlZm9yZSBhbGwgcmVndWxhciBvZmZzZXRzLiAqL1xuICAgIHN0YXRpYyBtaW4oKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhPZmZzZXQoU25hcHNob3RWZXJzaW9uLm1pbigpLCBEb2N1bWVudEtleS5lbXB0eSgpLCBJTklUSUFMX0xBUkdFU1RfQkFUQ0hfSUQpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhbiBvZmZzZXQgdGhhdCBzb3J0cyBhZnRlciBhbGwgcmVndWxhciBvZmZzZXRzLiAqL1xuICAgIHN0YXRpYyBtYXgoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhPZmZzZXQoU25hcHNob3RWZXJzaW9uLm1heCgpLCBEb2N1bWVudEtleS5lbXB0eSgpLCBJTklUSUFMX0xBUkdFU1RfQkFUQ0hfSUQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluZGV4T2Zmc2V0Q29tcGFyYXRvcihsZWZ0LCByaWdodCkge1xuICAgIGxldCBjbXAgPSBsZWZ0LnJlYWRUaW1lLmNvbXBhcmVUbyhyaWdodC5yZWFkVGltZSk7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gY21wO1xuICAgIH1cbiAgICBjbXAgPSBEb2N1bWVudEtleS5jb21wYXJhdG9yKGxlZnQuZG9jdW1lbnRLZXksIHJpZ2h0LmRvY3VtZW50S2V5KTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQubGFyZ2VzdEJhdGNoSWQsIHJpZ2h0Lmxhcmdlc3RCYXRjaElkKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IFBSSU1BUllfTEVBU0VfTE9TVF9FUlJPUl9NU0cgPSAnVGhlIGN1cnJlbnQgdGFiIGlzIG5vdCBpbiB0aGUgcmVxdWlyZWQgc3RhdGUgdG8gcGVyZm9ybSB0aGlzIG9wZXJhdGlvbi4gJyArXG4gICAgJ0l0IG1pZ2h0IGJlIG5lY2Vzc2FyeSB0byByZWZyZXNoIHRoZSBicm93c2VyIHRhYi4nO1xuLyoqXG4gKiBBIGJhc2UgY2xhc3MgcmVwcmVzZW50aW5nIGEgcGVyc2lzdGVuY2UgdHJhbnNhY3Rpb24sIGVuY2Fwc3VsYXRpbmcgYm90aCB0aGVcbiAqIHRyYW5zYWN0aW9uJ3Mgc2VxdWVuY2UgbnVtYmVycyBhcyB3ZWxsIGFzIGEgbGlzdCBvZiBvbkNvbW1pdHRlZCBsaXN0ZW5lcnMuXG4gKlxuICogV2hlbiB5b3UgY2FsbCBQZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbigpLCBpdCB3aWxsIGNyZWF0ZSBhIHRyYW5zYWN0aW9uIGFuZFxuICogcGFzcyBpdCB0byB5b3VyIGNhbGxiYWNrLiBZb3UgdGhlbiBwYXNzIGl0IHRvIGFueSBtZXRob2QgdGhhdCBvcGVyYXRlc1xuICogb24gcGVyc2lzdGVuY2UuXG4gKi9cbmNsYXNzIFBlcnNpc3RlbmNlVHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm9uQ29tbWl0dGVkTGlzdGVuZXJzID0gW107XG4gICAgfVxuICAgIGFkZE9uQ29tbWl0dGVkTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5vbkNvbW1pdHRlZExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgcmFpc2VPbkNvbW1pdHRlZEV2ZW50KCkge1xuICAgICAgICB0aGlzLm9uQ29tbWl0dGVkTGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIoKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBWZXJpZmllcyB0aGUgZXJyb3IgdGhyb3duIGJ5IGEgTG9jYWxTdG9yZSBvcGVyYXRpb24uIElmIGEgTG9jYWxTdG9yZVxuICogb3BlcmF0aW9uIGZhaWxzIGJlY2F1c2UgdGhlIHByaW1hcnkgbGVhc2UgaGFzIGJlZW4gdGFrZW4gYnkgYW5vdGhlciBjbGllbnQsXG4gKiB3ZSBpZ25vcmUgdGhlIGVycm9yICh0aGUgcGVyc2lzdGVuY2UgbGF5ZXIgd2lsbCBpbW1lZGlhdGVseSBjYWxsXG4gKiBgYXBwbHlQcmltYXJ5TGVhc2VgIHRvIHByb3BhZ2F0ZSB0aGUgcHJpbWFyeSBzdGF0ZSBjaGFuZ2UpLiBBbGwgb3RoZXIgZXJyb3JzXG4gKiBhcmUgcmUtdGhyb3duLlxuICpcbiAqIEBwYXJhbSBlcnIgLSBBbiBlcnJvciByZXR1cm5lZCBieSBhIExvY2FsU3RvcmUgb3BlcmF0aW9uLlxuICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgd2UgcmVjb3ZlcmVkLCBvciB0aGUgb3JpZ2luYWwgZXJyb3IuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGlnbm9yZUlmUHJpbWFyeUxlYXNlTG9zcyhlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgPT09IENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiAmJlxuICAgICAgICBlcnIubWVzc2FnZSA9PT0gUFJJTUFSWV9MRUFTRV9MT1NUX0VSUk9SX01TRykge1xuICAgICAgICBsb2dEZWJ1ZygnTG9jYWxTdG9yZScsICdVbmV4cGVjdGVkbHkgbG9zdCBwcmltYXJ5IGxlYXNlJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBQZXJzaXN0ZW5jZVByb21pc2UgaXMgZXNzZW50aWFsbHkgYSByZS1pbXBsZW1lbnRhdGlvbiBvZiBQcm9taXNlIGV4Y2VwdFxuICogaXQgaGFzIGEgLm5leHQoKSBtZXRob2QgaW5zdGVhZCBvZiAudGhlbigpIGFuZCAubmV4dCgpIGFuZCAuY2F0Y2goKSBjYWxsYmFja3NcbiAqIGFyZSBleGVjdXRlZCBzeW5jaHJvbm91c2x5IHdoZW4gYSBQZXJzaXN0ZW5jZVByb21pc2UgcmVzb2x2ZXMgcmF0aGVyIHRoYW5cbiAqIGFzeW5jaHJvbm91c2x5IChQcm9taXNlIGltcGxlbWVudGF0aW9ucyB1c2Ugc2V0SW1tZWRpYXRlKCkgb3Igc2ltaWxhcikuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgdG8gaW50ZXJvcGVyYXRlIHdpdGggSW5kZXhlZERCIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseVxuICogY29tbWl0IHRyYW5zYWN0aW9ucyBpZiBjb250cm9sIGlzIHJldHVybmVkIHRvIHRoZSBldmVudCBsb29wIHdpdGhvdXRcbiAqIHN5bmNocm9ub3VzbHkgaW5pdGlhdGluZyBhbm90aGVyIG9wZXJhdGlvbiBvbiB0aGUgdHJhbnNhY3Rpb24uXG4gKlxuICogTk9URTogLnRoZW4oKSBhbmQgLmNhdGNoKCkgb25seSBhbGxvdyBhIHNpbmdsZSBjb25zdW1lciwgdW5saWtlIG5vcm1hbFxuICogUHJvbWlzZXMuXG4gKi9cbmNsYXNzIFBlcnNpc3RlbmNlUHJvbWlzZSB7XG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2spIHtcbiAgICAgICAgLy8gTk9URTogbmV4dC9jYXRjaENhbGxiYWNrIHdpbGwgYWx3YXlzIHBvaW50IHRvIG91ciBvd24gd3JhcHBlciBmdW5jdGlvbnMsXG4gICAgICAgIC8vIG5vdCB0aGUgdXNlcidzIHJhdyBuZXh0KCkgb3IgY2F0Y2goKSBjYWxsYmFja3MuXG4gICAgICAgIHRoaXMubmV4dENhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYXRjaENhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgLy8gV2hlbiB0aGUgb3BlcmF0aW9uIHJlc29sdmVzLCB3ZSdsbCBzZXQgcmVzdWx0IG9yIGVycm9yIGFuZCBtYXJrIGlzRG9uZS5cbiAgICAgICAgdGhpcy5yZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaXNEb25lID0gZmFsc2U7XG4gICAgICAgIC8vIFNldCB0byB0cnVlIHdoZW4gLnRoZW4oKSBvciAuY2F0Y2goKSBhcmUgY2FsbGVkIGFuZCBwcmV2ZW50cyBhZGRpdGlvbmFsXG4gICAgICAgIC8vIGNoYWluaW5nLlxuICAgICAgICB0aGlzLmNhbGxiYWNrQXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgICAgY2FsbGJhY2sodmFsdWUgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc0RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHRDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIC8vIHZhbHVlIHNob3VsZCBiZSBkZWZpbmVkIHVubGVzcyBUIGlzIFZvaWQsIGJ1dCB3ZSBjYW4ndCBleHByZXNzXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBpbiB0aGUgdHlwZSBzeXN0ZW0uXG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbGJhY2sodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzRG9uZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICBpZiAodGhpcy5jYXRjaENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYXRjaENhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoKGZuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQodW5kZWZpbmVkLCBmbik7XG4gICAgfVxuICAgIG5leHQobmV4dEZuLCBjYXRjaEZuKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbGxiYWNrQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIGZhaWwoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGxiYWNrQXR0YWNoZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5pc0RvbmUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5lcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndyYXBTdWNjZXNzKG5leHRGbiwgdGhpcy5yZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JhcEZhaWx1cmUoY2F0Y2hGbiwgdGhpcy5lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbGJhY2sgPSAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cmFwU3VjY2VzcyhuZXh0Rm4sIHZhbHVlKS5uZXh0KHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhdGNoQ2FsbGJhY2sgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cmFwRmFpbHVyZShjYXRjaEZuLCBlcnJvcikubmV4dChyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1Byb21pc2UoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm5leHQocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHdyYXBVc2VyRnVuY3Rpb24oZm4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUGVyc2lzdGVuY2VQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cmFwU3VjY2VzcyhuZXh0Rm4sIHZhbHVlKSB7XG4gICAgICAgIGlmIChuZXh0Rm4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndyYXBVc2VyRnVuY3Rpb24oKCkgPT4gbmV4dEZuKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIG5leHRGbiwgdGhlbiBSIG11c3QgYmUgdGhlIHNhbWUgYXMgVFxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cmFwRmFpbHVyZShjYXRjaEZuLCBlcnJvcikge1xuICAgICAgICBpZiAoY2F0Y2hGbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JhcFVzZXJGdW5jdGlvbigoKSA9PiBjYXRjaEZuKGVycm9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHJlc29sdmUocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyByZWplY3QoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyB3YWl0Rm9yKFxuICAgIC8vIEFjY2VwdCBhbGwgUHJvbWlzZSB0eXBlcyBpbiB3YWl0Rm9yKCkuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBhbGwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IGV4cGVjdGVkQ291bnQgPSAwO1xuICAgICAgICAgICAgbGV0IHJlc29sdmVkQ291bnQgPSAwO1xuICAgICAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGFsbC5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgICsrZXhwZWN0ZWRDb3VudDtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICArK3Jlc29sdmVkQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lICYmIHJlc29sdmVkQ291bnQgPT09IGV4cGVjdGVkQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGVyciA9PiByZWplY3QoZXJyKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVkQ291bnQgPT09IGV4cGVjdGVkQ291bnQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbiBhcnJheSBvZiBwcmVkaWNhdGUgZnVuY3Rpb25zIHRoYXQgYXN5bmNocm9ub3VzbHkgZXZhbHVhdGUgdG8gYVxuICAgICAqIGJvb2xlYW4sIGltcGxlbWVudHMgYSBzaG9ydC1jaXJjdWl0aW5nIGBvcmAgYmV0d2VlbiB0aGUgcmVzdWx0cy4gUHJlZGljYXRlc1xuICAgICAqIHdpbGwgYmUgZXZhbHVhdGVkIHVudGlsIG9uZSBvZiB0aGVtIHJldHVybnMgYHRydWVgLCB0aGVuIHN0b3AuIFRoZSBmaW5hbFxuICAgICAqIHJlc3VsdCB3aWxsIGJlIHdoZXRoZXIgYW55IG9mIHRoZW0gcmV0dXJuZWQgYHRydWVgLlxuICAgICAqL1xuICAgIHN0YXRpYyBvcihwcmVkaWNhdGVzKSB7XG4gICAgICAgIGxldCBwID0gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICBmb3IgKGNvbnN0IHByZWRpY2F0ZSBvZiBwcmVkaWNhdGVzKSB7XG4gICAgICAgICAgICBwID0gcC5uZXh0KGlzVHJ1ZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoaXNUcnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVkaWNhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgc3RhdGljIGZvckVhY2goY29sbGVjdGlvbiwgZikge1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBjb2xsZWN0aW9uLmZvckVhY2goKHIsIHMpID0+IHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goZi5jYWxsKHRoaXMsIHIsIHMpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLndhaXRGb3IocHJvbWlzZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25jdXJyZW50bHkgbWFwIGFsbCBhcnJheSBlbGVtZW50cyB0aHJvdWdoIGFzeW5jaHJvbm91cyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgbWFwQXJyYXkoYXJyYXksIGYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRDb3VudCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkoZXhwZWN0ZWRDb3VudCk7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWRDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cGVjdGVkQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBpO1xuICAgICAgICAgICAgICAgIGYoYXJyYXlbY3VycmVudF0pLm5leHQocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tjdXJyZW50XSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgKytyZXNvbHZlZENvdW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWRDb3VudCA9PT0gZXhwZWN0ZWRDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGVyciA9PiByZWplY3QoZXJyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbiBhbHRlcm5hdGl2ZSB0byByZWN1cnNpdmUgUGVyc2lzdGVuY2VQcm9taXNlIGNhbGxzLCB0aGF0IGF2b2lkc1xuICAgICAqIHBvdGVudGlhbCBtZW1vcnkgcHJvYmxlbXMgZnJvbSB1bmJvdW5kZWQgY2hhaW5zIG9mIHByb21pc2VzLlxuICAgICAqXG4gICAgICogVGhlIGBhY3Rpb25gIHdpbGwgYmUgY2FsbGVkIHJlcGVhdGVkbHkgd2hpbGUgYGNvbmRpdGlvbmAgaXMgdHJ1ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZG9XaGlsZShjb25kaXRpb24sIGFjdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb25kaXRpb24oKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb24oKS5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcHJvY2VzcygpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBSZWZlcmVuY2VzIHRvIGB3aW5kb3dgIGFyZSBndWFyZGVkIGJ5IFNpbXBsZURiLmlzQXZhaWxhYmxlKClcbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xuY29uc3QgTE9HX1RBRyRpID0gJ1NpbXBsZURiJztcbi8qKlxuICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHJldHJ5IGF0dGVtcHRzIGZvciBhbiBJbmRleGVkRGIgdHJhbnNhY3Rpb24gdGhhdCBmYWlsc1xuICogd2l0aCBhIERPTUV4Y2VwdGlvbi5cbiAqL1xuY29uc3QgVFJBTlNBQ1RJT05fUkVUUllfQ09VTlQgPSAzO1xuLyoqXG4gKiBXcmFwcyBhbiBJREJUcmFuc2FjdGlvbiBhbmQgZXhwb3NlcyBhIHN0b3JlKCkgbWV0aG9kIHRvIGdldCBhIGhhbmRsZSB0byBhXG4gKiBzcGVjaWZpYyBvYmplY3Qgc3RvcmUuXG4gKi9cbmNsYXNzIFNpbXBsZURiVHJhbnNhY3Rpb24ge1xuICAgIHN0YXRpYyBvcGVuKGRiLCBhY3Rpb24sIG1vZGUsIG9iamVjdFN0b3JlTmFtZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2ltcGxlRGJUcmFuc2FjdGlvbihhY3Rpb24sIGRiLnRyYW5zYWN0aW9uKG9iamVjdFN0b3JlTmFtZXMsIG1vZGUpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEluZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoYWN0aW9uLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihhY3Rpb24sIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuYWN0aW9uID0gYWN0aW9uO1xuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gICAgICAgIHRoaXMuYWJvcnRlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIEluZGV4ZWREYiB0cmFuc2FjdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29tcGxldGlvbkRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGlvbkRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbi5vbmFib3J0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0aW9uRGVmZXJyZWQucmVqZWN0KG5ldyBJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGFjdGlvbiwgdHJhbnNhY3Rpb24uZXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGlvbkRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbi5vbmVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGNoZWNrRm9yQW5kUmVwb3J0aU9TRXJyb3IoZXZlbnQudGFyZ2V0LmVycm9yKTtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGlvbkRlZmVycmVkLnJlamVjdChuZXcgSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihhY3Rpb24sIGVycm9yKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCBjb21wbGV0aW9uUHJvbWlzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGlvbkRlZmVycmVkLnByb21pc2U7XG4gICAgfVxuICAgIGFib3J0KGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0aW9uRGVmZXJyZWQucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuYWJvcnRlZCkge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRpLCAnQWJvcnRpbmcgdHJhbnNhY3Rpb246JywgZXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0NsaWVudC1pbml0aWF0ZWQgYWJvcnQnKTtcbiAgICAgICAgICAgIHRoaXMuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWF5YmVDb21taXQoKSB7XG4gICAgICAgIC8vIElmIHRoZSBicm93c2VyIHN1cHBvcnRzIFYzIEluZGV4ZWREQiwgd2UgaW52b2tlIGNvbW1pdCgpIGV4cGxpY2l0bHkgdG9cbiAgICAgICAgLy8gc3BlZWQgdXAgaW5kZXggREIgcHJvY2Vzc2luZyBpZiB0aGUgZXZlbnQgbG9vcCByZW1haW5zIGJsb2Nrcy5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgbWF5YmVWM0luZGV4ZWREYiA9IHRoaXMudHJhbnNhY3Rpb247XG4gICAgICAgIGlmICghdGhpcy5hYm9ydGVkICYmIHR5cGVvZiBtYXliZVYzSW5kZXhlZERiLmNvbW1pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbWF5YmVWM0luZGV4ZWREYi5jb21taXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgU2ltcGxlRGJTdG9yZTxLZXlUeXBlLCBWYWx1ZVR5cGU+IGZvciB0aGUgc3BlY2lmaWVkIHN0b3JlLiBBbGxcbiAgICAgKiBvcGVyYXRpb25zIHBlcmZvcm1lZCBvbiB0aGUgU2ltcGxlRGJTdG9yZSBoYXBwZW4gd2l0aGluIHRoZSBjb250ZXh0IG9mIHRoaXNcbiAgICAgKiB0cmFuc2FjdGlvbiBhbmQgaXQgY2Fubm90IGJlIHVzZWQgYW55bW9yZSBvbmNlIHRoZSB0cmFuc2FjdGlvbiBpc1xuICAgICAqIGNvbXBsZXRlZC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB3ZSBjYW4ndCBhY3R1YWxseSBlbmZvcmNlIHRoYXQgdGhlIEtleVR5cGUgYW5kIFZhbHVlVHlwZSBhcmVcbiAgICAgKiBjb3JyZWN0LCBidXQgdGhleSBhbGxvdyB0eXBlIHNhZmV0eSB0aHJvdWdoIHRoZSByZXN0IG9mIHRoZSBjb25zdW1pbmcgY29kZS5cbiAgICAgKi9cbiAgICBzdG9yZShzdG9yZU5hbWUpIHtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSB0aGlzLnRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgICAgIHJldHVybiBuZXcgU2ltcGxlRGJTdG9yZShzdG9yZSk7XG4gICAgfVxufVxuLyoqXG4gKiBQcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIEluZGV4ZWREYiB3aXRoIGEgc2ltcGxpZmllZCBpbnRlcmZhY2UgdGhhdCB1c2VzXG4gKiBQcm9taXNlLWxpa2UgcmV0dXJuIHZhbHVlcyB0byBjaGFpbiBvcGVyYXRpb25zLiBSZWFsIHByb21pc2VzIGNhbm5vdCBiZSB1c2VkXG4gKiBzaW5jZSAudGhlbigpIGNvbnRpbnVhdGlvbnMgYXJlIGV4ZWN1dGVkIGFzeW5jaHJvbm91c2x5IChlLmcuIHZpYVxuICogLnNldEltbWVkaWF0ZSksIHdoaWNoIHdvdWxkIGNhdXNlIEluZGV4ZWREQiB0byBlbmQgdGhlIHRyYW5zYWN0aW9uLlxuICogU2VlIFBlcnNpc3RlbmNlUHJvbWlzZSBmb3IgbW9yZSBkZXRhaWxzLlxuICovXG5jbGFzcyBTaW1wbGVEYiB7XG4gICAgLyoqIERlbGV0ZXMgdGhlIHNwZWNpZmllZCBkYXRhYmFzZS4gKi9cbiAgICBzdGF0aWMgZGVsZXRlKG5hbWUpIHtcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRpLCAnUmVtb3ZpbmcgZGF0YWJhc2U6JywgbmFtZSk7XG4gICAgICAgIHJldHVybiB3cmFwUmVxdWVzdCh3aW5kb3cuaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKG5hbWUpKS50b1Byb21pc2UoKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiBJbmRleGVkREIgaXMgYXZhaWxhYmxlIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LiAqL1xuICAgIHN0YXRpYyBpc0F2YWlsYWJsZSgpIHtcbiAgICAgICAgaWYgKCFpc0luZGV4ZWREQkF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFNpbXBsZURiLmlzTW9ja1BlcnNpc3RlbmNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGV4dGVuc2l2ZWx5IHVzZSBpbmRleGVkIGFycmF5IHZhbHVlcyBhbmQgY29tcG91bmQga2V5cyxcbiAgICAgICAgLy8gd2hpY2ggSUUgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQuIEhvd2V2ZXIsIHRoZXkgc3RpbGwgaGF2ZSBpbmRleGVkREJcbiAgICAgICAgLy8gZGVmaW5lZCBvbiB0aGUgd2luZG93LCBzbyB3ZSBuZWVkIHRvIGNoZWNrIGZvciB0aGVtIGhlcmUgYW5kIG1ha2Ugc3VyZVxuICAgICAgICAvLyB0byByZXR1cm4gdGhhdCBwZXJzaXN0ZW5jZSBpcyBub3QgZW5hYmxlZCBmb3IgdGhvc2UgYnJvd3NlcnMuXG4gICAgICAgIC8vIEZvciB0cmFja2luZyBzdXBwb3J0IG9mIHRoaXMgZmVhdHVyZSwgc2VlIGhlcmU6XG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vc3RhdHVzL2luZGV4ZWRkYmFycmF5c2FuZG11bHRpZW50cnlzdXBwb3J0L1xuICAgICAgICAvLyBDaGVjayB0aGUgVUEgc3RyaW5nIHRvIGZpbmQgb3V0IHRoZSBicm93c2VyLlxuICAgICAgICBjb25zdCB1YSA9IGdldFVBKCk7XG4gICAgICAgIC8vIElFIDEwXG4gICAgICAgIC8vIHVhID0gJ01vemlsbGEvNS4wIChjb21wYXRpYmxlOyBNU0lFIDEwLjA7IFdpbmRvd3MgTlQgNi4yOyBUcmlkZW50LzYuMCknO1xuICAgICAgICAvLyBJRSAxMVxuICAgICAgICAvLyB1YSA9ICdNb3ppbGxhLzUuMCAoV2luZG93cyBOVCA2LjM7IFRyaWRlbnQvNy4wOyBydjoxMS4wKSBsaWtlIEdlY2tvJztcbiAgICAgICAgLy8gRWRnZVxuICAgICAgICAvLyB1YSA9ICdNb3ppbGxhLzUuMCAoV2luZG93cyBOVCAxMC4wOyBXT1c2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCxcbiAgICAgICAgLy8gbGlrZSBHZWNrbykgQ2hyb21lLzM5LjAuMjE3MS43MSBTYWZhcmkvNTM3LjM2IEVkZ2UvMTIuMCc7XG4gICAgICAgIC8vIGlPUyBTYWZhcmk6IERpc2FibGUgZm9yIHVzZXJzIHJ1bm5pbmcgaU9TIHZlcnNpb24gPCAxMC5cbiAgICAgICAgY29uc3QgaU9TVmVyc2lvbiA9IFNpbXBsZURiLmdldElPU1ZlcnNpb24odWEpO1xuICAgICAgICBjb25zdCBpc1Vuc3VwcG9ydGVkSU9TID0gMCA8IGlPU1ZlcnNpb24gJiYgaU9TVmVyc2lvbiA8IDEwO1xuICAgICAgICAvLyBBbmRyb2lkIGJyb3dzZXI6IERpc2FibGUgZm9yIHVzZXJzIHJ1bm5pbmcgdmVyc2lvbiA8IDQuNS5cbiAgICAgICAgY29uc3QgYW5kcm9pZFZlcnNpb24gPSBnZXRBbmRyb2lkVmVyc2lvbih1YSk7XG4gICAgICAgIGNvbnN0IGlzVW5zdXBwb3J0ZWRBbmRyb2lkID0gMCA8IGFuZHJvaWRWZXJzaW9uICYmIGFuZHJvaWRWZXJzaW9uIDwgNC41O1xuICAgICAgICBpZiAodWEuaW5kZXhPZignTVNJRSAnKSA+IDAgfHxcbiAgICAgICAgICAgIHVhLmluZGV4T2YoJ1RyaWRlbnQvJykgPiAwIHx8XG4gICAgICAgICAgICB1YS5pbmRleE9mKCdFZGdlLycpID4gMCB8fFxuICAgICAgICAgICAgaXNVbnN1cHBvcnRlZElPUyB8fFxuICAgICAgICAgICAgaXNVbnN1cHBvcnRlZEFuZHJvaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYmFja2luZyBJbmRleGVkREIgc3RvcmUgaXMgdGhlIE5vZGUgSW5kZXhlZERCU2hpbVxuICAgICAqIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2F4ZW1jbGlvbi9JbmRleGVkREJTaGltKS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNNb2NrUGVyc2lzdGVuY2UoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICgoX2EgPSBwcm9jZXNzLmVudikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLlVTRV9NT0NLX1BFUlNJU1RFTkNFKSA9PT0gJ1lFUycpO1xuICAgIH1cbiAgICAvKiogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZnJvbSBhIHRyYW5zYWN0aW9uLiAqL1xuICAgIHN0YXRpYyBnZXRTdG9yZSh0eG4sIHN0b3JlKSB7XG4gICAgICAgIHJldHVybiB0eG4uc3RvcmUoc3RvcmUpO1xuICAgIH1cbiAgICAvLyB2aXNpYmxlIGZvciB0ZXN0aW5nXG4gICAgLyoqIFBhcnNlIFVzZXIgQWdlbnQgdG8gZGV0ZXJtaW5lIGlPUyB2ZXJzaW9uLiBSZXR1cm5zIC0xIGlmIG5vdCBmb3VuZC4gKi9cbiAgICBzdGF0aWMgZ2V0SU9TVmVyc2lvbih1YSkge1xuICAgICAgICBjb25zdCBpT1NWZXJzaW9uUmVnZXggPSB1YS5tYXRjaCgvaSg/OnBob25lfHBhZHxwb2QpIG9zIChbXFxkX10rKS9pKTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IGlPU1ZlcnNpb25SZWdleFxuICAgICAgICAgICAgPyBpT1NWZXJzaW9uUmVnZXhbMV0uc3BsaXQoJ18nKS5zbGljZSgwLCAyKS5qb2luKCcuJylcbiAgICAgICAgICAgIDogJy0xJztcbiAgICAgICAgcmV0dXJuIE51bWJlcih2ZXJzaW9uKTtcbiAgICB9XG4gICAgLypcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNpbXBsZURiIHdyYXBwZXIgZm9yIEluZGV4ZWREYiBkYXRhYmFzZSBgbmFtZWAuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgYHZlcnNpb25gIG11c3Qgbm90IGJlIGEgZG93bmdyYWRlLiBJbmRleGVkREIgZG9lcyBub3Qgc3VwcG9ydFxuICAgICAqIGRvd25ncmFkaW5nIHRoZSBzY2hlbWEgdmVyc2lvbi4gV2UgY3VycmVudGx5IGRvIG5vdCBzdXBwb3J0IGFueSB3YXkgdG8gZG9cbiAgICAgKiB2ZXJzaW9uaW5nIG91dHNpZGUgb2YgSW5kZXhlZERCJ3MgdmVyc2lvbmluZyBtZWNoYW5pc20sIGFzIG9ubHlcbiAgICAgKiB2ZXJzaW9uLXVwZ3JhZGUgdHJhbnNhY3Rpb25zIGFyZSBhbGxvd2VkIHRvIGRvIHRoaW5ncyBsaWtlIGNyZWF0ZVxuICAgICAqIG9iamVjdHN0b3Jlcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB2ZXJzaW9uLCBzY2hlbWFDb252ZXJ0ZXIpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5zY2hlbWFDb252ZXJ0ZXIgPSBzY2hlbWFDb252ZXJ0ZXI7XG4gICAgICAgIGNvbnN0IGlPU1ZlcnNpb24gPSBTaW1wbGVEYi5nZXRJT1NWZXJzaW9uKGdldFVBKCkpO1xuICAgICAgICAvLyBOT1RFOiBBY2NvcmRpbmcgdG8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE5NzA1MCwgdGhlXG4gICAgICAgIC8vIGJ1ZyB3ZSdyZSBjaGVja2luZyBmb3Igc2hvdWxkIGV4aXN0IGluIGlPUyA+PSAxMi4yIGFuZCA8IDEzLCBidXQgZm9yXG4gICAgICAgIC8vIHdoYXRldmVyIHJlYXNvbiBpdCdzIG11Y2ggaGFyZGVyIHRvIGhpdCBhZnRlciAxMi4yIHNvIHdlIG9ubHkgcHJvYWN0aXZlbHlcbiAgICAgICAgLy8gbG9nIG9uIDEyLjIuXG4gICAgICAgIGlmIChpT1NWZXJzaW9uID09PSAxMi4yKSB7XG4gICAgICAgICAgICBsb2dFcnJvcignRmlyZXN0b3JlIHBlcnNpc3RlbmNlIHN1ZmZlcnMgZnJvbSBhIGJ1ZyBpbiBpT1MgMTIuMiAnICtcbiAgICAgICAgICAgICAgICAnU2FmYXJpIHRoYXQgbWF5IGNhdXNlIHlvdXIgYXBwIHRvIHN0b3Agd29ya2luZy4gU2VlICcgK1xuICAgICAgICAgICAgICAgICdodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvNTY0OTYyOTYvMTEwOTE1IGZvciBkZXRhaWxzICcgK1xuICAgICAgICAgICAgICAgICdhbmQgYSBwb3RlbnRpYWwgd29ya2Fyb3VuZC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVucyB0aGUgc3BlY2lmaWVkIGRhdGFiYXNlLCBjcmVhdGluZyBvciB1cGdyYWRpbmcgaXQgaWYgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIGFzeW5jIGVuc3VyZURiKGFjdGlvbikge1xuICAgICAgICBpZiAoIXRoaXMuZGIpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaSwgJ09wZW5pbmcgZGF0YWJhc2U6JywgdGhpcy5uYW1lKTtcbiAgICAgICAgICAgIHRoaXMuZGIgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhtaWtlbGVoZW4pOiBJbnZlc3RpZ2F0ZSBicm93c2VyIGNvbXBhdGliaWxpdHkuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0luZGV4ZWREQl9BUEkvVXNpbmdfSW5kZXhlZERCXG4gICAgICAgICAgICAgICAgLy8gc3VnZ2VzdHMgSUU5IGFuZCBvbGRlciBXZWJLaXQgYnJvd3NlcnMgaGFuZGxlIHVwZ3JhZGVcbiAgICAgICAgICAgICAgICAvLyBkaWZmZXJlbnRseS4gVGhleSBleHBlY3Qgc2V0VmVyc2lvbiwgYXMgZGVzY3JpYmVkIGhlcmU6XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0lEQlZlcnNpb25DaGFuZ2VSZXF1ZXN0L3NldFZlcnNpb25cbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4odGhpcy5uYW1lLCB0aGlzLnZlcnNpb24pO1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRiID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkYik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uYmxvY2tlZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGFjdGlvbiwgJ0Nhbm5vdCB1cGdyYWRlIEluZGV4ZWREQiBzY2hlbWEgd2hpbGUgYW5vdGhlciB0YWIgaXMgb3Blbi4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ2xvc2UgYWxsIHRhYnMgdGhhdCBhY2Nlc3MgRmlyZXN0b3JlIGFuZCByZWxvYWQgdGhpcyBwYWdlIHRvIHByb2NlZWQuJykpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZXZlbnQudGFyZ2V0LmVycm9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ1ZlcnNpb25FcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnQSBuZXdlciB2ZXJzaW9uIG9mIHRoZSBGaXJlc3RvcmUgU0RLIHdhcyBwcmV2aW91c2x5IHVzZWQgYW5kIHNvIHRoZSBwZXJzaXN0ZWQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgdmVyc2lvbiBvZiB0aGUgU0RLIHlvdSBhcmUgbm93IHVzaW5nLiBUaGUgU0RLICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd3aWxsIG9wZXJhdGUgd2l0aCBwZXJzaXN0ZW5jZSBkaXNhYmxlZC4gSWYgeW91IG5lZWQgcGVyc2lzdGVuY2UsIHBsZWFzZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmUtdXBncmFkZSB0byBhIG5ld2VyIHZlcnNpb24gb2YgdGhlIFNESyBvciBlbHNlIGNsZWFyIHRoZSBwZXJzaXN0ZWQgSW5kZXhlZERCICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhIGZvciB5b3VyIGFwcCB0byBzdGFydCBmcmVzaC4nKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ0ludmFsaWRTdGF0ZUVycm9yJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sICdVbmFibGUgdG8gb3BlbiBhbiBJbmRleGVkREIgY29ubmVjdGlvbi4gVGhpcyBjb3VsZCBiZSBkdWUgdG8gcnVubmluZyBpbiBhICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwcml2YXRlIGJyb3dzaW5nIHNlc3Npb24gb24gYSBicm93c2VyIHdob3NlIHByaXZhdGUgYnJvd3Npbmcgc2Vzc2lvbnMgZG8gbm90ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzdXBwb3J0IEluZGV4ZWREQjogJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihhY3Rpb24sIGVycm9yKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaSwgJ0RhdGFiYXNlIFwiJyArIHRoaXMubmFtZSArICdcIiByZXF1aXJlcyB1cGdyYWRlIGZyb20gdmVyc2lvbjonLCBldmVudC5vbGRWZXJzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGIgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjaGVtYUNvbnZlcnRlclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNyZWF0ZU9yVXBncmFkZShkYiwgcmVxdWVzdC50cmFuc2FjdGlvbiwgZXZlbnQub2xkVmVyc2lvbiwgdGhpcy52ZXJzaW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRpLCAnRGF0YWJhc2UgdXBncmFkZSB0byB2ZXJzaW9uICcgKyB0aGlzLnZlcnNpb24gKyAnIGNvbXBsZXRlJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52ZXJzaW9uY2hhbmdlbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZGIub252ZXJzaW9uY2hhbmdlID0gZXZlbnQgPT4gdGhpcy52ZXJzaW9uY2hhbmdlbGlzdGVuZXIoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRiO1xuICAgIH1cbiAgICBzZXRWZXJzaW9uQ2hhbmdlTGlzdGVuZXIodmVyc2lvbkNoYW5nZUxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMudmVyc2lvbmNoYW5nZWxpc3RlbmVyID0gdmVyc2lvbkNoYW5nZUxpc3RlbmVyO1xuICAgICAgICBpZiAodGhpcy5kYikge1xuICAgICAgICAgICAgdGhpcy5kYi5vbnZlcnNpb25jaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmVyc2lvbkNoYW5nZUxpc3RlbmVyKGV2ZW50KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcnVuVHJhbnNhY3Rpb24oYWN0aW9uLCBtb2RlLCBvYmplY3RTdG9yZXMsIHRyYW5zYWN0aW9uRm4pIHtcbiAgICAgICAgY29uc3QgcmVhZG9ubHkgPSBtb2RlID09PSAncmVhZG9ubHknO1xuICAgICAgICBsZXQgYXR0ZW1wdE51bWJlciA9IDA7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICArK2F0dGVtcHROdW1iZXI7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGIgPSBhd2FpdCB0aGlzLmVuc3VyZURiKGFjdGlvbik7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBTaW1wbGVEYlRyYW5zYWN0aW9uLm9wZW4odGhpcy5kYiwgYWN0aW9uLCByZWFkb25seSA/ICdyZWFkb25seScgOiAncmVhZHdyaXRlJywgb2JqZWN0U3RvcmVzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbkZuUmVzdWx0ID0gdHJhbnNhY3Rpb25Gbih0cmFuc2FjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgLm5leHQocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ubWF5YmVDb21taXQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBBYm9ydCB0aGUgdHJhbnNhY3Rpb24gaWYgdGhlcmUgd2FzIGFuIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5hYm9ydChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbm5vdCBhY3R1YWxseSByZWNvdmVyLCBhbmQgY2FsbGluZyBgYWJvcnQoKWAgd2lsbCBjYXVzZSB0aGUgdHJhbnNhY3Rpb24nc1xuICAgICAgICAgICAgICAgICAgICAvLyBjb21wbGV0aW9uIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQuIFRoaXMgaW4gdHVybiBtZWFucyB0aGF0IHdlIHdvbid0IHVzZVxuICAgICAgICAgICAgICAgICAgICAvLyBgdHJhbnNhY3Rpb25GblJlc3VsdGAgYmVsb3cuIFdlIHJldHVybiBhIHJlamVjdGlvbiBoZXJlIHNvIHRoYXQgd2UgZG9uJ3QgYWRkIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBwb3NzaWJpbGl0eSBvZiByZXR1cm5pbmcgYHZvaWRgIHRvIHRoZSB0eXBlIG9mIGB0cmFuc2FjdGlvbkZuUmVzdWx0YC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50b1Byb21pc2UoKTtcbiAgICAgICAgICAgICAgICAvLyBBcyBub3RlZCBhYm92ZSwgZXJyb3JzIGFyZSBwcm9wYWdhdGVkIGJ5IGFib3J0aW5nIHRoZSB0cmFuc2FjdGlvbi4gU29cbiAgICAgICAgICAgICAgICAvLyB3ZSBzd2FsbG93IGFueSBlcnJvciBoZXJlIHRvIGF2b2lkIHRoZSBicm93c2VyIGxvZ2dpbmcgaXQgYXMgdW5oYW5kbGVkLlxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uRm5SZXN1bHQuY2F0Y2goKCkgPT4geyB9KTtcbiAgICAgICAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgdHJhbnNhY3Rpb24gdG8gY29tcGxldGUgKGkuZS4gSW5kZXhlZERiJ3Mgb25zdWNjZXNzIGV2ZW50IHRvXG4gICAgICAgICAgICAgICAgLy8gZmlyZSksIGJ1dCBzdGlsbCByZXR1cm4gdGhlIG9yaWdpbmFsIHRyYW5zYWN0aW9uRm5SZXN1bHQgYmFjayB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyBjYWxsZXIuXG4gICAgICAgICAgICAgICAgYXdhaXQgdHJhbnNhY3Rpb24uY29tcGxldGlvblByb21pc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uRm5SZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKHNjaG1pZHQtc2ViYXN0aWFuKTogV2UgY291bGQgcHJvYmFibHkgYmUgc21hcnRlciBhYm91dCB0aGlzIGFuZFxuICAgICAgICAgICAgICAgIC8vIG5vdCByZXRyeSBleGNlcHRpb25zIHRoYXQgYXJlIGxpa2VseSB1bnJlY292ZXJhYmxlIChzdWNoIGFzIHF1b3RhXG4gICAgICAgICAgICAgICAgLy8gZXhjZWVkZWQgZXJyb3JzKS5cbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBXZSBjYW5ub3QgdXNlIGFuIGluc3RhbmNlb2YgY2hlY2sgZm9yIEZpcmVzdG9yZUV4Y2VwdGlvbiwgc2luY2UgdGhlXG4gICAgICAgICAgICAgICAgLy8gZXhjZXB0aW9uIGlzIHdyYXBwZWQgaW4gYSBnZW5lcmljIGVycm9yIGJ5IG91ciBhc3luYy9hd2FpdCBoYW5kbGluZy5cbiAgICAgICAgICAgICAgICBjb25zdCByZXRyeWFibGUgPSBlcnJvci5uYW1lICE9PSAnRmlyZWJhc2VFcnJvcicgJiZcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdE51bWJlciA8IFRSQU5TQUNUSU9OX1JFVFJZX0NPVU5UO1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaSwgJ1RyYW5zYWN0aW9uIGZhaWxlZCB3aXRoIGVycm9yOicsIGVycm9yLm1lc3NhZ2UsICdSZXRyeWluZzonLCByZXRyeWFibGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJldHJ5YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGIpIHtcbiAgICAgICAgICAgIHRoaXMuZGIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRiID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKiBQYXJzZSBVc2VyIEFnZW50IHRvIGRldGVybWluZSBBbmRyb2lkIHZlcnNpb24uIFJldHVybnMgLTEgaWYgbm90IGZvdW5kLiAqL1xuZnVuY3Rpb24gZ2V0QW5kcm9pZFZlcnNpb24odWEpIHtcbiAgICBjb25zdCBhbmRyb2lkVmVyc2lvblJlZ2V4ID0gdWEubWF0Y2goL0FuZHJvaWQgKFtcXGQuXSspL2kpO1xuICAgIGNvbnN0IHZlcnNpb24gPSBhbmRyb2lkVmVyc2lvblJlZ2V4XG4gICAgICAgID8gYW5kcm9pZFZlcnNpb25SZWdleFsxXS5zcGxpdCgnLicpLnNsaWNlKDAsIDIpLmpvaW4oJy4nKVxuICAgICAgICA6ICctMSc7XG4gICAgcmV0dXJuIE51bWJlcih2ZXJzaW9uKTtcbn1cbi8qKlxuICogQSBjb250cm9sbGVyIGZvciBpdGVyYXRpbmcgb3ZlciBhIGtleSByYW5nZSBvciBpbmRleC4gSXQgYWxsb3dzIGFuIGl0ZXJhdGVcbiAqIGNhbGxiYWNrIHRvIGRlbGV0ZSB0aGUgY3VycmVudGx5LXJlZmVyZW5jZWQgb2JqZWN0LCBvciBqdW1wIHRvIGEgbmV3IGtleVxuICogd2l0aGluIHRoZSBrZXkgcmFuZ2Ugb3IgaW5kZXguXG4gKi9cbmNsYXNzIEl0ZXJhdGlvbkNvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKGRiQ3Vyc29yKSB7XG4gICAgICAgIHRoaXMuZGJDdXJzb3IgPSBkYkN1cnNvcjtcbiAgICAgICAgdGhpcy5zaG91bGRTdG9wID0gZmFsc2U7XG4gICAgICAgIHRoaXMubmV4dEtleSA9IG51bGw7XG4gICAgfVxuICAgIGdldCBpc0RvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNob3VsZFN0b3A7XG4gICAgfVxuICAgIGdldCBza2lwVG9LZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRLZXk7XG4gICAgfVxuICAgIHNldCBjdXJzb3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy5kYkN1cnNvciA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgdG8gc3RvcCBpdGVyYXRpb24gYXQgYW55IHBvaW50LlxuICAgICAqL1xuICAgIGRvbmUoKSB7XG4gICAgICAgIHRoaXMuc2hvdWxkU3RvcCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIGNhbGxlZCB0byBza2lwIHRvIHRoYXQgbmV4dCBrZXksIHdoaWNoIGNvdWxkIGJlXG4gICAgICogYW4gaW5kZXggb3IgYSBwcmltYXJ5IGtleS5cbiAgICAgKi9cbiAgICBza2lwKGtleSkge1xuICAgICAgICB0aGlzLm5leHRLZXkgPSBrZXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSB0aGUgY3VycmVudCBjdXJzb3IgdmFsdWUgZnJvbSB0aGUgb2JqZWN0IHN0b3JlLlxuICAgICAqXG4gICAgICogTk9URTogWW91IENBTk5PVCBkbyB0aGlzIHdpdGggYSBrZXlzT25seSBxdWVyeS5cbiAgICAgKi9cbiAgICBkZWxldGUoKSB7XG4gICAgICAgIHJldHVybiB3cmFwUmVxdWVzdCh0aGlzLmRiQ3Vyc29yLmRlbGV0ZSgpKTtcbiAgICB9XG59XG4vKiogQW4gZXJyb3IgdGhhdCB3cmFwcyBleGNlcHRpb25zIHRoYXQgdGhyb3duIGR1cmluZyBJbmRleGVkREIgZXhlY3V0aW9uLiAqL1xuY2xhc3MgSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvciBleHRlbmRzIEZpcmVzdG9yZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihhY3Rpb25OYW1lLCBjYXVzZSkge1xuICAgICAgICBzdXBlcihDb2RlLlVOQVZBSUxBQkxFLCBgSW5kZXhlZERCIHRyYW5zYWN0aW9uICcke2FjdGlvbk5hbWV9JyBmYWlsZWQ6ICR7Y2F1c2V9YCk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yJztcbiAgICB9XG59XG4vKiogVmVyaWZpZXMgd2hldGhlciBgZWAgaXMgYW4gSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvci4gKi9cbmZ1bmN0aW9uIGlzSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihlKSB7XG4gICAgLy8gVXNlIG5hbWUgZXF1YWxpdHksIGFzIGluc3RhbmNlb2YgY2hlY2tzIG9uIGVycm9ycyBkb24ndCB3b3JrIHdpdGggZXJyb3JzXG4gICAgLy8gdGhhdCB3cmFwIG90aGVyIGVycm9ycy5cbiAgICByZXR1cm4gZS5uYW1lID09PSAnSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcic7XG59XG4vKipcbiAqIEEgd3JhcHBlciBhcm91bmQgYW4gSURCT2JqZWN0U3RvcmUgcHJvdmlkaW5nIGFuIEFQSSB0aGF0OlxuICpcbiAqIDEpIEhhcyBnZW5lcmljIEtleVR5cGUgLyBWYWx1ZVR5cGUgcGFyYW1ldGVycyB0byBwcm92aWRlIHN0cm9uZ2x5LXR5cGVkXG4gKiBtZXRob2RzIGZvciBhY3RpbmcgYWdhaW5zdCB0aGUgb2JqZWN0IHN0b3JlLlxuICogMikgRGVhbHMgd2l0aCBJbmRleGVkREIncyBvbnN1Y2Nlc3MgLyBvbmVycm9yIGV2ZW50IGNhbGxiYWNrcywgbWFraW5nIGV2ZXJ5XG4gKiBtZXRob2QgcmV0dXJuIGEgUGVyc2lzdGVuY2VQcm9taXNlIGluc3RlYWQuXG4gKiAzKSBQcm92aWRlcyBhIGhpZ2hlci1sZXZlbCBBUEkgdG8gYXZvaWQgbmVlZGluZyB0byBkbyBleGNlc3NpdmUgd3JhcHBpbmcgb2ZcbiAqIGludGVybWVkaWF0ZSBJbmRleGVkREIgdHlwZXMgKElEQkN1cnNvcldpdGhWYWx1ZSwgZXRjLilcbiAqL1xuY2xhc3MgU2ltcGxlRGJTdG9yZSB7XG4gICAgY29uc3RydWN0b3Ioc3RvcmUpIHtcbiAgICAgICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xuICAgIH1cbiAgICBwdXQoa2V5T3JWYWx1ZSwgdmFsdWUpIHtcbiAgICAgICAgbGV0IHJlcXVlc3Q7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGksICdQVVQnLCB0aGlzLnN0b3JlLm5hbWUsIGtleU9yVmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIHJlcXVlc3QgPSB0aGlzLnN0b3JlLnB1dCh2YWx1ZSwga2V5T3JWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGksICdQVVQnLCB0aGlzLnN0b3JlLm5hbWUsICc8YXV0by1rZXk+Jywga2V5T3JWYWx1ZSk7XG4gICAgICAgICAgICByZXF1ZXN0ID0gdGhpcy5zdG9yZS5wdXQoa2V5T3JWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyYXBSZXF1ZXN0KHJlcXVlc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IHZhbHVlIGludG8gYW4gT2JqZWN0IFN0b3JlIGFuZCByZXR1cm5zIHRoZSBuZXcga2V5LiBTaW1pbGFyIHRvXG4gICAgICogSW5kZXhlZERiJ3MgYGFkZCgpYCwgdGhpcyBtZXRob2Qgd2lsbCBmYWlsIG9uIHByaW1hcnkga2V5IGNvbGxpc2lvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgb2JqZWN0IHRvIHdyaXRlLlxuICAgICAqIEByZXR1cm5zIFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGFkZC5cbiAgICAgKi9cbiAgICBhZGQodmFsdWUpIHtcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRpLCAnQUREJywgdGhpcy5zdG9yZS5uYW1lLCB2YWx1ZSwgdmFsdWUpO1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5zdG9yZS5hZGQodmFsdWUpO1xuICAgICAgICByZXR1cm4gd3JhcFJlcXVlc3QocmVxdWVzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5IGZyb20gdGhlIHNwZWNpZmllZCBzdG9yZSwgb3IgbnVsbFxuICAgICAqIGlmIG5vIG9iamVjdCBleGlzdHMgd2l0aCB0aGUgc3BlY2lmaWVkIGtleS5cbiAgICAgKlxuICAgICAqIEBrZXkgVGhlIGtleSBvZiB0aGUgb2JqZWN0IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyBUaGUgb2JqZWN0IHdpdGggdGhlIHNwZWNpZmllZCBrZXkgb3IgbnVsbCBpZiBubyBvYmplY3QgZXhpc3RzLlxuICAgICAqL1xuICAgIGdldChrZXkpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuc3RvcmUuZ2V0KGtleSk7XG4gICAgICAgIC8vIFdlJ3JlIGRvaW5nIGFuIHVuc2FmZSBjYXN0IHRvIFZhbHVlVHlwZS5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIHdyYXBSZXF1ZXN0KHJlcXVlc3QpLm5leHQocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBub25leGlzdGVuY2UgdG8gbnVsbC5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGksICdHRVQnLCB0aGlzLnN0b3JlLm5hbWUsIGtleSwgcmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckaSwgJ0RFTEVURScsIHRoaXMuc3RvcmUubmFtZSwga2V5KTtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuc3RvcmUuZGVsZXRlKGtleSk7XG4gICAgICAgIHJldHVybiB3cmFwUmVxdWVzdChyZXF1ZXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgd2UgZXZlciBuZWVkIG1vcmUgb2YgdGhlIGNvdW50IHZhcmlhbnRzLCB3ZSBjYW4gYWRkIG92ZXJsb2Fkcy4gRm9yIG5vdyxcbiAgICAgKiBhbGwgd2UgbmVlZCBpcyB0byBjb3VudCBldmVyeXRoaW5nIGluIGEgc3RvcmUuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgc3RvcmUuXG4gICAgICovXG4gICAgY291bnQoKSB7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckaSwgJ0NPVU5UJywgdGhpcy5zdG9yZS5uYW1lKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuc3RvcmUuY291bnQoKTtcbiAgICAgICAgcmV0dXJuIHdyYXBSZXF1ZXN0KHJlcXVlc3QpO1xuICAgIH1cbiAgICBsb2FkQWxsKGluZGV4T3JSYW5nZSwgcmFuZ2UpIHtcbiAgICAgICAgY29uc3QgaXRlcmF0ZU9wdGlvbnMgPSB0aGlzLm9wdGlvbnMoaW5kZXhPclJhbmdlLCByYW5nZSk7XG4gICAgICAgIC8vIFVzZSBgZ2V0QWxsKClgIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIEluZGV4ZWREQiB2MywgYXMgaXQgaXMgcm91Z2hseVxuICAgICAgICAvLyAyMCUgZmFzdGVyLlxuICAgICAgICBjb25zdCBzdG9yZSA9IGl0ZXJhdGVPcHRpb25zLmluZGV4XG4gICAgICAgICAgICA/IHRoaXMuc3RvcmUuaW5kZXgoaXRlcmF0ZU9wdGlvbnMuaW5kZXgpXG4gICAgICAgICAgICA6IHRoaXMuc3RvcmU7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RvcmUuZ2V0QWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZ2V0QWxsKGl0ZXJhdGVPcHRpb25zLnJhbmdlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGV2ZW50LnRhcmdldC5lcnJvcik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGV2ZW50LnRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnNvciA9IHRoaXMuY3Vyc29yKGl0ZXJhdGVPcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdGVDdXJzb3IoY3Vyc29yLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9KS5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWRzIHRoZSBmaXJzdCBgY291bnRgIGVsZW1lbnRzIGZyb20gdGhlIHByb3ZpZGVkIGluZGV4IHJhbmdlLiBMb2FkcyBhbGxcbiAgICAgKiBlbGVtZW50cyBpZiBubyBsaW1pdCBpcyBwcm92aWRlZC5cbiAgICAgKi9cbiAgICBsb2FkRmlyc3QocmFuZ2UsIGNvdW50KSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLnN0b3JlLmdldEFsbChyYW5nZSwgY291bnQgPT09IG51bGwgPyB1bmRlZmluZWQgOiBjb3VudCk7XG4gICAgICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChldmVudC50YXJnZXQuZXJyb3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShldmVudC50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWxldGVBbGwoaW5kZXhPclJhbmdlLCByYW5nZSkge1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGksICdERUxFVEUgQUxMJywgdGhpcy5zdG9yZS5uYW1lKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyhpbmRleE9yUmFuZ2UsIHJhbmdlKTtcbiAgICAgICAgb3B0aW9ucy5rZXlzT25seSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjdXJzb3IgPSB0aGlzLmN1cnNvcihvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0ZUN1cnNvcihjdXJzb3IsIChrZXksIHZhbHVlLCBjb250cm9sKSA9PiB7XG4gICAgICAgICAgICAvLyBOT1RFOiBDYWxsaW5nIGRlbGV0ZSgpIG9uIGEgY3Vyc29yIGlzIGRvY3VtZW50ZWQgYXMgbW9yZSBlZmZpY2llbnQgdGhhblxuICAgICAgICAgICAgLy8gY2FsbGluZyBkZWxldGUoKSBvbiBhbiBvYmplY3Qgc3RvcmUgd2l0aCBhIHNpbmdsZSBrZXlcbiAgICAgICAgICAgIC8vIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSURCT2JqZWN0U3RvcmUvZGVsZXRlKSxcbiAgICAgICAgICAgIC8vIGhvd2V2ZXIsIHRoaXMgcmVxdWlyZXMgdXMgKm5vdCogdG8gdXNlIGEga2V5c09ubHkgY3Vyc29yXG4gICAgICAgICAgICAvLyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0lEQkN1cnNvci9kZWxldGUpLiBXZVxuICAgICAgICAgICAgLy8gbWF5IHdhbnQgdG8gY29tcGFyZSB0aGUgcGVyZm9ybWFuY2Ugb2YgZWFjaCBtZXRob2QuXG4gICAgICAgICAgICByZXR1cm4gY29udHJvbC5kZWxldGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGl0ZXJhdGUob3B0aW9uc09yQ2FsbGJhY2ssIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBvcHRpb25zO1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnNPckNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPckNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnNvciA9IHRoaXMuY3Vyc29yKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRlQ3Vyc29yKGN1cnNvciwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGEgc3RvcmUsIGJ1dCB3YWl0cyBmb3IgdGhlIGdpdmVuIGNhbGxiYWNrIHRvIGNvbXBsZXRlIGZvclxuICAgICAqIGVhY2ggZW50cnkgYmVmb3JlIGl0ZXJhdGluZyB0aGUgbmV4dCBlbnRyeS4gVGhpcyBhbGxvd3MgdGhlIGNhbGxiYWNrIHRvIGRvXG4gICAgICogYXN5bmNocm9ub3VzIHdvcmsgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgaXRlcmF0aW9uIHNob3VsZCBjb250aW51ZS5cbiAgICAgKlxuICAgICAqIFRoZSBwcm92aWRlZCBjYWxsYmFjayBzaG91bGQgcmV0dXJuIGB0cnVlYCB0byBjb250aW51ZSBpdGVyYXRpb24sIGFuZFxuICAgICAqIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGl0ZXJhdGVTZXJpYWwoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgY3Vyc29yUmVxdWVzdCA9IHRoaXMuY3Vyc29yKHt9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY3Vyc29yUmVxdWVzdC5vbmVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBjaGVja0ZvckFuZFJlcG9ydGlPU0Vycm9yKGV2ZW50LnRhcmdldC5lcnJvcik7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjdXJzb3JSZXF1ZXN0Lm9uc3VjY2VzcyA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvciA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGN1cnNvci5wcmltYXJ5S2V5LCBjdXJzb3IudmFsdWUpLm5leHQoc2hvdWxkQ29udGludWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkQ29udGludWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaXRlcmF0ZUN1cnNvcihjdXJzb3JSZXF1ZXN0LCBmbikge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGN1cnNvclJlcXVlc3Qub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChldmVudC50YXJnZXQuZXJyb3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGN1cnNvclJlcXVlc3Qub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBJdGVyYXRpb25Db250cm9sbGVyKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgY29uc3QgdXNlclJlc3VsdCA9IGZuKGN1cnNvci5wcmltYXJ5S2V5LCBjdXJzb3IudmFsdWUsIGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgIGlmICh1c2VyUmVzdWx0IGluc3RhbmNlb2YgUGVyc2lzdGVuY2VQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJQcm9taXNlID0gdXNlclJlc3VsdC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5kb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHVzZXJQcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuaXNEb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udHJvbGxlci5za2lwVG9LZXkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoY29udHJvbGxlci5za2lwVG9LZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pLm5leHQoKCkgPT4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocmVzdWx0cykpO1xuICAgIH1cbiAgICBvcHRpb25zKGluZGV4T3JSYW5nZSwgcmFuZ2UpIHtcbiAgICAgICAgbGV0IGluZGV4TmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGluZGV4T3JSYW5nZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4T3JSYW5nZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbmRleE5hbWUgPSBpbmRleE9yUmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByYW5nZSA9IGluZGV4T3JSYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBpbmRleDogaW5kZXhOYW1lLCByYW5nZSB9O1xuICAgIH1cbiAgICBjdXJzb3Iob3B0aW9ucykge1xuICAgICAgICBsZXQgZGlyZWN0aW9uID0gJ25leHQnO1xuICAgICAgICBpZiAob3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSAncHJldic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zdG9yZS5pbmRleChvcHRpb25zLmluZGV4KTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmtleXNPbmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4Lm9wZW5LZXlDdXJzb3Iob3B0aW9ucy5yYW5nZSwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleC5vcGVuQ3Vyc29yKG9wdGlvbnMucmFuZ2UsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5vcGVuQ3Vyc29yKG9wdGlvbnMucmFuZ2UsIGRpcmVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFdyYXBzIGFuIElEQlJlcXVlc3QgaW4gYSBQZXJzaXN0ZW5jZVByb21pc2UsIHVzaW5nIHRoZSBvbnN1Y2Nlc3MgLyBvbmVycm9yXG4gKiBoYW5kbGVycyB0byByZXNvbHZlIC8gcmVqZWN0IHRoZSBQZXJzaXN0ZW5jZVByb21pc2UgYXMgYXBwcm9wcmlhdGUuXG4gKi9cbmZ1bmN0aW9uIHdyYXBSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gY2hlY2tGb3JBbmRSZXBvcnRpT1NFcnJvcihldmVudC50YXJnZXQuZXJyb3IpO1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbi8vIEd1YXJkIHNvIHdlIG9ubHkgcmVwb3J0IHRoZSBlcnJvciBvbmNlLlxubGV0IHJlcG9ydGVkSU9TRXJyb3IgPSBmYWxzZTtcbmZ1bmN0aW9uIGNoZWNrRm9yQW5kUmVwb3J0aU9TRXJyb3IoZXJyb3IpIHtcbiAgICBjb25zdCBpT1NWZXJzaW9uID0gU2ltcGxlRGIuZ2V0SU9TVmVyc2lvbihnZXRVQSgpKTtcbiAgICBpZiAoaU9TVmVyc2lvbiA+PSAxMi4yICYmIGlPU1ZlcnNpb24gPCAxMykge1xuICAgICAgICBjb25zdCBJT1NfRVJST1IgPSAnQW4gaW50ZXJuYWwgZXJyb3Igd2FzIGVuY291bnRlcmVkIGluIHRoZSBJbmRleGVkIERhdGFiYXNlIHNlcnZlcic7XG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluZGV4T2YoSU9TX0VSUk9SKSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBXcmFwIGVycm9yIGluIGEgbW9yZSBkZXNjcmlwdGl2ZSBvbmUuXG4gICAgICAgICAgICBjb25zdCBuZXdFcnJvciA9IG5ldyBGaXJlc3RvcmVFcnJvcignaW50ZXJuYWwnLCBgSU9TX0lOREVYRUREQl9CVUcxOiBJbmRleGVkRGIgaGFzIHRocm93biAnJHtJT1NfRVJST1J9Jy4gVGhpcyBpcyBsaWtlbHkgYCArXG4gICAgICAgICAgICAgICAgYGR1ZSB0byBhbiB1bmF2b2lkYWJsZSBidWcgaW4gaU9TLiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzU2NDk2Mjk2LzExMDkxNSBgICtcbiAgICAgICAgICAgICAgICBgZm9yIGRldGFpbHMgYW5kIGEgcG90ZW50aWFsIHdvcmthcm91bmQuYCk7XG4gICAgICAgICAgICBpZiAoIXJlcG9ydGVkSU9TRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXBvcnRlZElPU0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBUaHJvdyBhIGdsb2JhbCBleGNlcHRpb24gb3V0c2lkZSBvZiB0aGlzIHByb21pc2UgY2hhaW4sIGZvciB0aGUgdXNlciB0b1xuICAgICAgICAgICAgICAgIC8vIHBvdGVudGlhbGx5IGNhdGNoLlxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXdFcnJvcjtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdFcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG59XG5cbmNvbnN0IExPR19UQUckaCA9ICdJbmRleEJhY2tmaWxsZXInO1xuLyoqIEhvdyBsb25nIHdlIHdhaXQgdG8gdHJ5IHJ1bm5pbmcgaW5kZXggYmFja2ZpbGwgYWZ0ZXIgU0RLIGluaXRpYWxpemF0aW9uLiAqL1xuY29uc3QgSU5JVElBTF9CQUNLRklMTF9ERUxBWV9NUyA9IDE1ICogMTAwMDtcbi8qKiBNaW5pbXVtIGFtb3VudCBvZiB0aW1lIGJldHdlZW4gYmFja2ZpbGwgY2hlY2tzLCBhZnRlciB0aGUgZmlyc3Qgb25lLiAqL1xuY29uc3QgUkVHVUxBUl9CQUNLRklMTF9ERUxBWV9NUyA9IDYwICogMTAwMDtcbi8qKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgZG9jdW1lbnRzIHRvIHByb2Nlc3MgZWFjaCB0aW1lIGJhY2tmaWxsKCkgaXMgY2FsbGVkLiAqL1xuY29uc3QgTUFYX0RPQ1VNRU5UU19UT19QUk9DRVNTID0gNTA7XG4vKiogVGhpcyBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgdGhlIHNjaGVkdWxpbmcgb2YgSW5kZXggQmFja2ZpbGxlci4gKi9cbmNsYXNzIEluZGV4QmFja2ZpbGxlclNjaGVkdWxlciB7XG4gICAgY29uc3RydWN0b3IoYXN5bmNRdWV1ZSwgYmFja2ZpbGxlcikge1xuICAgICAgICB0aGlzLmFzeW5jUXVldWUgPSBhc3luY1F1ZXVlO1xuICAgICAgICB0aGlzLmJhY2tmaWxsZXIgPSBiYWNrZmlsbGVyO1xuICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZShJTklUSUFMX0JBQ0tGSUxMX0RFTEFZX01TKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMudGFzaykge1xuICAgICAgICAgICAgdGhpcy50YXNrLmNhbmNlbCgpO1xuICAgICAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgc3RhcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFzayAhPT0gbnVsbDtcbiAgICB9XG4gICAgc2NoZWR1bGUoZGVsYXkpIHtcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRoLCBgU2NoZWR1bGVkIGluICR7ZGVsYXl9bXNgKTtcbiAgICAgICAgdGhpcy50YXNrID0gdGhpcy5hc3luY1F1ZXVlLmVucXVldWVBZnRlckRlbGF5KFwiaW5kZXhfYmFja2ZpbGxcIiAvKiBUaW1lcklkLkluZGV4QmFja2ZpbGwgKi8sIGRlbGF5LCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudHNQcm9jZXNzZWQgPSBhd2FpdCB0aGlzLmJhY2tmaWxsZXIuYmFja2ZpbGwoKTtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGgsIGBEb2N1bWVudHMgd3JpdHRlbjogJHtkb2N1bWVudHNQcm9jZXNzZWR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0luZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRoLCAnSWdub3JpbmcgSW5kZXhlZERCIGVycm9yIGR1cmluZyBpbmRleCBiYWNrZmlsbDogJywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBpZ25vcmVJZlByaW1hcnlMZWFzZUxvc3MoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zY2hlZHVsZShSRUdVTEFSX0JBQ0tGSUxMX0RFTEFZX01TKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIEltcGxlbWVudHMgdGhlIHN0ZXBzIGZvciBiYWNrZmlsbGluZyBpbmRleGVzLiAqL1xuY2xhc3MgSW5kZXhCYWNrZmlsbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBMb2NhbFN0b3JlIHByb3ZpZGVzIGFjY2VzcyB0byBJbmRleE1hbmFnZXIgYW5kIExvY2FsRG9jdW1lbnRWaWV3LlxuICAgICAqIFRoZXNlIHByb3BlcnRpZXMgd2lsbCB1cGRhdGUgd2hlbiB0aGUgdXNlciBjaGFuZ2VzLiBDb25zZXF1ZW50bHksXG4gICAgICogbWFraW5nIGEgbG9jYWwgY29weSBvZiBJbmRleE1hbmFnZXIgYW5kIExvY2FsRG9jdW1lbnRWaWV3IHdpbGwgcmVxdWlyZVxuICAgICAqIHVwZGF0ZXMgb3ZlciB0aW1lLiBUaGUgc2ltcGxlciBzb2x1dGlvbiBpcyB0byByZWx5IG9uIExvY2FsU3RvcmUgdG8gaGF2ZVxuICAgICAqIGFuIHVwLXRvLWRhdGUgcmVmZXJlbmNlcyB0byBJbmRleE1hbmFnZXIgYW5kIExvY2FsRG9jdW1lbnRTdG9yZS5cbiAgICAgKi9cbiAgICBsb2NhbFN0b3JlLCBwZXJzaXN0ZW5jZSkge1xuICAgICAgICB0aGlzLmxvY2FsU3RvcmUgPSBsb2NhbFN0b3JlO1xuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlID0gcGVyc2lzdGVuY2U7XG4gICAgfVxuICAgIGFzeW5jIGJhY2tmaWxsKG1heERvY3VtZW50c1RvUHJvY2VzcyA9IE1BWF9ET0NVTUVOVFNfVE9fUFJPQ0VTUykge1xuICAgICAgICByZXR1cm4gdGhpcy5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignQmFja2ZpbGwgSW5kZXhlcycsICdyZWFkd3JpdGUtcHJpbWFyeScsIHR4biA9PiB0aGlzLndyaXRlSW5kZXhFbnRyaWVzKHR4biwgbWF4RG9jdW1lbnRzVG9Qcm9jZXNzKSk7XG4gICAgfVxuICAgIC8qKiBXcml0ZXMgaW5kZXggZW50cmllcyB1bnRpbCB0aGUgY2FwIGlzIHJlYWNoZWQuIFJldHVybnMgdGhlIG51bWJlciBvZiBkb2N1bWVudHMgcHJvY2Vzc2VkLiAqL1xuICAgIHdyaXRlSW5kZXhFbnRyaWVzKHRyYW5zYWN0aW9uLCBtYXhEb2N1bWVudHNUb1Byb2Nlc3MpIHtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkQ29sbGVjdGlvbkdyb3VwcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgbGV0IGRvY3VtZW50c1JlbWFpbmluZyA9IG1heERvY3VtZW50c1RvUHJvY2VzcztcbiAgICAgICAgbGV0IGNvbnRpbnVlTG9vcCA9IHRydWU7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZG9XaGlsZSgoKSA9PiBjb250aW51ZUxvb3AgPT09IHRydWUgJiYgZG9jdW1lbnRzUmVtYWluaW5nID4gMCwgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxTdG9yZS5pbmRleE1hbmFnZXJcbiAgICAgICAgICAgICAgICAuZ2V0TmV4dENvbGxlY3Rpb25Hcm91cFRvVXBkYXRlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgIC5uZXh0KChjb2xsZWN0aW9uR3JvdXApID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29sbGVjdGlvbkdyb3VwID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZENvbGxlY3Rpb25Hcm91cHMuaGFzKGNvbGxlY3Rpb25Hcm91cCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVMb29wID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGgsIGBQcm9jZXNzaW5nIGNvbGxlY3Rpb246ICR7Y29sbGVjdGlvbkdyb3VwfWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53cml0ZUVudHJpZXNGb3JDb2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCwgZG9jdW1lbnRzUmVtYWluaW5nKS5uZXh0KGRvY3VtZW50c1Byb2Nlc3NlZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudHNSZW1haW5pbmcgLT0gZG9jdW1lbnRzUHJvY2Vzc2VkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkQ29sbGVjdGlvbkdyb3Vwcy5hZGQoY29sbGVjdGlvbkdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLm5leHQoKCkgPT4gbWF4RG9jdW1lbnRzVG9Qcm9jZXNzIC0gZG9jdW1lbnRzUmVtYWluaW5nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGVudHJpZXMgZm9yIHRoZSBwcm92aWRlZCBjb2xsZWN0aW9uIGdyb3VwLiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIHByb2Nlc3NlZC5cbiAgICAgKi9cbiAgICB3cml0ZUVudHJpZXNGb3JDb2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCwgZG9jdW1lbnRzUmVtYWluaW5nVW5kZXJDYXApIHtcbiAgICAgICAgLy8gVXNlIHRoZSBlYXJsaWVzdCBvZmZzZXQgb2YgYWxsIGZpZWxkIGluZGV4ZXMgdG8gcXVlcnkgdGhlIGxvY2FsIGNhY2hlLlxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFN0b3JlLmluZGV4TWFuYWdlclxuICAgICAgICAgICAgLmdldE1pbk9mZnNldEZyb21Db2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cClcbiAgICAgICAgICAgIC5uZXh0KGV4aXN0aW5nT2Zmc2V0ID0+IHRoaXMubG9jYWxTdG9yZS5sb2NhbERvY3VtZW50c1xuICAgICAgICAgICAgLmdldE5leHREb2N1bWVudHModHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCwgZXhpc3RpbmdPZmZzZXQsIGRvY3VtZW50c1JlbWFpbmluZ1VuZGVyQ2FwKVxuICAgICAgICAgICAgLm5leHQobmV4dEJhdGNoID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRvY3MgPSBuZXh0QmF0Y2guY2hhbmdlcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsU3RvcmUuaW5kZXhNYW5hZ2VyXG4gICAgICAgICAgICAgICAgLnVwZGF0ZUluZGV4RW50cmllcyh0cmFuc2FjdGlvbiwgZG9jcylcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiB0aGlzLmdldE5ld09mZnNldChleGlzdGluZ09mZnNldCwgbmV4dEJhdGNoKSlcbiAgICAgICAgICAgICAgICAubmV4dChuZXdPZmZzZXQgPT4ge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaCwgYFVwZGF0aW5nIG9mZnNldDogJHtuZXdPZmZzZXR9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxTdG9yZS5pbmRleE1hbmFnZXIudXBkYXRlQ29sbGVjdGlvbkdyb3VwKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIG5ld09mZnNldCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IGRvY3Muc2l6ZSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdGhlIG5leHQgb2Zmc2V0IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBkb2N1bWVudHMuICovXG4gICAgZ2V0TmV3T2Zmc2V0KGV4aXN0aW5nT2Zmc2V0LCBsb29rdXBSZXN1bHQpIHtcbiAgICAgICAgbGV0IG1heE9mZnNldCA9IGV4aXN0aW5nT2Zmc2V0O1xuICAgICAgICBsb29rdXBSZXN1bHQuY2hhbmdlcy5mb3JFYWNoKChrZXksIGRvY3VtZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdPZmZzZXQgPSBuZXdJbmRleE9mZnNldEZyb21Eb2N1bWVudChkb2N1bWVudCk7XG4gICAgICAgICAgICBpZiAoaW5kZXhPZmZzZXRDb21wYXJhdG9yKG5ld09mZnNldCwgbWF4T2Zmc2V0KSA+IDApIHtcbiAgICAgICAgICAgICAgICBtYXhPZmZzZXQgPSBuZXdPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEluZGV4T2Zmc2V0KG1heE9mZnNldC5yZWFkVGltZSwgbWF4T2Zmc2V0LmRvY3VtZW50S2V5LCBNYXRoLm1heChsb29rdXBSZXN1bHQuYmF0Y2hJZCwgZXhpc3RpbmdPZmZzZXQubGFyZ2VzdEJhdGNoSWQpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIGBMaXN0ZW5TZXF1ZW5jZWAgaXMgYSBtb25vdG9uaWMgc2VxdWVuY2UuIEl0IGlzIGluaXRpYWxpemVkIHdpdGggYSBtaW5pbXVtIHZhbHVlIHRvXG4gKiBleGNlZWQuIEFsbCBzdWJzZXF1ZW50IGNhbGxzIHRvIG5leHQgd2lsbCByZXR1cm4gaW5jcmVhc2luZyB2YWx1ZXMuIElmIHByb3ZpZGVkIHdpdGggYVxuICogYFNlcXVlbmNlTnVtYmVyU3luY2VyYCwgaXQgd2lsbCBhZGRpdGlvbmFsbHkgYnVtcCBpdHMgbmV4dCB2YWx1ZSB3aGVuIHRvbGQgb2YgYSBuZXcgdmFsdWUsIGFzXG4gKiB3ZWxsIGFzIHdyaXRlIG91dCBzZXF1ZW5jZSBudW1iZXJzIHRoYXQgaXQgcHJvZHVjZXMgdmlhIGBuZXh0KClgLlxuICovXG5jbGFzcyBMaXN0ZW5TZXF1ZW5jZSB7XG4gICAgY29uc3RydWN0b3IocHJldmlvdXNWYWx1ZSwgc2VxdWVuY2VOdW1iZXJTeW5jZXIpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91c1ZhbHVlID0gcHJldmlvdXNWYWx1ZTtcbiAgICAgICAgaWYgKHNlcXVlbmNlTnVtYmVyU3luY2VyKSB7XG4gICAgICAgICAgICBzZXF1ZW5jZU51bWJlclN5bmNlci5zZXF1ZW5jZU51bWJlckhhbmRsZXIgPSBzZXF1ZW5jZU51bWJlciA9PiB0aGlzLnNldFByZXZpb3VzVmFsdWUoc2VxdWVuY2VOdW1iZXIpO1xuICAgICAgICAgICAgdGhpcy53cml0ZU5ld1NlcXVlbmNlTnVtYmVyID0gc2VxdWVuY2VOdW1iZXIgPT4gc2VxdWVuY2VOdW1iZXJTeW5jZXIud3JpdGVTZXF1ZW5jZU51bWJlcihzZXF1ZW5jZU51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0UHJldmlvdXNWYWx1ZShleHRlcm5hbFByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91c1ZhbHVlID0gTWF0aC5tYXgoZXh0ZXJuYWxQcmV2aW91c1ZhbHVlLCB0aGlzLnByZXZpb3VzVmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91c1ZhbHVlO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCBuZXh0VmFsdWUgPSArK3RoaXMucHJldmlvdXNWYWx1ZTtcbiAgICAgICAgaWYgKHRoaXMud3JpdGVOZXdTZXF1ZW5jZU51bWJlcikge1xuICAgICAgICAgICAgdGhpcy53cml0ZU5ld1NlcXVlbmNlTnVtYmVyKG5leHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHRWYWx1ZTtcbiAgICB9XG59XG5MaXN0ZW5TZXF1ZW5jZS5JTlZBTElEID0gLTE7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBlc2NhcGVDaGFyID0gJ1xcdTAwMDEnO1xuY29uc3QgZW5jb2RlZFNlcGFyYXRvckNoYXIgPSAnXFx1MDAwMSc7XG5jb25zdCBlbmNvZGVkTnVsID0gJ1xcdTAwMTAnO1xuY29uc3QgZW5jb2RlZEVzY2FwZSA9ICdcXHUwMDExJztcbi8qKlxuICogRW5jb2RlcyBhIHJlc291cmNlIHBhdGggaW50byBhIEluZGV4ZWREYi1jb21wYXRpYmxlIHN0cmluZyBmb3JtLlxuICovXG5mdW5jdGlvbiBlbmNvZGVSZXNvdXJjZVBhdGgocGF0aCkge1xuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBlbmNvZGVTZXBhcmF0b3IocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBlbmNvZGVTZWdtZW50KHBhdGguZ2V0KGkpLCByZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gZW5jb2RlU2VwYXJhdG9yKHJlc3VsdCk7XG59XG4vKiogRW5jb2RlcyBhIHNpbmdsZSBzZWdtZW50IG9mIGEgcmVzb3VyY2UgcGF0aCBpbnRvIHRoZSBnaXZlbiByZXN1bHQgKi9cbmZ1bmN0aW9uIGVuY29kZVNlZ21lbnQoc2VnbWVudCwgcmVzdWx0QnVmKSB7XG4gICAgbGV0IHJlc3VsdCA9IHJlc3VsdEJ1ZjtcbiAgICBjb25zdCBsZW5ndGggPSBzZWdtZW50Lmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBzZWdtZW50LmNoYXJBdChpKTtcbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICBjYXNlICdcXDAnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBlc2NhcGVDaGFyICsgZW5jb2RlZE51bDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZXNjYXBlQ2hhcjpcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gZXNjYXBlQ2hhciArIGVuY29kZWRFc2NhcGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKiogRW5jb2RlcyBhIHBhdGggc2VwYXJhdG9yIGludG8gdGhlIGdpdmVuIHJlc3VsdCAqL1xuZnVuY3Rpb24gZW5jb2RlU2VwYXJhdG9yKHJlc3VsdCkge1xuICAgIHJldHVybiByZXN1bHQgKyBlc2NhcGVDaGFyICsgZW5jb2RlZFNlcGFyYXRvckNoYXI7XG59XG4vKipcbiAqIERlY29kZXMgdGhlIGdpdmVuIEluZGV4ZWREYi1jb21wYXRpYmxlIHN0cmluZyBmb3JtIG9mIGEgcmVzb3VyY2UgcGF0aCBpbnRvXG4gKiBhIFJlc291cmNlUGF0aCBpbnN0YW5jZS4gTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGlzIG5vdCBzdWl0YWJsZSBmb3IgdXNlIHdpdGhcbiAqIGRlY29kaW5nIHJlc291cmNlIG5hbWVzIGZyb20gdGhlIHNlcnZlcjsgdGhvc2UgYXJlIE9uZSBQbGF0Zm9ybSBmb3JtYXRcbiAqIHN0cmluZ3MuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZVJlc291cmNlUGF0aChwYXRoKSB7XG4gICAgLy8gRXZlbnQgdGhlIGVtcHR5IHBhdGggbXVzdCBlbmNvZGUgYXMgYSBwYXRoIG9mIGF0IGxlYXN0IGxlbmd0aCAyLiBBIHBhdGhcbiAgICAvLyB3aXRoIGV4YWN0bHkgMiBtdXN0IGJlIHRoZSBlbXB0eSBwYXRoLlxuICAgIGNvbnN0IGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICAgIGhhcmRBc3NlcnQobGVuZ3RoID49IDIpO1xuICAgIGlmIChsZW5ndGggPT09IDIpIHtcbiAgICAgICAgaGFyZEFzc2VydChwYXRoLmNoYXJBdCgwKSA9PT0gZXNjYXBlQ2hhciAmJiBwYXRoLmNoYXJBdCgxKSA9PT0gZW5jb2RlZFNlcGFyYXRvckNoYXIpO1xuICAgICAgICByZXR1cm4gUmVzb3VyY2VQYXRoLmVtcHR5UGF0aCgpO1xuICAgIH1cbiAgICAvLyBFc2NhcGUgY2hhcmFjdGVycyBjYW5ub3QgZXhpc3QgcGFzdCB0aGUgc2Vjb25kLXRvLWxhc3QgcG9zaXRpb24gaW4gdGhlXG4gICAgLy8gc291cmNlIHZhbHVlLlxuICAgIGNvbnN0IGxhc3RSZWFzb25hYmxlRXNjYXBlSW5kZXggPSBsZW5ndGggLSAyO1xuICAgIGNvbnN0IHNlZ21lbnRzID0gW107XG4gICAgbGV0IHNlZ21lbnRCdWlsZGVyID0gJyc7XG4gICAgZm9yIChsZXQgc3RhcnQgPSAwOyBzdGFydCA8IGxlbmd0aDspIHtcbiAgICAgICAgLy8gVGhlIGxhc3QgdHdvIGNoYXJhY3RlcnMgb2YgYSB2YWxpZCBlbmNvZGVkIHBhdGggbXVzdCBiZSBhIHNlcGFyYXRvciwgc29cbiAgICAgICAgLy8gdGhlcmUgbXVzdCBiZSBhbiBlbmQgdG8gdGhpcyBzZWdtZW50LlxuICAgICAgICBjb25zdCBlbmQgPSBwYXRoLmluZGV4T2YoZXNjYXBlQ2hhciwgc3RhcnQpO1xuICAgICAgICBpZiAoZW5kIDwgMCB8fCBlbmQgPiBsYXN0UmVhc29uYWJsZUVzY2FwZUluZGV4KSB7XG4gICAgICAgICAgICBmYWlsKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dCA9IHBhdGguY2hhckF0KGVuZCArIDEpO1xuICAgICAgICBzd2l0Y2ggKG5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgZW5jb2RlZFNlcGFyYXRvckNoYXI6XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFBpZWNlID0gcGF0aC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgbGV0IHNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlZ21lbnRCdWlsZGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCBjb3B5aW5nIGZvciB0aGUgY29tbW9uIGNhc2Ugb2YgYSBzZWdtZW50IHRoYXQgZXhjbHVkZXMgXFwwXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBcXDAwMVxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50ID0gY3VycmVudFBpZWNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudEJ1aWxkZXIgKz0gY3VycmVudFBpZWNlO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50ID0gc2VnbWVudEJ1aWxkZXI7XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRCdWlsZGVyID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGVuY29kZWROdWw6XG4gICAgICAgICAgICAgICAgc2VnbWVudEJ1aWxkZXIgKz0gcGF0aC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgc2VnbWVudEJ1aWxkZXIgKz0gJ1xcMCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGVuY29kZWRFc2NhcGU6XG4gICAgICAgICAgICAgICAgLy8gVGhlIGVzY2FwZSBjaGFyYWN0ZXIgY2FuIGJlIHVzZWQgaW4gdGhlIG91dHB1dCB0byBlbmNvZGUgaXRzZWxmLlxuICAgICAgICAgICAgICAgIHNlZ21lbnRCdWlsZGVyICs9IHBhdGguc3Vic3RyaW5nKHN0YXJ0LCBlbmQgKyAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgZmFpbCgpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gZW5kICsgMjtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZXNvdXJjZVBhdGgoc2VnbWVudHMpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgRGJSZW1vdGVEb2N1bWVudFN0b3JlJDEgPSAncmVtb3RlRG9jdW1lbnRzJztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogTmFtZSBvZiB0aGUgSW5kZXhlZERiIG9iamVjdCBzdG9yZS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIG5hbWUgJ293bmVyJyBpcyBjaG9zZW4gdG8gZW5zdXJlIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGhcbiAqIG9sZGVyIGNsaWVudHMgdGhhdCBvbmx5IHN1cHBvcnRlZCBzaW5nbGUgbG9ja2VkIGFjY2VzcyB0byB0aGUgcGVyc2lzdGVuY2VcbiAqIGxheWVyLlxuICovXG5jb25zdCBEYlByaW1hcnlDbGllbnRTdG9yZSA9ICdvd25lcic7XG4vKipcbiAqIFRoZSBrZXkgc3RyaW5nIHVzZWQgZm9yIHRoZSBzaW5nbGUgb2JqZWN0IHRoYXQgZXhpc3RzIGluIHRoZVxuICogRGJQcmltYXJ5Q2xpZW50IHN0b3JlLlxuICovXG5jb25zdCBEYlByaW1hcnlDbGllbnRLZXkgPSAnb3duZXInO1xuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICAqL1xuY29uc3QgRGJNdXRhdGlvblF1ZXVlU3RvcmUgPSAnbXV0YXRpb25RdWV1ZXMnO1xuLyoqIEtleXMgYXJlIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgdmlhIHRoZSB1c2VySWQgcHJvcGVydHkuICovXG5jb25zdCBEYk11dGF0aW9uUXVldWVLZXlQYXRoID0gJ3VzZXJJZCc7XG4vKiogTmFtZSBvZiB0aGUgSW5kZXhlZERiIG9iamVjdCBzdG9yZS4gICovXG5jb25zdCBEYk11dGF0aW9uQmF0Y2hTdG9yZSA9ICdtdXRhdGlvbnMnO1xuLyoqIEtleXMgYXJlIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgdmlhIHRoZSB1c2VySWQsIGJhdGNoSWQgcHJvcGVydGllcy4gKi9cbmNvbnN0IERiTXV0YXRpb25CYXRjaEtleVBhdGggPSAnYmF0Y2hJZCc7XG4vKiogVGhlIGluZGV4IG5hbWUgZm9yIGxvb2t1cCBvZiBtdXRhdGlvbnMgYnkgdXNlci4gKi9cbmNvbnN0IERiTXV0YXRpb25CYXRjaFVzZXJNdXRhdGlvbnNJbmRleCA9ICd1c2VyTXV0YXRpb25zSW5kZXgnO1xuLyoqIFRoZSB1c2VyIG11dGF0aW9ucyBpbmRleCBpcyBrZXllZCBieSBbdXNlcklkLCBiYXRjaElkXSBwYWlycy4gKi9cbmNvbnN0IERiTXV0YXRpb25CYXRjaFVzZXJNdXRhdGlvbnNLZXlQYXRoID0gWyd1c2VySWQnLCAnYmF0Y2hJZCddO1xuLyoqXG4gKiBDcmVhdGVzIGEgW3VzZXJJZF0ga2V5IGZvciB1c2UgaW4gdGhlIERiRG9jdW1lbnRNdXRhdGlvbnMgaW5kZXggdG8gaXRlcmF0ZVxuICogb3ZlciBhbGwgb2YgYSB1c2VyJ3MgZG9jdW1lbnQgbXV0YXRpb25zLlxuICovXG5mdW5jdGlvbiBuZXdEYkRvY3VtZW50TXV0YXRpb25QcmVmaXhGb3JVc2VyKHVzZXJJZCkge1xuICAgIHJldHVybiBbdXNlcklkXTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIFt1c2VySWQsIGVuY29kZWRQYXRoXSBrZXkgZm9yIHVzZSBpbiB0aGUgRGJEb2N1bWVudE11dGF0aW9uc1xuICogaW5kZXggdG8gaXRlcmF0ZSBvdmVyIGFsbCBhdCBkb2N1bWVudCBtdXRhdGlvbnMgZm9yIGEgZ2l2ZW4gcGF0aCBvciBsb3dlci5cbiAqL1xuZnVuY3Rpb24gbmV3RGJEb2N1bWVudE11dGF0aW9uUHJlZml4Rm9yUGF0aCh1c2VySWQsIHBhdGgpIHtcbiAgICByZXR1cm4gW3VzZXJJZCwgZW5jb2RlUmVzb3VyY2VQYXRoKHBhdGgpXTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bGwgaW5kZXgga2V5IG9mIFt1c2VySWQsIGVuY29kZWRQYXRoLCBiYXRjaElkXSBmb3IgaW5zZXJ0aW5nXG4gKiBhbmQgZGVsZXRpbmcgaW50byB0aGUgRGJEb2N1bWVudE11dGF0aW9ucyBpbmRleC5cbiAqL1xuZnVuY3Rpb24gbmV3RGJEb2N1bWVudE11dGF0aW9uS2V5KHVzZXJJZCwgcGF0aCwgYmF0Y2hJZCkge1xuICAgIHJldHVybiBbdXNlcklkLCBlbmNvZGVSZXNvdXJjZVBhdGgocGF0aCksIGJhdGNoSWRdO1xufVxuLyoqXG4gKiBCZWNhdXNlIHdlIHN0b3JlIGFsbCB0aGUgdXNlZnVsIGluZm9ybWF0aW9uIGZvciB0aGlzIHN0b3JlIGluIHRoZSBrZXksXG4gKiB0aGVyZSBpcyBubyB1c2VmdWwgaW5mb3JtYXRpb24gdG8gc3RvcmUgYXMgdGhlIHZhbHVlLiBUaGUgcmF3ICh1bmVuY29kZWQpXG4gKiBwYXRoIGNhbm5vdCBiZSBzdG9yZWQgYmVjYXVzZSBJbmRleGVkRGIgZG9lc24ndCBzdG9yZSBwcm90b3R5cGVcbiAqIGluZm9ybWF0aW9uLlxuICovXG5jb25zdCBEYkRvY3VtZW50TXV0YXRpb25QbGFjZWhvbGRlciA9IHt9O1xuY29uc3QgRGJEb2N1bWVudE11dGF0aW9uU3RvcmUgPSAnZG9jdW1lbnRNdXRhdGlvbnMnO1xuY29uc3QgRGJSZW1vdGVEb2N1bWVudFN0b3JlID0gJ3JlbW90ZURvY3VtZW50c1YxNCc7XG4vKipcbiAqIFRoZSBwcmltYXJ5IGtleSBvZiB0aGUgcmVtb3RlIGRvY3VtZW50cyBzdG9yZSwgd2hpY2ggYWxsb3dzIGZvciBlZmZpY2llbnRcbiAqIGFjY2VzcyBieSBjb2xsZWN0aW9uIHBhdGggYW5kIHJlYWQgdGltZS5cbiAqL1xuY29uc3QgRGJSZW1vdGVEb2N1bWVudEtleVBhdGggPSBbXG4gICAgJ3ByZWZpeFBhdGgnLFxuICAgICdjb2xsZWN0aW9uR3JvdXAnLFxuICAgICdyZWFkVGltZScsXG4gICAgJ2RvY3VtZW50SWQnXG5dO1xuLyoqIEFuIGluZGV4IHRoYXQgcHJvdmlkZXMgYWNjZXNzIHRvIGRvY3VtZW50cyBieSBrZXkuICovXG5jb25zdCBEYlJlbW90ZURvY3VtZW50RG9jdW1lbnRLZXlJbmRleCA9ICdkb2N1bWVudEtleUluZGV4JztcbmNvbnN0IERiUmVtb3RlRG9jdW1lbnREb2N1bWVudEtleUluZGV4UGF0aCA9IFtcbiAgICAncHJlZml4UGF0aCcsXG4gICAgJ2NvbGxlY3Rpb25Hcm91cCcsXG4gICAgJ2RvY3VtZW50SWQnXG5dO1xuLyoqXG4gKiBBbiBpbmRleCB0aGF0IHByb3ZpZGVzIGFjY2VzcyB0byBkb2N1bWVudHMgYnkgY29sbGVjdGlvbiBncm91cCBhbmQgcmVhZFxuICogdGltZS5cbiAqXG4gKiBUaGlzIGluZGV4IGlzIHVzZWQgYnkgdGhlIGluZGV4IGJhY2tmaWxsZXIuXG4gKi9cbmNvbnN0IERiUmVtb3RlRG9jdW1lbnRDb2xsZWN0aW9uR3JvdXBJbmRleCA9ICdjb2xsZWN0aW9uR3JvdXBJbmRleCc7XG5jb25zdCBEYlJlbW90ZURvY3VtZW50Q29sbGVjdGlvbkdyb3VwSW5kZXhQYXRoID0gW1xuICAgICdjb2xsZWN0aW9uR3JvdXAnLFxuICAgICdyZWFkVGltZScsXG4gICAgJ3ByZWZpeFBhdGgnLFxuICAgICdkb2N1bWVudElkJ1xuXTtcbmNvbnN0IERiUmVtb3RlRG9jdW1lbnRHbG9iYWxTdG9yZSA9ICdyZW1vdGVEb2N1bWVudEdsb2JhbCc7XG5jb25zdCBEYlJlbW90ZURvY3VtZW50R2xvYmFsS2V5ID0gJ3JlbW90ZURvY3VtZW50R2xvYmFsS2V5JztcbmNvbnN0IERiVGFyZ2V0U3RvcmUgPSAndGFyZ2V0cyc7XG4vKiogS2V5cyBhcmUgYXV0b21hdGljYWxseSBhc3NpZ25lZCB2aWEgdGhlIHRhcmdldElkIHByb3BlcnR5LiAqL1xuY29uc3QgRGJUYXJnZXRLZXlQYXRoID0gJ3RhcmdldElkJztcbi8qKiBUaGUgbmFtZSBvZiB0aGUgcXVlcnlUYXJnZXRzIGluZGV4LiAqL1xuY29uc3QgRGJUYXJnZXRRdWVyeVRhcmdldHNJbmRleE5hbWUgPSAncXVlcnlUYXJnZXRzSW5kZXgnO1xuLyoqXG4gKiBUaGUgaW5kZXggb2YgYWxsIGNhbm9uaWNhbElkcyB0byB0aGUgdGFyZ2V0cyB0aGF0IHRoZXkgbWF0Y2guIFRoaXMgaXMgbm90XG4gKiBhIHVuaXF1ZSBtYXBwaW5nIGJlY2F1c2UgY2Fub25pY2FsSWQgZG9lcyBub3QgcHJvbWlzZSBhIHVuaXF1ZSBuYW1lIGZvciBhbGxcbiAqIHBvc3NpYmxlIHF1ZXJpZXMsIHNvIHdlIGFwcGVuZCB0aGUgdGFyZ2V0SWQgdG8gbWFrZSB0aGUgbWFwcGluZyB1bmlxdWUuXG4gKi9cbmNvbnN0IERiVGFyZ2V0UXVlcnlUYXJnZXRzS2V5UGF0aCA9IFsnY2Fub25pY2FsSWQnLCAndGFyZ2V0SWQnXTtcbi8qKiBOYW1lIG9mIHRoZSBJbmRleGVkRGIgb2JqZWN0IHN0b3JlLiAgKi9cbmNvbnN0IERiVGFyZ2V0RG9jdW1lbnRTdG9yZSA9ICd0YXJnZXREb2N1bWVudHMnO1xuLyoqIEtleXMgYXJlIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgdmlhIHRoZSB0YXJnZXRJZCwgcGF0aCBwcm9wZXJ0aWVzLiAqL1xuY29uc3QgRGJUYXJnZXREb2N1bWVudEtleVBhdGggPSBbJ3RhcmdldElkJywgJ3BhdGgnXTtcbi8qKiBUaGUgaW5kZXggbmFtZSBmb3IgdGhlIHJldmVyc2UgaW5kZXguICovXG5jb25zdCBEYlRhcmdldERvY3VtZW50RG9jdW1lbnRUYXJnZXRzSW5kZXggPSAnZG9jdW1lbnRUYXJnZXRzSW5kZXgnO1xuLyoqIFdlIGFsc28gbmVlZCB0byBjcmVhdGUgdGhlIHJldmVyc2UgaW5kZXggZm9yIHRoZXNlIHByb3BlcnRpZXMuICovXG5jb25zdCBEYlRhcmdldERvY3VtZW50RG9jdW1lbnRUYXJnZXRzS2V5UGF0aCA9IFsncGF0aCcsICd0YXJnZXRJZCddO1xuLyoqXG4gKiBUaGUga2V5IHN0cmluZyB1c2VkIGZvciB0aGUgc2luZ2xlIG9iamVjdCB0aGF0IGV4aXN0cyBpbiB0aGVcbiAqIERiVGFyZ2V0R2xvYmFsIHN0b3JlLlxuICovXG5jb25zdCBEYlRhcmdldEdsb2JhbEtleSA9ICd0YXJnZXRHbG9iYWxLZXknO1xuY29uc3QgRGJUYXJnZXRHbG9iYWxTdG9yZSA9ICd0YXJnZXRHbG9iYWwnO1xuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICovXG5jb25zdCBEYkNvbGxlY3Rpb25QYXJlbnRTdG9yZSA9ICdjb2xsZWN0aW9uUGFyZW50cyc7XG4vKiogS2V5cyBhcmUgYXV0b21hdGljYWxseSBhc3NpZ25lZCB2aWEgdGhlIGNvbGxlY3Rpb25JZCwgcGFyZW50IHByb3BlcnRpZXMuICovXG5jb25zdCBEYkNvbGxlY3Rpb25QYXJlbnRLZXlQYXRoID0gWydjb2xsZWN0aW9uSWQnLCAncGFyZW50J107XG4vKiogTmFtZSBvZiB0aGUgSW5kZXhlZERiIG9iamVjdCBzdG9yZS4gKi9cbmNvbnN0IERiQ2xpZW50TWV0YWRhdGFTdG9yZSA9ICdjbGllbnRNZXRhZGF0YSc7XG4vKiogS2V5cyBhcmUgYXV0b21hdGljYWxseSBhc3NpZ25lZCB2aWEgdGhlIGNsaWVudElkIHByb3BlcnRpZXMuICovXG5jb25zdCBEYkNsaWVudE1ldGFkYXRhS2V5UGF0aCA9ICdjbGllbnRJZCc7XG4vKiogTmFtZSBvZiB0aGUgSW5kZXhlZERiIG9iamVjdCBzdG9yZS4gKi9cbmNvbnN0IERiQnVuZGxlU3RvcmUgPSAnYnVuZGxlcyc7XG5jb25zdCBEYkJ1bmRsZUtleVBhdGggPSAnYnVuZGxlSWQnO1xuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICovXG5jb25zdCBEYk5hbWVkUXVlcnlTdG9yZSA9ICduYW1lZFF1ZXJpZXMnO1xuY29uc3QgRGJOYW1lZFF1ZXJ5S2V5UGF0aCA9ICduYW1lJztcbi8qKiBOYW1lIG9mIHRoZSBJbmRleGVkRGIgb2JqZWN0IHN0b3JlLiAqL1xuY29uc3QgRGJJbmRleENvbmZpZ3VyYXRpb25TdG9yZSA9ICdpbmRleENvbmZpZ3VyYXRpb24nO1xuY29uc3QgRGJJbmRleENvbmZpZ3VyYXRpb25LZXlQYXRoID0gJ2luZGV4SWQnO1xuLyoqXG4gKiBBbiBpbmRleCB0aGF0IHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgaW5kZXggY29uZmlndXJhdGlvbnMgYnkgY29sbGVjdGlvblxuICogZ3JvdXAuXG4gKlxuICogUE9SVElORyBOT1RFOiBpT1MgYW5kIEFuZHJvaWQgbWFpbnRhaW4gdGhpcyBpbmRleCBpbi1tZW1vcnksIGJ1dCB0aGlzIGlzXG4gKiBub3QgcG9zc2libGUgaGVyZSBhcyB0aGUgV2ViIGNsaWVudCBzdXBwb3J0cyBjb25jdXJyZW50IGFjY2VzcyB0b1xuICogcGVyc2lzdGVuY2UgdmlhIG11bHRpLXRhYi5cbiAqL1xuY29uc3QgRGJJbmRleENvbmZpZ3VyYXRpb25Db2xsZWN0aW9uR3JvdXBJbmRleCA9ICdjb2xsZWN0aW9uR3JvdXBJbmRleCc7XG5jb25zdCBEYkluZGV4Q29uZmlndXJhdGlvbkNvbGxlY3Rpb25Hcm91cEluZGV4UGF0aCA9ICdjb2xsZWN0aW9uR3JvdXAnO1xuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICovXG5jb25zdCBEYkluZGV4U3RhdGVTdG9yZSA9ICdpbmRleFN0YXRlJztcbmNvbnN0IERiSW5kZXhTdGF0ZUtleVBhdGggPSBbJ2luZGV4SWQnLCAndWlkJ107XG4vKipcbiAqIEFuIGluZGV4IHRoYXQgcHJvdmlkZXMgYWNjZXNzIHRvIGRvY3VtZW50cyBpbiBhIGNvbGxlY3Rpb24gc29ydGVkIGJ5IGxhc3RcbiAqIHVwZGF0ZSB0aW1lLiBVc2VkIGJ5IHRoZSBiYWNrZmlsbGVyLlxuICpcbiAqIFBPUlRJTkcgTk9URTogaU9TIGFuZCBBbmRyb2lkIG1haW50YWluIHRoaXMgaW5kZXggaW4tbWVtb3J5LCBidXQgdGhpcyBpc1xuICogbm90IHBvc3NpYmxlIGhlcmUgYXMgdGhlIFdlYiBjbGllbnQgc3VwcG9ydHMgY29uY3VycmVudCBhY2Nlc3MgdG9cbiAqIHBlcnNpc3RlbmNlIHZpYSBtdWx0aS10YWIuXG4gKi9cbmNvbnN0IERiSW5kZXhTdGF0ZVNlcXVlbmNlTnVtYmVySW5kZXggPSAnc2VxdWVuY2VOdW1iZXJJbmRleCc7XG5jb25zdCBEYkluZGV4U3RhdGVTZXF1ZW5jZU51bWJlckluZGV4UGF0aCA9IFsndWlkJywgJ3NlcXVlbmNlTnVtYmVyJ107XG4vKiogTmFtZSBvZiB0aGUgSW5kZXhlZERiIG9iamVjdCBzdG9yZS4gKi9cbmNvbnN0IERiSW5kZXhFbnRyeVN0b3JlID0gJ2luZGV4RW50cmllcyc7XG5jb25zdCBEYkluZGV4RW50cnlLZXlQYXRoID0gW1xuICAgICdpbmRleElkJyxcbiAgICAndWlkJyxcbiAgICAnYXJyYXlWYWx1ZScsXG4gICAgJ2RpcmVjdGlvbmFsVmFsdWUnLFxuICAgICdvcmRlcmVkRG9jdW1lbnRLZXknLFxuICAgICdkb2N1bWVudEtleSdcbl07XG5jb25zdCBEYkluZGV4RW50cnlEb2N1bWVudEtleUluZGV4ID0gJ2RvY3VtZW50S2V5SW5kZXgnO1xuY29uc3QgRGJJbmRleEVudHJ5RG9jdW1lbnRLZXlJbmRleFBhdGggPSBbXG4gICAgJ2luZGV4SWQnLFxuICAgICd1aWQnLFxuICAgICdvcmRlcmVkRG9jdW1lbnRLZXknXG5dO1xuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICovXG5jb25zdCBEYkRvY3VtZW50T3ZlcmxheVN0b3JlID0gJ2RvY3VtZW50T3ZlcmxheXMnO1xuY29uc3QgRGJEb2N1bWVudE92ZXJsYXlLZXlQYXRoID0gW1xuICAgICd1c2VySWQnLFxuICAgICdjb2xsZWN0aW9uUGF0aCcsXG4gICAgJ2RvY3VtZW50SWQnXG5dO1xuY29uc3QgRGJEb2N1bWVudE92ZXJsYXlDb2xsZWN0aW9uUGF0aE92ZXJsYXlJbmRleCA9ICdjb2xsZWN0aW9uUGF0aE92ZXJsYXlJbmRleCc7XG5jb25zdCBEYkRvY3VtZW50T3ZlcmxheUNvbGxlY3Rpb25QYXRoT3ZlcmxheUluZGV4UGF0aCA9IFtcbiAgICAndXNlcklkJyxcbiAgICAnY29sbGVjdGlvblBhdGgnLFxuICAgICdsYXJnZXN0QmF0Y2hJZCdcbl07XG5jb25zdCBEYkRvY3VtZW50T3ZlcmxheUNvbGxlY3Rpb25Hcm91cE92ZXJsYXlJbmRleCA9ICdjb2xsZWN0aW9uR3JvdXBPdmVybGF5SW5kZXgnO1xuY29uc3QgRGJEb2N1bWVudE92ZXJsYXlDb2xsZWN0aW9uR3JvdXBPdmVybGF5SW5kZXhQYXRoID0gW1xuICAgICd1c2VySWQnLFxuICAgICdjb2xsZWN0aW9uR3JvdXAnLFxuICAgICdsYXJnZXN0QmF0Y2hJZCdcbl07XG4vKiogTmFtZSBvZiB0aGUgSW5kZXhlZERiIG9iamVjdCBzdG9yZS4gKi9cbmNvbnN0IERiR2xvYmFsc1N0b3JlID0gJ2dsb2JhbHMnO1xuY29uc3QgRGJHbG9iYWxzS2V5UGF0aCA9ICduYW1lJztcbi8vIFZpc2libGUgZm9yIHRlc3RpbmdcbmNvbnN0IFYxX1NUT1JFUyA9IFtcbiAgICBEYk11dGF0aW9uUXVldWVTdG9yZSxcbiAgICBEYk11dGF0aW9uQmF0Y2hTdG9yZSxcbiAgICBEYkRvY3VtZW50TXV0YXRpb25TdG9yZSxcbiAgICBEYlJlbW90ZURvY3VtZW50U3RvcmUkMSxcbiAgICBEYlRhcmdldFN0b3JlLFxuICAgIERiUHJpbWFyeUNsaWVudFN0b3JlLFxuICAgIERiVGFyZ2V0R2xvYmFsU3RvcmUsXG4gICAgRGJUYXJnZXREb2N1bWVudFN0b3JlXG5dO1xuLy8gVmlzaWJsZSBmb3IgdGVzdGluZ1xuY29uc3QgVjNfU1RPUkVTID0gVjFfU1RPUkVTO1xuLy8gTm90ZTogRGJSZW1vdGVEb2N1bWVudENoYW5nZXMgaXMgbm8gbG9uZ2VyIHVzZWQgYW5kIGRyb3BwZWQgd2l0aCB2OS5cbmNvbnN0IFY0X1NUT1JFUyA9IFsuLi5WM19TVE9SRVMsIERiQ2xpZW50TWV0YWRhdGFTdG9yZV07XG5jb25zdCBWNl9TVE9SRVMgPSBbLi4uVjRfU1RPUkVTLCBEYlJlbW90ZURvY3VtZW50R2xvYmFsU3RvcmVdO1xuY29uc3QgVjhfU1RPUkVTID0gWy4uLlY2X1NUT1JFUywgRGJDb2xsZWN0aW9uUGFyZW50U3RvcmVdO1xuY29uc3QgVjExX1NUT1JFUyA9IFsuLi5WOF9TVE9SRVMsIERiQnVuZGxlU3RvcmUsIERiTmFtZWRRdWVyeVN0b3JlXTtcbmNvbnN0IFYxMl9TVE9SRVMgPSBbLi4uVjExX1NUT1JFUywgRGJEb2N1bWVudE92ZXJsYXlTdG9yZV07XG5jb25zdCBWMTNfU1RPUkVTID0gW1xuICAgIERiTXV0YXRpb25RdWV1ZVN0b3JlLFxuICAgIERiTXV0YXRpb25CYXRjaFN0b3JlLFxuICAgIERiRG9jdW1lbnRNdXRhdGlvblN0b3JlLFxuICAgIERiUmVtb3RlRG9jdW1lbnRTdG9yZSxcbiAgICBEYlRhcmdldFN0b3JlLFxuICAgIERiUHJpbWFyeUNsaWVudFN0b3JlLFxuICAgIERiVGFyZ2V0R2xvYmFsU3RvcmUsXG4gICAgRGJUYXJnZXREb2N1bWVudFN0b3JlLFxuICAgIERiQ2xpZW50TWV0YWRhdGFTdG9yZSxcbiAgICBEYlJlbW90ZURvY3VtZW50R2xvYmFsU3RvcmUsXG4gICAgRGJDb2xsZWN0aW9uUGFyZW50U3RvcmUsXG4gICAgRGJCdW5kbGVTdG9yZSxcbiAgICBEYk5hbWVkUXVlcnlTdG9yZSxcbiAgICBEYkRvY3VtZW50T3ZlcmxheVN0b3JlXG5dO1xuY29uc3QgVjE0X1NUT1JFUyA9IFYxM19TVE9SRVM7XG5jb25zdCBWMTVfU1RPUkVTID0gW1xuICAgIC4uLlYxNF9TVE9SRVMsXG4gICAgRGJJbmRleENvbmZpZ3VyYXRpb25TdG9yZSxcbiAgICBEYkluZGV4U3RhdGVTdG9yZSxcbiAgICBEYkluZGV4RW50cnlTdG9yZVxuXTtcbmNvbnN0IFYxNl9TVE9SRVMgPSBWMTVfU1RPUkVTO1xuY29uc3QgVjE3X1NUT1JFUyA9IFsuLi5WMTVfU1RPUkVTLCBEYkdsb2JhbHNTdG9yZV07XG4vKiogUmV0dXJucyB0aGUgb2JqZWN0IHN0b3JlcyBmb3IgdGhlIHByb3ZpZGVkIHNjaGVtYS4gKi9cbmZ1bmN0aW9uIGdldE9iamVjdFN0b3JlcyhzY2hlbWFWZXJzaW9uKSB7XG4gICAgaWYgKHNjaGVtYVZlcnNpb24gPT09IDE3KSB7XG4gICAgICAgIHJldHVybiBWMTdfU1RPUkVTO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWFWZXJzaW9uID09PSAxNikge1xuICAgICAgICByZXR1cm4gVjE2X1NUT1JFUztcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hVmVyc2lvbiA9PT0gMTUpIHtcbiAgICAgICAgcmV0dXJuIFYxNV9TVE9SRVM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjaGVtYVZlcnNpb24gPT09IDE0KSB7XG4gICAgICAgIHJldHVybiBWMTRfU1RPUkVTO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWFWZXJzaW9uID09PSAxMykge1xuICAgICAgICByZXR1cm4gVjEzX1NUT1JFUztcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hVmVyc2lvbiA9PT0gMTIpIHtcbiAgICAgICAgcmV0dXJuIFYxMl9TVE9SRVM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjaGVtYVZlcnNpb24gPT09IDExKSB7XG4gICAgICAgIHJldHVybiBWMTFfU1RPUkVTO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZmFpbCgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIEluZGV4ZWREYlRyYW5zYWN0aW9uIGV4dGVuZHMgUGVyc2lzdGVuY2VUcmFuc2FjdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc2ltcGxlRGJUcmFuc2FjdGlvbiwgY3VycmVudFNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2ltcGxlRGJUcmFuc2FjdGlvbiA9IHNpbXBsZURiVHJhbnNhY3Rpb247XG4gICAgICAgIHRoaXMuY3VycmVudFNlcXVlbmNlTnVtYmVyID0gY3VycmVudFNlcXVlbmNlTnVtYmVyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFN0b3JlKHR4biwgc3RvcmUpIHtcbiAgICBjb25zdCBpbmRleGVkRGJUcmFuc2FjdGlvbiA9IGRlYnVnQ2FzdCh0eG4pO1xuICAgIHJldHVybiBTaW1wbGVEYi5nZXRTdG9yZShpbmRleGVkRGJUcmFuc2FjdGlvbi5zaW1wbGVEYlRyYW5zYWN0aW9uLCBzdG9yZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBvYmplY3RTaXplKG9iaikge1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb3VudDtcbn1cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgZm4oa2V5LCBvYmpba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBtYXBUb0FycmF5KG9iaiwgZm4pIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZuKG9ialtrZXldLCBrZXksIG9iaikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBpc0VtcHR5KG9iaikge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gQW4gaW1tdXRhYmxlIHNvcnRlZCBtYXAgaW1wbGVtZW50YXRpb24sIGJhc2VkIG9uIGEgTGVmdC1sZWFuaW5nIFJlZC1CbGFja1xuLy8gdHJlZS5cbmNsYXNzIFNvcnRlZE1hcCB7XG4gICAgY29uc3RydWN0b3IoY29tcGFyYXRvciwgcm9vdCkge1xuICAgICAgICB0aGlzLmNvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xuICAgICAgICB0aGlzLnJvb3QgPSByb290ID8gcm9vdCA6IExMUkJOb2RlLkVNUFRZO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgbWFwLCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5L3ZhbHVlIGFkZGVkIG9yIHJlcGxhY2VkLlxuICAgIGluc2VydChrZXksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwKHRoaXMuY29tcGFyYXRvciwgdGhpcy5yb290XG4gICAgICAgICAgICAuaW5zZXJ0KGtleSwgdmFsdWUsIHRoaXMuY29tcGFyYXRvcilcbiAgICAgICAgICAgIC5jb3B5KG51bGwsIG51bGwsIExMUkJOb2RlLkJMQUNLLCBudWxsLCBudWxsKSk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBtYXAsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkgcmVtb3ZlZC5cbiAgICByZW1vdmUoa2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwKHRoaXMuY29tcGFyYXRvciwgdGhpcy5yb290XG4gICAgICAgICAgICAucmVtb3ZlKGtleSwgdGhpcy5jb21wYXJhdG9yKVxuICAgICAgICAgICAgLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuQkxBQ0ssIG51bGwsIG51bGwpKTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5vZGUgd2l0aCB0aGUgZ2l2ZW4ga2V5LCBvciBudWxsLlxuICAgIGdldChrZXkpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnJvb3Q7XG4gICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNtcCA9IHRoaXMuY29tcGFyYXRvcihrZXksIG5vZGUua2V5KTtcbiAgICAgICAgICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA8IDApIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCBpbiB0aGlzIHNvcnRlZCBtYXAsIG9yIC0xIGlmIGl0IGRvZXNuJ3RcbiAgICAvLyBleGlzdC5cbiAgICBpbmRleE9mKGtleSkge1xuICAgICAgICAvLyBOdW1iZXIgb2Ygbm9kZXMgdGhhdCB3ZXJlIHBydW5lZCB3aGVuIGRlc2NlbmRpbmcgcmlnaHRcbiAgICAgICAgbGV0IHBydW5lZE5vZGVzID0gMDtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnJvb3Q7XG4gICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNtcCA9IHRoaXMuY29tcGFyYXRvcihrZXksIG5vZGUua2V5KTtcbiAgICAgICAgICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJ1bmVkTm9kZXMgKyBub2RlLmxlZnQuc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA8IDApIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ291bnQgYWxsIG5vZGVzIGxlZnQgb2YgdGhlIG5vZGUgcGx1cyB0aGUgbm9kZSBpdHNlbGZcbiAgICAgICAgICAgICAgICBwcnVuZWROb2RlcyArPSBub2RlLmxlZnQuc2l6ZSArIDE7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9kZSBub3QgZm91bmRcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290LmlzRW1wdHkoKTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIG5vZGVzIGluIHRoZSBtYXAuXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3Quc2l6ZTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgbWluaW11bSBrZXkgaW4gdGhlIG1hcC5cbiAgICBtaW5LZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QubWluS2V5KCk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIG1heGltdW0ga2V5IGluIHRoZSBtYXAuXG4gICAgbWF4S2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290Lm1heEtleSgpO1xuICAgIH1cbiAgICAvLyBUcmF2ZXJzZXMgdGhlIG1hcCBpbiBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXG4gICAgLy8gZm9yIGVhY2gga2V5L3ZhbHVlIHBhaXIuIElmIGFjdGlvbiByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxuICAgIC8vIFJldHVybnMgdGhlIGZpcnN0IHRydXRoeSB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24sIG9yIHRoZSBsYXN0IGZhbHNleVxuICAgIC8vIHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbi5cbiAgICBpbm9yZGVyVHJhdmVyc2FsKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290Lmlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKTtcbiAgICB9XG4gICAgZm9yRWFjaChmbikge1xuICAgICAgICB0aGlzLmlub3JkZXJUcmF2ZXJzYWwoKGssIHYpID0+IHtcbiAgICAgICAgICAgIGZuKGssIHYpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLmlub3JkZXJUcmF2ZXJzYWwoKGssIHYpID0+IHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9ucy5wdXNoKGAke2t9OiR7dn1gKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBgeyR7ZGVzY3JpcHRpb25zLmpvaW4oJywgJyl9fWA7XG4gICAgfVxuICAgIC8vIFRyYXZlcnNlcyB0aGUgbWFwIGluIHJldmVyc2Uga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvblxuICAgIC8vIGZ1bmN0aW9uIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyLiBJZiBhY3Rpb24gcmV0dXJucyB0cnVlLCB0cmF2ZXJzYWwgaXNcbiAgICAvLyBhYm9ydGVkLlxuICAgIC8vIFJldHVybnMgdGhlIGZpcnN0IHRydXRoeSB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24sIG9yIHRoZSBsYXN0IGZhbHNleVxuICAgIC8vIHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbi5cbiAgICByZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290LnJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIHRoZSBTb3J0ZWRNYXAuXG4gICAgZ2V0SXRlcmF0b3IoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwSXRlcmF0b3IodGhpcy5yb290LCBudWxsLCB0aGlzLmNvbXBhcmF0b3IsIGZhbHNlKTtcbiAgICB9XG4gICAgZ2V0SXRlcmF0b3JGcm9tKGtleSkge1xuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcEl0ZXJhdG9yKHRoaXMucm9vdCwga2V5LCB0aGlzLmNvbXBhcmF0b3IsIGZhbHNlKTtcbiAgICB9XG4gICAgZ2V0UmV2ZXJzZUl0ZXJhdG9yKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcEl0ZXJhdG9yKHRoaXMucm9vdCwgbnVsbCwgdGhpcy5jb21wYXJhdG9yLCB0cnVlKTtcbiAgICB9XG4gICAgZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbShrZXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3QsIGtleSwgdGhpcy5jb21wYXJhdG9yLCB0cnVlKTtcbiAgICB9XG59IC8vIGVuZCBTb3J0ZWRNYXBcbi8vIEFuIGl0ZXJhdG9yIG92ZXIgYW4gTExSQk5vZGUuXG5jbGFzcyBTb3J0ZWRNYXBJdGVyYXRvciB7XG4gICAgY29uc3RydWN0b3Iobm9kZSwgc3RhcnRLZXksIGNvbXBhcmF0b3IsIGlzUmV2ZXJzZSkge1xuICAgICAgICB0aGlzLmlzUmV2ZXJzZSA9IGlzUmV2ZXJzZTtcbiAgICAgICAgdGhpcy5ub2RlU3RhY2sgPSBbXTtcbiAgICAgICAgbGV0IGNtcCA9IDE7XG4gICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIGNtcCA9IHN0YXJ0S2V5ID8gY29tcGFyYXRvcihub2RlLmtleSwgc3RhcnRLZXkpIDogMTtcbiAgICAgICAgICAgIC8vIGZsaXAgdGhlIGNvbXBhcmlzb24gaWYgd2UncmUgZ29pbmcgaW4gcmV2ZXJzZVxuICAgICAgICAgICAgaWYgKHN0YXJ0S2V5ICYmIGlzUmV2ZXJzZSkge1xuICAgICAgICAgICAgICAgIGNtcCAqPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbXAgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBub2RlIGlzIGxlc3MgdGhhbiBvdXIgc3RhcnQga2V5LiBpZ25vcmUgaXRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1JldmVyc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgbm9kZSBpcyBleGFjdGx5IGVxdWFsIHRvIG91ciBzdGFydCBrZXkuIFB1c2ggaXQgb24gdGhlIHN0YWNrLFxuICAgICAgICAgICAgICAgIC8vIGJ1dCBzdG9wIGl0ZXJhdGluZztcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVTdGFjay5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBub2RlIGlzIGdyZWF0ZXIgdGhhbiBvdXIgc3RhcnQga2V5LCBhZGQgaXQgdG8gdGhlIHN0YWNrIGFuZCBtb3ZlXG4gICAgICAgICAgICAgICAgLy8gdG8gdGhlIG5leHQgb25lXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlU3RhY2sucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1JldmVyc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXROZXh0KCkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMubm9kZVN0YWNrLnBvcCgpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7IGtleTogbm9kZS5rZXksIHZhbHVlOiBub2RlLnZhbHVlIH07XG4gICAgICAgIGlmICh0aGlzLmlzUmV2ZXJzZSkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVTdGFjay5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlU3RhY2sucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGhhc05leHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVTdGFjay5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBwZWVrKCkge1xuICAgICAgICBpZiAodGhpcy5ub2RlU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5ub2RlU3RhY2tbdGhpcy5ub2RlU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiB7IGtleTogbm9kZS5rZXksIHZhbHVlOiBub2RlLnZhbHVlIH07XG4gICAgfVxufSAvLyBlbmQgU29ydGVkTWFwSXRlcmF0b3Jcbi8vIFJlcHJlc2VudHMgYSBub2RlIGluIGEgTGVmdC1sZWFuaW5nIFJlZC1CbGFjayB0cmVlLlxuY2xhc3MgTExSQk5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgdmFsdWUsIGNvbG9yLCBsZWZ0LCByaWdodCkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3IgIT0gbnVsbCA/IGNvbG9yIDogTExSQk5vZGUuUkVEO1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0ICE9IG51bGwgPyBsZWZ0IDogTExSQk5vZGUuRU1QVFk7XG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodCAhPSBudWxsID8gcmlnaHQgOiBMTFJCTm9kZS5FTVBUWTtcbiAgICAgICAgdGhpcy5zaXplID0gdGhpcy5sZWZ0LnNpemUgKyAxICsgdGhpcy5yaWdodC5zaXplO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBub2RlLCBvcHRpb25hbGx5IHJlcGxhY2luZyBwaWVjZXMgb2YgaXQuXG4gICAgY29weShrZXksIHZhbHVlLCBjb2xvciwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMTFJCTm9kZShrZXkgIT0gbnVsbCA/IGtleSA6IHRoaXMua2V5LCB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiB0aGlzLnZhbHVlLCBjb2xvciAhPSBudWxsID8gY29sb3IgOiB0aGlzLmNvbG9yLCBsZWZ0ICE9IG51bGwgPyBsZWZ0IDogdGhpcy5sZWZ0LCByaWdodCAhPSBudWxsID8gcmlnaHQgOiB0aGlzLnJpZ2h0KTtcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBUcmF2ZXJzZXMgdGhlIHRyZWUgaW4ga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvbiBmdW5jdGlvblxuICAgIC8vIGZvciBlYWNoIG5vZGUuIElmIGFjdGlvbiByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxuICAgIC8vIFJldHVybnMgdGhlIGZpcnN0IHRydXRoeSB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24sIG9yIHRoZSBsYXN0IGZhbHNleVxuICAgIC8vIHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbi5cbiAgICBpbm9yZGVyVHJhdmVyc2FsKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gKHRoaXMubGVmdC5pbm9yZGVyVHJhdmVyc2FsKGFjdGlvbikgfHxcbiAgICAgICAgICAgIGFjdGlvbih0aGlzLmtleSwgdGhpcy52YWx1ZSkgfHxcbiAgICAgICAgICAgIHRoaXMucmlnaHQuaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pKTtcbiAgICB9XG4gICAgLy8gVHJhdmVyc2VzIHRoZSB0cmVlIGluIHJldmVyc2Uga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvblxuICAgIC8vIGZ1bmN0aW9uIGZvciBlYWNoIG5vZGUuIElmIGFjdGlvbiByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxuICAgIC8vIFJldHVybnMgdGhlIGZpcnN0IHRydXRoeSB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24sIG9yIHRoZSBsYXN0IGZhbHNleVxuICAgIC8vIHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbi5cbiAgICByZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gKHRoaXMucmlnaHQucmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pIHx8XG4gICAgICAgICAgICBhY3Rpb24odGhpcy5rZXksIHRoaXMudmFsdWUpIHx8XG4gICAgICAgICAgICB0aGlzLmxlZnQucmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pKTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgbWluaW11bSBub2RlIGluIHRoZSB0cmVlLlxuICAgIG1pbigpIHtcbiAgICAgICAgaWYgKHRoaXMubGVmdC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5taW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIGtleSBpbiB0aGUgdHJlZS5cbiAgICBtaW5LZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbigpLmtleTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgbWF4aW11bSBrZXkgaW4gdGhlIHRyZWUuXG4gICAgbWF4S2V5KCkge1xuICAgICAgICBpZiAodGhpcy5yaWdodC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmtleTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0Lm1heEtleSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJldHVybnMgbmV3IHRyZWUsIHdpdGggdGhlIGtleS92YWx1ZSBhZGRlZC5cbiAgICBpbnNlcnQoa2V5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xuICAgICAgICBsZXQgbiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGNtcCA9IGNvbXBhcmF0b3Ioa2V5LCBuLmtleSk7XG4gICAgICAgIGlmIChjbXAgPCAwKSB7XG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG4ubGVmdC5pbnNlcnQoa2V5LCB2YWx1ZSwgY29tcGFyYXRvciksIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCB2YWx1ZSwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG51bGwsIG4ucmlnaHQuaW5zZXJ0KGtleSwgdmFsdWUsIGNvbXBhcmF0b3IpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbi5maXhVcCgpO1xuICAgIH1cbiAgICByZW1vdmVNaW4oKSB7XG4gICAgICAgIGlmICh0aGlzLmxlZnQuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTExSQk5vZGUuRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG4gPSB0aGlzO1xuICAgICAgICBpZiAoIW4ubGVmdC5pc1JlZCgpICYmICFuLmxlZnQubGVmdC5pc1JlZCgpKSB7XG4gICAgICAgICAgICBuID0gbi5tb3ZlUmVkTGVmdCgpO1xuICAgICAgICB9XG4gICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbi5sZWZ0LnJlbW92ZU1pbigpLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIG4uZml4VXAoKTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBuZXcgdHJlZSwgd2l0aCB0aGUgc3BlY2lmaWVkIGl0ZW0gcmVtb3ZlZC5cbiAgICByZW1vdmUoa2V5LCBjb21wYXJhdG9yKSB7XG4gICAgICAgIGxldCBzbWFsbGVzdDtcbiAgICAgICAgbGV0IG4gPSB0aGlzO1xuICAgICAgICBpZiAoY29tcGFyYXRvcihrZXksIG4ua2V5KSA8IDApIHtcbiAgICAgICAgICAgIGlmICghbi5sZWZ0LmlzRW1wdHkoKSAmJiAhbi5sZWZ0LmlzUmVkKCkgJiYgIW4ubGVmdC5sZWZ0LmlzUmVkKCkpIHtcbiAgICAgICAgICAgICAgICBuID0gbi5tb3ZlUmVkTGVmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBuLmxlZnQucmVtb3ZlKGtleSwgY29tcGFyYXRvciksIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG4ubGVmdC5pc1JlZCgpKSB7XG4gICAgICAgICAgICAgICAgbiA9IG4ucm90YXRlUmlnaHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbi5yaWdodC5pc0VtcHR5KCkgJiYgIW4ucmlnaHQuaXNSZWQoKSAmJiAhbi5yaWdodC5sZWZ0LmlzUmVkKCkpIHtcbiAgICAgICAgICAgICAgICBuID0gbi5tb3ZlUmVkUmlnaHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb21wYXJhdG9yKGtleSwgbi5rZXkpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKG4ucmlnaHQuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBMTFJCTm9kZS5FTVBUWTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNtYWxsZXN0ID0gbi5yaWdodC5taW4oKTtcbiAgICAgICAgICAgICAgICAgICAgbiA9IG4uY29weShzbWFsbGVzdC5rZXksIHNtYWxsZXN0LnZhbHVlLCBudWxsLCBudWxsLCBuLnJpZ2h0LnJlbW92ZU1pbigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG51bGwsIG4ucmlnaHQucmVtb3ZlKGtleSwgY29tcGFyYXRvcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuLmZpeFVwKCk7XG4gICAgfVxuICAgIGlzUmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xvcjtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBuZXcgdHJlZSBhZnRlciBwZXJmb3JtaW5nIGFueSBuZWVkZWQgcm90YXRpb25zLlxuICAgIGZpeFVwKCkge1xuICAgICAgICBsZXQgbiA9IHRoaXM7XG4gICAgICAgIGlmIChuLnJpZ2h0LmlzUmVkKCkgJiYgIW4ubGVmdC5pc1JlZCgpKSB7XG4gICAgICAgICAgICBuID0gbi5yb3RhdGVMZWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4ubGVmdC5pc1JlZCgpICYmIG4ubGVmdC5sZWZ0LmlzUmVkKCkpIHtcbiAgICAgICAgICAgIG4gPSBuLnJvdGF0ZVJpZ2h0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4ubGVmdC5pc1JlZCgpICYmIG4ucmlnaHQuaXNSZWQoKSkge1xuICAgICAgICAgICAgbiA9IG4uY29sb3JGbGlwKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIG1vdmVSZWRMZWZ0KCkge1xuICAgICAgICBsZXQgbiA9IHRoaXMuY29sb3JGbGlwKCk7XG4gICAgICAgIGlmIChuLnJpZ2h0LmxlZnQuaXNSZWQoKSkge1xuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBudWxsLCBuLnJpZ2h0LnJvdGF0ZVJpZ2h0KCkpO1xuICAgICAgICAgICAgbiA9IG4ucm90YXRlTGVmdCgpO1xuICAgICAgICAgICAgbiA9IG4uY29sb3JGbGlwKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIG1vdmVSZWRSaWdodCgpIHtcbiAgICAgICAgbGV0IG4gPSB0aGlzLmNvbG9yRmxpcCgpO1xuICAgICAgICBpZiAobi5sZWZ0LmxlZnQuaXNSZWQoKSkge1xuICAgICAgICAgICAgbiA9IG4ucm90YXRlUmlnaHQoKTtcbiAgICAgICAgICAgIG4gPSBuLmNvbG9yRmxpcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICByb3RhdGVMZWZ0KCkge1xuICAgICAgICBjb25zdCBubCA9IHRoaXMuY29weShudWxsLCBudWxsLCBMTFJCTm9kZS5SRUQsIG51bGwsIHRoaXMucmlnaHQubGVmdCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJpZ2h0LmNvcHkobnVsbCwgbnVsbCwgdGhpcy5jb2xvciwgbmwsIG51bGwpO1xuICAgIH1cbiAgICByb3RhdGVSaWdodCgpIHtcbiAgICAgICAgY29uc3QgbnIgPSB0aGlzLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuUkVELCB0aGlzLmxlZnQucmlnaHQsIG51bGwpO1xuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmNvcHkobnVsbCwgbnVsbCwgdGhpcy5jb2xvciwgbnVsbCwgbnIpO1xuICAgIH1cbiAgICBjb2xvckZsaXAoKSB7XG4gICAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLmxlZnQuY29weShudWxsLCBudWxsLCAhdGhpcy5sZWZ0LmNvbG9yLCBudWxsLCBudWxsKTtcbiAgICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLnJpZ2h0LmNvcHkobnVsbCwgbnVsbCwgIXRoaXMucmlnaHQuY29sb3IsIG51bGwsIG51bGwpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb3B5KG51bGwsIG51bGwsICF0aGlzLmNvbG9yLCBsZWZ0LCByaWdodCk7XG4gICAgfVxuICAgIC8vIEZvciB0ZXN0aW5nLlxuICAgIGNoZWNrTWF4RGVwdGgoKSB7XG4gICAgICAgIGNvbnN0IGJsYWNrRGVwdGggPSB0aGlzLmNoZWNrKCk7XG4gICAgICAgIGlmIChNYXRoLnBvdygyLjAsIGJsYWNrRGVwdGgpIDw9IHRoaXMuc2l6ZSArIDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEluIGEgYmFsYW5jZWQgUkIgdHJlZSwgdGhlIGJsYWNrLWRlcHRoIChudW1iZXIgb2YgYmxhY2sgbm9kZXMpIGZyb20gcm9vdCB0b1xuICAgIC8vIGxlYXZlcyBpcyBlcXVhbCBvbiBib3RoIHNpZGVzLiAgVGhpcyBmdW5jdGlvbiB2ZXJpZmllcyB0aGF0IG9yIGFzc2VydHMuXG4gICAgY2hlY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUmVkKCkgJiYgdGhpcy5sZWZ0LmlzUmVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IGZhaWwoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yaWdodC5pc1JlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBmYWlsKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxhY2tEZXB0aCA9IHRoaXMubGVmdC5jaGVjaygpO1xuICAgICAgICBpZiAoYmxhY2tEZXB0aCAhPT0gdGhpcy5yaWdodC5jaGVjaygpKSB7XG4gICAgICAgICAgICB0aHJvdyBmYWlsKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYmxhY2tEZXB0aCArICh0aGlzLmlzUmVkKCkgPyAwIDogMSk7XG4gICAgICAgIH1cbiAgICB9XG59IC8vIGVuZCBMTFJCTm9kZVxuLy8gRW1wdHkgbm9kZSBpcyBzaGFyZWQgYmV0d2VlbiBhbGwgTExSQiB0cmVlcy5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5MTFJCTm9kZS5FTVBUWSA9IG51bGw7XG5MTFJCTm9kZS5SRUQgPSB0cnVlO1xuTExSQk5vZGUuQkxBQ0sgPSBmYWxzZTtcbi8vIFJlcHJlc2VudHMgYW4gZW1wdHkgbm9kZSAoYSBsZWFmIG5vZGUgaW4gdGhlIFJlZC1CbGFjayBUcmVlKS5cbmNsYXNzIExMUkJFbXB0eU5vZGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cbiAgICBnZXQga2V5KCkge1xuICAgICAgICB0aHJvdyBmYWlsKCk7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgdGhyb3cgZmFpbCgpO1xuICAgIH1cbiAgICBnZXQgY29sb3IoKSB7XG4gICAgICAgIHRocm93IGZhaWwoKTtcbiAgICB9XG4gICAgZ2V0IGxlZnQoKSB7XG4gICAgICAgIHRocm93IGZhaWwoKTtcbiAgICB9XG4gICAgZ2V0IHJpZ2h0KCkge1xuICAgICAgICB0aHJvdyBmYWlsKCk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IG5vZGUuXG4gICAgY29weShrZXksIHZhbHVlLCBjb2xvciwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSB0cmVlLCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5L3ZhbHVlIGFkZGVkLlxuICAgIGluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgTExSQk5vZGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSB0cmVlLCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5IHJlbW92ZWQuXG4gICAgcmVtb3ZlKGtleSwgY29tcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtaW5LZXkoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBtYXhLZXkoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpc1JlZCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBGb3IgdGVzdGluZy5cbiAgICBjaGVja01heERlcHRoKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2hlY2soKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn0gLy8gZW5kIExMUkJFbXB0eU5vZGVcbkxMUkJOb2RlLkVNUFRZID0gbmV3IExMUkJFbXB0eU5vZGUoKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogU29ydGVkU2V0IGlzIGFuIGltbXV0YWJsZSAoY29weS1vbi13cml0ZSkgY29sbGVjdGlvbiB0aGF0IGhvbGRzIGVsZW1lbnRzXG4gKiBpbiBvcmRlciBzcGVjaWZpZWQgYnkgdGhlIHByb3ZpZGVkIGNvbXBhcmF0b3IuXG4gKlxuICogTk9URTogaWYgcHJvdmlkZWQgY29tcGFyYXRvciByZXR1cm5zIDAgZm9yIHR3byBlbGVtZW50cywgd2UgY29uc2lkZXIgdGhlbSB0b1xuICogYmUgZXF1YWwhXG4gKi9cbmNsYXNzIFNvcnRlZFNldCB7XG4gICAgY29uc3RydWN0b3IoY29tcGFyYXRvcikge1xuICAgICAgICB0aGlzLmNvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgU29ydGVkTWFwKHRoaXMuY29tcGFyYXRvcik7XG4gICAgfVxuICAgIGhhcyhlbGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuZ2V0KGVsZW0pICE9PSBudWxsO1xuICAgIH1cbiAgICBmaXJzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5taW5LZXkoKTtcbiAgICB9XG4gICAgbGFzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5tYXhLZXkoKTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuc2l6ZTtcbiAgICB9XG4gICAgaW5kZXhPZihlbGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuaW5kZXhPZihlbGVtKTtcbiAgICB9XG4gICAgLyoqIEl0ZXJhdGVzIGVsZW1lbnRzIGluIG9yZGVyIGRlZmluZWQgYnkgXCJjb21wYXJhdG9yXCIgKi9cbiAgICBmb3JFYWNoKGNiKSB7XG4gICAgICAgIHRoaXMuZGF0YS5pbm9yZGVyVHJhdmVyc2FsKChrLCB2KSA9PiB7XG4gICAgICAgICAgICBjYihrKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBJdGVyYXRlcyBvdmVyIGBlbGVtYHMgc3VjaCB0aGF0OiByYW5nZVswXSAmbHQ7PSBlbGVtICZsdDsgcmFuZ2VbMV0uICovXG4gICAgZm9yRWFjaEluUmFuZ2UocmFuZ2UsIGNiKSB7XG4gICAgICAgIGNvbnN0IGl0ZXIgPSB0aGlzLmRhdGEuZ2V0SXRlcmF0b3JGcm9tKHJhbmdlWzBdKTtcbiAgICAgICAgd2hpbGUgKGl0ZXIuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtID0gaXRlci5nZXROZXh0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wYXJhdG9yKGVsZW0ua2V5LCByYW5nZVsxXSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNiKGVsZW0ua2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGBlbGVtYHMgc3VjaCB0aGF0OiBzdGFydCAmbHQ7PSBlbGVtIHVudGlsIGZhbHNlIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGZvckVhY2hXaGlsZShjYiwgc3RhcnQpIHtcbiAgICAgICAgbGV0IGl0ZXI7XG4gICAgICAgIGlmIChzdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpdGVyID0gdGhpcy5kYXRhLmdldEl0ZXJhdG9yRnJvbShzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVyID0gdGhpcy5kYXRhLmdldEl0ZXJhdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGl0ZXIuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtID0gaXRlci5nZXROZXh0KCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYihlbGVtLmtleSk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogRmluZHMgdGhlIGxlYXN0IGVsZW1lbnQgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBlbGVtYC4gKi9cbiAgICBmaXJzdEFmdGVyT3JFcXVhbChlbGVtKSB7XG4gICAgICAgIGNvbnN0IGl0ZXIgPSB0aGlzLmRhdGEuZ2V0SXRlcmF0b3JGcm9tKGVsZW0pO1xuICAgICAgICByZXR1cm4gaXRlci5oYXNOZXh0KCkgPyBpdGVyLmdldE5leHQoKS5rZXkgOiBudWxsO1xuICAgIH1cbiAgICBnZXRJdGVyYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRTZXRJdGVyYXRvcih0aGlzLmRhdGEuZ2V0SXRlcmF0b3IoKSk7XG4gICAgfVxuICAgIGdldEl0ZXJhdG9yRnJvbShrZXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRTZXRJdGVyYXRvcih0aGlzLmRhdGEuZ2V0SXRlcmF0b3JGcm9tKGtleSkpO1xuICAgIH1cbiAgICAvKiogSW5zZXJ0cyBvciB1cGRhdGVzIGFuIGVsZW1lbnQgKi9cbiAgICBhZGQoZWxlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb3B5KHRoaXMuZGF0YS5yZW1vdmUoZWxlbSkuaW5zZXJ0KGVsZW0sIHRydWUpKTtcbiAgICB9XG4gICAgLyoqIERlbGV0ZXMgYW4gZWxlbWVudCAqL1xuICAgIGRlbGV0ZShlbGVtKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXMoZWxlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvcHkodGhpcy5kYXRhLnJlbW92ZShlbGVtKSk7XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuaXNFbXB0eSgpO1xuICAgIH1cbiAgICB1bmlvbldpdGgob3RoZXIpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXM7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBgcmVzdWx0YCBhbHdheXMgcmVmZXJzIHRvIHRoZSBsYXJnZXIgb25lIG9mIHRoZSB0d28gc2V0cy5cbiAgICAgICAgaWYgKHJlc3VsdC5zaXplIDwgb3RoZXIuc2l6ZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gb3RoZXI7XG4gICAgICAgICAgICBvdGhlciA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXIuZm9yRWFjaChlbGVtID0+IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoZWxlbSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU29ydGVkU2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNpemUgIT09IG90aGVyLnNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aGlzSXQgPSB0aGlzLmRhdGEuZ2V0SXRlcmF0b3IoKTtcbiAgICAgICAgY29uc3Qgb3RoZXJJdCA9IG90aGVyLmRhdGEuZ2V0SXRlcmF0b3IoKTtcbiAgICAgICAgd2hpbGUgKHRoaXNJdC5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRoaXNFbGVtID0gdGhpc0l0LmdldE5leHQoKS5rZXk7XG4gICAgICAgICAgICBjb25zdCBvdGhlckVsZW0gPSBvdGhlckl0LmdldE5leHQoKS5rZXk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wYXJhdG9yKHRoaXNFbGVtLCBvdGhlckVsZW0pICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0b0FycmF5KCkge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKHRhcmdldElkID0+IHtcbiAgICAgICAgICAgIHJlcy5wdXNoKHRhcmdldElkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKGVsZW0gPT4gcmVzdWx0LnB1c2goZWxlbSkpO1xuICAgICAgICByZXR1cm4gJ1NvcnRlZFNldCgnICsgcmVzdWx0LnRvU3RyaW5nKCkgKyAnKSc7XG4gICAgfVxuICAgIGNvcHkoZGF0YSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU29ydGVkU2V0KHRoaXMuY29tcGFyYXRvcik7XG4gICAgICAgIHJlc3VsdC5kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5jbGFzcyBTb3J0ZWRTZXRJdGVyYXRvciB7XG4gICAgY29uc3RydWN0b3IoaXRlcikge1xuICAgICAgICB0aGlzLml0ZXIgPSBpdGVyO1xuICAgIH1cbiAgICBnZXROZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVyLmdldE5leHQoKS5rZXk7XG4gICAgfVxuICAgIGhhc05leHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXIuaGFzTmV4dCgpO1xuICAgIH1cbn1cbi8qKlxuICogQ29tcGFyZXMgdHdvIHNvcnRlZCBzZXRzIGZvciBlcXVhbGl0eSB1c2luZyB0aGVpciBuYXR1cmFsIG9yZGVyaW5nLiBUaGVcbiAqIG1ldGhvZCBjb21wdXRlcyB0aGUgaW50ZXJzZWN0aW9uIGFuZCBpbnZva2VzIGBvbkFkZGAgZm9yIGV2ZXJ5IGVsZW1lbnQgdGhhdFxuICogaXMgaW4gYGFmdGVyYCBidXQgbm90IGBiZWZvcmVgLiBgb25SZW1vdmVgIGlzIGludm9rZWQgZm9yIGV2ZXJ5IGVsZW1lbnQgaW5cbiAqIGBiZWZvcmVgIGJ1dCBtaXNzaW5nIGZyb20gYGFmdGVyYC5cbiAqXG4gKiBUaGUgbWV0aG9kIGNyZWF0ZXMgYSBjb3B5IG9mIGJvdGggYGJlZm9yZWAgYW5kIGBhZnRlcmAgYW5kIHJ1bnMgaW4gTyhuIGxvZ1xuICogbiksIHdoZXJlIG4gaXMgdGhlIHNpemUgb2YgdGhlIHR3byBsaXN0cy5cbiAqXG4gKiBAcGFyYW0gYmVmb3JlIC0gVGhlIGVsZW1lbnRzIHRoYXQgZXhpc3QgaW4gdGhlIG9yaWdpbmFsIHNldC5cbiAqIEBwYXJhbSBhZnRlciAtIFRoZSBlbGVtZW50cyB0byBkaWZmIGFnYWluc3QgdGhlIG9yaWdpbmFsIHNldC5cbiAqIEBwYXJhbSBjb21wYXJhdG9yIC0gVGhlIGNvbXBhcmF0b3IgZm9yIHRoZSBlbGVtZW50cyBpbiBiZWZvcmUgYW5kIGFmdGVyLlxuICogQHBhcmFtIG9uQWRkIC0gQSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGV2ZXJ5IGVsZW1lbnQgdGhhdCBpcyBwYXJ0IG9mIGBcbiAqIGFmdGVyYCBidXQgbm90IGBiZWZvcmVgLlxuICogQHBhcmFtIG9uUmVtb3ZlIC0gQSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGV2ZXJ5IGVsZW1lbnQgdGhhdCBpcyBwYXJ0IG9mXG4gKiBgYmVmb3JlYCBidXQgbm90IGBhZnRlcmAuXG4gKi9cbmZ1bmN0aW9uIGRpZmZTb3J0ZWRTZXRzKGJlZm9yZSwgYWZ0ZXIsIGNvbXBhcmF0b3IsIG9uQWRkLCBvblJlbW92ZSkge1xuICAgIGNvbnN0IGJlZm9yZUl0ID0gYmVmb3JlLmdldEl0ZXJhdG9yKCk7XG4gICAgY29uc3QgYWZ0ZXJJdCA9IGFmdGVyLmdldEl0ZXJhdG9yKCk7XG4gICAgbGV0IGJlZm9yZVZhbHVlID0gYWR2YW5jZUl0ZXJhdG9yKGJlZm9yZUl0KTtcbiAgICBsZXQgYWZ0ZXJWYWx1ZSA9IGFkdmFuY2VJdGVyYXRvcihhZnRlckl0KTtcbiAgICAvLyBXYWxrIHRocm91Z2ggdGhlIHR3byBzZXRzIGF0IHRoZSBzYW1lIHRpbWUsIHVzaW5nIHRoZSBvcmRlcmluZyBkZWZpbmVkIGJ5XG4gICAgLy8gYGNvbXBhcmF0b3JgLlxuICAgIHdoaWxlIChiZWZvcmVWYWx1ZSB8fCBhZnRlclZhbHVlKSB7XG4gICAgICAgIGxldCBhZGRlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgcmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoYmVmb3JlVmFsdWUgJiYgYWZ0ZXJWYWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgY21wID0gY29tcGFyYXRvcihiZWZvcmVWYWx1ZSwgYWZ0ZXJWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IHdhcyByZW1vdmVkIGlmIHRoZSBuZXh0IGVsZW1lbnQgaW4gb3VyIG9yZGVyZWRcbiAgICAgICAgICAgICAgICAvLyB3YWxrdGhyb3VnaCBpcyBvbmx5IGluIGBiZWZvcmVgLlxuICAgICAgICAgICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IHdhcyBhZGRlZCBpZiB0aGUgbmV4dCBlbGVtZW50IGluIG91ciBvcmRlcmVkIHdhbGt0aHJvdWdoXG4gICAgICAgICAgICAgICAgLy8gaXMgb25seSBpbiBgYWZ0ZXJgLlxuICAgICAgICAgICAgICAgIGFkZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiZWZvcmVWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFkZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRkZWQpIHtcbiAgICAgICAgICAgIG9uQWRkKGFmdGVyVmFsdWUpO1xuICAgICAgICAgICAgYWZ0ZXJWYWx1ZSA9IGFkdmFuY2VJdGVyYXRvcihhZnRlckl0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZW1vdmVkKSB7XG4gICAgICAgICAgICBvblJlbW92ZShiZWZvcmVWYWx1ZSk7XG4gICAgICAgICAgICBiZWZvcmVWYWx1ZSA9IGFkdmFuY2VJdGVyYXRvcihiZWZvcmVJdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBiZWZvcmVWYWx1ZSA9IGFkdmFuY2VJdGVyYXRvcihiZWZvcmVJdCk7XG4gICAgICAgICAgICBhZnRlclZhbHVlID0gYWR2YW5jZUl0ZXJhdG9yKGFmdGVySXQpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuZXh0IGVsZW1lbnQgZnJvbSB0aGUgaXRlcmF0b3Igb3IgYHVuZGVmaW5lZGAgaWYgbm9uZSBhdmFpbGFibGUuXG4gKi9cbmZ1bmN0aW9uIGFkdmFuY2VJdGVyYXRvcihpdCkge1xuICAgIHJldHVybiBpdC5oYXNOZXh0KCkgPyBpdC5nZXROZXh0KCkgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFByb3ZpZGVzIGEgc2V0IG9mIGZpZWxkcyB0aGF0IGNhbiBiZSB1c2VkIHRvIHBhcnRpYWxseSBwYXRjaCBhIGRvY3VtZW50LlxuICogRmllbGRNYXNrIGlzIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBPYmplY3RWYWx1ZS5cbiAqIEV4YW1wbGVzOlxuICogICBmb28gLSBPdmVyd3JpdGVzIGZvbyBlbnRpcmVseSB3aXRoIHRoZSBwcm92aWRlZCB2YWx1ZS4gSWYgZm9vIGlzIG5vdFxuICogICAgICAgICBwcmVzZW50IGluIHRoZSBjb21wYW5pb24gT2JqZWN0VmFsdWUsIHRoZSBmaWVsZCBpcyBkZWxldGVkLlxuICogICBmb28uYmFyIC0gT3ZlcndyaXRlcyBvbmx5IHRoZSBmaWVsZCBiYXIgb2YgdGhlIG9iamVjdCBmb28uXG4gKiAgICAgICAgICAgICBJZiBmb28gaXMgbm90IGFuIG9iamVjdCwgZm9vIGlzIHJlcGxhY2VkIHdpdGggYW4gb2JqZWN0XG4gKiAgICAgICAgICAgICBjb250YWluaW5nIGZvb1xuICovXG5jbGFzcyBGaWVsZE1hc2sge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICAgICAgLy8gVE9ETyhkaW1vbmQpOiB2YWxpZGF0aW9uIG9mIEZpZWxkTWFza1xuICAgICAgICAvLyBTb3J0IHRoZSBmaWVsZCBtYXNrIHRvIHN1cHBvcnQgYEZpZWxkTWFzay5pc0VxdWFsKClgIGFuZCBhc3NlcnQgYmVsb3cuXG4gICAgICAgIGZpZWxkcy5zb3J0KEZpZWxkUGF0aCQxLmNvbXBhcmF0b3IpO1xuICAgIH1cbiAgICBzdGF0aWMgZW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGRNYXNrKFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBGaWVsZE1hc2sgb2JqZWN0IHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBhZGRpbmcgYWxsIHRoZSBnaXZlblxuICAgICAqIGZpZWxkcyBwYXRocyB0byB0aGlzIGZpZWxkIG1hc2suXG4gICAgICovXG4gICAgdW5pb25XaXRoKGV4dHJhRmllbGRzKSB7XG4gICAgICAgIGxldCBtZXJnZWRNYXNrU2V0ID0gbmV3IFNvcnRlZFNldChGaWVsZFBhdGgkMS5jb21wYXJhdG9yKTtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZFBhdGggb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgICAgIG1lcmdlZE1hc2tTZXQgPSBtZXJnZWRNYXNrU2V0LmFkZChmaWVsZFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZmllbGRQYXRoIG9mIGV4dHJhRmllbGRzKSB7XG4gICAgICAgICAgICBtZXJnZWRNYXNrU2V0ID0gbWVyZ2VkTWFza1NldC5hZGQoZmllbGRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZpZWxkTWFzayhtZXJnZWRNYXNrU2V0LnRvQXJyYXkoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIHRoYXQgYGZpZWxkUGF0aGAgaXMgaW5jbHVkZWQgYnkgYXQgbGVhc3Qgb25lIGZpZWxkIGluIHRoaXMgZmllbGRcbiAgICAgKiBtYXNrLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhbiBPKG4pIG9wZXJhdGlvbiwgd2hlcmUgYG5gIGlzIHRoZSBzaXplIG9mIHRoZSBmaWVsZCBtYXNrLlxuICAgICAqL1xuICAgIGNvdmVycyhmaWVsZFBhdGgpIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZE1hc2tQYXRoIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAoZmllbGRNYXNrUGF0aC5pc1ByZWZpeE9mKGZpZWxkUGF0aCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5RXF1YWxzKHRoaXMuZmllbGRzLCBvdGhlci5maWVsZHMsIChsLCByKSA9PiBsLmlzRXF1YWwocikpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKiBDb252ZXJ0cyBhIEJhc2U2NCBlbmNvZGVkIHN0cmluZyB0byBhIGJpbmFyeSBzdHJpbmcuICovXG5mdW5jdGlvbiBkZWNvZGVCYXNlNjQoZW5jb2RlZCkge1xuICAgIC8vIE5vdGU6IFdlIHVzZWQgdG8gdmFsaWRhdGUgdGhlIGJhc2U2NCBzdHJpbmcgaGVyZSB2aWEgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAgLy8gVGhpcyB3YXMgcmVtb3ZlZCB0byBpbXByb3ZlIHRoZSBwZXJmb3JtYW5jZSBvZiBpbmRleGluZy5cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oZW5jb2RlZCwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdiaW5hcnknKTtcbn1cbi8qKiBDb252ZXJ0cyBhIGJpbmFyeSBzdHJpbmcgdG8gYSBCYXNlNjQgZW5jb2RlZCBzdHJpbmcuICovXG5mdW5jdGlvbiBlbmNvZGVCYXNlNjQocmF3KSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHJhdywgJ2JpbmFyeScpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbn1cbi8qKiBUcnVlIGlmIGFuZCBvbmx5IGlmIHRoZSBCYXNlNjQgY29udmVyc2lvbiBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZS4gKi9cbmZ1bmN0aW9uIGlzQmFzZTY0QXZhaWxhYmxlKCkge1xuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBJbW11dGFibGUgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgXCJwcm90b1wiIGJ5dGUgc3RyaW5nLlxuICpcbiAqIFByb3RvIGJ5dGUgc3RyaW5ncyBjYW4gZWl0aGVyIGJlIEJhc2U2NC1lbmNvZGVkIHN0cmluZ3Mgb3IgVWludDhBcnJheXMgd2hlblxuICogc2VudCBvbiB0aGUgd2lyZS4gVGhpcyBjbGFzcyBhYnN0cmFjdHMgYXdheSB0aGlzIGRpZmZlcmVudGlhdGlvbiBieSBob2xkaW5nXG4gKiB0aGUgcHJvdG8gYnl0ZSBzdHJpbmcgaW4gYSBjb21tb24gY2xhc3MgdGhhdCBtdXN0IGJlIGNvbnZlcnRlZCBpbnRvIGEgc3RyaW5nXG4gKiBiZWZvcmUgYmVpbmcgc2VudCBhcyBhIHByb3RvLlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIEJ5dGVTdHJpbmcge1xuICAgIGNvbnN0cnVjdG9yKGJpbmFyeVN0cmluZykge1xuICAgICAgICB0aGlzLmJpbmFyeVN0cmluZyA9IGJpbmFyeVN0cmluZztcbiAgICB9XG4gICAgc3RhdGljIGZyb21CYXNlNjRTdHJpbmcoYmFzZTY0KSB7XG4gICAgICAgIGNvbnN0IGJpbmFyeVN0cmluZyA9IGRlY29kZUJhc2U2NChiYXNlNjQpO1xuICAgICAgICByZXR1cm4gbmV3IEJ5dGVTdHJpbmcoYmluYXJ5U3RyaW5nKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21VaW50OEFycmF5KGFycmF5KSB7XG4gICAgICAgIC8vIFRPRE8oaW5kZXhpbmcpOyBSZW1vdmUgdGhlIGNvcHkgb2YgdGhlIGJ5dGUgc3RyaW5nIGhlcmUgYXMgdGhpcyBtZXRob2RcbiAgICAgICAgLy8gaXMgZnJlcXVlbnRseSBjYWxsZWQgZHVyaW5nIGluZGV4aW5nLlxuICAgICAgICBjb25zdCBiaW5hcnlTdHJpbmcgPSBiaW5hcnlTdHJpbmdGcm9tVWludDhBcnJheShhcnJheSk7XG4gICAgICAgIHJldHVybiBuZXcgQnl0ZVN0cmluZyhiaW5hcnlTdHJpbmcpO1xuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgdGhpcy5iaW5hcnlTdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB0aGlzLmJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkrKyksIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICB0b0Jhc2U2NCgpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZUJhc2U2NCh0aGlzLmJpbmFyeVN0cmluZyk7XG4gICAgfVxuICAgIHRvVWludDhBcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlGcm9tQmluYXJ5U3RyaW5nKHRoaXMuYmluYXJ5U3RyaW5nKTtcbiAgICB9XG4gICAgYXBwcm94aW1hdGVCeXRlU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5U3RyaW5nLmxlbmd0aCAqIDI7XG4gICAgfVxuICAgIGNvbXBhcmVUbyhvdGhlcikge1xuICAgICAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcih0aGlzLmJpbmFyeVN0cmluZywgb3RoZXIuYmluYXJ5U3RyaW5nKTtcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5hcnlTdHJpbmcgPT09IG90aGVyLmJpbmFyeVN0cmluZztcbiAgICB9XG59XG5CeXRlU3RyaW5nLkVNUFRZX0JZVEVfU1RSSU5HID0gbmV3IEJ5dGVTdHJpbmcoJycpO1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBhbiBVaW50OGFycmF5IHRvIGEgYmluYXJ5IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmluYXJ5U3RyaW5nRnJvbVVpbnQ4QXJyYXkoYXJyYXkpIHtcbiAgICBsZXQgYmluYXJ5U3RyaW5nID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICBiaW5hcnlTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7XG4gICAgfVxuICAgIHJldHVybiBiaW5hcnlTdHJpbmc7XG59XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IGEgYmluYXJ5IHN0cmluZyB0byBhbiBVaW50OEFycmF5LlxuICovXG5mdW5jdGlvbiB1aW50OEFycmF5RnJvbUJpbmFyeVN0cmluZyhiaW5hcnlTdHJpbmcpIHtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShiaW5hcnlTdHJpbmcubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICBidWZmZXJbaV0gPSBiaW5hcnlTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8vIEEgUmVnRXhwIG1hdGNoaW5nIElTTyA4NjAxIFVUQyB0aW1lc3RhbXBzIHdpdGggb3B0aW9uYWwgZnJhY3Rpb24uXG5jb25zdCBJU09fVElNRVNUQU1QX1JFR19FWFAgPSBuZXcgUmVnRXhwKC9eXFxkezR9LVxcZFxcZC1cXGRcXGRUXFxkXFxkOlxcZFxcZDpcXGRcXGQoPzpcXC4oXFxkKykpP1okLyk7XG4vKipcbiAqIENvbnZlcnRzIHRoZSBwb3NzaWJsZSBQcm90byB2YWx1ZXMgZm9yIGEgdGltZXN0YW1wIHZhbHVlIGludG8gYSBcInNlY29uZHMgYW5kXG4gKiBuYW5vc1wiIHJlcHJlc2VudGF0aW9uLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVUaW1lc3RhbXAoZGF0ZSkge1xuICAgIGhhcmRBc3NlcnQoISFkYXRlKTtcbiAgICAvLyBUaGUganNvbiBpbnRlcmZhY2UgKGZvciB0aGUgYnJvd3Nlcikgd2lsbCByZXR1cm4gYW4gaXNvIHRpbWVzdGFtcCBzdHJpbmcsXG4gICAgLy8gd2hpbGUgdGhlIHByb3RvIGpzIGxpYnJhcnkgKGZvciBub2RlKSB3aWxsIHJldHVybiBhXG4gICAgLy8gZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBpbnN0YW5jZS5cbiAgICBpZiAodHlwZW9mIGRhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIFRoZSBkYXRlIHN0cmluZyBjYW4gaGF2ZSBoaWdoZXIgcHJlY2lzaW9uIChuYW5vcykgdGhhbiB0aGUgRGF0ZSBjbGFzc1xuICAgICAgICAvLyAobWlsbGlzKSwgc28gd2UgZG8gc29tZSBjdXN0b20gcGFyc2luZyBoZXJlLlxuICAgICAgICAvLyBQYXJzZSB0aGUgbmFub3MgcmlnaHQgb3V0IG9mIHRoZSBzdHJpbmcuXG4gICAgICAgIGxldCBuYW5vcyA9IDA7XG4gICAgICAgIGNvbnN0IGZyYWN0aW9uID0gSVNPX1RJTUVTVEFNUF9SRUdfRVhQLmV4ZWMoZGF0ZSk7XG4gICAgICAgIGhhcmRBc3NlcnQoISFmcmFjdGlvbik7XG4gICAgICAgIGlmIChmcmFjdGlvblsxXSkge1xuICAgICAgICAgICAgLy8gUGFkIHRoZSBmcmFjdGlvbiBvdXQgdG8gOSBkaWdpdHMgKG5hbm9zKS5cbiAgICAgICAgICAgIGxldCBuYW5vU3RyID0gZnJhY3Rpb25bMV07XG4gICAgICAgICAgICBuYW5vU3RyID0gKG5hbm9TdHIgKyAnMDAwMDAwMDAwJykuc3Vic3RyKDAsIDkpO1xuICAgICAgICAgICAgbmFub3MgPSBOdW1iZXIobmFub1N0cik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFyc2UgdGhlIGRhdGUgdG8gZ2V0IHRoZSBzZWNvbmRzLlxuICAgICAgICBjb25zdCBwYXJzZWREYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgICAgIGNvbnN0IHNlY29uZHMgPSBNYXRoLmZsb29yKHBhcnNlZERhdGUuZ2V0VGltZSgpIC8gMTAwMCk7XG4gICAgICAgIHJldHVybiB7IHNlY29uZHMsIG5hbm9zIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBUT0RPKGIvMzcyODIyMzcpOiBVc2Ugc3RyaW5ncyBmb3IgUHJvdG8zIHRpbWVzdGFtcHNcbiAgICAgICAgLy8gYXNzZXJ0KCF0aGlzLm9wdGlvbnMudXNlUHJvdG8zSnNvbixcbiAgICAgICAgLy8gICAnVGhlIHRpbWVzdGFtcCBpbnN0YW5jZSBmb3JtYXQgcmVxdWlyZXMgUHJvdG8gSlMuJyk7XG4gICAgICAgIGNvbnN0IHNlY29uZHMgPSBub3JtYWxpemVOdW1iZXIoZGF0ZS5zZWNvbmRzKTtcbiAgICAgICAgY29uc3QgbmFub3MgPSBub3JtYWxpemVOdW1iZXIoZGF0ZS5uYW5vcyk7XG4gICAgICAgIHJldHVybiB7IHNlY29uZHMsIG5hbm9zIH07XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgcG9zc2libGUgUHJvdG8gdHlwZXMgZm9yIG51bWJlcnMgaW50byBhIEphdmFTY3JpcHQgbnVtYmVyLlxuICogUmV0dXJucyAwIGlmIHRoZSB2YWx1ZSBpcyBub3QgbnVtZXJpYy5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplTnVtYmVyKHZhbHVlKSB7XG4gICAgLy8gVE9ETyhiam9ybmljayk6IEhhbmRsZSBpbnQ2NCBncmVhdGVyIHRoYW4gNTMgYml0cy5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG4vKiogQ29udmVydHMgdGhlIHBvc3NpYmxlIFByb3RvIHR5cGVzIGZvciBCbG9icyBpbnRvIGEgQnl0ZVN0cmluZy4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUJ5dGVTdHJpbmcoYmxvYikge1xuICAgIGlmICh0eXBlb2YgYmxvYiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIEJ5dGVTdHJpbmcuZnJvbUJhc2U2NFN0cmluZyhibG9iKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBCeXRlU3RyaW5nLmZyb21VaW50OEFycmF5KGJsb2IpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUmVwcmVzZW50cyBhIGxvY2FsbHktYXBwbGllZCBTZXJ2ZXJUaW1lc3RhbXAuXG4gKlxuICogU2VydmVyIFRpbWVzdGFtcHMgYXJlIGJhY2tlZCBieSBNYXBWYWx1ZXMgdGhhdCBjb250YWluIGFuIGludGVybmFsIGZpZWxkXG4gKiBgX190eXBlX19gIHdpdGggYSB2YWx1ZSBvZiBgc2VydmVyX3RpbWVzdGFtcGAuIFRoZSBwcmV2aW91cyB2YWx1ZSBhbmQgbG9jYWxcbiAqIHdyaXRlIHRpbWUgYXJlIHN0b3JlZCBpbiBpdHMgYF9fcHJldmlvdXNfdmFsdWVfX2AgYW5kIGBfX2xvY2FsX3dyaXRlX3RpbWVfX2BcbiAqIGZpZWxkcyByZXNwZWN0aXZlbHkuXG4gKlxuICogTm90ZXM6XG4gKiAtIFNlcnZlclRpbWVzdGFtcFZhbHVlIGluc3RhbmNlcyBhcmUgY3JlYXRlZCBhcyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGFcbiAqICAgdHJhbnNmb3JtLiBUaGV5IGNhbiBvbmx5IGV4aXN0IGluIHRoZSBsb2NhbCB2aWV3IG9mIGEgZG9jdW1lbnQuIFRoZXJlZm9yZVxuICogICB0aGV5IGRvIG5vdCBuZWVkIHRvIGJlIHBhcnNlZCBvciBzZXJpYWxpemVkLlxuICogLSBXaGVuIGV2YWx1YXRlZCBsb2NhbGx5IChlLmcuIGZvciBzbmFwc2hvdC5kYXRhKCkpLCB0aGV5IGJ5IGRlZmF1bHRcbiAqICAgZXZhbHVhdGUgdG8gYG51bGxgLiBUaGlzIGJlaGF2aW9yIGNhbiBiZSBjb25maWd1cmVkIGJ5IHBhc3NpbmcgY3VzdG9tXG4gKiAgIEZpZWxkVmFsdWVPcHRpb25zIHRvIHZhbHVlKCkuXG4gKiAtIFdpdGggcmVzcGVjdCB0byBvdGhlciBTZXJ2ZXJUaW1lc3RhbXBWYWx1ZXMsIHRoZXkgc29ydCBieSB0aGVpclxuICogICBsb2NhbFdyaXRlVGltZS5cbiAqL1xuY29uc3QgU0VSVkVSX1RJTUVTVEFNUF9TRU5USU5FTCA9ICdzZXJ2ZXJfdGltZXN0YW1wJztcbmNvbnN0IFRZUEVfS0VZJDEgPSAnX190eXBlX18nO1xuY29uc3QgUFJFVklPVVNfVkFMVUVfS0VZID0gJ19fcHJldmlvdXNfdmFsdWVfXyc7XG5jb25zdCBMT0NBTF9XUklURV9USU1FX0tFWSA9ICdfX2xvY2FsX3dyaXRlX3RpbWVfXyc7XG5mdW5jdGlvbiBpc1NlcnZlclRpbWVzdGFtcCh2YWx1ZSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgdHlwZSA9IChfYiA9ICgoKF9hID0gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLm1hcFZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmllbGRzKSB8fCB7fSlbVFlQRV9LRVkkMV0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdHJpbmdWYWx1ZTtcbiAgICByZXR1cm4gdHlwZSA9PT0gU0VSVkVSX1RJTUVTVEFNUF9TRU5USU5FTDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBTZXJ2ZXJUaW1lc3RhbXAgcHJvdG8gdmFsdWUgKHVzaW5nIHRoZSBpbnRlcm5hbCBmb3JtYXQpLlxuICovXG5mdW5jdGlvbiBzZXJ2ZXJUaW1lc3RhbXAkMShsb2NhbFdyaXRlVGltZSwgcHJldmlvdXNWYWx1ZSkge1xuICAgIGNvbnN0IG1hcFZhbHVlID0ge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIFtUWVBFX0tFWSQxXToge1xuICAgICAgICAgICAgICAgIHN0cmluZ1ZhbHVlOiBTRVJWRVJfVElNRVNUQU1QX1NFTlRJTkVMXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW0xPQ0FMX1dSSVRFX1RJTUVfS0VZXToge1xuICAgICAgICAgICAgICAgIHRpbWVzdGFtcFZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIHNlY29uZHM6IGxvY2FsV3JpdGVUaW1lLnNlY29uZHMsXG4gICAgICAgICAgICAgICAgICAgIG5hbm9zOiBsb2NhbFdyaXRlVGltZS5uYW5vc2Vjb25kc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gV2Ugc2hvdWxkIGF2b2lkIHN0b3JpbmcgZGVlcGx5IG5lc3RlZCBzZXJ2ZXIgdGltZXN0YW1wIG1hcCB2YWx1ZXNcbiAgICAvLyBiZWNhdXNlIHdlIG5ldmVyIHVzZSB0aGUgaW50ZXJtZWRpYXRlIFwicHJldmlvdXMgdmFsdWVzXCIuXG4gICAgLy8gRm9yIGV4YW1wbGU6XG4gICAgLy8gcHJldmlvdXM6IDQyTCwgYWRkOiB0MSwgcmVzdWx0OiB0MSAtPiA0MkxcbiAgICAvLyBwcmV2aW91czogdDEsICBhZGQ6IHQyLCByZXN1bHQ6IHQyIC0+IDQyTCAoTk9UIHQyIC0+IHQxIC0+IDQyTClcbiAgICAvLyBwcmV2aW91czogdDIsICBhZGQ6IHQzLCByZXN1bHQ6IHQzIC0+IDQyTCAoTk9UIHQzIC0+IHQyIC0+IHQxIC0+IDQyTClcbiAgICAvLyBgZ2V0UHJldmlvdXNWYWx1ZWAgcmVjdXJzaXZlbHkgdHJhdmVyc2VzIHNlcnZlciB0aW1lc3RhbXBzIHRvIGZpbmQgdGhlXG4gICAgLy8gbGVhc3QgcmVjZW50IFZhbHVlLlxuICAgIGlmIChwcmV2aW91c1ZhbHVlICYmIGlzU2VydmVyVGltZXN0YW1wKHByZXZpb3VzVmFsdWUpKSB7XG4gICAgICAgIHByZXZpb3VzVmFsdWUgPSBnZXRQcmV2aW91c1ZhbHVlKHByZXZpb3VzVmFsdWUpO1xuICAgIH1cbiAgICBpZiAocHJldmlvdXNWYWx1ZSkge1xuICAgICAgICBtYXBWYWx1ZS5maWVsZHNbUFJFVklPVVNfVkFMVUVfS0VZXSA9IHByZXZpb3VzVmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB7IG1hcFZhbHVlIH07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBmaWVsZCBiZWZvcmUgdGhpcyBTZXJ2ZXJUaW1lc3RhbXAgd2FzIHNldC5cbiAqXG4gKiBQcmVzZXJ2aW5nIHRoZSBwcmV2aW91cyB2YWx1ZXMgYWxsb3dzIHRoZSB1c2VyIHRvIGRpc3BsYXkgdGhlIGxhc3QgcmVzb2xlZFxuICogdmFsdWUgdW50aWwgdGhlIGJhY2tlbmQgcmVzcG9uZHMgd2l0aCB0aGUgdGltZXN0YW1wLlxuICovXG5mdW5jdGlvbiBnZXRQcmV2aW91c1ZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHZhbHVlLm1hcFZhbHVlLmZpZWxkc1tQUkVWSU9VU19WQUxVRV9LRVldO1xuICAgIGlmIChpc1NlcnZlclRpbWVzdGFtcChwcmV2aW91c1ZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZ2V0UHJldmlvdXNWYWx1ZShwcmV2aW91c1ZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHByZXZpb3VzVmFsdWU7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGxvY2FsIHRpbWUgYXQgd2hpY2ggdGhpcyB0aW1lc3RhbXAgd2FzIGZpcnN0IHNldC5cbiAqL1xuZnVuY3Rpb24gZ2V0TG9jYWxXcml0ZVRpbWUodmFsdWUpIHtcbiAgICBjb25zdCBsb2NhbFdyaXRlVGltZSA9IG5vcm1hbGl6ZVRpbWVzdGFtcCh2YWx1ZS5tYXBWYWx1ZS5maWVsZHNbTE9DQUxfV1JJVEVfVElNRV9LRVldLnRpbWVzdGFtcFZhbHVlKTtcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcChsb2NhbFdyaXRlVGltZS5zZWNvbmRzLCBsb2NhbFdyaXRlVGltZS5uYW5vcyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBEYXRhYmFzZUluZm8ge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBEYXRhYmFzZUluZm8gdXNpbmcgdGhlIHByb3ZpZGVkIGhvc3QsIGRhdGFiYXNlSWQgYW5kXG4gICAgICogcGVyc2lzdGVuY2VLZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YWJhc2VJZCAtIFRoZSBkYXRhYmFzZSB0byB1c2UuXG4gICAgICogQHBhcmFtIGFwcElkIC0gVGhlIEZpcmViYXNlIEFwcCBJZC5cbiAgICAgKiBAcGFyYW0gcGVyc2lzdGVuY2VLZXkgLSBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIEZpcmVzdG9yZSdzIGxvY2FsXG4gICAgICogc3RvcmFnZSAodXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBkYXRhYmFzZUlkKS5cbiAgICAgKiBAcGFyYW0gaG9zdCAtIFRoZSBGaXJlc3RvcmUgYmFja2VuZCBob3N0IHRvIGNvbm5lY3QgdG8uXG4gICAgICogQHBhcmFtIHNzbCAtIFdoZXRoZXIgdG8gdXNlIFNTTCB3aGVuIGNvbm5lY3RpbmcuXG4gICAgICogQHBhcmFtIGZvcmNlTG9uZ1BvbGxpbmcgLSBXaGV0aGVyIHRvIHVzZSB0aGUgZm9yY2VMb25nUG9sbGluZyBvcHRpb25cbiAgICAgKiB3aGVuIHVzaW5nIFdlYkNoYW5uZWwgYXMgdGhlIG5ldHdvcmsgdHJhbnNwb3J0LlxuICAgICAqIEBwYXJhbSBhdXRvRGV0ZWN0TG9uZ1BvbGxpbmcgLSBXaGV0aGVyIHRvIHVzZSB0aGUgZGV0ZWN0QnVmZmVyaW5nUHJveHlcbiAgICAgKiBvcHRpb24gd2hlbiB1c2luZyBXZWJDaGFubmVsIGFzIHRoZSBuZXR3b3JrIHRyYW5zcG9ydC5cbiAgICAgKiBAcGFyYW0gbG9uZ1BvbGxpbmdPcHRpb25zIE9wdGlvbnMgdGhhdCBjb25maWd1cmUgbG9uZy1wb2xsaW5nLlxuICAgICAqIEBwYXJhbSB1c2VGZXRjaFN0cmVhbXMgV2hldGhlciB0byB1c2UgdGhlIEZldGNoIEFQSSBpbnN0ZWFkIG9mXG4gICAgICogWE1MSFRUUFJlcXVlc3RcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihkYXRhYmFzZUlkLCBhcHBJZCwgcGVyc2lzdGVuY2VLZXksIGhvc3QsIHNzbCwgZm9yY2VMb25nUG9sbGluZywgYXV0b0RldGVjdExvbmdQb2xsaW5nLCBsb25nUG9sbGluZ09wdGlvbnMsIHVzZUZldGNoU3RyZWFtcykge1xuICAgICAgICB0aGlzLmRhdGFiYXNlSWQgPSBkYXRhYmFzZUlkO1xuICAgICAgICB0aGlzLmFwcElkID0gYXBwSWQ7XG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2VLZXkgPSBwZXJzaXN0ZW5jZUtleTtcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgdGhpcy5zc2wgPSBzc2w7XG4gICAgICAgIHRoaXMuZm9yY2VMb25nUG9sbGluZyA9IGZvcmNlTG9uZ1BvbGxpbmc7XG4gICAgICAgIHRoaXMuYXV0b0RldGVjdExvbmdQb2xsaW5nID0gYXV0b0RldGVjdExvbmdQb2xsaW5nO1xuICAgICAgICB0aGlzLmxvbmdQb2xsaW5nT3B0aW9ucyA9IGxvbmdQb2xsaW5nT3B0aW9ucztcbiAgICAgICAgdGhpcy51c2VGZXRjaFN0cmVhbXMgPSB1c2VGZXRjaFN0cmVhbXM7XG4gICAgfVxufVxuLyoqIFRoZSBkZWZhdWx0IGRhdGFiYXNlIG5hbWUgZm9yIGEgcHJvamVjdC4gKi9cbmNvbnN0IERFRkFVTFRfREFUQUJBU0VfTkFNRSA9ICcoZGVmYXVsdCknO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBkYXRhYmFzZSBJRCBhIEZpcmVzdG9yZSBjbGllbnQgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIERhdGFiYXNlSWQge1xuICAgIGNvbnN0cnVjdG9yKHByb2plY3RJZCwgZGF0YWJhc2UpIHtcbiAgICAgICAgdGhpcy5wcm9qZWN0SWQgPSBwcm9qZWN0SWQ7XG4gICAgICAgIHRoaXMuZGF0YWJhc2UgPSBkYXRhYmFzZSA/IGRhdGFiYXNlIDogREVGQVVMVF9EQVRBQkFTRV9OQU1FO1xuICAgIH1cbiAgICBzdGF0aWMgZW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YWJhc2VJZCgnJywgJycpO1xuICAgIH1cbiAgICBnZXQgaXNEZWZhdWx0RGF0YWJhc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFiYXNlID09PSBERUZBVUxUX0RBVEFCQVNFX05BTUU7XG4gICAgfVxuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIChvdGhlciBpbnN0YW5jZW9mIERhdGFiYXNlSWQgJiZcbiAgICAgICAgICAgIG90aGVyLnByb2plY3RJZCA9PT0gdGhpcy5wcm9qZWN0SWQgJiZcbiAgICAgICAgICAgIG90aGVyLmRhdGFiYXNlID09PSB0aGlzLmRhdGFiYXNlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkYXRhYmFzZUlkRnJvbUFwcChhcHAsIGRhdGFiYXNlKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmFwcGx5KGFwcC5vcHRpb25zLCBbJ3Byb2plY3RJZCddKSkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnXCJwcm9qZWN0SWRcIiBub3QgcHJvdmlkZWQgaW4gZmlyZWJhc2UuaW5pdGlhbGl6ZUFwcC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRhYmFzZUlkKGFwcC5vcHRpb25zLnByb2plY3RJZCwgZGF0YWJhc2UpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqIFNlbnRpbmVsIHZhbHVlIHRoYXQgc29ydHMgYmVmb3JlIGFueSBNdXRhdGlvbiBCYXRjaCBJRC4gKi9cbmNvbnN0IEJBVENISURfVU5LTk9XTiA9IC0xO1xuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgYSB2YXJpYWJsZSBpcyBlaXRoZXIgdW5kZWZpbmVkIG9yIG51bGwuXG4gKi9cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG4vKiogUmV0dXJucyB3aGV0aGVyIHRoZSB2YWx1ZSByZXByZXNlbnRzIC0wLiAqL1xuZnVuY3Rpb24gaXNOZWdhdGl2ZVplcm8odmFsdWUpIHtcbiAgICAvLyBEZXRlY3QgaWYgdGhlIHZhbHVlIGlzIC0wLjAuIEJhc2VkIG9uIHBvbHlmaWxsIGZyb21cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlID09PSAxIC8gLTA7XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBhIHZhbHVlIGlzIGFuIGludGVnZXIgYW5kIGluIHRoZSBzYWZlIGludGVnZXIgcmFuZ2VcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0IGZvciBiZWluZyBhbiBpbnRlZ2VyIGFuZCBpbiB0aGUgc2FmZSByYW5nZVxuICovXG5mdW5jdGlvbiBpc1NhZmVJbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmXG4gICAgICAgIE51bWJlci5pc0ludGVnZXIodmFsdWUpICYmXG4gICAgICAgICFpc05lZ2F0aXZlWmVybyh2YWx1ZSkgJiZcbiAgICAgICAgdmFsdWUgPD0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgJiZcbiAgICAgICAgdmFsdWUgPj0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgVFlQRV9LRVkgPSAnX190eXBlX18nO1xuY29uc3QgTUFYX1ZBTFVFX1RZUEUgPSAnX19tYXhfXyc7XG5jb25zdCBNQVhfVkFMVUUgPSB7XG4gICAgbWFwVmFsdWU6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICAnX190eXBlX18nOiB7IHN0cmluZ1ZhbHVlOiBNQVhfVkFMVUVfVFlQRSB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgVkVDVE9SX1ZBTFVFX1NFTlRJTkVMID0gJ19fdmVjdG9yX18nO1xuY29uc3QgVkVDVE9SX01BUF9WRUNUT1JTX0tFWSA9ICd2YWx1ZSc7XG5jb25zdCBNSU5fVkFMVUUgPSB7XG4gICAgbnVsbFZhbHVlOiAnTlVMTF9WQUxVRSdcbn07XG4vKiogRXh0cmFjdHMgdGhlIGJhY2tlbmQncyB0eXBlIG9yZGVyIGZvciB0aGUgcHJvdmlkZWQgdmFsdWUuICovXG5mdW5jdGlvbiB0eXBlT3JkZXIodmFsdWUpIHtcbiAgICBpZiAoJ251bGxWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIDAgLyogVHlwZU9yZGVyLk51bGxWYWx1ZSAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2Jvb2xlYW5WYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIDEgLyogVHlwZU9yZGVyLkJvb2xlYW5WYWx1ZSAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2ludGVnZXJWYWx1ZScgaW4gdmFsdWUgfHwgJ2RvdWJsZVZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gMiAvKiBUeXBlT3JkZXIuTnVtYmVyVmFsdWUgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKCd0aW1lc3RhbXBWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIDMgLyogVHlwZU9yZGVyLlRpbWVzdGFtcFZhbHVlICovO1xuICAgIH1cbiAgICBlbHNlIGlmICgnc3RyaW5nVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiA1IC8qIFR5cGVPcmRlci5TdHJpbmdWYWx1ZSAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2J5dGVzVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiA2IC8qIFR5cGVPcmRlci5CbG9iVmFsdWUgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKCdyZWZlcmVuY2VWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIDcgLyogVHlwZU9yZGVyLlJlZlZhbHVlICovO1xuICAgIH1cbiAgICBlbHNlIGlmICgnZ2VvUG9pbnRWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIDggLyogVHlwZU9yZGVyLkdlb1BvaW50VmFsdWUgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKCdhcnJheVZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gOSAvKiBUeXBlT3JkZXIuQXJyYXlWYWx1ZSAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoJ21hcFZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNTZXJ2ZXJUaW1lc3RhbXAodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gNCAvKiBUeXBlT3JkZXIuU2VydmVyVGltZXN0YW1wVmFsdWUgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNNYXhWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiA5MDA3MTk5MjU0NzQwOTkxIC8qIFR5cGVPcmRlci5NYXhWYWx1ZSAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ZlY3RvclZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIDEwIC8qIFR5cGVPcmRlci5WZWN0b3JWYWx1ZSAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMTEgLyogVHlwZU9yZGVyLk9iamVjdFZhbHVlICovO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG59XG4vKiogVGVzdHMgYGxlZnRgIGFuZCBgcmlnaHRgIGZvciBlcXVhbGl0eSBiYXNlZCBvbiB0aGUgYmFja2VuZCBzZW1hbnRpY3MuICovXG5mdW5jdGlvbiB2YWx1ZUVxdWFscyhsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0ID09PSByaWdodCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgbGVmdFR5cGUgPSB0eXBlT3JkZXIobGVmdCk7XG4gICAgY29uc3QgcmlnaHRUeXBlID0gdHlwZU9yZGVyKHJpZ2h0KTtcbiAgICBpZiAobGVmdFR5cGUgIT09IHJpZ2h0VHlwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN3aXRjaCAobGVmdFR5cGUpIHtcbiAgICAgICAgY2FzZSAwIC8qIFR5cGVPcmRlci5OdWxsVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAxIC8qIFR5cGVPcmRlci5Cb29sZWFuVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gbGVmdC5ib29sZWFuVmFsdWUgPT09IHJpZ2h0LmJvb2xlYW5WYWx1ZTtcbiAgICAgICAgY2FzZSA0IC8qIFR5cGVPcmRlci5TZXJ2ZXJUaW1lc3RhbXBWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBnZXRMb2NhbFdyaXRlVGltZShsZWZ0KS5pc0VxdWFsKGdldExvY2FsV3JpdGVUaW1lKHJpZ2h0KSk7XG4gICAgICAgIGNhc2UgMyAvKiBUeXBlT3JkZXIuVGltZXN0YW1wVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gdGltZXN0YW1wRXF1YWxzKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgY2FzZSA1IC8qIFR5cGVPcmRlci5TdHJpbmdWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LnN0cmluZ1ZhbHVlID09PSByaWdodC5zdHJpbmdWYWx1ZTtcbiAgICAgICAgY2FzZSA2IC8qIFR5cGVPcmRlci5CbG9iVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gYmxvYkVxdWFscyhsZWZ0LCByaWdodCk7XG4gICAgICAgIGNhc2UgNyAvKiBUeXBlT3JkZXIuUmVmVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gbGVmdC5yZWZlcmVuY2VWYWx1ZSA9PT0gcmlnaHQucmVmZXJlbmNlVmFsdWU7XG4gICAgICAgIGNhc2UgOCAvKiBUeXBlT3JkZXIuR2VvUG9pbnRWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBnZW9Qb2ludEVxdWFscyhsZWZ0LCByaWdodCk7XG4gICAgICAgIGNhc2UgMiAvKiBUeXBlT3JkZXIuTnVtYmVyVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyRXF1YWxzKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgY2FzZSA5IC8qIFR5cGVPcmRlci5BcnJheVZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIGFycmF5RXF1YWxzKGxlZnQuYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW10sIHJpZ2h0LmFycmF5VmFsdWUudmFsdWVzIHx8IFtdLCB2YWx1ZUVxdWFscyk7XG4gICAgICAgIGNhc2UgMTAgLyogVHlwZU9yZGVyLlZlY3RvclZhbHVlICovOlxuICAgICAgICBjYXNlIDExIC8qIFR5cGVPcmRlci5PYmplY3RWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RFcXVhbHMobGVmdCwgcmlnaHQpO1xuICAgICAgICBjYXNlIDkwMDcxOTkyNTQ3NDA5OTEgLyogVHlwZU9yZGVyLk1heFZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRpbWVzdGFtcEVxdWFscyhsZWZ0LCByaWdodCkge1xuICAgIGlmICh0eXBlb2YgbGVmdC50aW1lc3RhbXBWYWx1ZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgdHlwZW9mIHJpZ2h0LnRpbWVzdGFtcFZhbHVlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICBsZWZ0LnRpbWVzdGFtcFZhbHVlLmxlbmd0aCA9PT0gcmlnaHQudGltZXN0YW1wVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIC8vIFVzZSBzdHJpbmcgZXF1YWxpdHkgZm9yIElTTyA4NjAxIHRpbWVzdGFtcHNcbiAgICAgICAgcmV0dXJuIGxlZnQudGltZXN0YW1wVmFsdWUgPT09IHJpZ2h0LnRpbWVzdGFtcFZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBsZWZ0VGltZXN0YW1wID0gbm9ybWFsaXplVGltZXN0YW1wKGxlZnQudGltZXN0YW1wVmFsdWUpO1xuICAgIGNvbnN0IHJpZ2h0VGltZXN0YW1wID0gbm9ybWFsaXplVGltZXN0YW1wKHJpZ2h0LnRpbWVzdGFtcFZhbHVlKTtcbiAgICByZXR1cm4gKGxlZnRUaW1lc3RhbXAuc2Vjb25kcyA9PT0gcmlnaHRUaW1lc3RhbXAuc2Vjb25kcyAmJlxuICAgICAgICBsZWZ0VGltZXN0YW1wLm5hbm9zID09PSByaWdodFRpbWVzdGFtcC5uYW5vcyk7XG59XG5mdW5jdGlvbiBnZW9Qb2ludEVxdWFscyhsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiAobm9ybWFsaXplTnVtYmVyKGxlZnQuZ2VvUG9pbnRWYWx1ZS5sYXRpdHVkZSkgPT09XG4gICAgICAgIG5vcm1hbGl6ZU51bWJlcihyaWdodC5nZW9Qb2ludFZhbHVlLmxhdGl0dWRlKSAmJlxuICAgICAgICBub3JtYWxpemVOdW1iZXIobGVmdC5nZW9Qb2ludFZhbHVlLmxvbmdpdHVkZSkgPT09XG4gICAgICAgICAgICBub3JtYWxpemVOdW1iZXIocmlnaHQuZ2VvUG9pbnRWYWx1ZS5sb25naXR1ZGUpKTtcbn1cbmZ1bmN0aW9uIGJsb2JFcXVhbHMobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplQnl0ZVN0cmluZyhsZWZ0LmJ5dGVzVmFsdWUpLmlzRXF1YWwobm9ybWFsaXplQnl0ZVN0cmluZyhyaWdodC5ieXRlc1ZhbHVlKSk7XG59XG5mdW5jdGlvbiBudW1iZXJFcXVhbHMobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAoJ2ludGVnZXJWYWx1ZScgaW4gbGVmdCAmJiAnaW50ZWdlclZhbHVlJyBpbiByaWdodCkge1xuICAgICAgICByZXR1cm4gKG5vcm1hbGl6ZU51bWJlcihsZWZ0LmludGVnZXJWYWx1ZSkgPT09IG5vcm1hbGl6ZU51bWJlcihyaWdodC5pbnRlZ2VyVmFsdWUpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2RvdWJsZVZhbHVlJyBpbiBsZWZ0ICYmICdkb3VibGVWYWx1ZScgaW4gcmlnaHQpIHtcbiAgICAgICAgY29uc3QgbjEgPSBub3JtYWxpemVOdW1iZXIobGVmdC5kb3VibGVWYWx1ZSk7XG4gICAgICAgIGNvbnN0IG4yID0gbm9ybWFsaXplTnVtYmVyKHJpZ2h0LmRvdWJsZVZhbHVlKTtcbiAgICAgICAgaWYgKG4xID09PSBuMikge1xuICAgICAgICAgICAgcmV0dXJuIGlzTmVnYXRpdmVaZXJvKG4xKSA9PT0gaXNOZWdhdGl2ZVplcm8objIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzTmFOKG4xKSAmJiBpc05hTihuMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gb2JqZWN0RXF1YWxzKGxlZnQsIHJpZ2h0KSB7XG4gICAgY29uc3QgbGVmdE1hcCA9IGxlZnQubWFwVmFsdWUuZmllbGRzIHx8IHt9O1xuICAgIGNvbnN0IHJpZ2h0TWFwID0gcmlnaHQubWFwVmFsdWUuZmllbGRzIHx8IHt9O1xuICAgIGlmIChvYmplY3RTaXplKGxlZnRNYXApICE9PSBvYmplY3RTaXplKHJpZ2h0TWFwKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIGxlZnRNYXApIHtcbiAgICAgICAgaWYgKGxlZnRNYXAuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgaWYgKHJpZ2h0TWFwW2tleV0gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICF2YWx1ZUVxdWFscyhsZWZ0TWFwW2tleV0sIHJpZ2h0TWFwW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgQXJyYXlWYWx1ZSBjb250YWlucyB0aGUgc3BlY2lmaWVkIGVsZW1lbnQuICovXG5mdW5jdGlvbiBhcnJheVZhbHVlQ29udGFpbnMoaGF5c3RhY2ssIG5lZWRsZSkge1xuICAgIHJldHVybiAoKGhheXN0YWNrLnZhbHVlcyB8fCBbXSkuZmluZCh2ID0+IHZhbHVlRXF1YWxzKHYsIG5lZWRsZSkpICE9PSB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gdmFsdWVDb21wYXJlKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQgPT09IHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCBsZWZ0VHlwZSA9IHR5cGVPcmRlcihsZWZ0KTtcbiAgICBjb25zdCByaWdodFR5cGUgPSB0eXBlT3JkZXIocmlnaHQpO1xuICAgIGlmIChsZWZ0VHlwZSAhPT0gcmlnaHRUeXBlKSB7XG4gICAgICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnRUeXBlLCByaWdodFR5cGUpO1xuICAgIH1cbiAgICBzd2l0Y2ggKGxlZnRUeXBlKSB7XG4gICAgICAgIGNhc2UgMCAvKiBUeXBlT3JkZXIuTnVsbFZhbHVlICovOlxuICAgICAgICBjYXNlIDkwMDcxOTkyNTQ3NDA5OTEgLyogVHlwZU9yZGVyLk1heFZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGNhc2UgMSAvKiBUeXBlT3JkZXIuQm9vbGVhblZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdC5ib29sZWFuVmFsdWUsIHJpZ2h0LmJvb2xlYW5WYWx1ZSk7XG4gICAgICAgIGNhc2UgMiAvKiBUeXBlT3JkZXIuTnVtYmVyVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZU51bWJlcnMobGVmdCwgcmlnaHQpO1xuICAgICAgICBjYXNlIDMgLyogVHlwZU9yZGVyLlRpbWVzdGFtcFZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVUaW1lc3RhbXBzKGxlZnQudGltZXN0YW1wVmFsdWUsIHJpZ2h0LnRpbWVzdGFtcFZhbHVlKTtcbiAgICAgICAgY2FzZSA0IC8qIFR5cGVPcmRlci5TZXJ2ZXJUaW1lc3RhbXBWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlVGltZXN0YW1wcyhnZXRMb2NhbFdyaXRlVGltZShsZWZ0KSwgZ2V0TG9jYWxXcml0ZVRpbWUocmlnaHQpKTtcbiAgICAgICAgY2FzZSA1IC8qIFR5cGVPcmRlci5TdHJpbmdWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQuc3RyaW5nVmFsdWUsIHJpZ2h0LnN0cmluZ1ZhbHVlKTtcbiAgICAgICAgY2FzZSA2IC8qIFR5cGVPcmRlci5CbG9iVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZUJsb2JzKGxlZnQuYnl0ZXNWYWx1ZSwgcmlnaHQuYnl0ZXNWYWx1ZSk7XG4gICAgICAgIGNhc2UgNyAvKiBUeXBlT3JkZXIuUmVmVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZVJlZmVyZW5jZXMobGVmdC5yZWZlcmVuY2VWYWx1ZSwgcmlnaHQucmVmZXJlbmNlVmFsdWUpO1xuICAgICAgICBjYXNlIDggLyogVHlwZU9yZGVyLkdlb1BvaW50VmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZUdlb1BvaW50cyhsZWZ0Lmdlb1BvaW50VmFsdWUsIHJpZ2h0Lmdlb1BvaW50VmFsdWUpO1xuICAgICAgICBjYXNlIDkgLyogVHlwZU9yZGVyLkFycmF5VmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZUFycmF5cyhsZWZ0LmFycmF5VmFsdWUsIHJpZ2h0LmFycmF5VmFsdWUpO1xuICAgICAgICBjYXNlIDEwIC8qIFR5cGVPcmRlci5WZWN0b3JWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlVmVjdG9ycyhsZWZ0Lm1hcFZhbHVlLCByaWdodC5tYXBWYWx1ZSk7XG4gICAgICAgIGNhc2UgMTEgLyogVHlwZU9yZGVyLk9iamVjdFZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVNYXBzKGxlZnQubWFwVmFsdWUsIHJpZ2h0Lm1hcFZhbHVlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IGZhaWwoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wYXJlTnVtYmVycyhsZWZ0LCByaWdodCkge1xuICAgIGNvbnN0IGxlZnROdW1iZXIgPSBub3JtYWxpemVOdW1iZXIobGVmdC5pbnRlZ2VyVmFsdWUgfHwgbGVmdC5kb3VibGVWYWx1ZSk7XG4gICAgY29uc3QgcmlnaHROdW1iZXIgPSBub3JtYWxpemVOdW1iZXIocmlnaHQuaW50ZWdlclZhbHVlIHx8IHJpZ2h0LmRvdWJsZVZhbHVlKTtcbiAgICBpZiAobGVmdE51bWJlciA8IHJpZ2h0TnVtYmVyKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZWxzZSBpZiAobGVmdE51bWJlciA+IHJpZ2h0TnVtYmVyKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZWZ0TnVtYmVyID09PSByaWdodE51bWJlcikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIG9uZSBvciBib3RoIGFyZSBOYU4uXG4gICAgICAgIGlmIChpc05hTihsZWZ0TnVtYmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzTmFOKHJpZ2h0TnVtYmVyKSA/IDAgOiAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGFyZVRpbWVzdGFtcHMobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAodHlwZW9mIGxlZnQgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIHR5cGVvZiByaWdodCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgbGVmdC5sZW5ndGggPT09IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0LCByaWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGxlZnRUaW1lc3RhbXAgPSBub3JtYWxpemVUaW1lc3RhbXAobGVmdCk7XG4gICAgY29uc3QgcmlnaHRUaW1lc3RhbXAgPSBub3JtYWxpemVUaW1lc3RhbXAocmlnaHQpO1xuICAgIGNvbnN0IGNvbXBhcmlzb24gPSBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnRUaW1lc3RhbXAuc2Vjb25kcywgcmlnaHRUaW1lc3RhbXAuc2Vjb25kcyk7XG4gICAgaWYgKGNvbXBhcmlzb24gIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmlzb247XG4gICAgfVxuICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnRUaW1lc3RhbXAubmFub3MsIHJpZ2h0VGltZXN0YW1wLm5hbm9zKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVSZWZlcmVuY2VzKGxlZnRQYXRoLCByaWdodFBhdGgpIHtcbiAgICBjb25zdCBsZWZ0U2VnbWVudHMgPSBsZWZ0UGF0aC5zcGxpdCgnLycpO1xuICAgIGNvbnN0IHJpZ2h0U2VnbWVudHMgPSByaWdodFBhdGguc3BsaXQoJy8nKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlZnRTZWdtZW50cy5sZW5ndGggJiYgaSA8IHJpZ2h0U2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY29tcGFyaXNvbiA9IHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdFNlZ21lbnRzW2ldLCByaWdodFNlZ21lbnRzW2ldKTtcbiAgICAgICAgaWYgKGNvbXBhcmlzb24gIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJpc29uO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnRTZWdtZW50cy5sZW5ndGgsIHJpZ2h0U2VnbWVudHMubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVHZW9Qb2ludHMobGVmdCwgcmlnaHQpIHtcbiAgICBjb25zdCBjb21wYXJpc29uID0gcHJpbWl0aXZlQ29tcGFyYXRvcihub3JtYWxpemVOdW1iZXIobGVmdC5sYXRpdHVkZSksIG5vcm1hbGl6ZU51bWJlcihyaWdodC5sYXRpdHVkZSkpO1xuICAgIGlmIChjb21wYXJpc29uICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJpc29uO1xuICAgIH1cbiAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihub3JtYWxpemVOdW1iZXIobGVmdC5sb25naXR1ZGUpLCBub3JtYWxpemVOdW1iZXIocmlnaHQubG9uZ2l0dWRlKSk7XG59XG5mdW5jdGlvbiBjb21wYXJlQmxvYnMobGVmdCwgcmlnaHQpIHtcbiAgICBjb25zdCBsZWZ0Qnl0ZXMgPSBub3JtYWxpemVCeXRlU3RyaW5nKGxlZnQpO1xuICAgIGNvbnN0IHJpZ2h0Qnl0ZXMgPSBub3JtYWxpemVCeXRlU3RyaW5nKHJpZ2h0KTtcbiAgICByZXR1cm4gbGVmdEJ5dGVzLmNvbXBhcmVUbyhyaWdodEJ5dGVzKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVBcnJheXMobGVmdCwgcmlnaHQpIHtcbiAgICBjb25zdCBsZWZ0QXJyYXkgPSBsZWZ0LnZhbHVlcyB8fCBbXTtcbiAgICBjb25zdCByaWdodEFycmF5ID0gcmlnaHQudmFsdWVzIHx8IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdEFycmF5Lmxlbmd0aCAmJiBpIDwgcmlnaHRBcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjb21wYXJlID0gdmFsdWVDb21wYXJlKGxlZnRBcnJheVtpXSwgcmlnaHRBcnJheVtpXSk7XG4gICAgICAgIGlmIChjb21wYXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0QXJyYXkubGVuZ3RoLCByaWdodEFycmF5Lmxlbmd0aCk7XG59XG5mdW5jdGlvbiBjb21wYXJlVmVjdG9ycyhsZWZ0LCByaWdodCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBjb25zdCBsZWZ0TWFwID0gbGVmdC5maWVsZHMgfHwge307XG4gICAgY29uc3QgcmlnaHRNYXAgPSByaWdodC5maWVsZHMgfHwge307XG4gICAgLy8gVGhlIHZlY3RvciBpcyBhIG1hcCwgYnV0IG9ubHkgdmVjdG9yIHZhbHVlIGlzIGNvbXBhcmVkLlxuICAgIGNvbnN0IGxlZnRBcnJheVZhbHVlID0gKF9hID0gbGVmdE1hcFtWRUNUT1JfTUFQX1ZFQ1RPUlNfS0VZXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFycmF5VmFsdWU7XG4gICAgY29uc3QgcmlnaHRBcnJheVZhbHVlID0gKF9iID0gcmlnaHRNYXBbVkVDVE9SX01BUF9WRUNUT1JTX0tFWV0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hcnJheVZhbHVlO1xuICAgIGNvbnN0IGxlbmd0aENvbXBhcmUgPSBwcmltaXRpdmVDb21wYXJhdG9yKCgoX2MgPSBsZWZ0QXJyYXlWYWx1ZSA9PT0gbnVsbCB8fCBsZWZ0QXJyYXlWYWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGVmdEFycmF5VmFsdWUudmFsdWVzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubGVuZ3RoKSB8fCAwLCAoKF9kID0gcmlnaHRBcnJheVZhbHVlID09PSBudWxsIHx8IHJpZ2h0QXJyYXlWYWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmlnaHRBcnJheVZhbHVlLnZhbHVlcykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmxlbmd0aCkgfHwgMCk7XG4gICAgaWYgKGxlbmd0aENvbXBhcmUgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aENvbXBhcmU7XG4gICAgfVxuICAgIHJldHVybiBjb21wYXJlQXJyYXlzKGxlZnRBcnJheVZhbHVlLCByaWdodEFycmF5VmFsdWUpO1xufVxuZnVuY3Rpb24gY29tcGFyZU1hcHMobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdCA9PT0gTUFYX1ZBTFVFLm1hcFZhbHVlICYmIHJpZ2h0ID09PSBNQVhfVkFMVUUubWFwVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlZnQgPT09IE1BWF9WQUxVRS5tYXBWYWx1ZSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmlnaHQgPT09IE1BWF9WQUxVRS5tYXBWYWx1ZSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGNvbnN0IGxlZnRNYXAgPSBsZWZ0LmZpZWxkcyB8fCB7fTtcbiAgICBjb25zdCBsZWZ0S2V5cyA9IE9iamVjdC5rZXlzKGxlZnRNYXApO1xuICAgIGNvbnN0IHJpZ2h0TWFwID0gcmlnaHQuZmllbGRzIHx8IHt9O1xuICAgIGNvbnN0IHJpZ2h0S2V5cyA9IE9iamVjdC5rZXlzKHJpZ2h0TWFwKTtcbiAgICAvLyBFdmVuIHRob3VnaCBNYXBWYWx1ZXMgYXJlIGxpa2VseSBzb3J0ZWQgY29ycmVjdGx5IGJhc2VkIG9uIHRoZWlyIGluc2VydGlvblxuICAgIC8vIG9yZGVyIChlLmcuIHdoZW4gcmVjZWl2ZWQgZnJvbSB0aGUgYmFja2VuZCksIGxvY2FsIG1vZGlmaWNhdGlvbnMgY2FuIGJyaW5nXG4gICAgLy8gZWxlbWVudHMgb3V0IG9mIG9yZGVyLiBXZSBuZWVkIHRvIHJlLXNvcnQgdGhlIGVsZW1lbnRzIHRvIGVuc3VyZSB0aGF0XG4gICAgLy8gY2Fub25pY2FsIElEcyBhcmUgaW5kZXBlbmRlbnQgb2YgaW5zZXJ0aW9uIG9yZGVyLlxuICAgIGxlZnRLZXlzLnNvcnQoKTtcbiAgICByaWdodEtleXMuc29ydCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdEtleXMubGVuZ3RoICYmIGkgPCByaWdodEtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qga2V5Q29tcGFyZSA9IHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdEtleXNbaV0sIHJpZ2h0S2V5c1tpXSk7XG4gICAgICAgIGlmIChrZXlDb21wYXJlICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5Q29tcGFyZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wYXJlID0gdmFsdWVDb21wYXJlKGxlZnRNYXBbbGVmdEtleXNbaV1dLCByaWdodE1hcFtyaWdodEtleXNbaV1dKTtcbiAgICAgICAgaWYgKGNvbXBhcmUgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnRLZXlzLmxlbmd0aCwgcmlnaHRLZXlzLmxlbmd0aCk7XG59XG4vKipcbiAqIEdlbmVyYXRlcyB0aGUgY2Fub25pY2FsIElEIGZvciB0aGUgcHJvdmlkZWQgZmllbGQgdmFsdWUgKGFzIHVzZWQgaW4gVGFyZ2V0XG4gKiBzZXJpYWxpemF0aW9uKS5cbiAqL1xuZnVuY3Rpb24gY2Fub25pY2FsSWQodmFsdWUpIHtcbiAgICByZXR1cm4gY2Fub25pZnlWYWx1ZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBjYW5vbmlmeVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKCdudWxsVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdib29sZWFuVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAnJyArIHZhbHVlLmJvb2xlYW5WYWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2ludGVnZXJWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdmFsdWUuaW50ZWdlclZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmICgnZG91YmxlVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAnJyArIHZhbHVlLmRvdWJsZVZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmICgndGltZXN0YW1wVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjYW5vbmlmeVRpbWVzdGFtcCh2YWx1ZS50aW1lc3RhbXBWYWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdzdHJpbmdWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnN0cmluZ1ZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmICgnYnl0ZXNWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNhbm9uaWZ5Qnl0ZVN0cmluZyh2YWx1ZS5ieXRlc1ZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ3JlZmVyZW5jZVZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY2Fub25pZnlSZWZlcmVuY2UodmFsdWUucmVmZXJlbmNlVmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICgnZ2VvUG9pbnRWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNhbm9uaWZ5R2VvUG9pbnQodmFsdWUuZ2VvUG9pbnRWYWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdhcnJheVZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY2Fub25pZnlBcnJheSh2YWx1ZS5hcnJheVZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ21hcFZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY2Fub25pZnlNYXAodmFsdWUubWFwVmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjYW5vbmlmeUJ5dGVTdHJpbmcoYnl0ZVN0cmluZykge1xuICAgIHJldHVybiBub3JtYWxpemVCeXRlU3RyaW5nKGJ5dGVTdHJpbmcpLnRvQmFzZTY0KCk7XG59XG5mdW5jdGlvbiBjYW5vbmlmeVRpbWVzdGFtcCh0aW1lc3RhbXApIHtcbiAgICBjb25zdCBub3JtYWxpemVkVGltZXN0YW1wID0gbm9ybWFsaXplVGltZXN0YW1wKHRpbWVzdGFtcCk7XG4gICAgcmV0dXJuIGB0aW1lKCR7bm9ybWFsaXplZFRpbWVzdGFtcC5zZWNvbmRzfSwke25vcm1hbGl6ZWRUaW1lc3RhbXAubmFub3N9KWA7XG59XG5mdW5jdGlvbiBjYW5vbmlmeUdlb1BvaW50KGdlb1BvaW50KSB7XG4gICAgcmV0dXJuIGBnZW8oJHtnZW9Qb2ludC5sYXRpdHVkZX0sJHtnZW9Qb2ludC5sb25naXR1ZGV9KWA7XG59XG5mdW5jdGlvbiBjYW5vbmlmeVJlZmVyZW5jZShyZWZlcmVuY2VWYWx1ZSkge1xuICAgIHJldHVybiBEb2N1bWVudEtleS5mcm9tTmFtZShyZWZlcmVuY2VWYWx1ZSkudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGNhbm9uaWZ5TWFwKG1hcFZhbHVlKSB7XG4gICAgLy8gSXRlcmF0aW9uIG9yZGVyIGluIEphdmFTY3JpcHQgaXMgbm90IGd1YXJhbnRlZWQuIFRvIGVuc3VyZSB0aGF0IHdlIGdlbmVyYXRlXG4gICAgLy8gbWF0Y2hpbmcgY2Fub25pY2FsIElEcyBmb3IgaWRlbnRpY2FsIG1hcHMsIHdlIG5lZWQgdG8gc29ydCB0aGUga2V5cy5cbiAgICBjb25zdCBzb3J0ZWRLZXlzID0gT2JqZWN0LmtleXMobWFwVmFsdWUuZmllbGRzIHx8IHt9KS5zb3J0KCk7XG4gICAgbGV0IHJlc3VsdCA9ICd7JztcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHNvcnRlZEtleXMpIHtcbiAgICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICcsJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IGAke2tleX06JHtjYW5vbmlmeVZhbHVlKG1hcFZhbHVlLmZpZWxkc1trZXldKX1gO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0ICsgJ30nO1xufVxuZnVuY3Rpb24gY2Fub25pZnlBcnJheShhcnJheVZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9ICdbJztcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW10pIHtcbiAgICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICcsJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IGNhbm9uaWZ5VmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0ICsgJ10nO1xufVxuLyoqXG4gKiBSZXR1cm5zIGFuIGFwcHJveGltYXRlIChhbmQgd2lsZGx5IGluYWNjdXJhdGUpIGluLW1lbW9yeSBzaXplIGZvciB0aGUgZmllbGRcbiAqIHZhbHVlLlxuICpcbiAqIFRoZSBtZW1vcnkgc2l6ZSB0YWtlcyBpbnRvIGFjY291bnQgb25seSB0aGUgYWN0dWFsIHVzZXIgZGF0YSBhcyBpdCByZXNpZGVzXG4gKiBpbiBtZW1vcnkgYW5kIGlnbm9yZXMgb2JqZWN0IG92ZXJoZWFkLlxuICovXG5mdW5jdGlvbiBlc3RpbWF0ZUJ5dGVTaXplKHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlT3JkZXIodmFsdWUpKSB7XG4gICAgICAgIGNhc2UgMCAvKiBUeXBlT3JkZXIuTnVsbFZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIGNhc2UgMSAvKiBUeXBlT3JkZXIuQm9vbGVhblZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIGNhc2UgMiAvKiBUeXBlT3JkZXIuTnVtYmVyVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgY2FzZSAzIC8qIFR5cGVPcmRlci5UaW1lc3RhbXBWYWx1ZSAqLzpcbiAgICAgICAgICAgIC8vIFRpbWVzdGFtcHMgYXJlIG1hZGUgdXAgb2YgdHdvIGRpc3RpbmN0IG51bWJlcnMgKHNlY29uZHMgKyBuYW5vc2Vjb25kcylcbiAgICAgICAgICAgIHJldHVybiAxNjtcbiAgICAgICAgY2FzZSA0IC8qIFR5cGVPcmRlci5TZXJ2ZXJUaW1lc3RhbXBWYWx1ZSAqLzpcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSBnZXRQcmV2aW91c1ZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1ZhbHVlID8gMTYgKyBlc3RpbWF0ZUJ5dGVTaXplKHByZXZpb3VzVmFsdWUpIDogMTY7XG4gICAgICAgIGNhc2UgNSAvKiBUeXBlT3JkZXIuU3RyaW5nVmFsdWUgKi86XG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9EYXRhX3N0cnVjdHVyZXM6XG4gICAgICAgICAgICAvLyBcIkphdmFTY3JpcHQncyBTdHJpbmcgdHlwZSBpcyBbLi4uXSBhIHNldCBvZiBlbGVtZW50cyBvZiAxNi1iaXQgdW5zaWduZWRcbiAgICAgICAgICAgIC8vIGludGVnZXIgdmFsdWVzXCJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zdHJpbmdWYWx1ZS5sZW5ndGggKiAyO1xuICAgICAgICBjYXNlIDYgLyogVHlwZU9yZGVyLkJsb2JWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVCeXRlU3RyaW5nKHZhbHVlLmJ5dGVzVmFsdWUpLmFwcHJveGltYXRlQnl0ZVNpemUoKTtcbiAgICAgICAgY2FzZSA3IC8qIFR5cGVPcmRlci5SZWZWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5yZWZlcmVuY2VWYWx1ZS5sZW5ndGg7XG4gICAgICAgIGNhc2UgOCAvKiBUeXBlT3JkZXIuR2VvUG9pbnRWYWx1ZSAqLzpcbiAgICAgICAgICAgIC8vIEdlb1BvaW50cyBhcmUgbWFkZSB1cCBvZiB0d28gZGlzdGluY3QgbnVtYmVycyAobGF0aXR1ZGUgKyBsb25naXR1ZGUpXG4gICAgICAgICAgICByZXR1cm4gMTY7XG4gICAgICAgIGNhc2UgOSAvKiBUeXBlT3JkZXIuQXJyYXlWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBlc3RpbWF0ZUFycmF5Qnl0ZVNpemUodmFsdWUuYXJyYXlWYWx1ZSk7XG4gICAgICAgIGNhc2UgMTAgLyogVHlwZU9yZGVyLlZlY3RvclZhbHVlICovOlxuICAgICAgICBjYXNlIDExIC8qIFR5cGVPcmRlci5PYmplY3RWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBlc3RpbWF0ZU1hcEJ5dGVTaXplKHZhbHVlLm1hcFZhbHVlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IGZhaWwoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlc3RpbWF0ZU1hcEJ5dGVTaXplKG1hcFZhbHVlKSB7XG4gICAgbGV0IHNpemUgPSAwO1xuICAgIGZvckVhY2gobWFwVmFsdWUuZmllbGRzLCAoa2V5LCB2YWwpID0+IHtcbiAgICAgICAgc2l6ZSArPSBrZXkubGVuZ3RoICsgZXN0aW1hdGVCeXRlU2l6ZSh2YWwpO1xuICAgIH0pO1xuICAgIHJldHVybiBzaXplO1xufVxuZnVuY3Rpb24gZXN0aW1hdGVBcnJheUJ5dGVTaXplKGFycmF5VmFsdWUpIHtcbiAgICByZXR1cm4gKGFycmF5VmFsdWUudmFsdWVzIHx8IFtdKS5yZWR1Y2UoKHByZXZpb3VzU2l6ZSwgdmFsdWUpID0+IHByZXZpb3VzU2l6ZSArIGVzdGltYXRlQnl0ZVNpemUodmFsdWUpLCAwKTtcbn1cbi8qKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHZhbHVlIGZvciB0aGUgcHJvdmlkZWQgZGF0YWJhc2UgYW5kIGtleS4gKi9cbmZ1bmN0aW9uIHJlZlZhbHVlKGRhdGFiYXNlSWQsIGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlZmVyZW5jZVZhbHVlOiBgcHJvamVjdHMvJHtkYXRhYmFzZUlkLnByb2plY3RJZH0vZGF0YWJhc2VzLyR7ZGF0YWJhc2VJZC5kYXRhYmFzZX0vZG9jdW1lbnRzLyR7a2V5LnBhdGguY2Fub25pY2FsU3RyaW5nKCl9YFxuICAgIH07XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gSW50ZWdlclZhbHVlIC4gKi9cbmZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmICdpbnRlZ2VyVmFsdWUnIGluIHZhbHVlO1xufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgRG91YmxlVmFsdWUuICovXG5mdW5jdGlvbiBpc0RvdWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmICdkb3VibGVWYWx1ZScgaW4gdmFsdWU7XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgZWl0aGVyIGFuIEludGVnZXJWYWx1ZSBvciBhIERvdWJsZVZhbHVlLiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gaXNJbnRlZ2VyKHZhbHVlKSB8fCBpc0RvdWJsZSh2YWx1ZSk7XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gQXJyYXlWYWx1ZS4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gISF2YWx1ZSAmJiAnYXJyYXlWYWx1ZScgaW4gdmFsdWU7XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYSBOdWxsVmFsdWUuICovXG5mdW5jdGlvbiBpc051bGxWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmICdudWxsVmFsdWUnIGluIHZhbHVlO1xufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIE5hTi4gKi9cbmZ1bmN0aW9uIGlzTmFuVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gISF2YWx1ZSAmJiAnZG91YmxlVmFsdWUnIGluIHZhbHVlICYmIGlzTmFOKE51bWJlcih2YWx1ZS5kb3VibGVWYWx1ZSkpO1xufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgTWFwVmFsdWUuICovXG5mdW5jdGlvbiBpc01hcFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuICEhdmFsdWUgJiYgJ21hcFZhbHVlJyBpbiB2YWx1ZTtcbn1cbi8qKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhIFZldG9yVmFsdWUuICovXG5mdW5jdGlvbiBpc1ZlY3RvclZhbHVlKHZhbHVlKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB0eXBlID0gKF9iID0gKCgoX2EgPSB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUubWFwVmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maWVsZHMpIHx8IHt9KVtUWVBFX0tFWV0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdHJpbmdWYWx1ZTtcbiAgICByZXR1cm4gdHlwZSA9PT0gVkVDVE9SX1ZBTFVFX1NFTlRJTkVMO1xufVxuLyoqIENyZWF0ZXMgYSBkZWVwIGNvcHkgb2YgYHNvdXJjZWAuICovXG5mdW5jdGlvbiBkZWVwQ2xvbmUoc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZS5nZW9Qb2ludFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IGdlb1BvaW50VmFsdWU6IE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZS5nZW9Qb2ludFZhbHVlKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChzb3VyY2UudGltZXN0YW1wVmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHNvdXJjZS50aW1lc3RhbXBWYWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHsgdGltZXN0YW1wVmFsdWU6IE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZS50aW1lc3RhbXBWYWx1ZSkgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc291cmNlLm1hcFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHsgbWFwVmFsdWU6IHsgZmllbGRzOiB7fSB9IH07XG4gICAgICAgIGZvckVhY2goc291cmNlLm1hcFZhbHVlLmZpZWxkcywgKGtleSwgdmFsKSA9PiAodGFyZ2V0Lm1hcFZhbHVlLmZpZWxkc1trZXldID0gZGVlcENsb25lKHZhbCkpKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgZWxzZSBpZiAoc291cmNlLmFycmF5VmFsdWUpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0geyBhcnJheVZhbHVlOiB7IHZhbHVlczogW10gfSB9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IChzb3VyY2UuYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW10pLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0YXJnZXQuYXJyYXlWYWx1ZS52YWx1ZXNbaV0gPSBkZWVwQ2xvbmUoc291cmNlLmFycmF5VmFsdWUudmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZSk7XG4gICAgfVxufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgVmFsdWUgcmVwcmVzZW50cyB0aGUgY2Fub25pY2FsIHtAbGluayAjTUFYX1ZBTFVFfSAuICovXG5mdW5jdGlvbiBpc01heFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuICgoKCh2YWx1ZS5tYXBWYWx1ZSB8fCB7fSkuZmllbGRzIHx8IHt9KVsnX190eXBlX18nXSB8fCB7fSkuc3RyaW5nVmFsdWUgPT09XG4gICAgICAgIE1BWF9WQUxVRV9UWVBFKTtcbn1cbmNvbnN0IE1JTl9WRUNUT1JfVkFMVUUgPSB7XG4gICAgbWFwVmFsdWU6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICBbVFlQRV9LRVldOiB7IHN0cmluZ1ZhbHVlOiBWRUNUT1JfVkFMVUVfU0VOVElORUwgfSxcbiAgICAgICAgICAgIFtWRUNUT1JfTUFQX1ZFQ1RPUlNfS0VZXToge1xuICAgICAgICAgICAgICAgIGFycmF5VmFsdWU6IHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyoqIFJldHVybnMgdGhlIGxvd2VzdCB2YWx1ZSBmb3IgdGhlIGdpdmVuIHZhbHVlIHR5cGUgKGluY2x1c2l2ZSkuICovXG5mdW5jdGlvbiB2YWx1ZXNHZXRMb3dlckJvdW5kKHZhbHVlKSB7XG4gICAgaWYgKCdudWxsVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBNSU5fVkFMVUU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdib29sZWFuVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IGJvb2xlYW5WYWx1ZTogZmFsc2UgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2ludGVnZXJWYWx1ZScgaW4gdmFsdWUgfHwgJ2RvdWJsZVZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyBkb3VibGVWYWx1ZTogTmFOIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKCd0aW1lc3RhbXBWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgdGltZXN0YW1wVmFsdWU6IHsgc2Vjb25kczogTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgfSB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgnc3RyaW5nVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IHN0cmluZ1ZhbHVlOiAnJyB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgnYnl0ZXNWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgYnl0ZXNWYWx1ZTogJycgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ3JlZmVyZW5jZVZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcmVmVmFsdWUoRGF0YWJhc2VJZC5lbXB0eSgpLCBEb2N1bWVudEtleS5lbXB0eSgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2dlb1BvaW50VmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IGdlb1BvaW50VmFsdWU6IHsgbGF0aXR1ZGU6IC05MCwgbG9uZ2l0dWRlOiAtMTgwIH0gfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2FycmF5VmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IGFycmF5VmFsdWU6IHt9IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKCdtYXBWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzVmVjdG9yVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gTUlOX1ZFQ1RPUl9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtYXBWYWx1ZToge30gfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWlsKCk7XG4gICAgfVxufVxuLyoqIFJldHVybnMgdGhlIGxhcmdlc3QgdmFsdWUgZm9yIHRoZSBnaXZlbiB2YWx1ZSB0eXBlIChleGNsdXNpdmUpLiAqL1xuZnVuY3Rpb24gdmFsdWVzR2V0VXBwZXJCb3VuZCh2YWx1ZSkge1xuICAgIGlmICgnbnVsbFZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyBib29sZWFuVmFsdWU6IGZhbHNlIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKCdib29sZWFuVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IGRvdWJsZVZhbHVlOiBOYU4gfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2ludGVnZXJWYWx1ZScgaW4gdmFsdWUgfHwgJ2RvdWJsZVZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyB0aW1lc3RhbXBWYWx1ZTogeyBzZWNvbmRzOiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiB9IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKCd0aW1lc3RhbXBWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RyaW5nVmFsdWU6ICcnIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKCdzdHJpbmdWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgYnl0ZXNWYWx1ZTogJycgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2J5dGVzVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiByZWZWYWx1ZShEYXRhYmFzZUlkLmVtcHR5KCksIERvY3VtZW50S2V5LmVtcHR5KCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICgncmVmZXJlbmNlVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IGdlb1BvaW50VmFsdWU6IHsgbGF0aXR1ZGU6IC05MCwgbG9uZ2l0dWRlOiAtMTgwIH0gfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2dlb1BvaW50VmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IGFycmF5VmFsdWU6IHt9IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKCdhcnJheVZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gTUlOX1ZFQ1RPUl9WQUxVRTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ21hcFZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNWZWN0b3JWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1hcFZhbHVlOiB7fSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNQVhfVkFMVUU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxvd2VyQm91bmRDb21wYXJlKGxlZnQsIHJpZ2h0KSB7XG4gICAgY29uc3QgY21wID0gdmFsdWVDb21wYXJlKGxlZnQudmFsdWUsIHJpZ2h0LnZhbHVlKTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuICAgIGlmIChsZWZ0LmluY2x1c2l2ZSAmJiAhcmlnaHQuaW5jbHVzaXZlKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWxlZnQuaW5jbHVzaXZlICYmIHJpZ2h0LmluY2x1c2l2ZSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiB1cHBlckJvdW5kQ29tcGFyZShsZWZ0LCByaWdodCkge1xuICAgIGNvbnN0IGNtcCA9IHZhbHVlQ29tcGFyZShsZWZ0LnZhbHVlLCByaWdodC52YWx1ZSk7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gY21wO1xuICAgIH1cbiAgICBpZiAobGVmdC5pbmNsdXNpdmUgJiYgIXJpZ2h0LmluY2x1c2l2ZSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWxlZnQuaW5jbHVzaXZlICYmIHJpZ2h0LmluY2x1c2l2ZSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBbiBPYmplY3RWYWx1ZSByZXByZXNlbnRzIGEgTWFwVmFsdWUgaW4gdGhlIEZpcmVzdG9yZSBQcm90byBhbmQgb2ZmZXJzIHRoZVxuICogYWJpbGl0eSB0byBhZGQgYW5kIHJlbW92ZSBmaWVsZHMgKHZpYSB0aGUgT2JqZWN0VmFsdWVCdWlsZGVyKS5cbiAqL1xuY2xhc3MgT2JqZWN0VmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgc3RhdGljIGVtcHR5KCkge1xuICAgICAgICByZXR1cm4gbmV3IE9iamVjdFZhbHVlKHsgbWFwVmFsdWU6IHt9IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gcGF0aCBvciBudWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggLSB0aGUgcGF0aCB0byBzZWFyY2hcbiAgICAgKiBAcmV0dXJucyBUaGUgdmFsdWUgYXQgdGhlIHBhdGggb3IgbnVsbCBpZiB0aGUgcGF0aCBpcyBub3Qgc2V0LlxuICAgICAqL1xuICAgIGZpZWxkKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50TGV2ZWwgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IChjdXJyZW50TGV2ZWwubWFwVmFsdWUuZmllbGRzIHx8IHt9KVtwYXRoLmdldChpKV07XG4gICAgICAgICAgICAgICAgaWYgKCFpc01hcFZhbHVlKGN1cnJlbnRMZXZlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudExldmVsID0gKGN1cnJlbnRMZXZlbC5tYXBWYWx1ZS5maWVsZHMgfHwge30pW3BhdGgubGFzdFNlZ21lbnQoKV07XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudExldmVsIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZmllbGQgdG8gdGhlIHByb3ZpZGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggLSBUaGUgZmllbGQgcGF0aCB0byBzZXQuXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKi9cbiAgICBzZXQocGF0aCwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgZmllbGRzTWFwID0gdGhpcy5nZXRGaWVsZHNNYXAocGF0aC5wb3BMYXN0KCkpO1xuICAgICAgICBmaWVsZHNNYXBbcGF0aC5sYXN0U2VnbWVudCgpXSA9IGRlZXBDbG9uZSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHByb3ZpZGVkIGZpZWxkcyB0byB0aGUgcHJvdmlkZWQgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgLSBBIG1hcCBvZiBmaWVsZHMgdG8gdmFsdWVzIChvciBudWxsIGZvciBkZWxldGVzKS5cbiAgICAgKi9cbiAgICBzZXRBbGwoZGF0YSkge1xuICAgICAgICBsZXQgcGFyZW50ID0gRmllbGRQYXRoJDEuZW1wdHlQYXRoKCk7XG4gICAgICAgIGxldCB1cHNlcnRzID0ge307XG4gICAgICAgIGxldCBkZWxldGVzID0gW107XG4gICAgICAgIGRhdGEuZm9yRWFjaCgodmFsdWUsIHBhdGgpID0+IHtcbiAgICAgICAgICAgIGlmICghcGFyZW50LmlzSW1tZWRpYXRlUGFyZW50T2YocGF0aCkpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnNlcnQgdGhlIGFjY3VtdWxhdGVkIGNoYW5nZXMgYXQgdGhpcyBwYXJlbnQgbG9jYXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZHNNYXAgPSB0aGlzLmdldEZpZWxkc01hcChwYXJlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlDaGFuZ2VzKGZpZWxkc01hcCwgdXBzZXJ0cywgZGVsZXRlcyk7XG4gICAgICAgICAgICAgICAgdXBzZXJ0cyA9IHt9O1xuICAgICAgICAgICAgICAgIGRlbGV0ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXRoLnBvcExhc3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHVwc2VydHNbcGF0aC5sYXN0U2VnbWVudCgpXSA9IGRlZXBDbG9uZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGVzLnB1c2gocGF0aC5sYXN0U2VnbWVudCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGZpZWxkc01hcCA9IHRoaXMuZ2V0RmllbGRzTWFwKHBhcmVudCk7XG4gICAgICAgIHRoaXMuYXBwbHlDaGFuZ2VzKGZpZWxkc01hcCwgdXBzZXJ0cywgZGVsZXRlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGZpZWxkIGF0IHRoZSBzcGVjaWZpZWQgcGF0aC4gSWYgdGhlcmUgaXMgbm8gZmllbGQgYXQgdGhlXG4gICAgICogc3BlY2lmaWVkIHBhdGgsIG5vdGhpbmcgaXMgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIC0gVGhlIGZpZWxkIHBhdGggdG8gcmVtb3ZlLlxuICAgICAqL1xuICAgIGRlbGV0ZShwYXRoKSB7XG4gICAgICAgIGNvbnN0IG5lc3RlZFZhbHVlID0gdGhpcy5maWVsZChwYXRoLnBvcExhc3QoKSk7XG4gICAgICAgIGlmIChpc01hcFZhbHVlKG5lc3RlZFZhbHVlKSAmJiBuZXN0ZWRWYWx1ZS5tYXBWYWx1ZS5maWVsZHMpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXN0ZWRWYWx1ZS5tYXBWYWx1ZS5maWVsZHNbcGF0aC5sYXN0U2VnbWVudCgpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZUVxdWFscyh0aGlzLnZhbHVlLCBvdGhlci52YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1hcCB0aGF0IGNvbnRhaW5zIHRoZSBsZWFmIGVsZW1lbnQgb2YgYHBhdGhgLiBJZiB0aGUgcGFyZW50XG4gICAgICogZW50cnkgZG9lcyBub3QgeWV0IGV4aXN0LCBvciBpZiBpdCBpcyBub3QgYSBtYXAsIGEgbmV3IG1hcCB3aWxsIGJlIGNyZWF0ZWQuXG4gICAgICovXG4gICAgZ2V0RmllbGRzTWFwKHBhdGgpIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLnZhbHVlO1xuICAgICAgICBpZiAoIWN1cnJlbnQubWFwVmFsdWUuZmllbGRzKSB7XG4gICAgICAgICAgICBjdXJyZW50Lm1hcFZhbHVlID0geyBmaWVsZHM6IHt9IH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGN1cnJlbnQubWFwVmFsdWUuZmllbGRzW3BhdGguZ2V0KGkpXTtcbiAgICAgICAgICAgIGlmICghaXNNYXBWYWx1ZShuZXh0KSB8fCAhbmV4dC5tYXBWYWx1ZS5maWVsZHMpIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0geyBtYXBWYWx1ZTogeyBmaWVsZHM6IHt9IH0gfTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Lm1hcFZhbHVlLmZpZWxkc1twYXRoLmdldChpKV0gPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQubWFwVmFsdWUuZmllbGRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb2RpZmllcyBgZmllbGRzTWFwYCBieSBhZGRpbmcsIHJlcGxhY2luZyBvciBkZWxldGluZyB0aGUgc3BlY2lmaWVkXG4gICAgICogZW50cmllcy5cbiAgICAgKi9cbiAgICBhcHBseUNoYW5nZXMoZmllbGRzTWFwLCBpbnNlcnRzLCBkZWxldGVzKSB7XG4gICAgICAgIGZvckVhY2goaW5zZXJ0cywgKGtleSwgdmFsKSA9PiAoZmllbGRzTWFwW2tleV0gPSB2YWwpKTtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBkZWxldGVzKSB7XG4gICAgICAgICAgICBkZWxldGUgZmllbGRzTWFwW2ZpZWxkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RWYWx1ZShkZWVwQ2xvbmUodGhpcy52YWx1ZSkpO1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyBhIEZpZWxkTWFzayBidWlsdCBmcm9tIGFsbCBmaWVsZHMgaW4gYSBNYXBWYWx1ZS5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEZpZWxkTWFzayh2YWx1ZSkge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtdO1xuICAgIGZvckVhY2godmFsdWUuZmllbGRzLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50UGF0aCA9IG5ldyBGaWVsZFBhdGgkMShba2V5XSk7XG4gICAgICAgIGlmIChpc01hcFZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgbmVzdGVkTWFzayA9IGV4dHJhY3RGaWVsZE1hc2sodmFsdWUubWFwVmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgbmVzdGVkRmllbGRzID0gbmVzdGVkTWFzay5maWVsZHM7XG4gICAgICAgICAgICBpZiAobmVzdGVkRmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFByZXNlcnZlIHRoZSBlbXB0eSBtYXAgYnkgYWRkaW5nIGl0IHRvIHRoZSBGaWVsZE1hc2suXG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2goY3VycmVudFBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIG5lc3RlZCBhbmQgbm9uLWVtcHR5IE9iamVjdFZhbHVlcywgYWRkIHRoZSBGaWVsZFBhdGggb2YgdGhlXG4gICAgICAgICAgICAgICAgLy8gbGVhZiBub2Rlcy5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5lc3RlZFBhdGggb2YgbmVzdGVkRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKGN1cnJlbnRQYXRoLmNoaWxkKG5lc3RlZFBhdGgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3IgbmVzdGVkIGFuZCBub24tZW1wdHkgT2JqZWN0VmFsdWVzLCBhZGQgdGhlIEZpZWxkUGF0aCBvZiB0aGUgbGVhZlxuICAgICAgICAgICAgLy8gbm9kZXMuXG4gICAgICAgICAgICBmaWVsZHMucHVzaChjdXJyZW50UGF0aCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IEZpZWxkTWFzayhmaWVsZHMpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgZG9jdW1lbnQgaW4gRmlyZXN0b3JlIHdpdGggYSBrZXksIHZlcnNpb24sIGRhdGEgYW5kIHdoZXRoZXIgaXRcbiAqIGhhcyBsb2NhbCBtdXRhdGlvbnMgYXBwbGllZCB0byBpdC5cbiAqXG4gKiBEb2N1bWVudHMgY2FuIHRyYW5zaXRpb24gYmV0d2VlbiBzdGF0ZXMgdmlhIGBjb252ZXJ0VG9Gb3VuZERvY3VtZW50KClgLFxuICogYGNvbnZlcnRUb05vRG9jdW1lbnQoKWAgYW5kIGBjb252ZXJ0VG9Vbmtub3duRG9jdW1lbnQoKWAuIElmIGEgZG9jdW1lbnQgZG9lc1xuICogbm90IHRyYW5zaXRpb24gdG8gb25lIG9mIHRoZXNlIHN0YXRlcyBldmVuIGFmdGVyIGFsbCBtdXRhdGlvbnMgaGF2ZSBiZWVuXG4gKiBhcHBsaWVkLCBgaXNWYWxpZERvY3VtZW50KClgIHJldHVybnMgZmFsc2UgYW5kIHRoZSBkb2N1bWVudCBzaG91bGQgYmUgcmVtb3ZlZFxuICogZnJvbSBhbGwgdmlld3MuXG4gKi9cbmNsYXNzIE11dGFibGVEb2N1bWVudCB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCBkb2N1bWVudFR5cGUsIHZlcnNpb24sIHJlYWRUaW1lLCBjcmVhdGVUaW1lLCBkYXRhLCBkb2N1bWVudFN0YXRlKSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLmRvY3VtZW50VHlwZSA9IGRvY3VtZW50VHlwZTtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5yZWFkVGltZSA9IHJlYWRUaW1lO1xuICAgICAgICB0aGlzLmNyZWF0ZVRpbWUgPSBjcmVhdGVUaW1lO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmRvY3VtZW50U3RhdGUgPSBkb2N1bWVudFN0YXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZG9jdW1lbnQgd2l0aCBubyBrbm93biB2ZXJzaW9uIG9yIGRhdGEsIGJ1dCB3aGljaCBjYW4gc2VydmUgYXNcbiAgICAgKiBiYXNlIGRvY3VtZW50IGZvciBtdXRhdGlvbnMuXG4gICAgICovXG4gICAgc3RhdGljIG5ld0ludmFsaWREb2N1bWVudChkb2N1bWVudEtleSkge1xuICAgICAgICByZXR1cm4gbmV3IE11dGFibGVEb2N1bWVudChkb2N1bWVudEtleSwgMCAvKiBEb2N1bWVudFR5cGUuSU5WQUxJRCAqLywgXG4gICAgICAgIC8qIHZlcnNpb24gKi8gU25hcHNob3RWZXJzaW9uLm1pbigpLCBcbiAgICAgICAgLyogcmVhZFRpbWUgKi8gU25hcHNob3RWZXJzaW9uLm1pbigpLCBcbiAgICAgICAgLyogY3JlYXRlVGltZSAqLyBTbmFwc2hvdFZlcnNpb24ubWluKCksIE9iamVjdFZhbHVlLmVtcHR5KCksIDAgLyogRG9jdW1lbnRTdGF0ZS5TWU5DRUQgKi8pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGRvY3VtZW50IHRoYXQgaXMga25vd24gdG8gZXhpc3Qgd2l0aCB0aGUgZ2l2ZW4gZGF0YSBhdCB0aGVcbiAgICAgKiBnaXZlbiB2ZXJzaW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBuZXdGb3VuZERvY3VtZW50KGRvY3VtZW50S2V5LCB2ZXJzaW9uLCBjcmVhdGVUaW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IE11dGFibGVEb2N1bWVudChkb2N1bWVudEtleSwgMSAvKiBEb2N1bWVudFR5cGUuRk9VTkRfRE9DVU1FTlQgKi8sIFxuICAgICAgICAvKiB2ZXJzaW9uICovIHZlcnNpb24sIFxuICAgICAgICAvKiByZWFkVGltZSAqLyBTbmFwc2hvdFZlcnNpb24ubWluKCksIFxuICAgICAgICAvKiBjcmVhdGVUaW1lICovIGNyZWF0ZVRpbWUsIHZhbHVlLCAwIC8qIERvY3VtZW50U3RhdGUuU1lOQ0VEICovKTtcbiAgICB9XG4gICAgLyoqIENyZWF0ZXMgYSBuZXcgZG9jdW1lbnQgdGhhdCBpcyBrbm93biB0byBub3QgZXhpc3QgYXQgdGhlIGdpdmVuIHZlcnNpb24uICovXG4gICAgc3RhdGljIG5ld05vRG9jdW1lbnQoZG9jdW1lbnRLZXksIHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNdXRhYmxlRG9jdW1lbnQoZG9jdW1lbnRLZXksIDIgLyogRG9jdW1lbnRUeXBlLk5PX0RPQ1VNRU5UICovLCBcbiAgICAgICAgLyogdmVyc2lvbiAqLyB2ZXJzaW9uLCBcbiAgICAgICAgLyogcmVhZFRpbWUgKi8gU25hcHNob3RWZXJzaW9uLm1pbigpLCBcbiAgICAgICAgLyogY3JlYXRlVGltZSAqLyBTbmFwc2hvdFZlcnNpb24ubWluKCksIE9iamVjdFZhbHVlLmVtcHR5KCksIDAgLyogRG9jdW1lbnRTdGF0ZS5TWU5DRUQgKi8pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGRvY3VtZW50IHRoYXQgaXMga25vd24gdG8gZXhpc3QgYXQgdGhlIGdpdmVuIHZlcnNpb24gYnV0XG4gICAgICogd2hvc2UgZGF0YSBpcyBub3Qga25vd24gKGUuZy4gYSBkb2N1bWVudCB0aGF0IHdhcyB1cGRhdGVkIHdpdGhvdXQgYSBrbm93blxuICAgICAqIGJhc2UgZG9jdW1lbnQpLlxuICAgICAqL1xuICAgIHN0YXRpYyBuZXdVbmtub3duRG9jdW1lbnQoZG9jdW1lbnRLZXksIHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNdXRhYmxlRG9jdW1lbnQoZG9jdW1lbnRLZXksIDMgLyogRG9jdW1lbnRUeXBlLlVOS05PV05fRE9DVU1FTlQgKi8sIFxuICAgICAgICAvKiB2ZXJzaW9uICovIHZlcnNpb24sIFxuICAgICAgICAvKiByZWFkVGltZSAqLyBTbmFwc2hvdFZlcnNpb24ubWluKCksIFxuICAgICAgICAvKiBjcmVhdGVUaW1lICovIFNuYXBzaG90VmVyc2lvbi5taW4oKSwgT2JqZWN0VmFsdWUuZW1wdHkoKSwgMiAvKiBEb2N1bWVudFN0YXRlLkhBU19DT01NSVRURURfTVVUQVRJT05TICovKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgZG9jdW1lbnQgdHlwZSB0byBpbmRpY2F0ZSB0aGF0IGl0IGV4aXN0cyBhbmQgdGhhdCBpdHMgdmVyc2lvblxuICAgICAqIGFuZCBkYXRhIGFyZSBrbm93bi5cbiAgICAgKi9cbiAgICBjb252ZXJ0VG9Gb3VuZERvY3VtZW50KHZlcnNpb24sIHZhbHVlKSB7XG4gICAgICAgIC8vIElmIGEgZG9jdW1lbnQgaXMgc3dpdGNoaW5nIHN0YXRlIGZyb20gYmVpbmcgYW4gaW52YWxpZCBvciBkZWxldGVkXG4gICAgICAgIC8vIGRvY3VtZW50IHRvIGEgdmFsaWQgKEZPVU5EX0RPQ1VNRU5UKSBkb2N1bWVudCwgZWl0aGVyIGR1ZSB0byByZWNlaXZpbmcgYW5cbiAgICAgICAgLy8gdXBkYXRlIGZyb20gV2F0Y2ggb3IgZHVlIHRvIGFwcGx5aW5nIGEgbG9jYWwgc2V0IG11dGF0aW9uIG9uIHRvcFxuICAgICAgICAvLyBvZiBhIGRlbGV0ZWQgZG9jdW1lbnQsIG91ciBiZXN0IGd1ZXNzIGFib3V0IGl0cyBjcmVhdGVUaW1lIHdvdWxkIGJlIHRoZVxuICAgICAgICAvLyB2ZXJzaW9uIGF0IHdoaWNoIHRoZSBkb2N1bWVudCB0cmFuc2l0aW9uZWQgdG8gYSBGT1VORF9ET0NVTUVOVC5cbiAgICAgICAgaWYgKHRoaXMuY3JlYXRlVGltZS5pc0VxdWFsKFNuYXBzaG90VmVyc2lvbi5taW4oKSkgJiZcbiAgICAgICAgICAgICh0aGlzLmRvY3VtZW50VHlwZSA9PT0gMiAvKiBEb2N1bWVudFR5cGUuTk9fRE9DVU1FTlQgKi8gfHxcbiAgICAgICAgICAgICAgICB0aGlzLmRvY3VtZW50VHlwZSA9PT0gMCAvKiBEb2N1bWVudFR5cGUuSU5WQUxJRCAqLykpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlVGltZSA9IHZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5kb2N1bWVudFR5cGUgPSAxIC8qIERvY3VtZW50VHlwZS5GT1VORF9ET0NVTUVOVCAqLztcbiAgICAgICAgdGhpcy5kYXRhID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRTdGF0ZSA9IDAgLyogRG9jdW1lbnRTdGF0ZS5TWU5DRUQgKi87XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBkb2N1bWVudCB0eXBlIHRvIGluZGljYXRlIHRoYXQgaXQgZG9lc24ndCBleGlzdCBhdCB0aGUgZ2l2ZW5cbiAgICAgKiB2ZXJzaW9uLlxuICAgICAqL1xuICAgIGNvbnZlcnRUb05vRG9jdW1lbnQodmVyc2lvbikge1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLmRvY3VtZW50VHlwZSA9IDIgLyogRG9jdW1lbnRUeXBlLk5PX0RPQ1VNRU5UICovO1xuICAgICAgICB0aGlzLmRhdGEgPSBPYmplY3RWYWx1ZS5lbXB0eSgpO1xuICAgICAgICB0aGlzLmRvY3VtZW50U3RhdGUgPSAwIC8qIERvY3VtZW50U3RhdGUuU1lOQ0VEICovO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgZG9jdW1lbnQgdHlwZSB0byBpbmRpY2F0ZSB0aGF0IGl0IGV4aXN0cyBhdCBhIGdpdmVuIHZlcnNpb24gYnV0XG4gICAgICogdGhhdCBpdHMgZGF0YSBpcyBub3Qga25vd24gKGUuZy4gYSBkb2N1bWVudCB0aGF0IHdhcyB1cGRhdGVkIHdpdGhvdXQgYSBrbm93blxuICAgICAqIGJhc2UgZG9jdW1lbnQpLlxuICAgICAqL1xuICAgIGNvbnZlcnRUb1Vua25vd25Eb2N1bWVudCh2ZXJzaW9uKSB7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMuZG9jdW1lbnRUeXBlID0gMyAvKiBEb2N1bWVudFR5cGUuVU5LTk9XTl9ET0NVTUVOVCAqLztcbiAgICAgICAgdGhpcy5kYXRhID0gT2JqZWN0VmFsdWUuZW1wdHkoKTtcbiAgICAgICAgdGhpcy5kb2N1bWVudFN0YXRlID0gMiAvKiBEb2N1bWVudFN0YXRlLkhBU19DT01NSVRURURfTVVUQVRJT05TICovO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0SGFzQ29tbWl0dGVkTXV0YXRpb25zKCkge1xuICAgICAgICB0aGlzLmRvY3VtZW50U3RhdGUgPSAyIC8qIERvY3VtZW50U3RhdGUuSEFTX0NPTU1JVFRFRF9NVVRBVElPTlMgKi87XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRIYXNMb2NhbE11dGF0aW9ucygpIHtcbiAgICAgICAgdGhpcy5kb2N1bWVudFN0YXRlID0gMSAvKiBEb2N1bWVudFN0YXRlLkhBU19MT0NBTF9NVVRBVElPTlMgKi87XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IFNuYXBzaG90VmVyc2lvbi5taW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldFJlYWRUaW1lKHJlYWRUaW1lKSB7XG4gICAgICAgIHRoaXMucmVhZFRpbWUgPSByZWFkVGltZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBoYXNMb2NhbE11dGF0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRTdGF0ZSA9PT0gMSAvKiBEb2N1bWVudFN0YXRlLkhBU19MT0NBTF9NVVRBVElPTlMgKi87XG4gICAgfVxuICAgIGdldCBoYXNDb21taXR0ZWRNdXRhdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50U3RhdGUgPT09IDIgLyogRG9jdW1lbnRTdGF0ZS5IQVNfQ09NTUlUVEVEX01VVEFUSU9OUyAqLztcbiAgICB9XG4gICAgZ2V0IGhhc1BlbmRpbmdXcml0ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0xvY2FsTXV0YXRpb25zIHx8IHRoaXMuaGFzQ29tbWl0dGVkTXV0YXRpb25zO1xuICAgIH1cbiAgICBpc1ZhbGlkRG9jdW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50VHlwZSAhPT0gMCAvKiBEb2N1bWVudFR5cGUuSU5WQUxJRCAqLztcbiAgICB9XG4gICAgaXNGb3VuZERvY3VtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudFR5cGUgPT09IDEgLyogRG9jdW1lbnRUeXBlLkZPVU5EX0RPQ1VNRU5UICovO1xuICAgIH1cbiAgICBpc05vRG9jdW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50VHlwZSA9PT0gMiAvKiBEb2N1bWVudFR5cGUuTk9fRE9DVU1FTlQgKi87XG4gICAgfVxuICAgIGlzVW5rbm93bkRvY3VtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudFR5cGUgPT09IDMgLyogRG9jdW1lbnRUeXBlLlVOS05PV05fRE9DVU1FTlQgKi87XG4gICAgfVxuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIChvdGhlciBpbnN0YW5jZW9mIE11dGFibGVEb2N1bWVudCAmJlxuICAgICAgICAgICAgdGhpcy5rZXkuaXNFcXVhbChvdGhlci5rZXkpICYmXG4gICAgICAgICAgICB0aGlzLnZlcnNpb24uaXNFcXVhbChvdGhlci52ZXJzaW9uKSAmJlxuICAgICAgICAgICAgdGhpcy5kb2N1bWVudFR5cGUgPT09IG90aGVyLmRvY3VtZW50VHlwZSAmJlxuICAgICAgICAgICAgdGhpcy5kb2N1bWVudFN0YXRlID09PSBvdGhlci5kb2N1bWVudFN0YXRlICYmXG4gICAgICAgICAgICB0aGlzLmRhdGEuaXNFcXVhbChvdGhlci5kYXRhKSk7XG4gICAgfVxuICAgIG11dGFibGVDb3B5KCkge1xuICAgICAgICByZXR1cm4gbmV3IE11dGFibGVEb2N1bWVudCh0aGlzLmtleSwgdGhpcy5kb2N1bWVudFR5cGUsIHRoaXMudmVyc2lvbiwgdGhpcy5yZWFkVGltZSwgdGhpcy5jcmVhdGVUaW1lLCB0aGlzLmRhdGEuY2xvbmUoKSwgdGhpcy5kb2N1bWVudFN0YXRlKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoYERvY3VtZW50KCR7dGhpcy5rZXl9LCAke3RoaXMudmVyc2lvbn0sICR7SlNPTi5zdHJpbmdpZnkodGhpcy5kYXRhLnZhbHVlKX0sIGAgK1xuICAgICAgICAgICAgYHtjcmVhdGVUaW1lOiAke3RoaXMuY3JlYXRlVGltZX19KSwgYCArXG4gICAgICAgICAgICBge2RvY3VtZW50VHlwZTogJHt0aGlzLmRvY3VtZW50VHlwZX19KSwgYCArXG4gICAgICAgICAgICBge2RvY3VtZW50U3RhdGU6ICR7dGhpcy5kb2N1bWVudFN0YXRlfX0pYCk7XG4gICAgfVxufVxuLyoqXG4gKiBDb21wYXJlcyB0aGUgdmFsdWUgZm9yIGZpZWxkIGBmaWVsZGAgaW4gdGhlIHByb3ZpZGVkIGRvY3VtZW50cy4gVGhyb3dzIGlmXG4gKiB0aGUgZmllbGQgZG9lcyBub3QgZXhpc3QgaW4gYm90aCBkb2N1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVEb2N1bWVudHNCeUZpZWxkKGZpZWxkLCBkMSwgZDIpIHtcbiAgICBjb25zdCB2MSA9IGQxLmRhdGEuZmllbGQoZmllbGQpO1xuICAgIGNvbnN0IHYyID0gZDIuZGF0YS5maWVsZChmaWVsZCk7XG4gICAgaWYgKHYxICE9PSBudWxsICYmIHYyICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZUNvbXBhcmUodjEsIHYyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWlsKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgYm91bmQgb2YgYSBxdWVyeS5cbiAqXG4gKiBUaGUgYm91bmQgaXMgc3BlY2lmaWVkIHdpdGggdGhlIGdpdmVuIGNvbXBvbmVudHMgcmVwcmVzZW50aW5nIGEgcG9zaXRpb24gYW5kXG4gKiB3aGV0aGVyIGl0J3MganVzdCBiZWZvcmUgb3IganVzdCBhZnRlciB0aGUgcG9zaXRpb24gKHJlbGF0aXZlIHRvIHdoYXRldmVyIHRoZVxuICogcXVlcnkgb3JkZXIgaXMpLlxuICpcbiAqIFRoZSBwb3NpdGlvbiByZXByZXNlbnRzIGEgbG9naWNhbCBpbmRleCBwb3NpdGlvbiBmb3IgYSBxdWVyeS4gSXQncyBhIHByZWZpeFxuICogb2YgdmFsdWVzIGZvciB0aGUgKHBvdGVudGlhbGx5IGltcGxpY2l0KSBvcmRlciBieSBjbGF1c2VzIG9mIGEgcXVlcnkuXG4gKlxuICogQm91bmQgcHJvdmlkZXMgYSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgd2hldGhlciBhIGRvY3VtZW50IGNvbWVzIGJlZm9yZSBvclxuICogYWZ0ZXIgYSBib3VuZC4gVGhpcyBpcyBpbmZsdWVuY2VkIGJ5IHdoZXRoZXIgdGhlIHBvc2l0aW9uIGlzIGp1c3QgYmVmb3JlIG9yXG4gKiBqdXN0IGFmdGVyIHRoZSBwcm92aWRlZCB2YWx1ZXMuXG4gKi9cbmNsYXNzIEJvdW5kIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3NpdGlvbiwgaW5jbHVzaXZlKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgdGhpcy5pbmNsdXNpdmUgPSBpbmNsdXNpdmU7XG4gICAgfVxufVxuZnVuY3Rpb24gYm91bmRDb21wYXJlVG9Eb2N1bWVudChib3VuZCwgb3JkZXJCeSwgZG9jKSB7XG4gICAgbGV0IGNvbXBhcmlzb24gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm91bmQucG9zaXRpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb3JkZXJCeUNvbXBvbmVudCA9IG9yZGVyQnlbaV07XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGJvdW5kLnBvc2l0aW9uW2ldO1xuICAgICAgICBpZiAob3JkZXJCeUNvbXBvbmVudC5maWVsZC5pc0tleUZpZWxkKCkpIHtcbiAgICAgICAgICAgIGNvbXBhcmlzb24gPSBEb2N1bWVudEtleS5jb21wYXJhdG9yKERvY3VtZW50S2V5LmZyb21OYW1lKGNvbXBvbmVudC5yZWZlcmVuY2VWYWx1ZSksIGRvYy5rZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZG9jVmFsdWUgPSBkb2MuZGF0YS5maWVsZChvcmRlckJ5Q29tcG9uZW50LmZpZWxkKTtcbiAgICAgICAgICAgIGNvbXBhcmlzb24gPSB2YWx1ZUNvbXBhcmUoY29tcG9uZW50LCBkb2NWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yZGVyQnlDb21wb25lbnQuZGlyID09PSBcImRlc2NcIiAvKiBEaXJlY3Rpb24uREVTQ0VORElORyAqLykge1xuICAgICAgICAgICAgY29tcGFyaXNvbiA9IGNvbXBhcmlzb24gKiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcGFyaXNvbiAhPT0gMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbXBhcmlzb247XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhIGRvY3VtZW50IHNvcnRzIGFmdGVyIGEgYm91bmQgdXNpbmcgdGhlIHByb3ZpZGVkIHNvcnRcbiAqIG9yZGVyLlxuICovXG5mdW5jdGlvbiBib3VuZFNvcnRzQWZ0ZXJEb2N1bWVudChib3VuZCwgb3JkZXJCeSwgZG9jKSB7XG4gICAgY29uc3QgY29tcGFyaXNvbiA9IGJvdW5kQ29tcGFyZVRvRG9jdW1lbnQoYm91bmQsIG9yZGVyQnksIGRvYyk7XG4gICAgcmV0dXJuIGJvdW5kLmluY2x1c2l2ZSA/IGNvbXBhcmlzb24gPj0gMCA6IGNvbXBhcmlzb24gPiAwO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBkb2N1bWVudCBzb3J0cyBiZWZvcmUgYSBib3VuZCB1c2luZyB0aGUgcHJvdmlkZWQgc29ydFxuICogb3JkZXIuXG4gKi9cbmZ1bmN0aW9uIGJvdW5kU29ydHNCZWZvcmVEb2N1bWVudChib3VuZCwgb3JkZXJCeSwgZG9jKSB7XG4gICAgY29uc3QgY29tcGFyaXNvbiA9IGJvdW5kQ29tcGFyZVRvRG9jdW1lbnQoYm91bmQsIG9yZGVyQnksIGRvYyk7XG4gICAgcmV0dXJuIGJvdW5kLmluY2x1c2l2ZSA/IGNvbXBhcmlzb24gPD0gMCA6IGNvbXBhcmlzb24gPCAwO1xufVxuZnVuY3Rpb24gYm91bmRFcXVhbHMobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmlnaHQgPT09IG51bGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGxlZnQuaW5jbHVzaXZlICE9PSByaWdodC5pbmNsdXNpdmUgfHxcbiAgICAgICAgbGVmdC5wb3NpdGlvbi5sZW5ndGggIT09IHJpZ2h0LnBvc2l0aW9uLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdC5wb3NpdGlvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBsZWZ0UG9zaXRpb24gPSBsZWZ0LnBvc2l0aW9uW2ldO1xuICAgICAgICBjb25zdCByaWdodFBvc2l0aW9uID0gcmlnaHQucG9zaXRpb25baV07XG4gICAgICAgIGlmICghdmFsdWVFcXVhbHMobGVmdFBvc2l0aW9uLCByaWdodFBvc2l0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBbiBvcmRlcmluZyBvbiBhIGZpZWxkLCBpbiBzb21lIERpcmVjdGlvbi4gRGlyZWN0aW9uIGRlZmF1bHRzIHRvIEFTQ0VORElORy5cbiAqL1xuY2xhc3MgT3JkZXJCeSB7XG4gICAgY29uc3RydWN0b3IoZmllbGQsIGRpciA9IFwiYXNjXCIgLyogRGlyZWN0aW9uLkFTQ0VORElORyAqLykge1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIHRoaXMuZGlyID0gZGlyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNhbm9uaWZ5T3JkZXJCeShvcmRlckJ5KSB7XG4gICAgLy8gVE9ETyhiLzI5MTgzMTY1KTogTWFrZSB0aGlzIGNvbGxpc2lvbiByb2J1c3QuXG4gICAgcmV0dXJuIG9yZGVyQnkuZmllbGQuY2Fub25pY2FsU3RyaW5nKCkgKyBvcmRlckJ5LmRpcjtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeU9yZGVyQnkob3JkZXJCeSkge1xuICAgIHJldHVybiBgJHtvcmRlckJ5LmZpZWxkLmNhbm9uaWNhbFN0cmluZygpfSAoJHtvcmRlckJ5LmRpcn0pYDtcbn1cbmZ1bmN0aW9uIG9yZGVyQnlFcXVhbHMobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gbGVmdC5kaXIgPT09IHJpZ2h0LmRpciAmJiBsZWZ0LmZpZWxkLmlzRXF1YWwocmlnaHQuZmllbGQpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgRmlsdGVyIHtcbn1cbmNsYXNzIEZpZWxkRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgb3AsIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgdGhpcy5vcCA9IG9wO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmaWx0ZXIgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGZpZWxkLCBvcCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGZpZWxkLmlzS2V5RmllbGQoKSkge1xuICAgICAgICAgICAgaWYgKG9wID09PSBcImluXCIgLyogT3BlcmF0b3IuSU4gKi8gfHwgb3AgPT09IFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlS2V5RmllbGRJbkZpbHRlcihmaWVsZCwgb3AsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgS2V5RmllbGRGaWx0ZXIoZmllbGQsIG9wLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3AgPT09IFwiYXJyYXktY29udGFpbnNcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOUyAqLykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheUNvbnRhaW5zRmlsdGVyKGZpZWxkLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3AgPT09IFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqLykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbkZpbHRlcihmaWVsZCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOb3RJbkZpbHRlcihmaWVsZCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TX0FOWSAqLykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheUNvbnRhaW5zQW55RmlsdGVyKGZpZWxkLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpZWxkRmlsdGVyKGZpZWxkLCBvcCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVLZXlGaWVsZEluRmlsdGVyKGZpZWxkLCBvcCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG9wID09PSBcImluXCIgLyogT3BlcmF0b3IuSU4gKi9cbiAgICAgICAgICAgID8gbmV3IEtleUZpZWxkSW5GaWx0ZXIoZmllbGQsIHZhbHVlKVxuICAgICAgICAgICAgOiBuZXcgS2V5RmllbGROb3RJbkZpbHRlcihmaWVsZCwgdmFsdWUpO1xuICAgIH1cbiAgICBtYXRjaGVzKGRvYykge1xuICAgICAgICBjb25zdCBvdGhlciA9IGRvYy5kYXRhLmZpZWxkKHRoaXMuZmllbGQpO1xuICAgICAgICAvLyBUeXBlcyBkbyBub3QgaGF2ZSB0byBtYXRjaCBpbiBOT1RfRVFVQUwgZmlsdGVycy5cbiAgICAgICAgaWYgKHRoaXMub3AgPT09IFwiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiAob3RoZXIgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXNDb21wYXJpc29uKHZhbHVlQ29tcGFyZShvdGhlciwgdGhpcy52YWx1ZSkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IGNvbXBhcmUgdHlwZXMgd2l0aCBtYXRjaGluZyBiYWNrZW5kIG9yZGVyIChzdWNoIGFzIGRvdWJsZSBhbmQgaW50KS5cbiAgICAgICAgcmV0dXJuIChvdGhlciAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZU9yZGVyKHRoaXMudmFsdWUpID09PSB0eXBlT3JkZXIob3RoZXIpICYmXG4gICAgICAgICAgICB0aGlzLm1hdGNoZXNDb21wYXJpc29uKHZhbHVlQ29tcGFyZShvdGhlciwgdGhpcy52YWx1ZSkpKTtcbiAgICB9XG4gICAgbWF0Y2hlc0NvbXBhcmlzb24oY29tcGFyaXNvbikge1xuICAgICAgICBzd2l0Y2ggKHRoaXMub3ApIHtcbiAgICAgICAgICAgIGNhc2UgXCI8XCIgLyogT3BlcmF0b3IuTEVTU19USEFOICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJpc29uIDwgMDtcbiAgICAgICAgICAgIGNhc2UgXCI8PVwiIC8qIE9wZXJhdG9yLkxFU1NfVEhBTl9PUl9FUVVBTCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbiA8PSAwO1xuICAgICAgICAgICAgY2FzZSBcIj09XCIgLyogT3BlcmF0b3IuRVFVQUwgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmlzb24gPT09IDA7XG4gICAgICAgICAgICBjYXNlIFwiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmlzb24gIT09IDA7XG4gICAgICAgICAgICBjYXNlIFwiPlwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTiAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbiA+IDA7XG4gICAgICAgICAgICBjYXNlIFwiPj1cIiAvKiBPcGVyYXRvci5HUkVBVEVSX1RIQU5fT1JfRVFVQUwgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmlzb24gPj0gMDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0luZXF1YWxpdHkoKSB7XG4gICAgICAgIHJldHVybiAoW1xuICAgICAgICAgICAgXCI8XCIgLyogT3BlcmF0b3IuTEVTU19USEFOICovLFxuICAgICAgICAgICAgXCI8PVwiIC8qIE9wZXJhdG9yLkxFU1NfVEhBTl9PUl9FUVVBTCAqLyxcbiAgICAgICAgICAgIFwiPlwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTiAqLyxcbiAgICAgICAgICAgIFwiPj1cIiAvKiBPcGVyYXRvci5HUkVBVEVSX1RIQU5fT1JfRVFVQUwgKi8sXG4gICAgICAgICAgICBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovLFxuICAgICAgICAgICAgXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi9cbiAgICAgICAgXS5pbmRleE9mKHRoaXMub3ApID49IDApO1xuICAgIH1cbiAgICBnZXRGbGF0dGVuZWRGaWx0ZXJzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXNdO1xuICAgIH1cbiAgICBnZXRGaWx0ZXJzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXNdO1xuICAgIH1cbn1cbmNsYXNzIENvbXBvc2l0ZUZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gICAgY29uc3RydWN0b3IoZmlsdGVycywgb3ApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maWx0ZXJzID0gZmlsdGVycztcbiAgICAgICAgdGhpcy5vcCA9IG9wO1xuICAgICAgICB0aGlzLm1lbW9pemVkRmxhdHRlbmVkRmlsdGVycyA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmaWx0ZXIgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGZpbHRlcnMsIG9wKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9zaXRlRmlsdGVyKGZpbHRlcnMsIG9wKTtcbiAgICB9XG4gICAgbWF0Y2hlcyhkb2MpIHtcbiAgICAgICAgaWYgKGNvbXBvc2l0ZUZpbHRlcklzQ29uanVuY3Rpb24odGhpcykpIHtcbiAgICAgICAgICAgIC8vIEZvciBjb25qdW5jdGlvbnMsIGFsbCBmaWx0ZXJzIG11c3QgbWF0Y2gsIHNvIHJldHVybiBmYWxzZSBpZiBhbnkgZmlsdGVyIGRvZXNuJ3QgbWF0Y2guXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJzLmZpbmQoZmlsdGVyID0+ICFmaWx0ZXIubWF0Y2hlcyhkb2MpKSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yIGRpc2p1bmN0aW9ucywgYXQgbGVhc3Qgb25lIGZpbHRlciBzaG91bGQgbWF0Y2guXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJzLmZpbmQoZmlsdGVyID0+IGZpbHRlci5tYXRjaGVzKGRvYykpICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RmxhdHRlbmVkRmlsdGVycygpIHtcbiAgICAgICAgaWYgKHRoaXMubWVtb2l6ZWRGbGF0dGVuZWRGaWx0ZXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZW1vaXplZEZsYXR0ZW5lZEZpbHRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZW1vaXplZEZsYXR0ZW5lZEZpbHRlcnMgPSB0aGlzLmZpbHRlcnMucmVkdWNlKChyZXN1bHQsIHN1YmZpbHRlcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5jb25jYXQoc3ViZmlsdGVyLmdldEZsYXR0ZW5lZEZpbHRlcnMoKSk7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVtb2l6ZWRGbGF0dGVuZWRGaWx0ZXJzO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGEgbXV0YWJsZSBjb3B5IG9mIGB0aGlzLmZpbHRlcnNgXG4gICAgZ2V0RmlsdGVycygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oW10sIHRoaXMuZmlsdGVycyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcG9zaXRlRmlsdGVySXNDb25qdW5jdGlvbihjb21wb3NpdGVGaWx0ZXIpIHtcbiAgICByZXR1cm4gY29tcG9zaXRlRmlsdGVyLm9wID09PSBcImFuZFwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLkFORCAqLztcbn1cbmZ1bmN0aW9uIGNvbXBvc2l0ZUZpbHRlcklzRGlzanVuY3Rpb24oY29tcG9zaXRlRmlsdGVyKSB7XG4gICAgcmV0dXJuIGNvbXBvc2l0ZUZpbHRlci5vcCA9PT0gXCJvclwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLk9SICovO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBmaWx0ZXIgaXMgYSBjb25qdW5jdGlvbiBvZiBmaWVsZCBmaWx0ZXJzIG9ubHkuIFJldHVybnMgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBjb21wb3NpdGVGaWx0ZXJJc0ZsYXRDb25qdW5jdGlvbihjb21wb3NpdGVGaWx0ZXIpIHtcbiAgICByZXR1cm4gKGNvbXBvc2l0ZUZpbHRlcklzRmxhdChjb21wb3NpdGVGaWx0ZXIpICYmXG4gICAgICAgIGNvbXBvc2l0ZUZpbHRlcklzQ29uanVuY3Rpb24oY29tcG9zaXRlRmlsdGVyKSk7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGZpbHRlciBkb2VzIG5vdCBjb250YWluIGFueSBjb21wb3NpdGUgZmlsdGVycy4gUmV0dXJucyBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGNvbXBvc2l0ZUZpbHRlcklzRmxhdChjb21wb3NpdGVGaWx0ZXIpIHtcbiAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBjb21wb3NpdGVGaWx0ZXIuZmlsdGVycykge1xuICAgICAgICBpZiAoZmlsdGVyIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjYW5vbmlmeUZpbHRlcihmaWx0ZXIpIHtcbiAgICBpZiAoZmlsdGVyIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIpIHtcbiAgICAgICAgLy8gVE9ETyhiLzI5MTgzMTY1KTogVGVjaG5pY2FsbHksIHRoaXMgd29uJ3QgYmUgdW5pcXVlIGlmIHR3byB2YWx1ZXMgaGF2ZVxuICAgICAgICAvLyB0aGUgc2FtZSBkZXNjcmlwdGlvbiwgc3VjaCBhcyB0aGUgaW50IDMgYW5kIHRoZSBzdHJpbmcgXCIzXCIuIFNvIHdlIHNob3VsZFxuICAgICAgICAvLyBhZGQgdGhlIHR5cGVzIGluIGhlcmUgc29tZWhvdywgdG9vLlxuICAgICAgICByZXR1cm4gKGZpbHRlci5maWVsZC5jYW5vbmljYWxTdHJpbmcoKSArXG4gICAgICAgICAgICBmaWx0ZXIub3AudG9TdHJpbmcoKSArXG4gICAgICAgICAgICBjYW5vbmljYWxJZChmaWx0ZXIudmFsdWUpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29tcG9zaXRlRmlsdGVySXNGbGF0Q29uanVuY3Rpb24oZmlsdGVyKSkge1xuICAgICAgICAvLyBPbGRlciBTREsgdmVyc2lvbnMgdXNlIGFuIGltcGxpY2l0IEFORCBvcGVyYXRpb24gYmV0d2VlbiB0aGVpciBmaWx0ZXJzLlxuICAgICAgICAvLyBJbiB0aGUgbmV3IFNESyB2ZXJzaW9ucywgdGhlIGRldmVsb3BlciBtYXkgdXNlIGFuIGV4cGxpY2l0IEFORCBmaWx0ZXIuXG4gICAgICAgIC8vIFRvIHN0YXkgY29uc2lzdGVudCB3aXRoIHRoZSBvbGQgdXNhZ2VzLCB3ZSBhZGQgYSBzcGVjaWFsIGNhc2UgdG8gZW5zdXJlXG4gICAgICAgIC8vIHRoZSBjYW5vbmljYWwgSUQgZm9yIHRoZXNlIHR3byBhcmUgdGhlIHNhbWUuIEZvciBleGFtcGxlOlxuICAgICAgICAvLyBgY29sLndoZXJlRXF1YWxzKFwiYVwiLCAxKS53aGVyZUVxdWFscyhcImJcIiwgMilgIHNob3VsZCBoYXZlIHRoZSBzYW1lXG4gICAgICAgIC8vIGNhbm9uaWNhbCBJRCBhcyBgY29sLndoZXJlKGFuZChlcXVhbHMoXCJhXCIsMSksIGVxdWFscyhcImJcIiwyKSkpYC5cbiAgICAgICAgcmV0dXJuIGZpbHRlci5maWx0ZXJzLm1hcChmaWx0ZXIgPT4gY2Fub25pZnlGaWx0ZXIoZmlsdGVyKSkuam9pbignLCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gZmlsdGVyIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyXG4gICAgICAgIGNvbnN0IGNhbm9uaWNhbElkc1N0cmluZyA9IGZpbHRlci5maWx0ZXJzXG4gICAgICAgICAgICAubWFwKGZpbHRlciA9PiBjYW5vbmlmeUZpbHRlcihmaWx0ZXIpKVxuICAgICAgICAgICAgLmpvaW4oJywnKTtcbiAgICAgICAgcmV0dXJuIGAke2ZpbHRlci5vcH0oJHtjYW5vbmljYWxJZHNTdHJpbmd9KWA7XG4gICAgfVxufVxuZnVuY3Rpb24gZmlsdGVyRXF1YWxzKGYxLCBmMikge1xuICAgIGlmIChmMSBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBmaWVsZEZpbHRlckVxdWFscyhmMSwgZjIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChmMSBpbnN0YW5jZW9mIENvbXBvc2l0ZUZpbHRlcikge1xuICAgICAgICByZXR1cm4gY29tcG9zaXRlRmlsdGVyRXF1YWxzKGYxLCBmMik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmYWlsKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZmllbGRGaWx0ZXJFcXVhbHMoZjEsIGYyKSB7XG4gICAgcmV0dXJuIChmMiBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyICYmXG4gICAgICAgIGYxLm9wID09PSBmMi5vcCAmJlxuICAgICAgICBmMS5maWVsZC5pc0VxdWFsKGYyLmZpZWxkKSAmJlxuICAgICAgICB2YWx1ZUVxdWFscyhmMS52YWx1ZSwgZjIudmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGNvbXBvc2l0ZUZpbHRlckVxdWFscyhmMSwgZjIpIHtcbiAgICBpZiAoZjIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIgJiZcbiAgICAgICAgZjEub3AgPT09IGYyLm9wICYmXG4gICAgICAgIGYxLmZpbHRlcnMubGVuZ3RoID09PSBmMi5maWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBzdWJGaWx0ZXJzTWF0Y2ggPSBmMS5maWx0ZXJzLnJlZHVjZSgocmVzdWx0LCBmMUZpbHRlciwgaW5kZXgpID0+IHJlc3VsdCAmJiBmaWx0ZXJFcXVhbHMoZjFGaWx0ZXIsIGYyLmZpbHRlcnNbaW5kZXhdKSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBzdWJGaWx0ZXJzTWF0Y2g7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogUmV0dXJucyBhIG5ldyBjb21wb3NpdGUgZmlsdGVyIHRoYXQgY29udGFpbnMgYWxsIGZpbHRlciBmcm9tXG4gKiBgY29tcG9zaXRlRmlsdGVyYCBwbHVzIGFsbCB0aGUgZ2l2ZW4gZmlsdGVycyBpbiBgb3RoZXJGaWx0ZXJzYC5cbiAqL1xuZnVuY3Rpb24gY29tcG9zaXRlRmlsdGVyV2l0aEFkZGVkRmlsdGVycyhjb21wb3NpdGVGaWx0ZXIsIG90aGVyRmlsdGVycykge1xuICAgIGNvbnN0IG1lcmdlZEZpbHRlcnMgPSBjb21wb3NpdGVGaWx0ZXIuZmlsdGVycy5jb25jYXQob3RoZXJGaWx0ZXJzKTtcbiAgICByZXR1cm4gQ29tcG9zaXRlRmlsdGVyLmNyZWF0ZShtZXJnZWRGaWx0ZXJzLCBjb21wb3NpdGVGaWx0ZXIub3ApO1xufVxuLyoqIFJldHVybnMgYSBkZWJ1ZyBkZXNjcmlwdGlvbiBmb3IgYGZpbHRlcmAuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlGaWx0ZXIoZmlsdGVyKSB7XG4gICAgaWYgKGZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlGaWVsZEZpbHRlcihmaWx0ZXIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeUNvbXBvc2l0ZUZpbHRlcihmaWx0ZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdGaWx0ZXInO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeUNvbXBvc2l0ZUZpbHRlcihmaWx0ZXIpIHtcbiAgICByZXR1cm4gKGZpbHRlci5vcC50b1N0cmluZygpICtcbiAgICAgICAgYCB7YCArXG4gICAgICAgIGZpbHRlci5nZXRGaWx0ZXJzKCkubWFwKHN0cmluZ2lmeUZpbHRlcikuam9pbignICwnKSArXG4gICAgICAgICd9Jyk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlGaWVsZEZpbHRlcihmaWx0ZXIpIHtcbiAgICByZXR1cm4gYCR7ZmlsdGVyLmZpZWxkLmNhbm9uaWNhbFN0cmluZygpfSAke2ZpbHRlci5vcH0gJHtjYW5vbmljYWxJZChmaWx0ZXIudmFsdWUpfWA7XG59XG4vKiogRmlsdGVyIHRoYXQgbWF0Y2hlcyBvbiBrZXkgZmllbGRzIChpLmUuICdfX25hbWVfXycpLiAqL1xuY2xhc3MgS2V5RmllbGRGaWx0ZXIgZXh0ZW5kcyBGaWVsZEZpbHRlciB7XG4gICAgY29uc3RydWN0b3IoZmllbGQsIG9wLCB2YWx1ZSkge1xuICAgICAgICBzdXBlcihmaWVsZCwgb3AsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5rZXkgPSBEb2N1bWVudEtleS5mcm9tTmFtZSh2YWx1ZS5yZWZlcmVuY2VWYWx1ZSk7XG4gICAgfVxuICAgIG1hdGNoZXMoZG9jKSB7XG4gICAgICAgIGNvbnN0IGNvbXBhcmlzb24gPSBEb2N1bWVudEtleS5jb21wYXJhdG9yKGRvYy5rZXksIHRoaXMua2V5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hlc0NvbXBhcmlzb24oY29tcGFyaXNvbik7XG4gICAgfVxufVxuLyoqIEZpbHRlciB0aGF0IG1hdGNoZXMgb24ga2V5IGZpZWxkcyB3aXRoaW4gYW4gYXJyYXkuICovXG5jbGFzcyBLZXlGaWVsZEluRmlsdGVyIGV4dGVuZHMgRmllbGRGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCB2YWx1ZSkge1xuICAgICAgICBzdXBlcihmaWVsZCwgXCJpblwiIC8qIE9wZXJhdG9yLklOICovLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMua2V5cyA9IGV4dHJhY3REb2N1bWVudEtleXNGcm9tQXJyYXlWYWx1ZShcImluXCIgLyogT3BlcmF0b3IuSU4gKi8sIHZhbHVlKTtcbiAgICB9XG4gICAgbWF0Y2hlcyhkb2MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5cy5zb21lKGtleSA9PiBrZXkuaXNFcXVhbChkb2Mua2V5KSk7XG4gICAgfVxufVxuLyoqIEZpbHRlciB0aGF0IG1hdGNoZXMgb24ga2V5IGZpZWxkcyBub3QgcHJlc2VudCB3aXRoaW4gYW4gYXJyYXkuICovXG5jbGFzcyBLZXlGaWVsZE5vdEluRmlsdGVyIGV4dGVuZHMgRmllbGRGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCB2YWx1ZSkge1xuICAgICAgICBzdXBlcihmaWVsZCwgXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi8sIHZhbHVlKTtcbiAgICAgICAgdGhpcy5rZXlzID0gZXh0cmFjdERvY3VtZW50S2V5c0Zyb21BcnJheVZhbHVlKFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIG1hdGNoZXMoZG9jKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5rZXlzLnNvbWUoa2V5ID0+IGtleS5pc0VxdWFsKGRvYy5rZXkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBleHRyYWN0RG9jdW1lbnRLZXlzRnJvbUFycmF5VmFsdWUob3AsIHZhbHVlKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKChfYSA9IHZhbHVlLmFycmF5VmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52YWx1ZXMpIHx8IFtdKS5tYXAodiA9PiB7XG4gICAgICAgIHJldHVybiBEb2N1bWVudEtleS5mcm9tTmFtZSh2LnJlZmVyZW5jZVZhbHVlKTtcbiAgICB9KTtcbn1cbi8qKiBBIEZpbHRlciB0aGF0IGltcGxlbWVudHMgdGhlIGFycmF5LWNvbnRhaW5zIG9wZXJhdG9yLiAqL1xuY2xhc3MgQXJyYXlDb250YWluc0ZpbHRlciBleHRlbmRzIEZpZWxkRmlsdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIoZmllbGQsIFwiYXJyYXktY29udGFpbnNcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOUyAqLywgdmFsdWUpO1xuICAgIH1cbiAgICBtYXRjaGVzKGRvYykge1xuICAgICAgICBjb25zdCBvdGhlciA9IGRvYy5kYXRhLmZpZWxkKHRoaXMuZmllbGQpO1xuICAgICAgICByZXR1cm4gaXNBcnJheShvdGhlcikgJiYgYXJyYXlWYWx1ZUNvbnRhaW5zKG90aGVyLmFycmF5VmFsdWUsIHRoaXMudmFsdWUpO1xuICAgIH1cbn1cbi8qKiBBIEZpbHRlciB0aGF0IGltcGxlbWVudHMgdGhlIElOIG9wZXJhdG9yLiAqL1xuY2xhc3MgSW5GaWx0ZXIgZXh0ZW5kcyBGaWVsZEZpbHRlciB7XG4gICAgY29uc3RydWN0b3IoZmllbGQsIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkLCBcImluXCIgLyogT3BlcmF0b3IuSU4gKi8sIHZhbHVlKTtcbiAgICB9XG4gICAgbWF0Y2hlcyhkb2MpIHtcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBkb2MuZGF0YS5maWVsZCh0aGlzLmZpZWxkKTtcbiAgICAgICAgcmV0dXJuIG90aGVyICE9PSBudWxsICYmIGFycmF5VmFsdWVDb250YWlucyh0aGlzLnZhbHVlLmFycmF5VmFsdWUsIG90aGVyKTtcbiAgICB9XG59XG4vKiogQSBGaWx0ZXIgdGhhdCBpbXBsZW1lbnRzIHRoZSBub3QtaW4gb3BlcmF0b3IuICovXG5jbGFzcyBOb3RJbkZpbHRlciBleHRlbmRzIEZpZWxkRmlsdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIoZmllbGQsIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIG1hdGNoZXMoZG9jKSB7XG4gICAgICAgIGlmIChhcnJheVZhbHVlQ29udGFpbnModGhpcy52YWx1ZS5hcnJheVZhbHVlLCB7IG51bGxWYWx1ZTogJ05VTExfVkFMVUUnIH0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3RoZXIgPSBkb2MuZGF0YS5maWVsZCh0aGlzLmZpZWxkKTtcbiAgICAgICAgcmV0dXJuIG90aGVyICE9PSBudWxsICYmICFhcnJheVZhbHVlQ29udGFpbnModGhpcy52YWx1ZS5hcnJheVZhbHVlLCBvdGhlcik7XG4gICAgfVxufVxuLyoqIEEgRmlsdGVyIHRoYXQgaW1wbGVtZW50cyB0aGUgYXJyYXktY29udGFpbnMtYW55IG9wZXJhdG9yLiAqL1xuY2xhc3MgQXJyYXlDb250YWluc0FueUZpbHRlciBleHRlbmRzIEZpZWxkRmlsdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIoZmllbGQsIFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIG1hdGNoZXMoZG9jKSB7XG4gICAgICAgIGNvbnN0IG90aGVyID0gZG9jLmRhdGEuZmllbGQodGhpcy5maWVsZCk7XG4gICAgICAgIGlmICghaXNBcnJheShvdGhlcikgfHwgIW90aGVyLmFycmF5VmFsdWUudmFsdWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG90aGVyLmFycmF5VmFsdWUudmFsdWVzLnNvbWUodmFsID0+IGFycmF5VmFsdWVDb250YWlucyh0aGlzLnZhbHVlLmFycmF5VmFsdWUsIHZhbCkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8vIFZpc2libGUgZm9yIHRlc3RpbmdcbmNsYXNzIFRhcmdldEltcGwge1xuICAgIGNvbnN0cnVjdG9yKHBhdGgsIGNvbGxlY3Rpb25Hcm91cCA9IG51bGwsIG9yZGVyQnkgPSBbXSwgZmlsdGVycyA9IFtdLCBsaW1pdCA9IG51bGwsIHN0YXJ0QXQgPSBudWxsLCBlbmRBdCA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uR3JvdXAgPSBjb2xsZWN0aW9uR3JvdXA7XG4gICAgICAgIHRoaXMub3JkZXJCeSA9IG9yZGVyQnk7XG4gICAgICAgIHRoaXMuZmlsdGVycyA9IGZpbHRlcnM7XG4gICAgICAgIHRoaXMubGltaXQgPSBsaW1pdDtcbiAgICAgICAgdGhpcy5zdGFydEF0ID0gc3RhcnRBdDtcbiAgICAgICAgdGhpcy5lbmRBdCA9IGVuZEF0O1xuICAgICAgICB0aGlzLm1lbW9pemVkQ2Fub25pY2FsSWQgPSBudWxsO1xuICAgIH1cbn1cbi8qKlxuICogSW5pdGlhbGl6ZXMgYSBUYXJnZXQgd2l0aCBhIHBhdGggYW5kIG9wdGlvbmFsIGFkZGl0aW9uYWwgcXVlcnkgY29uc3RyYWludHMuXG4gKiBQYXRoIG11c3QgY3VycmVudGx5IGJlIGVtcHR5IGlmIHRoaXMgaXMgYSBjb2xsZWN0aW9uIGdyb3VwIHF1ZXJ5LlxuICpcbiAqIE5PVEU6IHlvdSBzaG91bGQgYWx3YXlzIGNvbnN0cnVjdCBgVGFyZ2V0YCBmcm9tIGBRdWVyeS50b1RhcmdldGAgaW5zdGVhZCBvZlxuICogdXNpbmcgdGhpcyBmYWN0b3J5IG1ldGhvZCwgYmVjYXVzZSBgUXVlcnlgIHByb3ZpZGVzIGFuIGltcGxpY2l0IGBvcmRlckJ5YFxuICogcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIG5ld1RhcmdldChwYXRoLCBjb2xsZWN0aW9uR3JvdXAgPSBudWxsLCBvcmRlckJ5ID0gW10sIGZpbHRlcnMgPSBbXSwgbGltaXQgPSBudWxsLCBzdGFydEF0ID0gbnVsbCwgZW5kQXQgPSBudWxsKSB7XG4gICAgcmV0dXJuIG5ldyBUYXJnZXRJbXBsKHBhdGgsIGNvbGxlY3Rpb25Hcm91cCwgb3JkZXJCeSwgZmlsdGVycywgbGltaXQsIHN0YXJ0QXQsIGVuZEF0KTtcbn1cbmZ1bmN0aW9uIGNhbm9uaWZ5VGFyZ2V0KHRhcmdldCkge1xuICAgIGNvbnN0IHRhcmdldEltcGwgPSBkZWJ1Z0Nhc3QodGFyZ2V0KTtcbiAgICBpZiAodGFyZ2V0SW1wbC5tZW1vaXplZENhbm9uaWNhbElkID09PSBudWxsKSB7XG4gICAgICAgIGxldCBzdHIgPSB0YXJnZXRJbXBsLnBhdGguY2Fub25pY2FsU3RyaW5nKCk7XG4gICAgICAgIGlmICh0YXJnZXRJbXBsLmNvbGxlY3Rpb25Hcm91cCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RyICs9ICd8Y2c6JyArIHRhcmdldEltcGwuY29sbGVjdGlvbkdyb3VwO1xuICAgICAgICB9XG4gICAgICAgIHN0ciArPSAnfGY6JztcbiAgICAgICAgc3RyICs9IHRhcmdldEltcGwuZmlsdGVycy5tYXAoZiA9PiBjYW5vbmlmeUZpbHRlcihmKSkuam9pbignLCcpO1xuICAgICAgICBzdHIgKz0gJ3xvYjonO1xuICAgICAgICBzdHIgKz0gdGFyZ2V0SW1wbC5vcmRlckJ5Lm1hcChvID0+IGNhbm9uaWZ5T3JkZXJCeShvKSkuam9pbignLCcpO1xuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHRhcmdldEltcGwubGltaXQpKSB7XG4gICAgICAgICAgICBzdHIgKz0gJ3xsOic7XG4gICAgICAgICAgICBzdHIgKz0gdGFyZ2V0SW1wbC5saW1pdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0SW1wbC5zdGFydEF0KSB7XG4gICAgICAgICAgICBzdHIgKz0gJ3xsYjonO1xuICAgICAgICAgICAgc3RyICs9IHRhcmdldEltcGwuc3RhcnRBdC5pbmNsdXNpdmUgPyAnYjonIDogJ2E6JztcbiAgICAgICAgICAgIHN0ciArPSB0YXJnZXRJbXBsLnN0YXJ0QXQucG9zaXRpb24ubWFwKHAgPT4gY2Fub25pY2FsSWQocCkpLmpvaW4oJywnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0SW1wbC5lbmRBdCkge1xuICAgICAgICAgICAgc3RyICs9ICd8dWI6JztcbiAgICAgICAgICAgIHN0ciArPSB0YXJnZXRJbXBsLmVuZEF0LmluY2x1c2l2ZSA/ICdhOicgOiAnYjonO1xuICAgICAgICAgICAgc3RyICs9IHRhcmdldEltcGwuZW5kQXQucG9zaXRpb24ubWFwKHAgPT4gY2Fub25pY2FsSWQocCkpLmpvaW4oJywnKTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXRJbXBsLm1lbW9pemVkQ2Fub25pY2FsSWQgPSBzdHI7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRJbXBsLm1lbW9pemVkQ2Fub25pY2FsSWQ7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlUYXJnZXQodGFyZ2V0KSB7XG4gICAgbGV0IHN0ciA9IHRhcmdldC5wYXRoLmNhbm9uaWNhbFN0cmluZygpO1xuICAgIGlmICh0YXJnZXQuY29sbGVjdGlvbkdyb3VwICE9PSBudWxsKSB7XG4gICAgICAgIHN0ciArPSAnIGNvbGxlY3Rpb25Hcm91cD0nICsgdGFyZ2V0LmNvbGxlY3Rpb25Hcm91cDtcbiAgICB9XG4gICAgaWYgKHRhcmdldC5maWx0ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3RyICs9IGAsIGZpbHRlcnM6IFske3RhcmdldC5maWx0ZXJzXG4gICAgICAgICAgICAubWFwKGYgPT4gc3RyaW5naWZ5RmlsdGVyKGYpKVxuICAgICAgICAgICAgLmpvaW4oJywgJyl9XWA7XG4gICAgfVxuICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQodGFyZ2V0LmxpbWl0KSkge1xuICAgICAgICBzdHIgKz0gJywgbGltaXQ6ICcgKyB0YXJnZXQubGltaXQ7XG4gICAgfVxuICAgIGlmICh0YXJnZXQub3JkZXJCeS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHN0ciArPSBgLCBvcmRlckJ5OiBbJHt0YXJnZXQub3JkZXJCeVxuICAgICAgICAgICAgLm1hcChvID0+IHN0cmluZ2lmeU9yZGVyQnkobykpXG4gICAgICAgICAgICAuam9pbignLCAnKX1dYDtcbiAgICB9XG4gICAgaWYgKHRhcmdldC5zdGFydEF0KSB7XG4gICAgICAgIHN0ciArPSAnLCBzdGFydEF0OiAnO1xuICAgICAgICBzdHIgKz0gdGFyZ2V0LnN0YXJ0QXQuaW5jbHVzaXZlID8gJ2I6JyA6ICdhOic7XG4gICAgICAgIHN0ciArPSB0YXJnZXQuc3RhcnRBdC5wb3NpdGlvbi5tYXAocCA9PiBjYW5vbmljYWxJZChwKSkuam9pbignLCcpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0LmVuZEF0KSB7XG4gICAgICAgIHN0ciArPSAnLCBlbmRBdDogJztcbiAgICAgICAgc3RyICs9IHRhcmdldC5lbmRBdC5pbmNsdXNpdmUgPyAnYTonIDogJ2I6JztcbiAgICAgICAgc3RyICs9IHRhcmdldC5lbmRBdC5wb3NpdGlvbi5tYXAocCA9PiBjYW5vbmljYWxJZChwKSkuam9pbignLCcpO1xuICAgIH1cbiAgICByZXR1cm4gYFRhcmdldCgke3N0cn0pYDtcbn1cbmZ1bmN0aW9uIHRhcmdldEVxdWFscyhsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LmxpbWl0ICE9PSByaWdodC5saW1pdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsZWZ0Lm9yZGVyQnkubGVuZ3RoICE9PSByaWdodC5vcmRlckJ5Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdC5vcmRlckJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghb3JkZXJCeUVxdWFscyhsZWZ0Lm9yZGVyQnlbaV0sIHJpZ2h0Lm9yZGVyQnlbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxlZnQuZmlsdGVycy5sZW5ndGggIT09IHJpZ2h0LmZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0LmZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFmaWx0ZXJFcXVhbHMobGVmdC5maWx0ZXJzW2ldLCByaWdodC5maWx0ZXJzW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChsZWZ0LmNvbGxlY3Rpb25Hcm91cCAhPT0gcmlnaHQuY29sbGVjdGlvbkdyb3VwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFsZWZ0LnBhdGguaXNFcXVhbChyaWdodC5wYXRoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghYm91bmRFcXVhbHMobGVmdC5zdGFydEF0LCByaWdodC5zdGFydEF0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBib3VuZEVxdWFscyhsZWZ0LmVuZEF0LCByaWdodC5lbmRBdCk7XG59XG5mdW5jdGlvbiB0YXJnZXRJc0RvY3VtZW50VGFyZ2V0KHRhcmdldCkge1xuICAgIHJldHVybiAoRG9jdW1lbnRLZXkuaXNEb2N1bWVudEtleSh0YXJnZXQucGF0aCkgJiZcbiAgICAgICAgdGFyZ2V0LmNvbGxlY3Rpb25Hcm91cCA9PT0gbnVsbCAmJlxuICAgICAgICB0YXJnZXQuZmlsdGVycy5sZW5ndGggPT09IDApO1xufVxuLyoqIFJldHVybnMgdGhlIGZpZWxkIGZpbHRlcnMgdGhhdCB0YXJnZXQgdGhlIGdpdmVuIGZpZWxkIHBhdGguICovXG5mdW5jdGlvbiB0YXJnZXRHZXRGaWVsZEZpbHRlcnNGb3JQYXRoKHRhcmdldCwgcGF0aCkge1xuICAgIHJldHVybiB0YXJnZXQuZmlsdGVycy5maWx0ZXIoZiA9PiBmIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIgJiYgZi5maWVsZC5pc0VxdWFsKHBhdGgpKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWVzIHRoYXQgYXJlIHVzZWQgaW4gQVJSQVlfQ09OVEFJTlMgb3IgQVJSQVlfQ09OVEFJTlNfQU5ZXG4gKiBmaWx0ZXJzLiBSZXR1cm5zIGBudWxsYCBpZiB0aGVyZSBhcmUgbm8gc3VjaCBmaWx0ZXJzLlxuICovXG5mdW5jdGlvbiB0YXJnZXRHZXRBcnJheVZhbHVlcyh0YXJnZXQsIGZpZWxkSW5kZXgpIHtcbiAgICBjb25zdCBzZWdtZW50ID0gZmllbGRJbmRleEdldEFycmF5U2VnbWVudChmaWVsZEluZGV4KTtcbiAgICBpZiAoc2VnbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZpZWxkRmlsdGVyIG9mIHRhcmdldEdldEZpZWxkRmlsdGVyc0ZvclBhdGgodGFyZ2V0LCBzZWdtZW50LmZpZWxkUGF0aCkpIHtcbiAgICAgICAgc3dpdGNoIChmaWVsZEZpbHRlci5vcCkge1xuICAgICAgICAgICAgY2FzZSBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TX0FOWSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmllbGRGaWx0ZXIudmFsdWUuYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW107XG4gICAgICAgICAgICBjYXNlIFwiYXJyYXktY29udGFpbnNcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOUyAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gW2ZpZWxkRmlsdGVyLnZhbHVlXTtcbiAgICAgICAgICAgIC8vIFJlbWFpbmluZyBmaWx0ZXJzIGFyZSBub3QgYXJyYXkgZmlsdGVycy5cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbGlzdCBvZiB2YWx1ZXMgdGhhdCBhcmUgdXNlZCBpbiAhPSBvciBOT1RfSU4gZmlsdGVycy4gUmV0dXJuc1xuICogYG51bGxgIGlmIHRoZXJlIGFyZSBubyBzdWNoIGZpbHRlcnMuXG4gKi9cbmZ1bmN0aW9uIHRhcmdldEdldE5vdEluVmFsdWVzKHRhcmdldCwgZmllbGRJbmRleCkge1xuICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgZmllbGRJbmRleEdldERpcmVjdGlvbmFsU2VnbWVudHMoZmllbGRJbmRleCkpIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZEZpbHRlciBvZiB0YXJnZXRHZXRGaWVsZEZpbHRlcnNGb3JQYXRoKHRhcmdldCwgc2VnbWVudC5maWVsZFBhdGgpKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkRmlsdGVyLm9wKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIj09XCIgLyogT3BlcmF0b3IuRVFVQUwgKi86XG4gICAgICAgICAgICAgICAgY2FzZSBcImluXCIgLyogT3BlcmF0b3IuSU4gKi86XG4gICAgICAgICAgICAgICAgICAgIC8vIEVuY29kZSBlcXVhbGl0eSBwcmVmaXgsIHdoaWNoIGlzIGVuY29kZWQgaW4gdGhlIGluZGV4IHZhbHVlIGJlZm9yZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgaW5lcXVhbGl0eSAoZS5nLiBgYSA9PSAnYScgJiYgYiAhPSAnYidgIGlzIGVuY29kZWQgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gYHZhbHVlICE9ICdhYidgKS5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnNldChzZWdtZW50LmZpZWxkUGF0aC5jYW5vbmljYWxTdHJpbmcoKSwgZmllbGRGaWx0ZXIudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovOlxuICAgICAgICAgICAgICAgIGNhc2UgXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqLzpcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90SW4vTm90RXF1YWwgaXMgYWx3YXlzIGEgc3VmZml4LiBUaGVyZSBjYW5ub3QgYmUgYW55IHJlbWFpbmluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBzZWdtZW50cyBhbmQgaGVuY2Ugd2UgY2FuIHJldHVybiBlYXJseSBoZXJlLlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuc2V0KHNlZ21lbnQuZmllbGRQYXRoLmNhbm9uaWNhbFN0cmluZygpLCBmaWVsZEZpbHRlci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHZhbHVlcy52YWx1ZXMoKSk7XG4gICAgICAgICAgICAgICAgLy8gUmVtYWluaW5nIGZpbHRlcnMgY2Fubm90IGJlIHVzZWQgYXMgbm90SW4gYm91bmRzLlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgbG93ZXIgYm91bmQgb2YgZmllbGQgdmFsdWVzIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSBzdGFydGluZyBwb2ludCB0b1xuICogc2NhbiB0aGUgaW5kZXggZGVmaW5lZCBieSBgZmllbGRJbmRleGAuIFJldHVybnMgYE1JTl9WQUxVRWAgaWYgbm8gbG93ZXIgYm91bmRcbiAqIGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gdGFyZ2V0R2V0TG93ZXJCb3VuZCh0YXJnZXQsIGZpZWxkSW5kZXgpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBsZXQgaW5jbHVzaXZlID0gdHJ1ZTtcbiAgICAvLyBGb3IgZWFjaCBzZWdtZW50LCByZXRyaWV2ZSBhIGxvd2VyIGJvdW5kIGlmIHRoZXJlIGlzIGEgc3VpdGFibGUgZmlsdGVyIG9yXG4gICAgLy8gc3RhcnRBdC5cbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgZmllbGRJbmRleEdldERpcmVjdGlvbmFsU2VnbWVudHMoZmllbGRJbmRleCkpIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudEJvdW5kID0gc2VnbWVudC5raW5kID09PSAwIC8qIEluZGV4S2luZC5BU0NFTkRJTkcgKi9cbiAgICAgICAgICAgID8gdGFyZ2V0R2V0QXNjZW5kaW5nQm91bmQodGFyZ2V0LCBzZWdtZW50LmZpZWxkUGF0aCwgdGFyZ2V0LnN0YXJ0QXQpXG4gICAgICAgICAgICA6IHRhcmdldEdldERlc2NlbmRpbmdCb3VuZCh0YXJnZXQsIHNlZ21lbnQuZmllbGRQYXRoLCB0YXJnZXQuc3RhcnRBdCk7XG4gICAgICAgIHZhbHVlcy5wdXNoKHNlZ21lbnRCb3VuZC52YWx1ZSk7XG4gICAgICAgIGluY2x1c2l2ZSAmJiAoaW5jbHVzaXZlID0gc2VnbWVudEJvdW5kLmluY2x1c2l2ZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQm91bmQodmFsdWVzLCBpbmNsdXNpdmUpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGFuIHVwcGVyIGJvdW5kIG9mIGZpZWxkIHZhbHVlcyB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIGVuZGluZyBwb2ludFxuICogd2hlbiBzY2FubmluZyB0aGUgaW5kZXggZGVmaW5lZCBieSBgZmllbGRJbmRleGAuIFJldHVybnMgYE1BWF9WQUxVRWAgaWYgbm9cbiAqIHVwcGVyIGJvdW5kIGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gdGFyZ2V0R2V0VXBwZXJCb3VuZCh0YXJnZXQsIGZpZWxkSW5kZXgpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBsZXQgaW5jbHVzaXZlID0gdHJ1ZTtcbiAgICAvLyBGb3IgZWFjaCBzZWdtZW50LCByZXRyaWV2ZSBhbiB1cHBlciBib3VuZCBpZiB0aGVyZSBpcyBhIHN1aXRhYmxlIGZpbHRlciBvclxuICAgIC8vIGVuZEF0LlxuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBmaWVsZEluZGV4R2V0RGlyZWN0aW9uYWxTZWdtZW50cyhmaWVsZEluZGV4KSkge1xuICAgICAgICBjb25zdCBzZWdtZW50Qm91bmQgPSBzZWdtZW50LmtpbmQgPT09IDAgLyogSW5kZXhLaW5kLkFTQ0VORElORyAqL1xuICAgICAgICAgICAgPyB0YXJnZXRHZXREZXNjZW5kaW5nQm91bmQodGFyZ2V0LCBzZWdtZW50LmZpZWxkUGF0aCwgdGFyZ2V0LmVuZEF0KVxuICAgICAgICAgICAgOiB0YXJnZXRHZXRBc2NlbmRpbmdCb3VuZCh0YXJnZXQsIHNlZ21lbnQuZmllbGRQYXRoLCB0YXJnZXQuZW5kQXQpO1xuICAgICAgICB2YWx1ZXMucHVzaChzZWdtZW50Qm91bmQudmFsdWUpO1xuICAgICAgICBpbmNsdXNpdmUgJiYgKGluY2x1c2l2ZSA9IHNlZ21lbnRCb3VuZC5pbmNsdXNpdmUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEJvdW5kKHZhbHVlcywgaW5jbHVzaXZlKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgdG8gdXNlIGFzIHRoZSBsb3dlciBib3VuZCBmb3IgYXNjZW5kaW5nIGluZGV4IHNlZ21lbnQgYXRcbiAqIHRoZSBwcm92aWRlZCBgZmllbGRQYXRoYCAob3IgdGhlIHVwcGVyIGJvdW5kIGZvciBhbiBkZXNjZW5kaW5nIHNlZ21lbnQpLlxuICovXG5mdW5jdGlvbiB0YXJnZXRHZXRBc2NlbmRpbmdCb3VuZCh0YXJnZXQsIGZpZWxkUGF0aCwgYm91bmQpIHtcbiAgICBsZXQgdmFsdWUgPSBNSU5fVkFMVUU7XG4gICAgbGV0IGluY2x1c2l2ZSA9IHRydWU7XG4gICAgLy8gUHJvY2VzcyBhbGwgZmlsdGVycyB0byBmaW5kIGEgdmFsdWUgZm9yIHRoZSBjdXJyZW50IGZpZWxkIHNlZ21lbnRcbiAgICBmb3IgKGNvbnN0IGZpZWxkRmlsdGVyIG9mIHRhcmdldEdldEZpZWxkRmlsdGVyc0ZvclBhdGgodGFyZ2V0LCBmaWVsZFBhdGgpKSB7XG4gICAgICAgIGxldCBmaWx0ZXJWYWx1ZSA9IE1JTl9WQUxVRTtcbiAgICAgICAgbGV0IGZpbHRlckluY2x1c2l2ZSA9IHRydWU7XG4gICAgICAgIHN3aXRjaCAoZmllbGRGaWx0ZXIub3ApIHtcbiAgICAgICAgICAgIGNhc2UgXCI8XCIgLyogT3BlcmF0b3IuTEVTU19USEFOICovOlxuICAgICAgICAgICAgY2FzZSBcIjw9XCIgLyogT3BlcmF0b3IuTEVTU19USEFOX09SX0VRVUFMICovOlxuICAgICAgICAgICAgICAgIGZpbHRlclZhbHVlID0gdmFsdWVzR2V0TG93ZXJCb3VuZChmaWVsZEZpbHRlci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLzpcbiAgICAgICAgICAgIGNhc2UgXCJpblwiIC8qIE9wZXJhdG9yLklOICovOlxuICAgICAgICAgICAgY2FzZSBcIj49XCIgLyogT3BlcmF0b3IuR1JFQVRFUl9USEFOX09SX0VRVUFMICovOlxuICAgICAgICAgICAgICAgIGZpbHRlclZhbHVlID0gZmllbGRGaWx0ZXIudmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiPlwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTiAqLzpcbiAgICAgICAgICAgICAgICBmaWx0ZXJWYWx1ZSA9IGZpZWxkRmlsdGVyLnZhbHVlO1xuICAgICAgICAgICAgICAgIGZpbHRlckluY2x1c2l2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovOlxuICAgICAgICAgICAgY2FzZSBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLzpcbiAgICAgICAgICAgICAgICBmaWx0ZXJWYWx1ZSA9IE1JTl9WQUxVRTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIFJlbWFpbmluZyBmaWx0ZXJzIGNhbm5vdCBiZSB1c2VkIGFzIGxvd2VyIGJvdW5kcy5cbiAgICAgICAgfVxuICAgICAgICBpZiAobG93ZXJCb3VuZENvbXBhcmUoeyB2YWx1ZSwgaW5jbHVzaXZlIH0sIHsgdmFsdWU6IGZpbHRlclZhbHVlLCBpbmNsdXNpdmU6IGZpbHRlckluY2x1c2l2ZSB9KSA8IDApIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmlsdGVyVmFsdWU7XG4gICAgICAgICAgICBpbmNsdXNpdmUgPSBmaWx0ZXJJbmNsdXNpdmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gYWRkaXRpb25hbCBib3VuZCwgY29tcGFyZSB0aGUgdmFsdWVzIGFnYWluc3QgdGhlIGV4aXN0aW5nXG4gICAgLy8gcmFuZ2UgdG8gc2VlIGlmIHdlIGNhbiBuYXJyb3cgdGhlIHNjb3BlLlxuICAgIGlmIChib3VuZCAhPT0gbnVsbCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldC5vcmRlckJ5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBvcmRlckJ5ID0gdGFyZ2V0Lm9yZGVyQnlbaV07XG4gICAgICAgICAgICBpZiAob3JkZXJCeS5maWVsZC5pc0VxdWFsKGZpZWxkUGF0aCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJzb3JWYWx1ZSA9IGJvdW5kLnBvc2l0aW9uW2ldO1xuICAgICAgICAgICAgICAgIGlmIChsb3dlckJvdW5kQ29tcGFyZSh7IHZhbHVlLCBpbmNsdXNpdmUgfSwgeyB2YWx1ZTogY3Vyc29yVmFsdWUsIGluY2x1c2l2ZTogYm91bmQuaW5jbHVzaXZlIH0pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGN1cnNvclZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmUgPSBib3VuZC5pbmNsdXNpdmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHZhbHVlLCBpbmNsdXNpdmUgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgdG8gdXNlIGFzIHRoZSB1cHBlciBib3VuZCBmb3IgYXNjZW5kaW5nIGluZGV4IHNlZ21lbnQgYXRcbiAqIHRoZSBwcm92aWRlZCBgZmllbGRQYXRoYCAob3IgdGhlIGxvd2VyIGJvdW5kIGZvciBhIGRlc2NlbmRpbmcgc2VnbWVudCkuXG4gKi9cbmZ1bmN0aW9uIHRhcmdldEdldERlc2NlbmRpbmdCb3VuZCh0YXJnZXQsIGZpZWxkUGF0aCwgYm91bmQpIHtcbiAgICBsZXQgdmFsdWUgPSBNQVhfVkFMVUU7XG4gICAgbGV0IGluY2x1c2l2ZSA9IHRydWU7XG4gICAgLy8gUHJvY2VzcyBhbGwgZmlsdGVycyB0byBmaW5kIGEgdmFsdWUgZm9yIHRoZSBjdXJyZW50IGZpZWxkIHNlZ21lbnRcbiAgICBmb3IgKGNvbnN0IGZpZWxkRmlsdGVyIG9mIHRhcmdldEdldEZpZWxkRmlsdGVyc0ZvclBhdGgodGFyZ2V0LCBmaWVsZFBhdGgpKSB7XG4gICAgICAgIGxldCBmaWx0ZXJWYWx1ZSA9IE1BWF9WQUxVRTtcbiAgICAgICAgbGV0IGZpbHRlckluY2x1c2l2ZSA9IHRydWU7XG4gICAgICAgIHN3aXRjaCAoZmllbGRGaWx0ZXIub3ApIHtcbiAgICAgICAgICAgIGNhc2UgXCI+PVwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTl9PUl9FUVVBTCAqLzpcbiAgICAgICAgICAgIGNhc2UgXCI+XCIgLyogT3BlcmF0b3IuR1JFQVRFUl9USEFOICovOlxuICAgICAgICAgICAgICAgIGZpbHRlclZhbHVlID0gdmFsdWVzR2V0VXBwZXJCb3VuZChmaWVsZEZpbHRlci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgZmlsdGVySW5jbHVzaXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLzpcbiAgICAgICAgICAgIGNhc2UgXCJpblwiIC8qIE9wZXJhdG9yLklOICovOlxuICAgICAgICAgICAgY2FzZSBcIjw9XCIgLyogT3BlcmF0b3IuTEVTU19USEFOX09SX0VRVUFMICovOlxuICAgICAgICAgICAgICAgIGZpbHRlclZhbHVlID0gZmllbGRGaWx0ZXIudmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiPFwiIC8qIE9wZXJhdG9yLkxFU1NfVEhBTiAqLzpcbiAgICAgICAgICAgICAgICBmaWx0ZXJWYWx1ZSA9IGZpZWxkRmlsdGVyLnZhbHVlO1xuICAgICAgICAgICAgICAgIGZpbHRlckluY2x1c2l2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovOlxuICAgICAgICAgICAgY2FzZSBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLzpcbiAgICAgICAgICAgICAgICBmaWx0ZXJWYWx1ZSA9IE1BWF9WQUxVRTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIFJlbWFpbmluZyBmaWx0ZXJzIGNhbm5vdCBiZSB1c2VkIGFzIHVwcGVyIGJvdW5kcy5cbiAgICAgICAgfVxuICAgICAgICBpZiAodXBwZXJCb3VuZENvbXBhcmUoeyB2YWx1ZSwgaW5jbHVzaXZlIH0sIHsgdmFsdWU6IGZpbHRlclZhbHVlLCBpbmNsdXNpdmU6IGZpbHRlckluY2x1c2l2ZSB9KSA+IDApIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmlsdGVyVmFsdWU7XG4gICAgICAgICAgICBpbmNsdXNpdmUgPSBmaWx0ZXJJbmNsdXNpdmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gYWRkaXRpb25hbCBib3VuZCwgY29tcGFyZSB0aGUgdmFsdWVzIGFnYWluc3QgdGhlIGV4aXN0aW5nXG4gICAgLy8gcmFuZ2UgdG8gc2VlIGlmIHdlIGNhbiBuYXJyb3cgdGhlIHNjb3BlLlxuICAgIGlmIChib3VuZCAhPT0gbnVsbCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldC5vcmRlckJ5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBvcmRlckJ5ID0gdGFyZ2V0Lm9yZGVyQnlbaV07XG4gICAgICAgICAgICBpZiAob3JkZXJCeS5maWVsZC5pc0VxdWFsKGZpZWxkUGF0aCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJzb3JWYWx1ZSA9IGJvdW5kLnBvc2l0aW9uW2ldO1xuICAgICAgICAgICAgICAgIGlmICh1cHBlckJvdW5kQ29tcGFyZSh7IHZhbHVlLCBpbmNsdXNpdmUgfSwgeyB2YWx1ZTogY3Vyc29yVmFsdWUsIGluY2x1c2l2ZTogYm91bmQuaW5jbHVzaXZlIH0pID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGN1cnNvclZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmUgPSBib3VuZC5pbmNsdXNpdmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHZhbHVlLCBpbmNsdXNpdmUgfTtcbn1cbi8qKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygc2VnbWVudHMgb2YgYSBwZXJmZWN0IGluZGV4IGZvciB0aGlzIHRhcmdldC4gKi9cbmZ1bmN0aW9uIHRhcmdldEdldFNlZ21lbnRDb3VudCh0YXJnZXQpIHtcbiAgICBsZXQgZmllbGRzID0gbmV3IFNvcnRlZFNldChGaWVsZFBhdGgkMS5jb21wYXJhdG9yKTtcbiAgICBsZXQgaGFzQXJyYXlTZWdtZW50ID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgdGFyZ2V0LmZpbHRlcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBzdWJGaWx0ZXIgb2YgZmlsdGVyLmdldEZsYXR0ZW5lZEZpbHRlcnMoKSkge1xuICAgICAgICAgICAgLy8gX19uYW1lX18gaXMgbm90IGFuIGV4cGxpY2l0IHNlZ21lbnQgb2YgYW55IGluZGV4LCBzbyB3ZSBkb24ndCBuZWVkIHRvXG4gICAgICAgICAgICAvLyBjb3VudCBpdC5cbiAgICAgICAgICAgIGlmIChzdWJGaWx0ZXIuZmllbGQuaXNLZXlGaWVsZCgpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBUlJBWV9DT05UQUlOUyBvciBBUlJBWV9DT05UQUlOU19BTlkgZmlsdGVycyBtdXN0IGJlIGNvdW50ZWQgc2VwYXJhdGVseS5cbiAgICAgICAgICAgIC8vIEZvciBpbnN0YW5jZSwgaXQgaXMgcG9zc2libGUgdG8gaGF2ZSBhbiBpbmRleCBmb3IgXCJhIEFSUkFZIGEgQVNDXCIuIEV2ZW5cbiAgICAgICAgICAgIC8vIHRob3VnaCB0aGVzZSBhcmUgb24gdGhlIHNhbWUgZmllbGQsIHRoZXkgc2hvdWxkIGJlIGNvdW50ZWQgYXMgdHdvXG4gICAgICAgICAgICAvLyBzZXBhcmF0ZSBzZWdtZW50cyBpbiBhbiBpbmRleC5cbiAgICAgICAgICAgIGlmIChzdWJGaWx0ZXIub3AgPT09IFwiYXJyYXktY29udGFpbnNcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOUyAqLyB8fFxuICAgICAgICAgICAgICAgIHN1YkZpbHRlci5vcCA9PT0gXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi8pIHtcbiAgICAgICAgICAgICAgICBoYXNBcnJheVNlZ21lbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmllbGRzID0gZmllbGRzLmFkZChzdWJGaWx0ZXIuZmllbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qgb3JkZXJCeSBvZiB0YXJnZXQub3JkZXJCeSkge1xuICAgICAgICAvLyBfX25hbWVfXyBpcyBub3QgYW4gZXhwbGljaXQgc2VnbWVudCBvZiBhbnkgaW5kZXgsIHNvIHdlIGRvbid0IG5lZWQgdG9cbiAgICAgICAgLy8gY291bnQgaXQuXG4gICAgICAgIGlmICghb3JkZXJCeS5maWVsZC5pc0tleUZpZWxkKCkpIHtcbiAgICAgICAgICAgIGZpZWxkcyA9IGZpZWxkcy5hZGQob3JkZXJCeS5maWVsZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkcy5zaXplICsgKGhhc0FycmF5U2VnbWVudCA/IDEgOiAwKTtcbn1cbmZ1bmN0aW9uIHRhcmdldEhhc0xpbWl0KHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQubGltaXQgIT09IG51bGw7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFF1ZXJ5IGVuY2Fwc3VsYXRlcyBhbGwgdGhlIHF1ZXJ5IGF0dHJpYnV0ZXMgd2Ugc3VwcG9ydCBpbiB0aGUgU0RLLiBJdCBjYW5cbiAqIGJlIHJ1biBhZ2FpbnN0IHRoZSBMb2NhbFN0b3JlLCBhcyB3ZWxsIGFzIGJlIGNvbnZlcnRlZCB0byBhIGBUYXJnZXRgIHRvXG4gKiBxdWVyeSB0aGUgUmVtb3RlU3RvcmUgcmVzdWx0cy5cbiAqXG4gKiBWaXNpYmxlIGZvciB0ZXN0aW5nLlxuICovXG5jbGFzcyBRdWVyeUltcGwge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgUXVlcnkgd2l0aCBhIHBhdGggYW5kIG9wdGlvbmFsIGFkZGl0aW9uYWwgcXVlcnkgY29uc3RyYWludHMuXG4gICAgICogUGF0aCBtdXN0IGN1cnJlbnRseSBiZSBlbXB0eSBpZiB0aGlzIGlzIGEgY29sbGVjdGlvbiBncm91cCBxdWVyeS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXRoLCBjb2xsZWN0aW9uR3JvdXAgPSBudWxsLCBleHBsaWNpdE9yZGVyQnkgPSBbXSwgZmlsdGVycyA9IFtdLCBsaW1pdCA9IG51bGwsIGxpbWl0VHlwZSA9IFwiRlwiIC8qIExpbWl0VHlwZS5GaXJzdCAqLywgc3RhcnRBdCA9IG51bGwsIGVuZEF0ID0gbnVsbCkge1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25Hcm91cCA9IGNvbGxlY3Rpb25Hcm91cDtcbiAgICAgICAgdGhpcy5leHBsaWNpdE9yZGVyQnkgPSBleHBsaWNpdE9yZGVyQnk7XG4gICAgICAgIHRoaXMuZmlsdGVycyA9IGZpbHRlcnM7XG4gICAgICAgIHRoaXMubGltaXQgPSBsaW1pdDtcbiAgICAgICAgdGhpcy5saW1pdFR5cGUgPSBsaW1pdFR5cGU7XG4gICAgICAgIHRoaXMuc3RhcnRBdCA9IHN0YXJ0QXQ7XG4gICAgICAgIHRoaXMuZW5kQXQgPSBlbmRBdDtcbiAgICAgICAgdGhpcy5tZW1vaXplZE5vcm1hbGl6ZWRPcmRlckJ5ID0gbnVsbDtcbiAgICAgICAgLy8gVGhlIGNvcnJlc3BvbmRpbmcgYFRhcmdldGAgb2YgdGhpcyBgUXVlcnlgIGluc3RhbmNlLCBmb3IgdXNlIHdpdGhcbiAgICAgICAgLy8gbm9uLWFnZ3JlZ2F0ZSBxdWVyaWVzLlxuICAgICAgICB0aGlzLm1lbW9pemVkVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgLy8gVGhlIGNvcnJlc3BvbmRpbmcgYFRhcmdldGAgb2YgdGhpcyBgUXVlcnlgIGluc3RhbmNlLCBmb3IgdXNlIHdpdGhcbiAgICAgICAgLy8gYWdncmVnYXRlIHF1ZXJpZXMuIFVubGlrZSB0YXJnZXRzIGZvciBub24tYWdncmVnYXRlIHF1ZXJpZXMsXG4gICAgICAgIC8vIGFnZ3JlZ2F0ZSBxdWVyeSB0YXJnZXRzIGRvIG5vdCBjb250YWluIG5vcm1hbGl6ZWQgb3JkZXItYnlzLCB0aGV5IG9ubHlcbiAgICAgICAgLy8gY29udGFpbiBleHBsaWNpdCBvcmRlci1ieXMuXG4gICAgICAgIHRoaXMubWVtb2l6ZWRBZ2dyZWdhdGVUYXJnZXQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5zdGFydEF0KSA7XG4gICAgICAgIGlmICh0aGlzLmVuZEF0KSA7XG4gICAgfVxufVxuLyoqIENyZWF0ZXMgYSBuZXcgUXVlcnkgaW5zdGFuY2Ugd2l0aCB0aGUgb3B0aW9ucyBwcm92aWRlZC4gKi9cbmZ1bmN0aW9uIG5ld1F1ZXJ5KHBhdGgsIGNvbGxlY3Rpb25Hcm91cCwgZXhwbGljaXRPcmRlckJ5LCBmaWx0ZXJzLCBsaW1pdCwgbGltaXRUeXBlLCBzdGFydEF0LCBlbmRBdCkge1xuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHBhdGgsIGNvbGxlY3Rpb25Hcm91cCwgZXhwbGljaXRPcmRlckJ5LCBmaWx0ZXJzLCBsaW1pdCwgbGltaXRUeXBlLCBzdGFydEF0LCBlbmRBdCk7XG59XG4vKiogQ3JlYXRlcyBhIG5ldyBRdWVyeSBmb3IgYSBxdWVyeSB0aGF0IG1hdGNoZXMgYWxsIGRvY3VtZW50cyBhdCBgcGF0aGAgKi9cbmZ1bmN0aW9uIG5ld1F1ZXJ5Rm9yUGF0aChwYXRoKSB7XG4gICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocGF0aCk7XG59XG4vKipcbiAqIEhlbHBlciB0byBjb252ZXJ0IGEgY29sbGVjdGlvbiBncm91cCBxdWVyeSBpbnRvIGEgY29sbGVjdGlvbiBxdWVyeSBhdCBhXG4gKiBzcGVjaWZpYyBwYXRoLiBUaGlzIGlzIHVzZWQgd2hlbiBleGVjdXRpbmcgY29sbGVjdGlvbiBncm91cCBxdWVyaWVzLCBzaW5jZVxuICogd2UgaGF2ZSB0byBzcGxpdCB0aGUgcXVlcnkgaW50byBhIHNldCBvZiBjb2xsZWN0aW9uIHF1ZXJpZXMgYXQgbXVsdGlwbGVcbiAqIHBhdGhzLlxuICovXG5mdW5jdGlvbiBhc0NvbGxlY3Rpb25RdWVyeUF0UGF0aChxdWVyeSwgcGF0aCkge1xuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHBhdGgsIFxuICAgIC8qY29sbGVjdGlvbkdyb3VwPSovIG51bGwsIHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeS5zbGljZSgpLCBxdWVyeS5maWx0ZXJzLnNsaWNlKCksIHF1ZXJ5LmxpbWl0LCBxdWVyeS5saW1pdFR5cGUsIHF1ZXJ5LnN0YXJ0QXQsIHF1ZXJ5LmVuZEF0KTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcXVlcnkgZG9lcyBub3Qgc3BlY2lmeSBhbnkgcXVlcnkgY29uc3RyYWludHMgdGhhdFxuICogY291bGQgcmVtb3ZlIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5TWF0Y2hlc0FsbERvY3VtZW50cyhxdWVyeSkge1xuICAgIHJldHVybiAocXVlcnkuZmlsdGVycy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgcXVlcnkubGltaXQgPT09IG51bGwgJiZcbiAgICAgICAgcXVlcnkuc3RhcnRBdCA9PSBudWxsICYmXG4gICAgICAgIHF1ZXJ5LmVuZEF0ID09IG51bGwgJiZcbiAgICAgICAgKHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeS5sZW5ndGggPT09IDAgfHxcbiAgICAgICAgICAgIChxdWVyeS5leHBsaWNpdE9yZGVyQnkubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgICAgcXVlcnkuZXhwbGljaXRPcmRlckJ5WzBdLmZpZWxkLmlzS2V5RmllbGQoKSkpKTtcbn1cbi8vIFJldHVybnMgdGhlIHNvcnRlZCBzZXQgb2YgaW5lcXVhbGl0eSBmaWx0ZXIgZmllbGRzIHVzZWQgaW4gdGhpcyBxdWVyeS5cbmZ1bmN0aW9uIGdldEluZXF1YWxpdHlGaWx0ZXJGaWVsZHMocXVlcnkpIHtcbiAgICBsZXQgcmVzdWx0ID0gbmV3IFNvcnRlZFNldChGaWVsZFBhdGgkMS5jb21wYXJhdG9yKTtcbiAgICBxdWVyeS5maWx0ZXJzLmZvckVhY2goKGZpbHRlcikgPT4ge1xuICAgICAgICBjb25zdCBzdWJGaWx0ZXJzID0gZmlsdGVyLmdldEZsYXR0ZW5lZEZpbHRlcnMoKTtcbiAgICAgICAgc3ViRmlsdGVycy5mb3JFYWNoKChmaWx0ZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChmaWx0ZXIuaXNJbmVxdWFsaXR5KCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGZpbHRlci5maWVsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgUXVlcnkgZm9yIGEgY29sbGVjdGlvbiBncm91cCBxdWVyeSB0aGF0IG1hdGNoZXMgYWxsIGRvY3VtZW50c1xuICogd2l0aGluIHRoZSBwcm92aWRlZCBjb2xsZWN0aW9uIGdyb3VwLlxuICovXG5mdW5jdGlvbiBuZXdRdWVyeUZvckNvbGxlY3Rpb25Hcm91cChjb2xsZWN0aW9uSWQpIHtcbiAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChSZXNvdXJjZVBhdGguZW1wdHlQYXRoKCksIGNvbGxlY3Rpb25JZCk7XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgcXVlcnkgbWF0Y2hlcyBhIHNpbmdsZSBkb2N1bWVudCBieSBwYXRoIChyYXRoZXIgdGhhbiBhXG4gKiBjb2xsZWN0aW9uKS5cbiAqL1xuZnVuY3Rpb24gaXNEb2N1bWVudFF1ZXJ5JDEocXVlcnkpIHtcbiAgICByZXR1cm4gKERvY3VtZW50S2V5LmlzRG9jdW1lbnRLZXkocXVlcnkucGF0aCkgJiZcbiAgICAgICAgcXVlcnkuY29sbGVjdGlvbkdyb3VwID09PSBudWxsICYmXG4gICAgICAgIHF1ZXJ5LmZpbHRlcnMubGVuZ3RoID09PSAwKTtcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBxdWVyeSBtYXRjaGVzIGEgY29sbGVjdGlvbiBncm91cCByYXRoZXIgdGhhbiBhIHNwZWNpZmljXG4gKiBjb2xsZWN0aW9uLlxuICovXG5mdW5jdGlvbiBpc0NvbGxlY3Rpb25Hcm91cFF1ZXJ5KHF1ZXJ5KSB7XG4gICAgcmV0dXJuIHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cCAhPT0gbnVsbDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbm9ybWFsaXplZCBvcmRlci1ieSBjb25zdHJhaW50IHRoYXQgaXMgdXNlZCB0byBleGVjdXRlIHRoZSBRdWVyeSxcbiAqIHdoaWNoIGNhbiBiZSBkaWZmZXJlbnQgZnJvbSB0aGUgb3JkZXItYnkgY29uc3RyYWludHMgdGhlIHVzZXIgcHJvdmlkZWQgKGUuZy5cbiAqIHRoZSBTREsgYW5kIGJhY2tlbmQgYWx3YXlzIG9yZGVycyBieSBgX19uYW1lX19gKS4gVGhlIG5vcm1hbGl6ZWQgb3JkZXItYnlcbiAqIGluY2x1ZGVzIGltcGxpY2l0IG9yZGVyLWJ5cyBpbiBhZGRpdGlvbiB0byB0aGUgZXhwbGljaXQgdXNlciBwcm92aWRlZFxuICogb3JkZXItYnlzLlxuICovXG5mdW5jdGlvbiBxdWVyeU5vcm1hbGl6ZWRPcmRlckJ5KHF1ZXJ5KSB7XG4gICAgY29uc3QgcXVlcnlJbXBsID0gZGVidWdDYXN0KHF1ZXJ5KTtcbiAgICBpZiAocXVlcnlJbXBsLm1lbW9pemVkTm9ybWFsaXplZE9yZGVyQnkgPT09IG51bGwpIHtcbiAgICAgICAgcXVlcnlJbXBsLm1lbW9pemVkTm9ybWFsaXplZE9yZGVyQnkgPSBbXTtcbiAgICAgICAgY29uc3QgZmllbGRzTm9ybWFsaXplZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgLy8gQW55IGV4cGxpY2l0IG9yZGVyIGJ5IGZpZWxkcyBzaG91bGQgYmUgYWRkZWQgYXMgaXMuXG4gICAgICAgIGZvciAoY29uc3Qgb3JkZXJCeSBvZiBxdWVyeUltcGwuZXhwbGljaXRPcmRlckJ5KSB7XG4gICAgICAgICAgICBxdWVyeUltcGwubWVtb2l6ZWROb3JtYWxpemVkT3JkZXJCeS5wdXNoKG9yZGVyQnkpO1xuICAgICAgICAgICAgZmllbGRzTm9ybWFsaXplZC5hZGQob3JkZXJCeS5maWVsZC5jYW5vbmljYWxTdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIG9yZGVyIG9mIHRoZSBpbXBsaWNpdCBvcmRlcmluZyBhbHdheXMgbWF0Y2hlcyB0aGUgbGFzdCBleHBsaWNpdCBvcmRlciBieS5cbiAgICAgICAgY29uc3QgbGFzdERpcmVjdGlvbiA9IHF1ZXJ5SW1wbC5leHBsaWNpdE9yZGVyQnkubGVuZ3RoID4gMFxuICAgICAgICAgICAgPyBxdWVyeUltcGwuZXhwbGljaXRPcmRlckJ5W3F1ZXJ5SW1wbC5leHBsaWNpdE9yZGVyQnkubGVuZ3RoIC0gMV0uZGlyXG4gICAgICAgICAgICA6IFwiYXNjXCIgLyogRGlyZWN0aW9uLkFTQ0VORElORyAqLztcbiAgICAgICAgLy8gQW55IGluZXF1YWxpdHkgZmllbGRzIG5vdCBleHBsaWNpdGx5IG9yZGVyZWQgc2hvdWxkIGJlIGltcGxpY2l0bHkgb3JkZXJlZCBpbiBhIGxleGljb2dyYXBoaWNhbFxuICAgICAgICAvLyBvcmRlci4gV2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgaW5lcXVhbGl0eSBmaWx0ZXJzIG9uIHRoZSBzYW1lIGZpZWxkLCB0aGUgZmllbGQgc2hvdWxkIGJlIGFkZGVkXG4gICAgICAgIC8vIG9ubHkgb25jZS5cbiAgICAgICAgLy8gTm90ZTogYFNvcnRlZFNldDxGaWVsZFBhdGg+YCBzb3J0cyB0aGUga2V5IGZpZWxkIGJlZm9yZSBvdGhlciBmaWVsZHMuIEhvd2V2ZXIsIHdlIHdhbnQgdGhlIGtleVxuICAgICAgICAvLyBmaWVsZCB0byBiZSBzb3J0ZWQgbGFzdC5cbiAgICAgICAgY29uc3QgaW5lcXVhbGl0eUZpZWxkcyA9IGdldEluZXF1YWxpdHlGaWx0ZXJGaWVsZHMocXVlcnlJbXBsKTtcbiAgICAgICAgaW5lcXVhbGl0eUZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgICAgICAgIGlmICghZmllbGRzTm9ybWFsaXplZC5oYXMoZmllbGQuY2Fub25pY2FsU3RyaW5nKCkpICYmXG4gICAgICAgICAgICAgICAgIWZpZWxkLmlzS2V5RmllbGQoKSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5SW1wbC5tZW1vaXplZE5vcm1hbGl6ZWRPcmRlckJ5LnB1c2gobmV3IE9yZGVyQnkoZmllbGQsIGxhc3REaXJlY3Rpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFkZCB0aGUgZG9jdW1lbnQga2V5IGZpZWxkIHRvIHRoZSBsYXN0IGlmIGl0IGlzIG5vdCBleHBsaWNpdGx5IG9yZGVyZWQuXG4gICAgICAgIGlmICghZmllbGRzTm9ybWFsaXplZC5oYXMoRmllbGRQYXRoJDEua2V5RmllbGQoKS5jYW5vbmljYWxTdHJpbmcoKSkpIHtcbiAgICAgICAgICAgIHF1ZXJ5SW1wbC5tZW1vaXplZE5vcm1hbGl6ZWRPcmRlckJ5LnB1c2gobmV3IE9yZGVyQnkoRmllbGRQYXRoJDEua2V5RmllbGQoKSwgbGFzdERpcmVjdGlvbikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBxdWVyeUltcGwubWVtb2l6ZWROb3JtYWxpemVkT3JkZXJCeTtcbn1cbi8qKlxuICogQ29udmVydHMgdGhpcyBgUXVlcnlgIGluc3RhbmNlIHRvIGl0cyBjb3JyZXNwb25kaW5nIGBUYXJnZXRgIHJlcHJlc2VudGF0aW9uLlxuICovXG5mdW5jdGlvbiBxdWVyeVRvVGFyZ2V0KHF1ZXJ5KSB7XG4gICAgY29uc3QgcXVlcnlJbXBsID0gZGVidWdDYXN0KHF1ZXJ5KTtcbiAgICBpZiAoIXF1ZXJ5SW1wbC5tZW1vaXplZFRhcmdldCkge1xuICAgICAgICBxdWVyeUltcGwubWVtb2l6ZWRUYXJnZXQgPSBfcXVlcnlUb1RhcmdldChxdWVyeUltcGwsIHF1ZXJ5Tm9ybWFsaXplZE9yZGVyQnkocXVlcnkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5SW1wbC5tZW1vaXplZFRhcmdldDtcbn1cbi8qKlxuICogQ29udmVydHMgdGhpcyBgUXVlcnlgIGluc3RhbmNlIHRvIGl0cyBjb3JyZXNwb25kaW5nIGBUYXJnZXRgIHJlcHJlc2VudGF0aW9uLFxuICogZm9yIHVzZSB3aXRoaW4gYW4gYWdncmVnYXRlIHF1ZXJ5LiBVbmxpa2UgdGFyZ2V0cyBmb3Igbm9uLWFnZ3JlZ2F0ZSBxdWVyaWVzLFxuICogYWdncmVnYXRlIHF1ZXJ5IHRhcmdldHMgZG8gbm90IGNvbnRhaW4gbm9ybWFsaXplZCBvcmRlci1ieXMsIHRoZXkgb25seVxuICogY29udGFpbiBleHBsaWNpdCBvcmRlci1ieXMuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5VG9BZ2dyZWdhdGVUYXJnZXQocXVlcnkpIHtcbiAgICBjb25zdCBxdWVyeUltcGwgPSBkZWJ1Z0Nhc3QocXVlcnkpO1xuICAgIGlmICghcXVlcnlJbXBsLm1lbW9pemVkQWdncmVnYXRlVGFyZ2V0KSB7XG4gICAgICAgIC8vIERvIG5vdCBpbmNsdWRlIGltcGxpY2l0IG9yZGVyLWJ5cyBmb3IgYWdncmVnYXRlIHF1ZXJpZXMuXG4gICAgICAgIHF1ZXJ5SW1wbC5tZW1vaXplZEFnZ3JlZ2F0ZVRhcmdldCA9IF9xdWVyeVRvVGFyZ2V0KHF1ZXJ5SW1wbCwgcXVlcnkuZXhwbGljaXRPcmRlckJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5SW1wbC5tZW1vaXplZEFnZ3JlZ2F0ZVRhcmdldDtcbn1cbmZ1bmN0aW9uIF9xdWVyeVRvVGFyZ2V0KHF1ZXJ5SW1wbCwgb3JkZXJCeXMpIHtcbiAgICBpZiAocXVlcnlJbXBsLmxpbWl0VHlwZSA9PT0gXCJGXCIgLyogTGltaXRUeXBlLkZpcnN0ICovKSB7XG4gICAgICAgIHJldHVybiBuZXdUYXJnZXQocXVlcnlJbXBsLnBhdGgsIHF1ZXJ5SW1wbC5jb2xsZWN0aW9uR3JvdXAsIG9yZGVyQnlzLCBxdWVyeUltcGwuZmlsdGVycywgcXVlcnlJbXBsLmxpbWl0LCBxdWVyeUltcGwuc3RhcnRBdCwgcXVlcnlJbXBsLmVuZEF0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEZsaXAgdGhlIG9yZGVyQnkgZGlyZWN0aW9ucyBzaW5jZSB3ZSB3YW50IHRoZSBsYXN0IHJlc3VsdHNcbiAgICAgICAgb3JkZXJCeXMgPSBvcmRlckJ5cy5tYXAob3JkZXJCeSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkaXIgPSBvcmRlckJ5LmRpciA9PT0gXCJkZXNjXCIgLyogRGlyZWN0aW9uLkRFU0NFTkRJTkcgKi9cbiAgICAgICAgICAgICAgICA/IFwiYXNjXCIgLyogRGlyZWN0aW9uLkFTQ0VORElORyAqL1xuICAgICAgICAgICAgICAgIDogXCJkZXNjXCIgLyogRGlyZWN0aW9uLkRFU0NFTkRJTkcgKi87XG4gICAgICAgICAgICByZXR1cm4gbmV3IE9yZGVyQnkob3JkZXJCeS5maWVsZCwgZGlyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gc3dhcCB0aGUgY3Vyc29ycyB0byBtYXRjaCB0aGUgbm93LWZsaXBwZWQgcXVlcnkgb3JkZXJpbmcuXG4gICAgICAgIGNvbnN0IHN0YXJ0QXQgPSBxdWVyeUltcGwuZW5kQXRcbiAgICAgICAgICAgID8gbmV3IEJvdW5kKHF1ZXJ5SW1wbC5lbmRBdC5wb3NpdGlvbiwgcXVlcnlJbXBsLmVuZEF0LmluY2x1c2l2ZSlcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgY29uc3QgZW5kQXQgPSBxdWVyeUltcGwuc3RhcnRBdFxuICAgICAgICAgICAgPyBuZXcgQm91bmQocXVlcnlJbXBsLnN0YXJ0QXQucG9zaXRpb24sIHF1ZXJ5SW1wbC5zdGFydEF0LmluY2x1c2l2ZSlcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgLy8gTm93IHJldHVybiBhcyBhIExpbWl0VHlwZS5GaXJzdCBxdWVyeS5cbiAgICAgICAgcmV0dXJuIG5ld1RhcmdldChxdWVyeUltcGwucGF0aCwgcXVlcnlJbXBsLmNvbGxlY3Rpb25Hcm91cCwgb3JkZXJCeXMsIHF1ZXJ5SW1wbC5maWx0ZXJzLCBxdWVyeUltcGwubGltaXQsIHN0YXJ0QXQsIGVuZEF0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBxdWVyeVdpdGhBZGRlZEZpbHRlcihxdWVyeSwgZmlsdGVyKSB7XG4gICAgY29uc3QgbmV3RmlsdGVycyA9IHF1ZXJ5LmZpbHRlcnMuY29uY2F0KFtmaWx0ZXJdKTtcbiAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5wYXRoLCBxdWVyeS5jb2xsZWN0aW9uR3JvdXAsIHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeS5zbGljZSgpLCBuZXdGaWx0ZXJzLCBxdWVyeS5saW1pdCwgcXVlcnkubGltaXRUeXBlLCBxdWVyeS5zdGFydEF0LCBxdWVyeS5lbmRBdCk7XG59XG5mdW5jdGlvbiBxdWVyeVdpdGhBZGRlZE9yZGVyQnkocXVlcnksIG9yZGVyQnkpIHtcbiAgICAvLyBUT0RPKGRpbW9uZCk6IHZhbGlkYXRlIHRoYXQgb3JkZXJCeSBkb2VzIG5vdCBsaXN0IHRoZSBzYW1lIGtleSB0d2ljZS5cbiAgICBjb25zdCBuZXdPcmRlckJ5ID0gcXVlcnkuZXhwbGljaXRPcmRlckJ5LmNvbmNhdChbb3JkZXJCeV0pO1xuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5LnBhdGgsIHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cCwgbmV3T3JkZXJCeSwgcXVlcnkuZmlsdGVycy5zbGljZSgpLCBxdWVyeS5saW1pdCwgcXVlcnkubGltaXRUeXBlLCBxdWVyeS5zdGFydEF0LCBxdWVyeS5lbmRBdCk7XG59XG5mdW5jdGlvbiBxdWVyeVdpdGhMaW1pdChxdWVyeSwgbGltaXQsIGxpbWl0VHlwZSkge1xuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5LnBhdGgsIHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cCwgcXVlcnkuZXhwbGljaXRPcmRlckJ5LnNsaWNlKCksIHF1ZXJ5LmZpbHRlcnMuc2xpY2UoKSwgbGltaXQsIGxpbWl0VHlwZSwgcXVlcnkuc3RhcnRBdCwgcXVlcnkuZW5kQXQpO1xufVxuZnVuY3Rpb24gcXVlcnlXaXRoU3RhcnRBdChxdWVyeSwgYm91bmQpIHtcbiAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5wYXRoLCBxdWVyeS5jb2xsZWN0aW9uR3JvdXAsIHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeS5zbGljZSgpLCBxdWVyeS5maWx0ZXJzLnNsaWNlKCksIHF1ZXJ5LmxpbWl0LCBxdWVyeS5saW1pdFR5cGUsIGJvdW5kLCBxdWVyeS5lbmRBdCk7XG59XG5mdW5jdGlvbiBxdWVyeVdpdGhFbmRBdChxdWVyeSwgYm91bmQpIHtcbiAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5wYXRoLCBxdWVyeS5jb2xsZWN0aW9uR3JvdXAsIHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeS5zbGljZSgpLCBxdWVyeS5maWx0ZXJzLnNsaWNlKCksIHF1ZXJ5LmxpbWl0LCBxdWVyeS5saW1pdFR5cGUsIHF1ZXJ5LnN0YXJ0QXQsIGJvdW5kKTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5RXF1YWxzKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuICh0YXJnZXRFcXVhbHMocXVlcnlUb1RhcmdldChsZWZ0KSwgcXVlcnlUb1RhcmdldChyaWdodCkpICYmXG4gICAgICAgIGxlZnQubGltaXRUeXBlID09PSByaWdodC5saW1pdFR5cGUpO1xufVxuLy8gVE9ETyhiLzI5MTgzMTY1KTogVGhpcyBpcyB1c2VkIHRvIGdldCBhIHVuaXF1ZSBzdHJpbmcgZnJvbSBhIHF1ZXJ5IHRvLCBmb3Jcbi8vIGV4YW1wbGUsIHVzZSBhcyBhIGRpY3Rpb25hcnkga2V5LCBidXQgdGhlIGltcGxlbWVudGF0aW9uIGlzIHN1YmplY3QgdG9cbi8vIGNvbGxpc2lvbnMuIE1ha2UgaXQgY29sbGlzaW9uLWZyZWUuXG5mdW5jdGlvbiBjYW5vbmlmeVF1ZXJ5KHF1ZXJ5KSB7XG4gICAgcmV0dXJuIGAke2Nhbm9uaWZ5VGFyZ2V0KHF1ZXJ5VG9UYXJnZXQocXVlcnkpKX18bHQ6JHtxdWVyeS5saW1pdFR5cGV9YDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KSB7XG4gICAgcmV0dXJuIGBRdWVyeSh0YXJnZXQ9JHtzdHJpbmdpZnlUYXJnZXQocXVlcnlUb1RhcmdldChxdWVyeSkpfTsgbGltaXRUeXBlPSR7cXVlcnkubGltaXRUeXBlfSlgO1xufVxuLyoqIFJldHVybnMgd2hldGhlciBgZG9jYCBtYXRjaGVzIHRoZSBjb25zdHJhaW50cyBvZiBgcXVlcnlgLiAqL1xuZnVuY3Rpb24gcXVlcnlNYXRjaGVzKHF1ZXJ5LCBkb2MpIHtcbiAgICByZXR1cm4gKGRvYy5pc0ZvdW5kRG9jdW1lbnQoKSAmJlxuICAgICAgICBxdWVyeU1hdGNoZXNQYXRoQW5kQ29sbGVjdGlvbkdyb3VwKHF1ZXJ5LCBkb2MpICYmXG4gICAgICAgIHF1ZXJ5TWF0Y2hlc09yZGVyQnkocXVlcnksIGRvYykgJiZcbiAgICAgICAgcXVlcnlNYXRjaGVzRmlsdGVycyhxdWVyeSwgZG9jKSAmJlxuICAgICAgICBxdWVyeU1hdGNoZXNCb3VuZHMocXVlcnksIGRvYykpO1xufVxuZnVuY3Rpb24gcXVlcnlNYXRjaGVzUGF0aEFuZENvbGxlY3Rpb25Hcm91cChxdWVyeSwgZG9jKSB7XG4gICAgY29uc3QgZG9jUGF0aCA9IGRvYy5rZXkucGF0aDtcbiAgICBpZiAocXVlcnkuY29sbGVjdGlvbkdyb3VwICE9PSBudWxsKSB7XG4gICAgICAgIC8vIE5PVEU6IHRoaXMucGF0aCBpcyBjdXJyZW50bHkgYWx3YXlzIGVtcHR5IHNpbmNlIHdlIGRvbid0IGV4cG9zZSBDb2xsZWN0aW9uXG4gICAgICAgIC8vIEdyb3VwIHF1ZXJpZXMgcm9vdGVkIGF0IGEgZG9jdW1lbnQgcGF0aCB5ZXQuXG4gICAgICAgIHJldHVybiAoZG9jLmtleS5oYXNDb2xsZWN0aW9uSWQocXVlcnkuY29sbGVjdGlvbkdyb3VwKSAmJlxuICAgICAgICAgICAgcXVlcnkucGF0aC5pc1ByZWZpeE9mKGRvY1BhdGgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoRG9jdW1lbnRLZXkuaXNEb2N1bWVudEtleShxdWVyeS5wYXRoKSkge1xuICAgICAgICAvLyBleGFjdCBtYXRjaCBmb3IgZG9jdW1lbnQgcXVlcmllc1xuICAgICAgICByZXR1cm4gcXVlcnkucGF0aC5pc0VxdWFsKGRvY1BhdGgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gc2hhbGxvdyBhbmNlc3RvciBxdWVyaWVzIGJ5IGRlZmF1bHRcbiAgICAgICAgcmV0dXJuIHF1ZXJ5LnBhdGguaXNJbW1lZGlhdGVQYXJlbnRPZihkb2NQYXRoKTtcbiAgICB9XG59XG4vKipcbiAqIEEgZG9jdW1lbnQgbXVzdCBoYXZlIGEgdmFsdWUgZm9yIGV2ZXJ5IG9yZGVyaW5nIGNsYXVzZSBpbiBvcmRlciB0byBzaG93IHVwXG4gKiBpbiB0aGUgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gcXVlcnlNYXRjaGVzT3JkZXJCeShxdWVyeSwgZG9jKSB7XG4gICAgLy8gV2UgbXVzdCB1c2UgYHF1ZXJ5Tm9ybWFsaXplZE9yZGVyQnkoKWAgdG8gZ2V0IHRoZSBsaXN0IG9mIGFsbCBvcmRlckJ5cyAoYm90aCBpbXBsaWNpdCBhbmQgZXhwbGljaXQpLlxuICAgIC8vIE5vdGUgdGhhdCBmb3IgT1IgcXVlcmllcywgb3JkZXJCeSBhcHBsaWVzIHRvIGFsbCBkaXNqdW5jdGlvbiB0ZXJtcyBhbmQgaW1wbGljaXQgb3JkZXJCeXMgbXVzdFxuICAgIC8vIGJlIHRha2VuIGludG8gYWNjb3VudC4gRm9yIGV4YW1wbGUsIHRoZSBxdWVyeSBcImEgPiAxIHx8IGI9PTFcIiBoYXMgYW4gaW1wbGljaXQgXCJvcmRlckJ5IGFcIiBkdWVcbiAgICAvLyB0byB0aGUgaW5lcXVhbGl0eSwgYW5kIGlzIGV2YWx1YXRlZCBhcyBcImEgPiAxIG9yZGVyQnkgYSB8fCBiPT0xIG9yZGVyQnkgYVwiLlxuICAgIC8vIEEgZG9jdW1lbnQgd2l0aCBjb250ZW50IG9mIHtiOjF9IG1hdGNoZXMgdGhlIGZpbHRlcnMsIGJ1dCBkb2VzIG5vdCBtYXRjaCB0aGUgb3JkZXJCeSBiZWNhdXNlXG4gICAgLy8gaXQncyBtaXNzaW5nIHRoZSBmaWVsZCAnYScuXG4gICAgZm9yIChjb25zdCBvcmRlckJ5IG9mIHF1ZXJ5Tm9ybWFsaXplZE9yZGVyQnkocXVlcnkpKSB7XG4gICAgICAgIC8vIG9yZGVyLWJ5IGtleSBhbHdheXMgbWF0Y2hlc1xuICAgICAgICBpZiAoIW9yZGVyQnkuZmllbGQuaXNLZXlGaWVsZCgpICYmIGRvYy5kYXRhLmZpZWxkKG9yZGVyQnkuZmllbGQpID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBxdWVyeU1hdGNoZXNGaWx0ZXJzKHF1ZXJ5LCBkb2MpIHtcbiAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBxdWVyeS5maWx0ZXJzKSB7XG4gICAgICAgIGlmICghZmlsdGVyLm1hdGNoZXMoZG9jKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqIE1ha2VzIHN1cmUgYSBkb2N1bWVudCBpcyB3aXRoaW4gdGhlIGJvdW5kcywgaWYgcHJvdmlkZWQuICovXG5mdW5jdGlvbiBxdWVyeU1hdGNoZXNCb3VuZHMocXVlcnksIGRvYykge1xuICAgIGlmIChxdWVyeS5zdGFydEF0ICYmXG4gICAgICAgICFib3VuZFNvcnRzQmVmb3JlRG9jdW1lbnQocXVlcnkuc3RhcnRBdCwgcXVlcnlOb3JtYWxpemVkT3JkZXJCeShxdWVyeSksIGRvYykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocXVlcnkuZW5kQXQgJiZcbiAgICAgICAgIWJvdW5kU29ydHNBZnRlckRvY3VtZW50KHF1ZXJ5LmVuZEF0LCBxdWVyeU5vcm1hbGl6ZWRPcmRlckJ5KHF1ZXJ5KSwgZG9jKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb2xsZWN0aW9uIGdyb3VwIHRoYXQgdGhpcyBxdWVyeSB0YXJnZXRzLlxuICpcbiAqIFBPUlRJTkcgTk9URTogVGhpcyBpcyBvbmx5IHVzZWQgaW4gdGhlIFdlYiBTREsgdG8gZmFjaWxpdGF0ZSBtdWx0aS10YWJcbiAqIHN5bmNocm9uaXphdGlvbiBmb3IgcXVlcnkgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gcXVlcnlDb2xsZWN0aW9uR3JvdXAocXVlcnkpIHtcbiAgICByZXR1cm4gKHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cCB8fFxuICAgICAgICAocXVlcnkucGF0aC5sZW5ndGggJSAyID09PSAxXG4gICAgICAgICAgICA/IHF1ZXJ5LnBhdGgubGFzdFNlZ21lbnQoKVxuICAgICAgICAgICAgOiBxdWVyeS5wYXRoLmdldChxdWVyeS5wYXRoLmxlbmd0aCAtIDIpKSk7XG59XG4vKipcbiAqIFJldHVybnMgYSBuZXcgY29tcGFyYXRvciBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbXBhcmUgdHdvIGRvY3VtZW50c1xuICogYmFzZWQgb24gdGhlIFF1ZXJ5J3Mgb3JkZXJpbmcgY29uc3RyYWludC5cbiAqL1xuZnVuY3Rpb24gbmV3UXVlcnlDb21wYXJhdG9yKHF1ZXJ5KSB7XG4gICAgcmV0dXJuIChkMSwgZDIpID0+IHtcbiAgICAgICAgbGV0IGNvbXBhcmVkT25LZXlGaWVsZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IG9yZGVyQnkgb2YgcXVlcnlOb3JtYWxpemVkT3JkZXJCeShxdWVyeSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXAgPSBjb21wYXJlRG9jcyhvcmRlckJ5LCBkMSwgZDIpO1xuICAgICAgICAgICAgaWYgKGNvbXAgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBhcmVkT25LZXlGaWVsZCA9IGNvbXBhcmVkT25LZXlGaWVsZCB8fCBvcmRlckJ5LmZpZWxkLmlzS2V5RmllbGQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcGFyZURvY3Mob3JkZXJCeSwgZDEsIGQyKSB7XG4gICAgY29uc3QgY29tcGFyaXNvbiA9IG9yZGVyQnkuZmllbGQuaXNLZXlGaWVsZCgpXG4gICAgICAgID8gRG9jdW1lbnRLZXkuY29tcGFyYXRvcihkMS5rZXksIGQyLmtleSlcbiAgICAgICAgOiBjb21wYXJlRG9jdW1lbnRzQnlGaWVsZChvcmRlckJ5LmZpZWxkLCBkMSwgZDIpO1xuICAgIHN3aXRjaCAob3JkZXJCeS5kaXIpIHtcbiAgICAgICAgY2FzZSBcImFzY1wiIC8qIERpcmVjdGlvbi5BU0NFTkRJTkcgKi86XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbjtcbiAgICAgICAgY2FzZSBcImRlc2NcIiAvKiBEaXJlY3Rpb24uREVTQ0VORElORyAqLzpcbiAgICAgICAgICAgIHJldHVybiAtMSAqIGNvbXBhcmlzb247XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSBtYXAgaW1wbGVtZW50YXRpb24gdGhhdCB1c2VzIG9iamVjdHMgYXMga2V5cy4gT2JqZWN0cyBtdXN0IGhhdmUgYW5cbiAqIGFzc29jaWF0ZWQgZXF1YWxzIGZ1bmN0aW9uIGFuZCBtdXN0IGJlIGltbXV0YWJsZS4gRW50cmllcyBpbiB0aGUgbWFwIGFyZVxuICogc3RvcmVkIHRvZ2V0aGVyIHdpdGggdGhlIGtleSBiZWluZyBwcm9kdWNlZCBmcm9tIHRoZSBtYXBLZXlGbi4gVGhpcyBtYXBcbiAqIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyBjb2xsaXNpb25zIG9mIGtleXMuXG4gKi9cbmNsYXNzIE9iamVjdE1hcCB7XG4gICAgY29uc3RydWN0b3IobWFwS2V5Rm4sIGVxdWFsc0ZuKSB7XG4gICAgICAgIHRoaXMubWFwS2V5Rm4gPSBtYXBLZXlGbjtcbiAgICAgICAgdGhpcy5lcXVhbHNGbiA9IGVxdWFsc0ZuO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGlubmVyIG1hcCBmb3IgYSBrZXkvdmFsdWUgcGFpci4gRHVlIHRvIHRoZSBwb3NzaWJpbGl0eSBvZiBjb2xsaXNpb25zIHdlXG4gICAgICAgICAqIGtlZXAgYSBsaXN0IG9mIGVudHJpZXMgdGhhdCB3ZSBkbyBhIGxpbmVhciBzZWFyY2ggdGhyb3VnaCB0byBmaW5kIGFuIGFjdHVhbFxuICAgICAgICAgKiBtYXRjaC4gTm90ZSB0aGF0IGNvbGxpc2lvbnMgc2hvdWxkIGJlIHJhcmUsIHNvIHdlIHN0aWxsIGV4cGVjdCBuZWFyXG4gICAgICAgICAqIGNvbnN0YW50IHRpbWUgbG9va3VwcyBpbiBwcmFjdGljZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5uZXIgPSB7fTtcbiAgICAgICAgLyoqIFRoZSBudW1iZXIgb2YgZW50cmllcyBzdG9yZWQgaW4gdGhlIG1hcCAqL1xuICAgICAgICB0aGlzLmlubmVyU2l6ZSA9IDA7XG4gICAgfVxuICAgIC8qKiBHZXQgYSB2YWx1ZSBmb3IgdGhpcyBrZXksIG9yIHVuZGVmaW5lZCBpZiBpdCBkb2VzIG5vdCBleGlzdC4gKi9cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5tYXBLZXlGbihrZXkpO1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gdGhpcy5pbm5lcltpZF07XG4gICAgICAgIGlmIChtYXRjaGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbb3RoZXJLZXksIHZhbHVlXSBvZiBtYXRjaGVzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lcXVhbHNGbihvdGhlcktleSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChrZXkpICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKiBQdXQgdGhpcyBrZXkgYW5kIHZhbHVlIGluIHRoZSBtYXAuICovXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLm1hcEtleUZuKGtleSk7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLmlubmVyW2lkXTtcbiAgICAgICAgaWYgKG1hdGNoZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5pbm5lcltpZF0gPSBbW2tleSwgdmFsdWVdXTtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJTaXplKys7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lcXVhbHNGbihtYXRjaGVzW2ldWzBdLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB1cGRhdGluZyBhbiBleGlzdGluZyBlbnRyeSBhbmQgZG9lcyBub3QgaW5jcmVhc2UgYGlubmVyU2l6ZWAuXG4gICAgICAgICAgICAgICAgbWF0Y2hlc1tpXSA9IFtrZXksIHZhbHVlXTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2hlcy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICAgIHRoaXMuaW5uZXJTaXplKys7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGlzIGtleSBmcm9tIHRoZSBtYXAuIFJldHVybnMgYSBib29sZWFuIGlmIGFueXRoaW5nIHdhcyBkZWxldGVkLlxuICAgICAqL1xuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLm1hcEtleUZuKGtleSk7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLmlubmVyW2lkXTtcbiAgICAgICAgaWYgKG1hdGNoZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXF1YWxzRm4obWF0Y2hlc1tpXVswXSwga2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5pbm5lcltpZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbm5lclNpemUtLTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvckVhY2goZm4pIHtcbiAgICAgICAgZm9yRWFjaCh0aGlzLmlubmVyLCAoXywgZW50cmllcykgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgZW50cmllcykge1xuICAgICAgICAgICAgICAgIGZuKGssIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIGlzRW1wdHkodGhpcy5pbm5lcik7XG4gICAgfVxuICAgIHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlubmVyU2l6ZTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBFTVBUWV9NVVRBQkxFX0RPQ1VNRU5UX01BUCA9IG5ldyBTb3J0ZWRNYXAoRG9jdW1lbnRLZXkuY29tcGFyYXRvcik7XG5mdW5jdGlvbiBtdXRhYmxlRG9jdW1lbnRNYXAoKSB7XG4gICAgcmV0dXJuIEVNUFRZX01VVEFCTEVfRE9DVU1FTlRfTUFQO1xufVxuY29uc3QgRU1QVFlfRE9DVU1FTlRfTUFQID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcbmZ1bmN0aW9uIGRvY3VtZW50TWFwKC4uLmRvY3MpIHtcbiAgICBsZXQgbWFwID0gRU1QVFlfRE9DVU1FTlRfTUFQO1xuICAgIGZvciAoY29uc3QgZG9jIG9mIGRvY3MpIHtcbiAgICAgICAgbWFwID0gbWFwLmluc2VydChkb2Mua2V5LCBkb2MpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xufVxuZnVuY3Rpb24gbmV3T3ZlcmxheWVkRG9jdW1lbnRNYXAoKSB7XG4gICAgcmV0dXJuIG5ld0RvY3VtZW50S2V5TWFwKCk7XG59XG5mdW5jdGlvbiBjb252ZXJ0T3ZlcmxheWVkRG9jdW1lbnRNYXBUb0RvY3VtZW50TWFwKGNvbGxlY3Rpb24pIHtcbiAgICBsZXQgZG9jdW1lbnRzID0gRU1QVFlfRE9DVU1FTlRfTUFQO1xuICAgIGNvbGxlY3Rpb24uZm9yRWFjaCgoaywgdikgPT4gKGRvY3VtZW50cyA9IGRvY3VtZW50cy5pbnNlcnQoaywgdi5vdmVybGF5ZWREb2N1bWVudCkpKTtcbiAgICByZXR1cm4gZG9jdW1lbnRzO1xufVxuZnVuY3Rpb24gbmV3T3ZlcmxheU1hcCgpIHtcbiAgICByZXR1cm4gbmV3RG9jdW1lbnRLZXlNYXAoKTtcbn1cbmZ1bmN0aW9uIG5ld011dGF0aW9uTWFwKCkge1xuICAgIHJldHVybiBuZXdEb2N1bWVudEtleU1hcCgpO1xufVxuZnVuY3Rpb24gbmV3RG9jdW1lbnRLZXlNYXAoKSB7XG4gICAgcmV0dXJuIG5ldyBPYmplY3RNYXAoa2V5ID0+IGtleS50b1N0cmluZygpLCAobCwgcikgPT4gbC5pc0VxdWFsKHIpKTtcbn1cbmNvbnN0IEVNUFRZX0RPQ1VNRU5UX1ZFUlNJT05fTUFQID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcbmZ1bmN0aW9uIGRvY3VtZW50VmVyc2lvbk1hcCgpIHtcbiAgICByZXR1cm4gRU1QVFlfRE9DVU1FTlRfVkVSU0lPTl9NQVA7XG59XG5jb25zdCBFTVBUWV9ET0NVTUVOVF9LRVlfU0VUID0gbmV3IFNvcnRlZFNldChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcbmZ1bmN0aW9uIGRvY3VtZW50S2V5U2V0KC4uLmtleXMpIHtcbiAgICBsZXQgc2V0ID0gRU1QVFlfRE9DVU1FTlRfS0VZX1NFVDtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIHNldCA9IHNldC5hZGQoa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHNldDtcbn1cbmNvbnN0IEVNUFRZX1RBUkdFVF9JRF9TRVQgPSBuZXcgU29ydGVkU2V0KHByaW1pdGl2ZUNvbXBhcmF0b3IpO1xuZnVuY3Rpb24gdGFyZ2V0SWRTZXQoKSB7XG4gICAgcmV0dXJuIEVNUFRZX1RBUkdFVF9JRF9TRVQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJldHVybnMgYW4gRG91YmxlVmFsdWUgZm9yIGB2YWx1ZWAgdGhhdCBpcyBlbmNvZGVkIGJhc2VkIHRoZSBzZXJpYWxpemVyJ3NcbiAqIGB1c2VQcm90bzNKc29uYCBzZXR0aW5nLlxuICovXG5mdW5jdGlvbiB0b0RvdWJsZShzZXJpYWxpemVyLCB2YWx1ZSkge1xuICAgIGlmIChzZXJpYWxpemVyLnVzZVByb3RvM0pzb24pIHtcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZG91YmxlVmFsdWU6ICdOYU4nIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4geyBkb3VibGVWYWx1ZTogJ0luZmluaXR5JyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRvdWJsZVZhbHVlOiAnLUluZmluaXR5JyB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGRvdWJsZVZhbHVlOiBpc05lZ2F0aXZlWmVybyh2YWx1ZSkgPyAnLTAnIDogdmFsdWUgfTtcbn1cbi8qKlxuICogUmV0dXJucyBhbiBJbnRlZ2VyVmFsdWUgZm9yIGB2YWx1ZWAuXG4gKi9cbmZ1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSkge1xuICAgIHJldHVybiB7IGludGVnZXJWYWx1ZTogJycgKyB2YWx1ZSB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgdmFsdWUgZm9yIGEgbnVtYmVyIHRoYXQncyBhcHByb3ByaWF0ZSB0byBwdXQgaW50byBhIHByb3RvLlxuICogVGhlIHJldHVybiB2YWx1ZSBpcyBhbiBJbnRlZ2VyVmFsdWUgaWYgaXQgY2FuIHNhZmVseSByZXByZXNlbnQgdGhlIHZhbHVlLFxuICogb3RoZXJ3aXNlIGEgRG91YmxlVmFsdWUgaXMgcmV0dXJuZWQuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHNlcmlhbGl6ZXIsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzU2FmZUludGVnZXIodmFsdWUpID8gdG9JbnRlZ2VyKHZhbHVlKSA6IHRvRG91YmxlKHNlcmlhbGl6ZXIsIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKiBVc2VkIHRvIHJlcHJlc2VudCBhIGZpZWxkIHRyYW5zZm9ybSBvbiBhIG11dGF0aW9uLiAqL1xuY2xhc3MgVHJhbnNmb3JtT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHN0cnVjdHVyYWwgdHlwZSBvZiBgVHJhbnNmb3JtT3BlcmF0aW9uYCBpcyB1bmlxdWUuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzU0NTFcbiAgICAgICAgdGhpcy5fID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGxvY2FsIHRyYW5zZm9ybSByZXN1bHQgYWdhaW5zdCB0aGUgcHJvdmlkZWQgYHByZXZpb3VzVmFsdWVgLFxuICogb3B0aW9uYWxseSB1c2luZyB0aGUgcHJvdmlkZWQgbG9jYWxXcml0ZVRpbWUuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtT3BlcmF0aW9uVG9Mb2NhbFZpZXcodHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlLCBsb2NhbFdyaXRlVGltZSkge1xuICAgIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBTZXJ2ZXJUaW1lc3RhbXBUcmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIHNlcnZlclRpbWVzdGFtcCQxKGxvY2FsV3JpdGVUaW1lLCBwcmV2aW91c1ZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHJhbnNmb3JtIGluc3RhbmNlb2YgQXJyYXlVbmlvblRyYW5zZm9ybU9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm4gYXBwbHlBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uKHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRyYW5zZm9ybSBpbnN0YW5jZW9mIEFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBhcHBseUFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uKHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYXBwbHlOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uVG9Mb2NhbFZpZXcodHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKTtcbiAgICB9XG59XG4vKipcbiAqIENvbXB1dGVzIGEgZmluYWwgdHJhbnNmb3JtIHJlc3VsdCBhZnRlciB0aGUgdHJhbnNmb3JtIGhhcyBiZWVuIGFja25vd2xlZGdlZFxuICogYnkgdGhlIHNlcnZlciwgcG90ZW50aWFsbHkgdXNpbmcgdGhlIHNlcnZlci1wcm92aWRlZCB0cmFuc2Zvcm1SZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtT3BlcmF0aW9uVG9SZW1vdGVEb2N1bWVudCh0cmFuc2Zvcm0sIHByZXZpb3VzVmFsdWUsIHRyYW5zZm9ybVJlc3VsdCkge1xuICAgIC8vIFRoZSBzZXJ2ZXIganVzdCBzZW5kcyBudWxsIGFzIHRoZSB0cmFuc2Zvcm0gcmVzdWx0IGZvciBhcnJheSBvcGVyYXRpb25zLFxuICAgIC8vIHNvIHdlIGhhdmUgdG8gY2FsY3VsYXRlIGEgcmVzdWx0IHRoZSBzYW1lIGFzIHdlIGRvIGZvciBsb2NhbFxuICAgIC8vIGFwcGxpY2F0aW9ucy5cbiAgICBpZiAodHJhbnNmb3JtIGluc3RhbmNlb2YgQXJyYXlVbmlvblRyYW5zZm9ybU9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm4gYXBwbHlBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uKHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRyYW5zZm9ybSBpbnN0YW5jZW9mIEFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBhcHBseUFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uKHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2Zvcm1SZXN1bHQ7XG59XG4vKipcbiAqIElmIHRoaXMgdHJhbnNmb3JtIG9wZXJhdGlvbiBpcyBub3QgaWRlbXBvdGVudCwgcmV0dXJucyB0aGUgYmFzZSB2YWx1ZSB0b1xuICogcGVyc2lzdCBmb3IgdGhpcyB0cmFuc2Zvcm0uIElmIGEgYmFzZSB2YWx1ZSBpcyByZXR1cm5lZCwgdGhlIHRyYW5zZm9ybVxuICogb3BlcmF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIHRvIHRoaXMgYmFzZSB2YWx1ZSwgZXZlbiBpZiBkb2N1bWVudCBoYXNcbiAqIGFscmVhZHkgYmVlbiB1cGRhdGVkLlxuICpcbiAqIEJhc2UgdmFsdWVzIHByb3ZpZGUgY29uc2lzdGVudCBiZWhhdmlvciBmb3Igbm9uLWlkZW1wb3RlbnQgdHJhbnNmb3JtcyBhbmRcbiAqIGFsbG93IHVzIHRvIHJldHVybiB0aGUgc2FtZSBsYXRlbmN5LWNvbXBlbnNhdGVkIHZhbHVlIGV2ZW4gaWYgdGhlIGJhY2tlbmRcbiAqIGhhcyBhbHJlYWR5IGFwcGxpZWQgdGhlIHRyYW5zZm9ybSBvcGVyYXRpb24uIFRoZSBiYXNlIHZhbHVlIGlzIG51bGwgZm9yXG4gKiBpZGVtcG90ZW50IHRyYW5zZm9ybXMsIGFzIHRoZXkgY2FuIGJlIHJlLXBsYXllZCBldmVuIGlmIHRoZSBiYWNrZW5kIGhhc1xuICogYWxyZWFkeSBhcHBsaWVkIHRoZW0uXG4gKlxuICogQHJldHVybnMgYSBiYXNlIHZhbHVlIHRvIHN0b3JlIGFsb25nIHdpdGggdGhlIG11dGF0aW9uLCBvciBudWxsIGZvclxuICogaWRlbXBvdGVudCB0cmFuc2Zvcm1zLlxuICovXG5mdW5jdGlvbiBjb21wdXRlVHJhbnNmb3JtT3BlcmF0aW9uQmFzZVZhbHVlKHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSkge1xuICAgIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBpc051bWJlcihwcmV2aW91c1ZhbHVlKSA/IHByZXZpb3VzVmFsdWUgOiB7IGludGVnZXJWYWx1ZTogMCB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybU9wZXJhdGlvbkVxdWFscyhsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0IGluc3RhbmNlb2YgQXJyYXlVbmlvblRyYW5zZm9ybU9wZXJhdGlvbiAmJlxuICAgICAgICByaWdodCBpbnN0YW5jZW9mIEFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGFycmF5RXF1YWxzKGxlZnQuZWxlbWVudHMsIHJpZ2h0LmVsZW1lbnRzLCB2YWx1ZUVxdWFscyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlZnQgaW5zdGFuY2VvZiBBcnJheVJlbW92ZVRyYW5zZm9ybU9wZXJhdGlvbiAmJlxuICAgICAgICByaWdodCBpbnN0YW5jZW9mIEFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBhcnJheUVxdWFscyhsZWZ0LmVsZW1lbnRzLCByaWdodC5lbGVtZW50cywgdmFsdWVFcXVhbHMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZWZ0IGluc3RhbmNlb2YgTnVtZXJpY0luY3JlbWVudFRyYW5zZm9ybU9wZXJhdGlvbiAmJlxuICAgICAgICByaWdodCBpbnN0YW5jZW9mIE51bWVyaWNJbmNyZW1lbnRUcmFuc2Zvcm1PcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlRXF1YWxzKGxlZnQub3BlcmFuZCwgcmlnaHQub3BlcmFuZCk7XG4gICAgfVxuICAgIHJldHVybiAobGVmdCBpbnN0YW5jZW9mIFNlcnZlclRpbWVzdGFtcFRyYW5zZm9ybSAmJlxuICAgICAgICByaWdodCBpbnN0YW5jZW9mIFNlcnZlclRpbWVzdGFtcFRyYW5zZm9ybSk7XG59XG4vKiogVHJhbnNmb3JtcyBhIHZhbHVlIGludG8gYSBzZXJ2ZXItZ2VuZXJhdGVkIHRpbWVzdGFtcC4gKi9cbmNsYXNzIFNlcnZlclRpbWVzdGFtcFRyYW5zZm9ybSBleHRlbmRzIFRyYW5zZm9ybU9wZXJhdGlvbiB7XG59XG4vKiogVHJhbnNmb3JtcyBhbiBhcnJheSB2YWx1ZSB2aWEgYSB1bmlvbiBvcGVyYXRpb24uICovXG5jbGFzcyBBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uIGV4dGVuZHMgVHJhbnNmb3JtT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uKHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlcyA9IGNvZXJjZWRGaWVsZFZhbHVlc0FycmF5KHByZXZpb3VzVmFsdWUpO1xuICAgIGZvciAoY29uc3QgdG9VbmlvbiBvZiB0cmFuc2Zvcm0uZWxlbWVudHMpIHtcbiAgICAgICAgaWYgKCF2YWx1ZXMuc29tZShlbGVtZW50ID0+IHZhbHVlRXF1YWxzKGVsZW1lbnQsIHRvVW5pb24pKSkge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2godG9Vbmlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgYXJyYXlWYWx1ZTogeyB2YWx1ZXMgfSB9O1xufVxuLyoqIFRyYW5zZm9ybXMgYW4gYXJyYXkgdmFsdWUgdmlhIGEgcmVtb3ZlIG9wZXJhdGlvbi4gKi9cbmNsYXNzIEFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uIGV4dGVuZHMgVHJhbnNmb3JtT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlBcnJheVJlbW92ZVRyYW5zZm9ybU9wZXJhdGlvbih0cmFuc2Zvcm0sIHByZXZpb3VzVmFsdWUpIHtcbiAgICBsZXQgdmFsdWVzID0gY29lcmNlZEZpZWxkVmFsdWVzQXJyYXkocHJldmlvdXNWYWx1ZSk7XG4gICAgZm9yIChjb25zdCB0b1JlbW92ZSBvZiB0cmFuc2Zvcm0uZWxlbWVudHMpIHtcbiAgICAgICAgdmFsdWVzID0gdmFsdWVzLmZpbHRlcihlbGVtZW50ID0+ICF2YWx1ZUVxdWFscyhlbGVtZW50LCB0b1JlbW92ZSkpO1xuICAgIH1cbiAgICByZXR1cm4geyBhcnJheVZhbHVlOiB7IHZhbHVlcyB9IH07XG59XG4vKipcbiAqIEltcGxlbWVudHMgdGhlIGJhY2tlbmQgc2VtYW50aWNzIGZvciBsb2NhbGx5IGNvbXB1dGVkIE5VTUVSSUNfQUREIChpbmNyZW1lbnQpXG4gKiB0cmFuc2Zvcm1zLiBDb252ZXJ0cyBhbGwgZmllbGQgdmFsdWVzIHRvIGludGVnZXJzIG9yIGRvdWJsZXMsIGJ1dCB1bmxpa2UgdGhlXG4gKiBiYWNrZW5kIGRvZXMgbm90IGNhcCBpbnRlZ2VyIHZhbHVlcyBhdCAyXjYzLiBJbnN0ZWFkLCBKYXZhU2NyaXB0IG51bWJlclxuICogYXJpdGhtZXRpYyBpcyB1c2VkIGFuZCBwcmVjaXNpb24gbG9zcyBjYW4gb2NjdXIgZm9yIHZhbHVlcyBncmVhdGVyIHRoYW4gMl41My5cbiAqL1xuY2xhc3MgTnVtZXJpY0luY3JlbWVudFRyYW5zZm9ybU9wZXJhdGlvbiBleHRlbmRzIFRyYW5zZm9ybU9wZXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWFsaXplciwgb3BlcmFuZCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xuICAgICAgICB0aGlzLm9wZXJhbmQgPSBvcGVyYW5kO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5TnVtZXJpY0luY3JlbWVudFRyYW5zZm9ybU9wZXJhdGlvblRvTG9jYWxWaWV3KHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSkge1xuICAgIC8vIFBPUlRJTkcgTk9URTogU2luY2UgSmF2YVNjcmlwdCdzIGludGVnZXIgYXJpdGhtZXRpYyBpcyBsaW1pdGVkIHRvIDUzIGJpdFxuICAgIC8vIHByZWNpc2lvbiBhbmQgcmVzb2x2ZXMgb3ZlcmZsb3dzIGJ5IHJlZHVjaW5nIHByZWNpc2lvbiwgd2UgZG8gbm90XG4gICAgLy8gbWFudWFsbHkgY2FwIG92ZXJmbG93cyBhdCAyXjYzLlxuICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGNvbXB1dGVUcmFuc2Zvcm1PcGVyYXRpb25CYXNlVmFsdWUodHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKTtcbiAgICBjb25zdCBzdW0gPSBhc051bWJlcihiYXNlVmFsdWUpICsgYXNOdW1iZXIodHJhbnNmb3JtLm9wZXJhbmQpO1xuICAgIGlmIChpc0ludGVnZXIoYmFzZVZhbHVlKSAmJiBpc0ludGVnZXIodHJhbnNmb3JtLm9wZXJhbmQpKSB7XG4gICAgICAgIHJldHVybiB0b0ludGVnZXIoc3VtKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0b0RvdWJsZSh0cmFuc2Zvcm0uc2VyaWFsaXplciwgc3VtKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhc051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiBub3JtYWxpemVOdW1iZXIodmFsdWUuaW50ZWdlclZhbHVlIHx8IHZhbHVlLmRvdWJsZVZhbHVlKTtcbn1cbmZ1bmN0aW9uIGNvZXJjZWRGaWVsZFZhbHVlc0FycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmFycmF5VmFsdWUudmFsdWVzXG4gICAgICAgID8gdmFsdWUuYXJyYXlWYWx1ZS52YWx1ZXMuc2xpY2UoKVxuICAgICAgICA6IFtdO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqIEEgZmllbGQgcGF0aCBhbmQgdGhlIFRyYW5zZm9ybU9wZXJhdGlvbiB0byBwZXJmb3JtIHVwb24gaXQuICovXG5jbGFzcyBGaWVsZFRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3IoZmllbGQsIHRyYW5zZm9ybSkge1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpZWxkVHJhbnNmb3JtRXF1YWxzKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIChsZWZ0LmZpZWxkLmlzRXF1YWwocmlnaHQuZmllbGQpICYmXG4gICAgICAgIHRyYW5zZm9ybU9wZXJhdGlvbkVxdWFscyhsZWZ0LnRyYW5zZm9ybSwgcmlnaHQudHJhbnNmb3JtKSk7XG59XG5mdW5jdGlvbiBmaWVsZFRyYW5zZm9ybXNBcmVFcXVhbChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0ID09PSB1bmRlZmluZWQgJiYgcmlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGxlZnQgJiYgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5RXF1YWxzKGxlZnQsIHJpZ2h0LCAobCwgcikgPT4gZmllbGRUcmFuc2Zvcm1FcXVhbHMobCwgcikpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKiogVGhlIHJlc3VsdCBvZiBzdWNjZXNzZnVsbHkgYXBwbHlpbmcgYSBtdXRhdGlvbiB0byB0aGUgYmFja2VuZC4gKi9cbmNsYXNzIE11dGF0aW9uUmVzdWx0IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBUaGUgdmVyc2lvbiBhdCB3aGljaCB0aGUgbXV0YXRpb24gd2FzIGNvbW1pdHRlZDpcbiAgICAgKlxuICAgICAqIC0gRm9yIG1vc3Qgb3BlcmF0aW9ucywgdGhpcyBpcyB0aGUgdXBkYXRlVGltZSBpbiB0aGUgV3JpdGVSZXN1bHQuXG4gICAgICogLSBGb3IgZGVsZXRlcywgdGhlIGNvbW1pdFRpbWUgb2YgdGhlIFdyaXRlUmVzcG9uc2UgKGJlY2F1c2UgZGVsZXRlcyBhcmVcbiAgICAgKiAgIG5vdCBzdG9yZWQgYW5kIGhhdmUgbm8gdXBkYXRlVGltZSkuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhlc2UgdmVyc2lvbnMgY2FuIGJlIGRpZmZlcmVudDogTm8tb3Agd3JpdGVzIHdpbGwgbm90IGNoYW5nZVxuICAgICAqIHRoZSB1cGRhdGVUaW1lIGV2ZW4gdGhvdWdoIHRoZSBjb21taXRUaW1lIGFkdmFuY2VzLlxuICAgICAqL1xuICAgIHZlcnNpb24sIFxuICAgIC8qKlxuICAgICAqIFRoZSByZXN1bHRpbmcgZmllbGRzIHJldHVybmVkIGZyb20gdGhlIGJhY2tlbmQgYWZ0ZXIgYSBtdXRhdGlvblxuICAgICAqIGNvbnRhaW5pbmcgZmllbGQgdHJhbnNmb3JtcyBoYXMgYmVlbiBjb21taXR0ZWQuIENvbnRhaW5zIG9uZSBGaWVsZFZhbHVlXG4gICAgICogZm9yIGVhY2ggRmllbGRUcmFuc2Zvcm0gdGhhdCB3YXMgaW4gdGhlIG11dGF0aW9uLlxuICAgICAqXG4gICAgICogV2lsbCBiZSBlbXB0eSBpZiB0aGUgbXV0YXRpb24gZGlkIG5vdCBjb250YWluIGFueSBmaWVsZCB0cmFuc2Zvcm1zLlxuICAgICAqL1xuICAgIHRyYW5zZm9ybVJlc3VsdHMpIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1SZXN1bHRzID0gdHJhbnNmb3JtUmVzdWx0cztcbiAgICB9XG59XG4vKipcbiAqIEVuY29kZXMgYSBwcmVjb25kaXRpb24gZm9yIGEgbXV0YXRpb24uIFRoaXMgZm9sbG93cyB0aGUgbW9kZWwgdGhhdCB0aGVcbiAqIGJhY2tlbmQgYWNjZXB0cyB3aXRoIHRoZSBzcGVjaWFsIGNhc2Ugb2YgYW4gZXhwbGljaXQgXCJlbXB0eVwiIHByZWNvbmRpdGlvblxuICogKG1lYW5pbmcgbm8gcHJlY29uZGl0aW9uKS5cbiAqL1xuY2xhc3MgUHJlY29uZGl0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih1cGRhdGVUaW1lLCBleGlzdHMpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUaW1lID0gdXBkYXRlVGltZTtcbiAgICAgICAgdGhpcy5leGlzdHMgPSBleGlzdHM7XG4gICAgfVxuICAgIC8qKiBDcmVhdGVzIGEgbmV3IGVtcHR5IFByZWNvbmRpdGlvbi4gKi9cbiAgICBzdGF0aWMgbm9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVjb25kaXRpb24oKTtcbiAgICB9XG4gICAgLyoqIENyZWF0ZXMgYSBuZXcgUHJlY29uZGl0aW9uIHdpdGggYW4gZXhpc3RzIGZsYWcuICovXG4gICAgc3RhdGljIGV4aXN0cyhleGlzdHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVjb25kaXRpb24odW5kZWZpbmVkLCBleGlzdHMpO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlcyBhIG5ldyBQcmVjb25kaXRpb24gYmFzZWQgb24gYSB2ZXJzaW9uIGEgZG9jdW1lbnQgZXhpc3RzIGF0LiAqL1xuICAgIHN0YXRpYyB1cGRhdGVUaW1lKHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVjb25kaXRpb24odmVyc2lvbik7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBQcmVjb25kaXRpb24gaXMgZW1wdHkuICovXG4gICAgZ2V0IGlzTm9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlVGltZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuZXhpc3RzID09PSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmV4aXN0cyA9PT0gb3RoZXIuZXhpc3RzICYmXG4gICAgICAgICAgICAodGhpcy51cGRhdGVUaW1lXG4gICAgICAgICAgICAgICAgPyAhIW90aGVyLnVwZGF0ZVRpbWUgJiYgdGhpcy51cGRhdGVUaW1lLmlzRXF1YWwob3RoZXIudXBkYXRlVGltZSlcbiAgICAgICAgICAgICAgICA6ICFvdGhlci51cGRhdGVUaW1lKSk7XG4gICAgfVxufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJlY29uZGl0aW9ucyBpcyB2YWxpZCBmb3IgdGhlIGdpdmVuIGRvY3VtZW50LiAqL1xuZnVuY3Rpb24gcHJlY29uZGl0aW9uSXNWYWxpZEZvckRvY3VtZW50KHByZWNvbmRpdGlvbiwgZG9jdW1lbnQpIHtcbiAgICBpZiAocHJlY29uZGl0aW9uLnVwZGF0ZVRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gKGRvY3VtZW50LmlzRm91bmREb2N1bWVudCgpICYmXG4gICAgICAgICAgICBkb2N1bWVudC52ZXJzaW9uLmlzRXF1YWwocHJlY29uZGl0aW9uLnVwZGF0ZVRpbWUpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJlY29uZGl0aW9uLmV4aXN0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBwcmVjb25kaXRpb24uZXhpc3RzID09PSBkb2N1bWVudC5pc0ZvdW5kRG9jdW1lbnQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbi8qKlxuICogQSBtdXRhdGlvbiBkZXNjcmliZXMgYSBzZWxmLWNvbnRhaW5lZCBjaGFuZ2UgdG8gYSBkb2N1bWVudC4gTXV0YXRpb25zIGNhblxuICogY3JlYXRlLCByZXBsYWNlLCBkZWxldGUsIGFuZCB1cGRhdGUgc3Vic2V0cyBvZiBkb2N1bWVudHMuXG4gKlxuICogTXV0YXRpb25zIG5vdCBvbmx5IGFjdCBvbiB0aGUgdmFsdWUgb2YgdGhlIGRvY3VtZW50IGJ1dCBhbHNvIGl0cyB2ZXJzaW9uLlxuICpcbiAqIEZvciBsb2NhbCBtdXRhdGlvbnMgKG11dGF0aW9ucyB0aGF0IGhhdmVuJ3QgYmVlbiBjb21taXR0ZWQgeWV0KSwgd2UgcHJlc2VydmVcbiAqIHRoZSBleGlzdGluZyB2ZXJzaW9uIGZvciBTZXQgYW5kIFBhdGNoIG11dGF0aW9ucy4gRm9yIERlbGV0ZSBtdXRhdGlvbnMsIHdlXG4gKiByZXNldCB0aGUgdmVyc2lvbiB0byAwLlxuICpcbiAqIEhlcmUncyB0aGUgZXhwZWN0ZWQgdHJhbnNpdGlvbiB0YWJsZS5cbiAqXG4gKiBNVVRBVElPTiAgICAgICAgICAgQVBQTElFRCBUTyAgICAgICAgICAgIFJFU1VMVFMgSU5cbiAqXG4gKiBTZXRNdXRhdGlvbiAgICAgICAgRG9jdW1lbnQodjMpICAgICAgICAgIERvY3VtZW50KHYzKVxuICogU2V0TXV0YXRpb24gICAgICAgIE5vRG9jdW1lbnQodjMpICAgICAgICBEb2N1bWVudCh2MClcbiAqIFNldE11dGF0aW9uICAgICAgICBJbnZhbGlkRG9jdW1lbnQodjApICAgRG9jdW1lbnQodjApXG4gKiBQYXRjaE11dGF0aW9uICAgICAgRG9jdW1lbnQodjMpICAgICAgICAgIERvY3VtZW50KHYzKVxuICogUGF0Y2hNdXRhdGlvbiAgICAgIE5vRG9jdW1lbnQodjMpICAgICAgICBOb0RvY3VtZW50KHYzKVxuICogUGF0Y2hNdXRhdGlvbiAgICAgIEludmFsaWREb2N1bWVudCh2MCkgICBVbmtub3duRG9jdW1lbnQodjMpXG4gKiBEZWxldGVNdXRhdGlvbiAgICAgRG9jdW1lbnQodjMpICAgICAgICAgIE5vRG9jdW1lbnQodjApXG4gKiBEZWxldGVNdXRhdGlvbiAgICAgTm9Eb2N1bWVudCh2MykgICAgICAgIE5vRG9jdW1lbnQodjApXG4gKiBEZWxldGVNdXRhdGlvbiAgICAgSW52YWxpZERvY3VtZW50KHYwKSAgIE5vRG9jdW1lbnQodjApXG4gKlxuICogRm9yIGFja25vd2xlZGdlZCBtdXRhdGlvbnMsIHdlIHVzZSB0aGUgdXBkYXRlVGltZSBvZiB0aGUgV3JpdGVSZXNwb25zZSBhc1xuICogdGhlIHJlc3VsdGluZyB2ZXJzaW9uIGZvciBTZXQgYW5kIFBhdGNoIG11dGF0aW9ucy4gQXMgZGVsZXRlcyBoYXZlIG5vXG4gKiBleHBsaWNpdCB1cGRhdGUgdGltZSwgd2UgdXNlIHRoZSBjb21taXRUaW1lIG9mIHRoZSBXcml0ZVJlc3BvbnNlIGZvclxuICogRGVsZXRlIG11dGF0aW9ucy5cbiAqXG4gKiBJZiBhIG11dGF0aW9uIGlzIGFja25vd2xlZGdlZCBieSB0aGUgYmFja2VuZCBidXQgZmFpbHMgdGhlIHByZWNvbmRpdGlvbiBjaGVja1xuICogbG9jYWxseSwgd2UgdHJhbnNpdGlvbiB0byBhbiBgVW5rbm93bkRvY3VtZW50YCBhbmQgcmVseSBvbiBXYXRjaCB0byBzZW5kIHVzXG4gKiB0aGUgdXBkYXRlZCB2ZXJzaW9uLlxuICpcbiAqIEZpZWxkIHRyYW5zZm9ybXMgYXJlIHVzZWQgb25seSB3aXRoIFBhdGNoIGFuZCBTZXQgTXV0YXRpb25zLiBXZSB1c2UgdGhlXG4gKiBgdXBkYXRlVHJhbnNmb3Jtc2AgbWVzc2FnZSB0byBzdG9yZSB0cmFuc2Zvcm1zLCByYXRoZXIgdGhhbiB0aGUgYHRyYW5zZm9ybXNgc1xuICogbWVzc2FnZXMuXG4gKlxuICogIyMgU3ViY2xhc3NpbmcgTm90ZXNcbiAqXG4gKiBFdmVyeSB0eXBlIG9mIG11dGF0aW9uIG5lZWRzIHRvIGltcGxlbWVudCBpdHMgb3duIGFwcGx5VG9SZW1vdGVEb2N1bWVudCgpIGFuZFxuICogYXBwbHlUb0xvY2FsVmlldygpIHRvIGltcGxlbWVudCB0aGUgYWN0dWFsIGJlaGF2aW9yIG9mIGFwcGx5aW5nIHRoZSBtdXRhdGlvblxuICogdG8gc29tZSBzb3VyY2UgZG9jdW1lbnQgKHNlZSBgc2V0TXV0YXRpb25BcHBseVRvUmVtb3RlRG9jdW1lbnQoKWAgZm9yIGFuXG4gKiBleGFtcGxlKS5cbiAqL1xuY2xhc3MgTXV0YXRpb24ge1xufVxuLyoqXG4gKiBBIHV0aWxpdHkgbWV0aG9kIHRvIGNhbGN1bGF0ZSBhIGBNdXRhdGlvbmAgcmVwcmVzZW50aW5nIHRoZSBvdmVybGF5IGZyb20gdGhlXG4gKiBmaW5hbCBzdGF0ZSBvZiB0aGUgZG9jdW1lbnQsIGFuZCBhIGBGaWVsZE1hc2tgIHJlcHJlc2VudGluZyB0aGUgZmllbGRzIHRoYXRcbiAqIGFyZSBtdXRhdGVkIGJ5IHRoZSBsb2NhbCBtdXRhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZU92ZXJsYXlNdXRhdGlvbihkb2MsIG1hc2spIHtcbiAgICBpZiAoIWRvYy5oYXNMb2NhbE11dGF0aW9ucyB8fCAobWFzayAmJiBtYXNrLmZpZWxkcy5sZW5ndGggPT09IDApKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBtYXNrIGlzIG51bGwgd2hlbiBzZXRzIG9yIGRlbGV0ZXMgYXJlIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgZG9jdW1lbnQuXG4gICAgaWYgKG1hc2sgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKGRvYy5pc05vRG9jdW1lbnQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWxldGVNdXRhdGlvbihkb2Mua2V5LCBQcmVjb25kaXRpb24ubm9uZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2V0TXV0YXRpb24oZG9jLmtleSwgZG9jLmRhdGEsIFByZWNvbmRpdGlvbi5ub25lKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBkb2NWYWx1ZSA9IGRvYy5kYXRhO1xuICAgICAgICBjb25zdCBwYXRjaFZhbHVlID0gT2JqZWN0VmFsdWUuZW1wdHkoKTtcbiAgICAgICAgbGV0IG1hc2tTZXQgPSBuZXcgU29ydGVkU2V0KEZpZWxkUGF0aCQxLmNvbXBhcmF0b3IpO1xuICAgICAgICBmb3IgKGxldCBwYXRoIG9mIG1hc2suZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAoIW1hc2tTZXQuaGFzKHBhdGgpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZG9jVmFsdWUuZmllbGQocGF0aCk7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGRlbGV0aW5nIGEgbmVzdGVkIGZpZWxkLCB3ZSB0YWtlIHRoZSBpbW1lZGlhdGUgcGFyZW50IGFzXG4gICAgICAgICAgICAgICAgLy8gdGhlIG1hc2sgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIHJlc3VsdGluZyBtdXRhdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBKdXN0aWZpY2F0aW9uOiBOZXN0ZWQgZmllbGRzIGNhbiBjcmVhdGUgcGFyZW50IGZpZWxkcyBpbXBsaWNpdGx5LiBJZlxuICAgICAgICAgICAgICAgIC8vIG9ubHkgYSBsZWFmIGVudHJ5IGlzIGRlbGV0ZWQgaW4gbGF0ZXIgbXV0YXRpb25zLCB0aGUgcGFyZW50IGZpZWxkXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIHN0aWxsIHJlbWFpbiwgYnV0IHdlIG1heSBoYXZlIGxvc3QgdGhpcyBpbmZvcm1hdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBDb25zaWRlciBtdXRhdGlvbiAoZm9vLmJhciAxKSwgdGhlbiBtdXRhdGlvbiAoZm9vLmJhciBkZWxldGUoKSkuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBsZWF2ZXMgdGhlIGZpbmFsIHJlc3VsdCAoZm9vLCB7fSkuIERlc3BpdGUgdGhlIGZhY3QgdGhhdCBgZG9jYFxuICAgICAgICAgICAgICAgIC8vIGhhcyB0aGUgY29ycmVjdCByZXN1bHQsIGBmb29gIGlzIG5vdCBpbiBgbWFza2AsIGFuZCB0aGUgcmVzdWx0aW5nXG4gICAgICAgICAgICAgICAgLy8gbXV0YXRpb24gd291bGQgbWlzcyBgZm9vYC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgJiYgcGF0aC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnBvcExhc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBkb2NWYWx1ZS5maWVsZChwYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoVmFsdWUuZGVsZXRlKHBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hWYWx1ZS5zZXQocGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXNrU2V0ID0gbWFza1NldC5hZGQocGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQYXRjaE11dGF0aW9uKGRvYy5rZXksIHBhdGNoVmFsdWUsIG5ldyBGaWVsZE1hc2sobWFza1NldC50b0FycmF5KCkpLCBQcmVjb25kaXRpb24ubm9uZSgpKTtcbiAgICB9XG59XG4vKipcbiAqIEFwcGxpZXMgdGhpcyBtdXRhdGlvbiB0byB0aGUgZ2l2ZW4gZG9jdW1lbnQgZm9yIHRoZSBwdXJwb3NlcyBvZiBjb21wdXRpbmcgYVxuICogbmV3IHJlbW90ZSBkb2N1bWVudC4gSWYgdGhlIGlucHV0IGRvY3VtZW50IGRvZXNuJ3QgbWF0Y2ggdGhlIGV4cGVjdGVkIHN0YXRlXG4gKiAoZS5nLiBpdCBpcyBpbnZhbGlkIG9yIG91dGRhdGVkKSwgdGhlIGRvY3VtZW50IHR5cGUgbWF5IHRyYW5zaXRpb24gdG9cbiAqIHVua25vd24uXG4gKlxuICogQHBhcmFtIG11dGF0aW9uIC0gVGhlIG11dGF0aW9uIHRvIGFwcGx5LlxuICogQHBhcmFtIGRvY3VtZW50IC0gVGhlIGRvY3VtZW50IHRvIG11dGF0ZS4gVGhlIGlucHV0IGRvY3VtZW50IGNhbiBiZSBhblxuICogICAgIGludmFsaWQgZG9jdW1lbnQgaWYgdGhlIGNsaWVudCBoYXMgbm8ga25vd2xlZGdlIG9mIHRoZSBwcmUtbXV0YXRpb24gc3RhdGVcbiAqICAgICBvZiB0aGUgZG9jdW1lbnQuXG4gKiBAcGFyYW0gbXV0YXRpb25SZXN1bHQgLSBUaGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBtdXRhdGlvbiBmcm9tIHRoZSBiYWNrZW5kLlxuICovXG5mdW5jdGlvbiBtdXRhdGlvbkFwcGx5VG9SZW1vdGVEb2N1bWVudChtdXRhdGlvbiwgZG9jdW1lbnQsIG11dGF0aW9uUmVzdWx0KSB7XG4gICAgaWYgKG11dGF0aW9uIGluc3RhbmNlb2YgU2V0TXV0YXRpb24pIHtcbiAgICAgICAgc2V0TXV0YXRpb25BcHBseVRvUmVtb3RlRG9jdW1lbnQobXV0YXRpb24sIGRvY3VtZW50LCBtdXRhdGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG11dGF0aW9uIGluc3RhbmNlb2YgUGF0Y2hNdXRhdGlvbikge1xuICAgICAgICBwYXRjaE11dGF0aW9uQXBwbHlUb1JlbW90ZURvY3VtZW50KG11dGF0aW9uLCBkb2N1bWVudCwgbXV0YXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGVsZXRlTXV0YXRpb25BcHBseVRvUmVtb3RlRG9jdW1lbnQobXV0YXRpb24sIGRvY3VtZW50LCBtdXRhdGlvblJlc3VsdCk7XG4gICAgfVxufVxuLyoqXG4gKiBBcHBsaWVzIHRoaXMgbXV0YXRpb24gdG8gdGhlIGdpdmVuIGRvY3VtZW50IGZvciB0aGUgcHVycG9zZXMgb2YgY29tcHV0aW5nXG4gKiB0aGUgbmV3IGxvY2FsIHZpZXcgb2YgYSBkb2N1bWVudC4gSWYgdGhlIGlucHV0IGRvY3VtZW50IGRvZXNuJ3QgbWF0Y2ggdGhlXG4gKiBleHBlY3RlZCBzdGF0ZSwgdGhlIGRvY3VtZW50IGlzIG5vdCBtb2RpZmllZC5cbiAqXG4gKiBAcGFyYW0gbXV0YXRpb24gLSBUaGUgbXV0YXRpb24gdG8gYXBwbHkuXG4gKiBAcGFyYW0gZG9jdW1lbnQgLSBUaGUgZG9jdW1lbnQgdG8gbXV0YXRlLiBUaGUgaW5wdXQgZG9jdW1lbnQgY2FuIGJlIGFuXG4gKiAgICAgaW52YWxpZCBkb2N1bWVudCBpZiB0aGUgY2xpZW50IGhhcyBubyBrbm93bGVkZ2Ugb2YgdGhlIHByZS1tdXRhdGlvbiBzdGF0ZVxuICogICAgIG9mIHRoZSBkb2N1bWVudC5cbiAqIEBwYXJhbSBwcmV2aW91c01hc2sgLSBUaGUgZmllbGRzIHRoYXQgaGF2ZSBiZWVuIHVwZGF0ZWQgYmVmb3JlIGFwcGx5aW5nIHRoaXMgbXV0YXRpb24uXG4gKiBAcGFyYW0gbG9jYWxXcml0ZVRpbWUgLSBBIHRpbWVzdGFtcCBpbmRpY2F0aW5nIHRoZSBsb2NhbCB3cml0ZSB0aW1lIG9mIHRoZVxuICogICAgIGJhdGNoIHRoaXMgbXV0YXRpb24gaXMgYSBwYXJ0IG9mLlxuICogQHJldHVybnMgQSBgRmllbGRNYXNrYCByZXByZXNlbnRpbmcgdGhlIGZpZWxkcyB0aGF0IGFyZSBjaGFuZ2VkIGJ5IGFwcGx5aW5nIHRoaXMgbXV0YXRpb24uXG4gKi9cbmZ1bmN0aW9uIG11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhtdXRhdGlvbiwgZG9jdW1lbnQsIHByZXZpb3VzTWFzaywgbG9jYWxXcml0ZVRpbWUpIHtcbiAgICBpZiAobXV0YXRpb24gaW5zdGFuY2VvZiBTZXRNdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gc2V0TXV0YXRpb25BcHBseVRvTG9jYWxWaWV3KG11dGF0aW9uLCBkb2N1bWVudCwgcHJldmlvdXNNYXNrLCBsb2NhbFdyaXRlVGltZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG11dGF0aW9uIGluc3RhbmNlb2YgUGF0Y2hNdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gcGF0Y2hNdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcobXV0YXRpb24sIGRvY3VtZW50LCBwcmV2aW91c01hc2ssIGxvY2FsV3JpdGVUaW1lKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWxldGVNdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcobXV0YXRpb24sIGRvY3VtZW50LCBwcmV2aW91c01hc2spO1xuICAgIH1cbn1cbi8qKlxuICogSWYgdGhpcyBtdXRhdGlvbiBpcyBub3QgaWRlbXBvdGVudCwgcmV0dXJucyB0aGUgYmFzZSB2YWx1ZSB0byBwZXJzaXN0IHdpdGhcbiAqIHRoaXMgbXV0YXRpb24uIElmIGEgYmFzZSB2YWx1ZSBpcyByZXR1cm5lZCwgdGhlIG11dGF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkXG4gKiB0byB0aGlzIGJhc2UgdmFsdWUsIGV2ZW4gaWYgZG9jdW1lbnQgaGFzIGFscmVhZHkgYmVlbiB1cGRhdGVkLlxuICpcbiAqIFRoZSBiYXNlIHZhbHVlIGlzIGEgc3BhcnNlIG9iamVjdCB0aGF0IGNvbnNpc3RzIG9mIG9ubHkgdGhlIGRvY3VtZW50XG4gKiBmaWVsZHMgZm9yIHdoaWNoIHRoaXMgbXV0YXRpb24gY29udGFpbnMgYSBub24taWRlbXBvdGVudCB0cmFuc2Zvcm1hdGlvblxuICogKGUuZy4gYSBudW1lcmljIGluY3JlbWVudCkuIFRoZSBwcm92aWRlZCB2YWx1ZSBndWFyYW50ZWVzIGNvbnNpc3RlbnRcbiAqIGJlaGF2aW9yIGZvciBub24taWRlbXBvdGVudCB0cmFuc2Zvcm1zIGFuZCBhbGxvdyB1cyB0byByZXR1cm4gdGhlIHNhbWVcbiAqIGxhdGVuY3ktY29tcGVuc2F0ZWQgdmFsdWUgZXZlbiBpZiB0aGUgYmFja2VuZCBoYXMgYWxyZWFkeSBhcHBsaWVkIHRoZVxuICogbXV0YXRpb24uIFRoZSBiYXNlIHZhbHVlIGlzIG51bGwgZm9yIGlkZW1wb3RlbnQgbXV0YXRpb25zLCBhcyB0aGV5IGNhbiBiZVxuICogcmUtcGxheWVkIGV2ZW4gaWYgdGhlIGJhY2tlbmQgaGFzIGFscmVhZHkgYXBwbGllZCB0aGVtLlxuICpcbiAqIEByZXR1cm5zIGEgYmFzZSB2YWx1ZSB0byBzdG9yZSBhbG9uZyB3aXRoIHRoZSBtdXRhdGlvbiwgb3IgbnVsbCBmb3JcbiAqIGlkZW1wb3RlbnQgbXV0YXRpb25zLlxuICovXG5mdW5jdGlvbiBtdXRhdGlvbkV4dHJhY3RCYXNlVmFsdWUobXV0YXRpb24sIGRvY3VtZW50KSB7XG4gICAgbGV0IGJhc2VPYmplY3QgPSBudWxsO1xuICAgIGZvciAoY29uc3QgZmllbGRUcmFuc2Zvcm0gb2YgbXV0YXRpb24uZmllbGRUcmFuc2Zvcm1zKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVmFsdWUgPSBkb2N1bWVudC5kYXRhLmZpZWxkKGZpZWxkVHJhbnNmb3JtLmZpZWxkKTtcbiAgICAgICAgY29uc3QgY29lcmNlZFZhbHVlID0gY29tcHV0ZVRyYW5zZm9ybU9wZXJhdGlvbkJhc2VWYWx1ZShmaWVsZFRyYW5zZm9ybS50cmFuc2Zvcm0sIGV4aXN0aW5nVmFsdWUgfHwgbnVsbCk7XG4gICAgICAgIGlmIChjb2VyY2VkVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGJhc2VPYmplY3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBiYXNlT2JqZWN0ID0gT2JqZWN0VmFsdWUuZW1wdHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJhc2VPYmplY3Quc2V0KGZpZWxkVHJhbnNmb3JtLmZpZWxkLCBjb2VyY2VkVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiYXNlT2JqZWN0ID8gYmFzZU9iamVjdCA6IG51bGw7XG59XG5mdW5jdGlvbiBtdXRhdGlvbkVxdWFscyhsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgIT09IHJpZ2h0LnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWxlZnQua2V5LmlzRXF1YWwocmlnaHQua2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghbGVmdC5wcmVjb25kaXRpb24uaXNFcXVhbChyaWdodC5wcmVjb25kaXRpb24pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFmaWVsZFRyYW5zZm9ybXNBcmVFcXVhbChsZWZ0LmZpZWxkVHJhbnNmb3JtcywgcmlnaHQuZmllbGRUcmFuc2Zvcm1zKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsZWZ0LnR5cGUgPT09IDAgLyogTXV0YXRpb25UeXBlLlNldCAqLykge1xuICAgICAgICByZXR1cm4gbGVmdC52YWx1ZS5pc0VxdWFsKHJpZ2h0LnZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gMSAvKiBNdXRhdGlvblR5cGUuUGF0Y2ggKi8pIHtcbiAgICAgICAgcmV0dXJuIChsZWZ0LmRhdGEuaXNFcXVhbChyaWdodC5kYXRhKSAmJlxuICAgICAgICAgICAgbGVmdC5maWVsZE1hc2suaXNFcXVhbChyaWdodC5maWVsZE1hc2spKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEEgbXV0YXRpb24gdGhhdCBjcmVhdGVzIG9yIHJlcGxhY2VzIHRoZSBkb2N1bWVudCBhdCB0aGUgZ2l2ZW4ga2V5IHdpdGggdGhlXG4gKiBvYmplY3QgdmFsdWUgY29udGVudHMuXG4gKi9cbmNsYXNzIFNldE11dGF0aW9uIGV4dGVuZHMgTXV0YXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgdmFsdWUsIHByZWNvbmRpdGlvbiwgZmllbGRUcmFuc2Zvcm1zID0gW10pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5wcmVjb25kaXRpb24gPSBwcmVjb25kaXRpb247XG4gICAgICAgIHRoaXMuZmllbGRUcmFuc2Zvcm1zID0gZmllbGRUcmFuc2Zvcm1zO1xuICAgICAgICB0aGlzLnR5cGUgPSAwIC8qIE11dGF0aW9uVHlwZS5TZXQgKi87XG4gICAgfVxuICAgIGdldEZpZWxkTWFzaygpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0TXV0YXRpb25BcHBseVRvUmVtb3RlRG9jdW1lbnQobXV0YXRpb24sIGRvY3VtZW50LCBtdXRhdGlvblJlc3VsdCkge1xuICAgIC8vIFVubGlrZSBzZXRNdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcsIGlmIHdlJ3JlIGFwcGx5aW5nIGEgbXV0YXRpb24gdG8gYVxuICAgIC8vIHJlbW90ZSBkb2N1bWVudCB0aGUgc2VydmVyIGhhcyBhY2NlcHRlZCB0aGUgbXV0YXRpb24gc28gdGhlIHByZWNvbmRpdGlvblxuICAgIC8vIG11c3QgaGF2ZSBoZWxkLlxuICAgIGNvbnN0IG5ld0RhdGEgPSBtdXRhdGlvbi52YWx1ZS5jbG9uZSgpO1xuICAgIGNvbnN0IHRyYW5zZm9ybVJlc3VsdHMgPSBzZXJ2ZXJUcmFuc2Zvcm1SZXN1bHRzKG11dGF0aW9uLmZpZWxkVHJhbnNmb3JtcywgZG9jdW1lbnQsIG11dGF0aW9uUmVzdWx0LnRyYW5zZm9ybVJlc3VsdHMpO1xuICAgIG5ld0RhdGEuc2V0QWxsKHRyYW5zZm9ybVJlc3VsdHMpO1xuICAgIGRvY3VtZW50XG4gICAgICAgIC5jb252ZXJ0VG9Gb3VuZERvY3VtZW50KG11dGF0aW9uUmVzdWx0LnZlcnNpb24sIG5ld0RhdGEpXG4gICAgICAgIC5zZXRIYXNDb21taXR0ZWRNdXRhdGlvbnMoKTtcbn1cbmZ1bmN0aW9uIHNldE11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhtdXRhdGlvbiwgZG9jdW1lbnQsIHByZXZpb3VzTWFzaywgbG9jYWxXcml0ZVRpbWUpIHtcbiAgICBpZiAoIXByZWNvbmRpdGlvbklzVmFsaWRGb3JEb2N1bWVudChtdXRhdGlvbi5wcmVjb25kaXRpb24sIGRvY3VtZW50KSkge1xuICAgICAgICAvLyBUaGUgbXV0YXRpb24gZmFpbGVkIHRvIGFwcGx5IChlLmcuIGEgZG9jdW1lbnQgSUQgY3JlYXRlZCB3aXRoIGFkZCgpXG4gICAgICAgIC8vIGNhdXNlZCBhIG5hbWUgY29sbGlzaW9uKS5cbiAgICAgICAgcmV0dXJuIHByZXZpb3VzTWFzaztcbiAgICB9XG4gICAgY29uc3QgbmV3RGF0YSA9IG11dGF0aW9uLnZhbHVlLmNsb25lKCk7XG4gICAgY29uc3QgdHJhbnNmb3JtUmVzdWx0cyA9IGxvY2FsVHJhbnNmb3JtUmVzdWx0cyhtdXRhdGlvbi5maWVsZFRyYW5zZm9ybXMsIGxvY2FsV3JpdGVUaW1lLCBkb2N1bWVudCk7XG4gICAgbmV3RGF0YS5zZXRBbGwodHJhbnNmb3JtUmVzdWx0cyk7XG4gICAgZG9jdW1lbnRcbiAgICAgICAgLmNvbnZlcnRUb0ZvdW5kRG9jdW1lbnQoZG9jdW1lbnQudmVyc2lvbiwgbmV3RGF0YSlcbiAgICAgICAgLnNldEhhc0xvY2FsTXV0YXRpb25zKCk7XG4gICAgcmV0dXJuIG51bGw7IC8vIFNldE11dGF0aW9uIG92ZXJ3cml0ZXMgYWxsIGZpZWxkcy5cbn1cbi8qKlxuICogQSBtdXRhdGlvbiB0aGF0IG1vZGlmaWVzIGZpZWxkcyBvZiB0aGUgZG9jdW1lbnQgYXQgdGhlIGdpdmVuIGtleSB3aXRoIHRoZVxuICogZ2l2ZW4gdmFsdWVzLiBUaGUgdmFsdWVzIGFyZSBhcHBsaWVkIHRocm91Z2ggYSBmaWVsZCBtYXNrOlxuICpcbiAqICAqIFdoZW4gYSBmaWVsZCBpcyBpbiBib3RoIHRoZSBtYXNrIGFuZCB0aGUgdmFsdWVzLCB0aGUgY29ycmVzcG9uZGluZyBmaWVsZFxuICogICAgaXMgdXBkYXRlZC5cbiAqICAqIFdoZW4gYSBmaWVsZCBpcyBpbiBuZWl0aGVyIHRoZSBtYXNrIG5vciB0aGUgdmFsdWVzLCB0aGUgY29ycmVzcG9uZGluZ1xuICogICAgZmllbGQgaXMgdW5tb2RpZmllZC5cbiAqICAqIFdoZW4gYSBmaWVsZCBpcyBpbiB0aGUgbWFzayBidXQgbm90IGluIHRoZSB2YWx1ZXMsIHRoZSBjb3JyZXNwb25kaW5nIGZpZWxkXG4gKiAgICBpcyBkZWxldGVkLlxuICogICogV2hlbiBhIGZpZWxkIGlzIG5vdCBpbiB0aGUgbWFzayBidXQgaXMgaW4gdGhlIHZhbHVlcywgdGhlIHZhbHVlcyBtYXAgaXNcbiAqICAgIGlnbm9yZWQuXG4gKi9cbmNsYXNzIFBhdGNoTXV0YXRpb24gZXh0ZW5kcyBNdXRhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCBkYXRhLCBmaWVsZE1hc2ssIHByZWNvbmRpdGlvbiwgZmllbGRUcmFuc2Zvcm1zID0gW10pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuZmllbGRNYXNrID0gZmllbGRNYXNrO1xuICAgICAgICB0aGlzLnByZWNvbmRpdGlvbiA9IHByZWNvbmRpdGlvbjtcbiAgICAgICAgdGhpcy5maWVsZFRyYW5zZm9ybXMgPSBmaWVsZFRyYW5zZm9ybXM7XG4gICAgICAgIHRoaXMudHlwZSA9IDEgLyogTXV0YXRpb25UeXBlLlBhdGNoICovO1xuICAgIH1cbiAgICBnZXRGaWVsZE1hc2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkTWFzaztcbiAgICB9XG59XG5mdW5jdGlvbiBwYXRjaE11dGF0aW9uQXBwbHlUb1JlbW90ZURvY3VtZW50KG11dGF0aW9uLCBkb2N1bWVudCwgbXV0YXRpb25SZXN1bHQpIHtcbiAgICBpZiAoIXByZWNvbmRpdGlvbklzVmFsaWRGb3JEb2N1bWVudChtdXRhdGlvbi5wcmVjb25kaXRpb24sIGRvY3VtZW50KSkge1xuICAgICAgICAvLyBTaW5jZSB0aGUgbXV0YXRpb24gd2FzIG5vdCByZWplY3RlZCwgd2Uga25vdyB0aGF0IHRoZSBwcmVjb25kaXRpb25cbiAgICAgICAgLy8gbWF0Y2hlZCBvbiB0aGUgYmFja2VuZC4gV2UgdGhlcmVmb3JlIG11c3Qgbm90IGhhdmUgdGhlIGV4cGVjdGVkIHZlcnNpb25cbiAgICAgICAgLy8gb2YgdGhlIGRvY3VtZW50IGluIG91ciBjYWNoZSBhbmQgY29udmVydCB0byBhbiBVbmtub3duRG9jdW1lbnQgd2l0aCBhXG4gICAgICAgIC8vIGtub3duIHVwZGF0ZVRpbWUuXG4gICAgICAgIGRvY3VtZW50LmNvbnZlcnRUb1Vua25vd25Eb2N1bWVudChtdXRhdGlvblJlc3VsdC52ZXJzaW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc2Zvcm1SZXN1bHRzID0gc2VydmVyVHJhbnNmb3JtUmVzdWx0cyhtdXRhdGlvbi5maWVsZFRyYW5zZm9ybXMsIGRvY3VtZW50LCBtdXRhdGlvblJlc3VsdC50cmFuc2Zvcm1SZXN1bHRzKTtcbiAgICBjb25zdCBuZXdEYXRhID0gZG9jdW1lbnQuZGF0YTtcbiAgICBuZXdEYXRhLnNldEFsbChnZXRQYXRjaChtdXRhdGlvbikpO1xuICAgIG5ld0RhdGEuc2V0QWxsKHRyYW5zZm9ybVJlc3VsdHMpO1xuICAgIGRvY3VtZW50XG4gICAgICAgIC5jb252ZXJ0VG9Gb3VuZERvY3VtZW50KG11dGF0aW9uUmVzdWx0LnZlcnNpb24sIG5ld0RhdGEpXG4gICAgICAgIC5zZXRIYXNDb21taXR0ZWRNdXRhdGlvbnMoKTtcbn1cbmZ1bmN0aW9uIHBhdGNoTXV0YXRpb25BcHBseVRvTG9jYWxWaWV3KG11dGF0aW9uLCBkb2N1bWVudCwgcHJldmlvdXNNYXNrLCBsb2NhbFdyaXRlVGltZSkge1xuICAgIGlmICghcHJlY29uZGl0aW9uSXNWYWxpZEZvckRvY3VtZW50KG11dGF0aW9uLnByZWNvbmRpdGlvbiwgZG9jdW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBwcmV2aW91c01hc2s7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zZm9ybVJlc3VsdHMgPSBsb2NhbFRyYW5zZm9ybVJlc3VsdHMobXV0YXRpb24uZmllbGRUcmFuc2Zvcm1zLCBsb2NhbFdyaXRlVGltZSwgZG9jdW1lbnQpO1xuICAgIGNvbnN0IG5ld0RhdGEgPSBkb2N1bWVudC5kYXRhO1xuICAgIG5ld0RhdGEuc2V0QWxsKGdldFBhdGNoKG11dGF0aW9uKSk7XG4gICAgbmV3RGF0YS5zZXRBbGwodHJhbnNmb3JtUmVzdWx0cyk7XG4gICAgZG9jdW1lbnRcbiAgICAgICAgLmNvbnZlcnRUb0ZvdW5kRG9jdW1lbnQoZG9jdW1lbnQudmVyc2lvbiwgbmV3RGF0YSlcbiAgICAgICAgLnNldEhhc0xvY2FsTXV0YXRpb25zKCk7XG4gICAgaWYgKHByZXZpb3VzTWFzayA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHByZXZpb3VzTWFza1xuICAgICAgICAudW5pb25XaXRoKG11dGF0aW9uLmZpZWxkTWFzay5maWVsZHMpXG4gICAgICAgIC51bmlvbldpdGgobXV0YXRpb24uZmllbGRUcmFuc2Zvcm1zLm1hcCh0cmFuc2Zvcm0gPT4gdHJhbnNmb3JtLmZpZWxkKSk7XG59XG4vKipcbiAqIFJldHVybnMgYSBGaWVsZFBhdGgvVmFsdWUgbWFwIHdpdGggdGhlIGNvbnRlbnQgb2YgdGhlIFBhdGNoTXV0YXRpb24uXG4gKi9cbmZ1bmN0aW9uIGdldFBhdGNoKG11dGF0aW9uKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICAgIG11dGF0aW9uLmZpZWxkTWFzay5maWVsZHMuZm9yRWFjaChmaWVsZFBhdGggPT4ge1xuICAgICAgICBpZiAoIWZpZWxkUGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gbXV0YXRpb24uZGF0YS5maWVsZChmaWVsZFBhdGgpO1xuICAgICAgICAgICAgcmVzdWx0LnNldChmaWVsZFBhdGgsIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBsaXN0IG9mIFwidHJhbnNmb3JtIHJlc3VsdHNcIiAoYSB0cmFuc2Zvcm0gcmVzdWx0IGlzIGEgZmllbGQgdmFsdWVcbiAqIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGEgdHJhbnNmb3JtKSBmb3IgdXNlIGFmdGVyIGEgbXV0YXRpb25cbiAqIGNvbnRhaW5pbmcgdHJhbnNmb3JtcyBoYXMgYmVlbiBhY2tub3dsZWRnZWQgYnkgdGhlIHNlcnZlci5cbiAqXG4gKiBAcGFyYW0gZmllbGRUcmFuc2Zvcm1zIC0gVGhlIGZpZWxkIHRyYW5zZm9ybXMgdG8gYXBwbHkgdGhlIHJlc3VsdCB0by5cbiAqIEBwYXJhbSBtdXRhYmxlRG9jdW1lbnQgLSBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZG9jdW1lbnQgYWZ0ZXIgYXBwbHlpbmcgYWxsXG4gKiBwcmV2aW91cyBtdXRhdGlvbnMuXG4gKiBAcGFyYW0gc2VydmVyVHJhbnNmb3JtUmVzdWx0cyAtIFRoZSB0cmFuc2Zvcm0gcmVzdWx0cyByZWNlaXZlZCBieSB0aGUgc2VydmVyLlxuICogQHJldHVybnMgVGhlIHRyYW5zZm9ybSByZXN1bHRzIGxpc3QuXG4gKi9cbmZ1bmN0aW9uIHNlcnZlclRyYW5zZm9ybVJlc3VsdHMoZmllbGRUcmFuc2Zvcm1zLCBtdXRhYmxlRG9jdW1lbnQsIHNlcnZlclRyYW5zZm9ybVJlc3VsdHMpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm1SZXN1bHRzID0gbmV3IE1hcCgpO1xuICAgIGhhcmRBc3NlcnQoZmllbGRUcmFuc2Zvcm1zLmxlbmd0aCA9PT0gc2VydmVyVHJhbnNmb3JtUmVzdWx0cy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VydmVyVHJhbnNmb3JtUmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBmaWVsZFRyYW5zZm9ybSA9IGZpZWxkVHJhbnNmb3Jtc1tpXTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gZmllbGRUcmFuc2Zvcm0udHJhbnNmb3JtO1xuICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gbXV0YWJsZURvY3VtZW50LmRhdGEuZmllbGQoZmllbGRUcmFuc2Zvcm0uZmllbGQpO1xuICAgICAgICB0cmFuc2Zvcm1SZXN1bHRzLnNldChmaWVsZFRyYW5zZm9ybS5maWVsZCwgYXBwbHlUcmFuc2Zvcm1PcGVyYXRpb25Ub1JlbW90ZURvY3VtZW50KHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSwgc2VydmVyVHJhbnNmb3JtUmVzdWx0c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNmb3JtUmVzdWx0cztcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGxpc3Qgb2YgXCJ0cmFuc2Zvcm0gcmVzdWx0c1wiIChhIHRyYW5zZm9ybSByZXN1bHQgaXMgYSBmaWVsZCB2YWx1ZVxuICogcmVwcmVzZW50aW5nIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYSB0cmFuc2Zvcm0pIGZvciB1c2Ugd2hlbiBhcHBseWluZyBhXG4gKiB0cmFuc2Zvcm0gbG9jYWxseS5cbiAqXG4gKiBAcGFyYW0gZmllbGRUcmFuc2Zvcm1zIC0gVGhlIGZpZWxkIHRyYW5zZm9ybXMgdG8gYXBwbHkgdGhlIHJlc3VsdCB0by5cbiAqIEBwYXJhbSBsb2NhbFdyaXRlVGltZSAtIFRoZSBsb2NhbCB0aW1lIG9mIHRoZSBtdXRhdGlvbiAodXNlZCB0b1xuICogICAgIGdlbmVyYXRlIFNlcnZlclRpbWVzdGFtcFZhbHVlcykuXG4gKiBAcGFyYW0gbXV0YWJsZURvY3VtZW50IC0gVGhlIGRvY3VtZW50IHRvIGFwcGx5IHRyYW5zZm9ybXMgb24uXG4gKiBAcmV0dXJucyBUaGUgdHJhbnNmb3JtIHJlc3VsdHMgbGlzdC5cbiAqL1xuZnVuY3Rpb24gbG9jYWxUcmFuc2Zvcm1SZXN1bHRzKGZpZWxkVHJhbnNmb3JtcywgbG9jYWxXcml0ZVRpbWUsIG11dGFibGVEb2N1bWVudCkge1xuICAgIGNvbnN0IHRyYW5zZm9ybVJlc3VsdHMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBmaWVsZFRyYW5zZm9ybSBvZiBmaWVsZFRyYW5zZm9ybXMpIHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gZmllbGRUcmFuc2Zvcm0udHJhbnNmb3JtO1xuICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gbXV0YWJsZURvY3VtZW50LmRhdGEuZmllbGQoZmllbGRUcmFuc2Zvcm0uZmllbGQpO1xuICAgICAgICB0cmFuc2Zvcm1SZXN1bHRzLnNldChmaWVsZFRyYW5zZm9ybS5maWVsZCwgYXBwbHlUcmFuc2Zvcm1PcGVyYXRpb25Ub0xvY2FsVmlldyh0cmFuc2Zvcm0sIHByZXZpb3VzVmFsdWUsIGxvY2FsV3JpdGVUaW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2Zvcm1SZXN1bHRzO1xufVxuLyoqIEEgbXV0YXRpb24gdGhhdCBkZWxldGVzIHRoZSBkb2N1bWVudCBhdCB0aGUgZ2l2ZW4ga2V5LiAqL1xuY2xhc3MgRGVsZXRlTXV0YXRpb24gZXh0ZW5kcyBNdXRhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCBwcmVjb25kaXRpb24pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMucHJlY29uZGl0aW9uID0gcHJlY29uZGl0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAyIC8qIE11dGF0aW9uVHlwZS5EZWxldGUgKi87XG4gICAgICAgIHRoaXMuZmllbGRUcmFuc2Zvcm1zID0gW107XG4gICAgfVxuICAgIGdldEZpZWxkTWFzaygpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVsZXRlTXV0YXRpb25BcHBseVRvUmVtb3RlRG9jdW1lbnQobXV0YXRpb24sIGRvY3VtZW50LCBtdXRhdGlvblJlc3VsdCkge1xuICAgIC8vIFVubGlrZSBhcHBseVRvTG9jYWxWaWV3LCBpZiB3ZSdyZSBhcHBseWluZyBhIG11dGF0aW9uIHRvIGEgcmVtb3RlXG4gICAgLy8gZG9jdW1lbnQgdGhlIHNlcnZlciBoYXMgYWNjZXB0ZWQgdGhlIG11dGF0aW9uIHNvIHRoZSBwcmVjb25kaXRpb24gbXVzdFxuICAgIC8vIGhhdmUgaGVsZC5cbiAgICBkb2N1bWVudFxuICAgICAgICAuY29udmVydFRvTm9Eb2N1bWVudChtdXRhdGlvblJlc3VsdC52ZXJzaW9uKVxuICAgICAgICAuc2V0SGFzQ29tbWl0dGVkTXV0YXRpb25zKCk7XG59XG5mdW5jdGlvbiBkZWxldGVNdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcobXV0YXRpb24sIGRvY3VtZW50LCBwcmV2aW91c01hc2spIHtcbiAgICBpZiAocHJlY29uZGl0aW9uSXNWYWxpZEZvckRvY3VtZW50KG11dGF0aW9uLnByZWNvbmRpdGlvbiwgZG9jdW1lbnQpKSB7XG4gICAgICAgIGRvY3VtZW50LmNvbnZlcnRUb05vRG9jdW1lbnQoZG9jdW1lbnQudmVyc2lvbikuc2V0SGFzTG9jYWxNdXRhdGlvbnMoKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBwcmV2aW91c01hc2s7XG59XG4vKipcbiAqIEEgbXV0YXRpb24gdGhhdCB2ZXJpZmllcyB0aGUgZXhpc3RlbmNlIG9mIHRoZSBkb2N1bWVudCBhdCB0aGUgZ2l2ZW4ga2V5IHdpdGhcbiAqIHRoZSBwcm92aWRlZCBwcmVjb25kaXRpb24uXG4gKlxuICogVGhlIGB2ZXJpZnlgIG9wZXJhdGlvbiBpcyBvbmx5IHVzZWQgaW4gVHJhbnNhY3Rpb25zLCBhbmQgdGhpcyBjbGFzcyBzZXJ2ZXNcbiAqIHByaW1hcmlseSB0byBmYWNpbGl0YXRlIHNlcmlhbGl6YXRpb24gaW50byBwcm90b3MuXG4gKi9cbmNsYXNzIFZlcmlmeU11dGF0aW9uIGV4dGVuZHMgTXV0YXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgcHJlY29uZGl0aW9uKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnByZWNvbmRpdGlvbiA9IHByZWNvbmRpdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gMyAvKiBNdXRhdGlvblR5cGUuVmVyaWZ5ICovO1xuICAgICAgICB0aGlzLmZpZWxkVHJhbnNmb3JtcyA9IFtdO1xuICAgIH1cbiAgICBnZXRGaWVsZE1hc2soKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSBiYXRjaCBvZiBtdXRhdGlvbnMgdGhhdCB3aWxsIGJlIHNlbnQgYXMgb25lIHVuaXQgdG8gdGhlIGJhY2tlbmQuXG4gKi9cbmNsYXNzIE11dGF0aW9uQmF0Y2gge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBiYXRjaElkIC0gVGhlIHVuaXF1ZSBJRCBvZiB0aGlzIG11dGF0aW9uIGJhdGNoLlxuICAgICAqIEBwYXJhbSBsb2NhbFdyaXRlVGltZSAtIFRoZSBvcmlnaW5hbCB3cml0ZSB0aW1lIG9mIHRoaXMgbXV0YXRpb24uXG4gICAgICogQHBhcmFtIGJhc2VNdXRhdGlvbnMgLSBNdXRhdGlvbnMgdGhhdCBhcmUgdXNlZCB0byBwb3B1bGF0ZSB0aGUgYmFzZVxuICAgICAqIHZhbHVlcyB3aGVuIHRoaXMgbXV0YXRpb24gaXMgYXBwbGllZCBsb2NhbGx5LiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvY2FsbHlcbiAgICAgKiBvdmVyd3JpdGUgdmFsdWVzIHRoYXQgYXJlIHBlcnNpc3RlZCBpbiB0aGUgcmVtb3RlIGRvY3VtZW50IGNhY2hlLiBCYXNlXG4gICAgICogbXV0YXRpb25zIGFyZSBuZXZlciBzZW50IHRvIHRoZSBiYWNrZW5kLlxuICAgICAqIEBwYXJhbSBtdXRhdGlvbnMgLSBUaGUgdXNlci1wcm92aWRlZCBtdXRhdGlvbnMgaW4gdGhpcyBtdXRhdGlvbiBiYXRjaC5cbiAgICAgKiBVc2VyLXByb3ZpZGVkIG11dGF0aW9ucyBhcmUgYXBwbGllZCBib3RoIGxvY2FsbHkgYW5kIHJlbW90ZWx5IG9uIHRoZVxuICAgICAqIGJhY2tlbmQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYmF0Y2hJZCwgbG9jYWxXcml0ZVRpbWUsIGJhc2VNdXRhdGlvbnMsIG11dGF0aW9ucykge1xuICAgICAgICB0aGlzLmJhdGNoSWQgPSBiYXRjaElkO1xuICAgICAgICB0aGlzLmxvY2FsV3JpdGVUaW1lID0gbG9jYWxXcml0ZVRpbWU7XG4gICAgICAgIHRoaXMuYmFzZU11dGF0aW9ucyA9IGJhc2VNdXRhdGlvbnM7XG4gICAgICAgIHRoaXMubXV0YXRpb25zID0gbXV0YXRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGFsbCB0aGUgbXV0YXRpb25zIGluIHRoaXMgTXV0YXRpb25CYXRjaCB0byB0aGUgc3BlY2lmaWVkIGRvY3VtZW50XG4gICAgICogdG8gY29tcHV0ZSB0aGUgc3RhdGUgb2YgdGhlIHJlbW90ZSBkb2N1bWVudFxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50IC0gVGhlIGRvY3VtZW50IHRvIGFwcGx5IG11dGF0aW9ucyB0by5cbiAgICAgKiBAcGFyYW0gYmF0Y2hSZXN1bHQgLSBUaGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBNdXRhdGlvbkJhdGNoIHRvIHRoZVxuICAgICAqIGJhY2tlbmQuXG4gICAgICovXG4gICAgYXBwbHlUb1JlbW90ZURvY3VtZW50KGRvY3VtZW50LCBiYXRjaFJlc3VsdCkge1xuICAgICAgICBjb25zdCBtdXRhdGlvblJlc3VsdHMgPSBiYXRjaFJlc3VsdC5tdXRhdGlvblJlc3VsdHM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tdXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG11dGF0aW9uID0gdGhpcy5tdXRhdGlvbnNbaV07XG4gICAgICAgICAgICBpZiAobXV0YXRpb24ua2V5LmlzRXF1YWwoZG9jdW1lbnQua2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG11dGF0aW9uUmVzdWx0ID0gbXV0YXRpb25SZXN1bHRzW2ldO1xuICAgICAgICAgICAgICAgIG11dGF0aW9uQXBwbHlUb1JlbW90ZURvY3VtZW50KG11dGF0aW9uLCBkb2N1bWVudCwgbXV0YXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBsb2NhbCB2aWV3IG9mIGEgZG9jdW1lbnQgZ2l2ZW4gYWxsIHRoZSBtdXRhdGlvbnMgaW4gdGhpc1xuICAgICAqIGJhdGNoLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50IC0gVGhlIGRvY3VtZW50IHRvIGFwcGx5IG11dGF0aW9ucyB0by5cbiAgICAgKiBAcGFyYW0gbXV0YXRlZEZpZWxkcyAtIEZpZWxkcyB0aGF0IGhhdmUgYmVlbiB1cGRhdGVkIGJlZm9yZSBhcHBseWluZyB0aGlzIG11dGF0aW9uIGJhdGNoLlxuICAgICAqIEByZXR1cm5zIEEgYEZpZWxkTWFza2AgcmVwcmVzZW50aW5nIGFsbCB0aGUgZmllbGRzIHRoYXQgYXJlIG11dGF0ZWQuXG4gICAgICovXG4gICAgYXBwbHlUb0xvY2FsVmlldyhkb2N1bWVudCwgbXV0YXRlZEZpZWxkcykge1xuICAgICAgICAvLyBGaXJzdCwgYXBwbHkgdGhlIGJhc2Ugc3RhdGUuIFRoaXMgYWxsb3dzIHVzIHRvIGFwcGx5IG5vbi1pZGVtcG90ZW50XG4gICAgICAgIC8vIHRyYW5zZm9ybSBhZ2FpbnN0IGEgY29uc2lzdGVudCBzZXQgb2YgdmFsdWVzLlxuICAgICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIHRoaXMuYmFzZU11dGF0aW9ucykge1xuICAgICAgICAgICAgaWYgKG11dGF0aW9uLmtleS5pc0VxdWFsKGRvY3VtZW50LmtleSkpIHtcbiAgICAgICAgICAgICAgICBtdXRhdGVkRmllbGRzID0gbXV0YXRpb25BcHBseVRvTG9jYWxWaWV3KG11dGF0aW9uLCBkb2N1bWVudCwgbXV0YXRlZEZpZWxkcywgdGhpcy5sb2NhbFdyaXRlVGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2Vjb25kLCBhcHBseSBhbGwgdXNlci1wcm92aWRlZCBtdXRhdGlvbnMuXG4gICAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgdGhpcy5tdXRhdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChtdXRhdGlvbi5rZXkuaXNFcXVhbChkb2N1bWVudC5rZXkpKSB7XG4gICAgICAgICAgICAgICAgbXV0YXRlZEZpZWxkcyA9IG11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhtdXRhdGlvbiwgZG9jdW1lbnQsIG11dGF0ZWRGaWVsZHMsIHRoaXMubG9jYWxXcml0ZVRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtdXRhdGVkRmllbGRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbG9jYWwgdmlldyBmb3IgYWxsIHByb3ZpZGVkIGRvY3VtZW50cyBnaXZlbiB0aGUgbXV0YXRpb25zIGluXG4gICAgICogdGhpcyBiYXRjaC4gUmV0dXJucyBhIGBEb2N1bWVudEtleWAgdG8gYE11dGF0aW9uYCBtYXAgd2hpY2ggY2FuIGJlIHVzZWQgdG9cbiAgICAgKiByZXBsYWNlIGFsbCB0aGUgbXV0YXRpb24gYXBwbGljYXRpb25zLlxuICAgICAqL1xuICAgIGFwcGx5VG9Mb2NhbERvY3VtZW50U2V0KGRvY3VtZW50TWFwLCBkb2N1bWVudHNXaXRob3V0UmVtb3RlVmVyc2lvbikge1xuICAgICAgICAvLyBUT0RPKG1yc2NobWlkdCk6IFRoaXMgaW1wbGVtZW50YXRpb24gaXMgTyhuXjIpLiBJZiB3ZSBhcHBseSB0aGUgbXV0YXRpb25zXG4gICAgICAgIC8vIGRpcmVjdGx5IChhcyBkb25lIGluIGBhcHBseVRvTG9jYWxWaWV3KClgKSwgd2UgY2FuIHJlZHVjZSB0aGUgY29tcGxleGl0eVxuICAgICAgICAvLyB0byBPKG4pLlxuICAgICAgICBjb25zdCBvdmVybGF5cyA9IG5ld011dGF0aW9uTWFwKCk7XG4gICAgICAgIHRoaXMubXV0YXRpb25zLmZvckVhY2gobSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvdmVybGF5ZWREb2N1bWVudCA9IGRvY3VtZW50TWFwLmdldChtLmtleSk7XG4gICAgICAgICAgICAvLyBUT0RPKG11dGFibGVkb2N1bWVudHMpOiBUaGlzIG1ldGhvZCBzaG91bGQgdGFrZSBhIE11dGFibGVEb2N1bWVudE1hcFxuICAgICAgICAgICAgLy8gYW5kIHdlIHNob3VsZCByZW1vdmUgdGhpcyBjYXN0LlxuICAgICAgICAgICAgY29uc3QgbXV0YWJsZURvY3VtZW50ID0gb3ZlcmxheWVkRG9jdW1lbnQub3ZlcmxheWVkRG9jdW1lbnQ7XG4gICAgICAgICAgICBsZXQgbXV0YXRlZEZpZWxkcyA9IHRoaXMuYXBwbHlUb0xvY2FsVmlldyhtdXRhYmxlRG9jdW1lbnQsIG92ZXJsYXllZERvY3VtZW50Lm11dGF0ZWRGaWVsZHMpO1xuICAgICAgICAgICAgLy8gU2V0IG11dGF0ZWRGaWVsZHMgdG8gbnVsbCBpZiB0aGUgZG9jdW1lbnQgaXMgb25seSBmcm9tIGxvY2FsIG11dGF0aW9ucy5cbiAgICAgICAgICAgIC8vIFRoaXMgY3JlYXRlcyBhIFNldCBvciBEZWxldGUgbXV0YXRpb24sIGluc3RlYWQgb2YgdHJ5aW5nIHRvIGNyZWF0ZSBhXG4gICAgICAgICAgICAvLyBwYXRjaCBtdXRhdGlvbiBhcyB0aGUgb3ZlcmxheS5cbiAgICAgICAgICAgIG11dGF0ZWRGaWVsZHMgPSBkb2N1bWVudHNXaXRob3V0UmVtb3RlVmVyc2lvbi5oYXMobS5rZXkpXG4gICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgOiBtdXRhdGVkRmllbGRzO1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheSA9IGNhbGN1bGF0ZU92ZXJsYXlNdXRhdGlvbihtdXRhYmxlRG9jdW1lbnQsIG11dGF0ZWRGaWVsZHMpO1xuICAgICAgICAgICAgaWYgKG92ZXJsYXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvdmVybGF5cy5zZXQobS5rZXksIG92ZXJsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtdXRhYmxlRG9jdW1lbnQuaXNWYWxpZERvY3VtZW50KCkpIHtcbiAgICAgICAgICAgICAgICBtdXRhYmxlRG9jdW1lbnQuY29udmVydFRvTm9Eb2N1bWVudChTbmFwc2hvdFZlcnNpb24ubWluKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG92ZXJsYXlzO1xuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tdXRhdGlvbnMucmVkdWNlKChrZXlzLCBtKSA9PiBrZXlzLmFkZChtLmtleSksIGRvY3VtZW50S2V5U2V0KCkpO1xuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5iYXRjaElkID09PSBvdGhlci5iYXRjaElkICYmXG4gICAgICAgICAgICBhcnJheUVxdWFscyh0aGlzLm11dGF0aW9ucywgb3RoZXIubXV0YXRpb25zLCAobCwgcikgPT4gbXV0YXRpb25FcXVhbHMobCwgcikpICYmXG4gICAgICAgICAgICBhcnJheUVxdWFscyh0aGlzLmJhc2VNdXRhdGlvbnMsIG90aGVyLmJhc2VNdXRhdGlvbnMsIChsLCByKSA9PiBtdXRhdGlvbkVxdWFscyhsLCByKSkpO1xuICAgIH1cbn1cbi8qKiBUaGUgcmVzdWx0IG9mIGFwcGx5aW5nIGEgbXV0YXRpb24gYmF0Y2ggdG8gdGhlIGJhY2tlbmQuICovXG5jbGFzcyBNdXRhdGlvbkJhdGNoUmVzdWx0IHtcbiAgICBjb25zdHJ1Y3RvcihiYXRjaCwgY29tbWl0VmVyc2lvbiwgbXV0YXRpb25SZXN1bHRzLCBcbiAgICAvKipcbiAgICAgKiBBIHByZS1jb21wdXRlZCBtYXBwaW5nIGZyb20gZWFjaCBtdXRhdGVkIGRvY3VtZW50IHRvIHRoZSByZXN1bHRpbmdcbiAgICAgKiB2ZXJzaW9uLlxuICAgICAqL1xuICAgIGRvY1ZlcnNpb25zKSB7XG4gICAgICAgIHRoaXMuYmF0Y2ggPSBiYXRjaDtcbiAgICAgICAgdGhpcy5jb21taXRWZXJzaW9uID0gY29tbWl0VmVyc2lvbjtcbiAgICAgICAgdGhpcy5tdXRhdGlvblJlc3VsdHMgPSBtdXRhdGlvblJlc3VsdHM7XG4gICAgICAgIHRoaXMuZG9jVmVyc2lvbnMgPSBkb2NWZXJzaW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBNdXRhdGlvbkJhdGNoUmVzdWx0IGZvciB0aGUgZ2l2ZW4gYmF0Y2ggYW5kIHJlc3VsdHMuIFRoZXJlXG4gICAgICogbXVzdCBiZSBvbmUgcmVzdWx0IGZvciBlYWNoIG11dGF0aW9uIGluIHRoZSBiYXRjaC4gVGhpcyBzdGF0aWMgZmFjdG9yeVxuICAgICAqIGNhY2hlcyBhIGRvY3VtZW50PSZndDt2ZXJzaW9uIG1hcHBpbmcgKGRvY1ZlcnNpb25zKS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShiYXRjaCwgY29tbWl0VmVyc2lvbiwgcmVzdWx0cykge1xuICAgICAgICBoYXJkQXNzZXJ0KGJhdGNoLm11dGF0aW9ucy5sZW5ndGggPT09IHJlc3VsdHMubGVuZ3RoKTtcbiAgICAgICAgbGV0IHZlcnNpb25NYXAgPSBkb2N1bWVudFZlcnNpb25NYXAoKTtcbiAgICAgICAgY29uc3QgbXV0YXRpb25zID0gYmF0Y2gubXV0YXRpb25zO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmVyc2lvbk1hcCA9IHZlcnNpb25NYXAuaW5zZXJ0KG11dGF0aW9uc1tpXS5rZXksIHJlc3VsdHNbaV0udmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBNdXRhdGlvbkJhdGNoUmVzdWx0KGJhdGNoLCBjb21taXRWZXJzaW9uLCByZXN1bHRzLCB2ZXJzaW9uTWFwKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIG9mIGFuIG92ZXJsYXkgY29tcHV0ZWQgYnkgRmlyZXN0b3JlLlxuICpcbiAqIEhvbGRzIGluZm9ybWF0aW9uIGFib3V0IGEgbXV0YXRpb24gYW5kIHRoZSBsYXJnZXN0IGJhdGNoIGlkIGluIEZpcmVzdG9yZSB3aGVuXG4gKiB0aGUgbXV0YXRpb24gd2FzIGNyZWF0ZWQuXG4gKi9cbmNsYXNzIE92ZXJsYXkge1xuICAgIGNvbnN0cnVjdG9yKGxhcmdlc3RCYXRjaElkLCBtdXRhdGlvbikge1xuICAgICAgICB0aGlzLmxhcmdlc3RCYXRjaElkID0gbGFyZ2VzdEJhdGNoSWQ7XG4gICAgICAgIHRoaXMubXV0YXRpb24gPSBtdXRhdGlvbjtcbiAgICB9XG4gICAgZ2V0S2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tdXRhdGlvbi5rZXk7XG4gICAgfVxuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyICE9PSBudWxsICYmIHRoaXMubXV0YXRpb24gPT09IG90aGVyLm11dGF0aW9uO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBPdmVybGF5e1xuICAgICAgbGFyZ2VzdEJhdGNoSWQ6ICR7dGhpcy5sYXJnZXN0QmF0Y2hJZH0sXG4gICAgICBtdXRhdGlvbjogJHt0aGlzLm11dGF0aW9uLnRvU3RyaW5nKCl9XG4gICAgfWA7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgRXhpc3RlbmNlRmlsdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb3VudCwgdW5jaGFuZ2VkTmFtZXMpIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50O1xuICAgICAgICB0aGlzLnVuY2hhbmdlZE5hbWVzID0gdW5jaGFuZ2VkTmFtZXM7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBFcnJvciBDb2RlcyBkZXNjcmliaW5nIHRoZSBkaWZmZXJlbnQgd2F5cyBHUlBDIGNhbiBmYWlsLiBUaGVzZSBhcmUgY29waWVkXG4gKiBkaXJlY3RseSBmcm9tIEdSUEMncyBzb3VyY2VzIGhlcmU6XG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy9ibG9iL2JjZWVjOTRlYTRmYzVmMDA4NWQ4MTIzNWQ4ZTFjMDY3OThkYzM0MWEvaW5jbHVkZS9ncnBjJTJCJTJCL2ltcGwvY29kZWdlbi9zdGF0dXNfY29kZV9lbnVtLmhcbiAqXG4gKiBJbXBvcnRhbnQhIFRoZSBuYW1lcyBvZiB0aGVzZSBpZGVudGlmaWVycyBtYXR0ZXIgYmVjYXVzZSB0aGUgc3RyaW5nIGZvcm1zXG4gKiBhcmUgdXNlZCBmb3IgcmV2ZXJzZSBsb29rdXBzIGZyb20gdGhlIHdlYmNoYW5uZWwgc3RyZWFtLiBEbyBOT1QgY2hhbmdlIHRoZVxuICogbmFtZXMgb2YgdGhlc2UgaWRlbnRpZmllcnMgb3IgY2hhbmdlIHRoaXMgaW50byBhIGNvbnN0IGVudW0uXG4gKi9cbnZhciBScGNDb2RlO1xuKGZ1bmN0aW9uIChScGNDb2RlKSB7XG4gICAgUnBjQ29kZVtScGNDb2RlW1wiT0tcIl0gPSAwXSA9IFwiT0tcIjtcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJDQU5DRUxMRURcIl0gPSAxXSA9IFwiQ0FOQ0VMTEVEXCI7XG4gICAgUnBjQ29kZVtScGNDb2RlW1wiVU5LTk9XTlwiXSA9IDJdID0gXCJVTktOT1dOXCI7XG4gICAgUnBjQ29kZVtScGNDb2RlW1wiSU5WQUxJRF9BUkdVTUVOVFwiXSA9IDNdID0gXCJJTlZBTElEX0FSR1VNRU5UXCI7XG4gICAgUnBjQ29kZVtScGNDb2RlW1wiREVBRExJTkVfRVhDRUVERURcIl0gPSA0XSA9IFwiREVBRExJTkVfRVhDRUVERURcIjtcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJOT1RfRk9VTkRcIl0gPSA1XSA9IFwiTk9UX0ZPVU5EXCI7XG4gICAgUnBjQ29kZVtScGNDb2RlW1wiQUxSRUFEWV9FWElTVFNcIl0gPSA2XSA9IFwiQUxSRUFEWV9FWElTVFNcIjtcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJQRVJNSVNTSU9OX0RFTklFRFwiXSA9IDddID0gXCJQRVJNSVNTSU9OX0RFTklFRFwiO1xuICAgIFJwY0NvZGVbUnBjQ29kZVtcIlVOQVVUSEVOVElDQVRFRFwiXSA9IDE2XSA9IFwiVU5BVVRIRU5USUNBVEVEXCI7XG4gICAgUnBjQ29kZVtScGNDb2RlW1wiUkVTT1VSQ0VfRVhIQVVTVEVEXCJdID0gOF0gPSBcIlJFU09VUkNFX0VYSEFVU1RFRFwiO1xuICAgIFJwY0NvZGVbUnBjQ29kZVtcIkZBSUxFRF9QUkVDT05ESVRJT05cIl0gPSA5XSA9IFwiRkFJTEVEX1BSRUNPTkRJVElPTlwiO1xuICAgIFJwY0NvZGVbUnBjQ29kZVtcIkFCT1JURURcIl0gPSAxMF0gPSBcIkFCT1JURURcIjtcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJPVVRfT0ZfUkFOR0VcIl0gPSAxMV0gPSBcIk9VVF9PRl9SQU5HRVwiO1xuICAgIFJwY0NvZGVbUnBjQ29kZVtcIlVOSU1QTEVNRU5URURcIl0gPSAxMl0gPSBcIlVOSU1QTEVNRU5URURcIjtcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJJTlRFUk5BTFwiXSA9IDEzXSA9IFwiSU5URVJOQUxcIjtcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJVTkFWQUlMQUJMRVwiXSA9IDE0XSA9IFwiVU5BVkFJTEFCTEVcIjtcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJEQVRBX0xPU1NcIl0gPSAxNV0gPSBcIkRBVEFfTE9TU1wiO1xufSkoUnBjQ29kZSB8fCAoUnBjQ29kZSA9IHt9KSk7XG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhbiBlcnJvciBjb2RlIHJlcHJlc2VudHMgYSBwZXJtYW5lbnQgZXJyb3Igd2hlbiByZWNlaXZlZFxuICogaW4gcmVzcG9uc2UgdG8gYSBub24td3JpdGUgb3BlcmF0aW9uLlxuICpcbiAqIFNlZSBpc1Blcm1hbmVudFdyaXRlRXJyb3IgZm9yIGNsYXNzaWZ5aW5nIHdyaXRlIGVycm9ycy5cbiAqL1xuZnVuY3Rpb24gaXNQZXJtYW5lbnRFcnJvcihjb2RlKSB7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgIGNhc2UgQ29kZS5PSzpcbiAgICAgICAgICAgIHJldHVybiBmYWlsKCk7XG4gICAgICAgIGNhc2UgQ29kZS5DQU5DRUxMRUQ6XG4gICAgICAgIGNhc2UgQ29kZS5VTktOT1dOOlxuICAgICAgICBjYXNlIENvZGUuREVBRExJTkVfRVhDRUVERUQ6XG4gICAgICAgIGNhc2UgQ29kZS5SRVNPVVJDRV9FWEhBVVNURUQ6XG4gICAgICAgIGNhc2UgQ29kZS5JTlRFUk5BTDpcbiAgICAgICAgY2FzZSBDb2RlLlVOQVZBSUxBQkxFOlxuICAgICAgICAvLyBVbmF1dGhlbnRpY2F0ZWQgbWVhbnMgc29tZXRoaW5nIHdlbnQgd3Jvbmcgd2l0aCBvdXIgdG9rZW4gYW5kIHdlIG5lZWRcbiAgICAgICAgLy8gdG8gcmV0cnkgd2l0aCBuZXcgY3JlZGVudGlhbHMgd2hpY2ggd2lsbCBoYXBwZW4gYXV0b21hdGljYWxseS5cbiAgICAgICAgY2FzZSBDb2RlLlVOQVVUSEVOVElDQVRFRDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY2FzZSBDb2RlLklOVkFMSURfQVJHVU1FTlQ6XG4gICAgICAgIGNhc2UgQ29kZS5OT1RfRk9VTkQ6XG4gICAgICAgIGNhc2UgQ29kZS5BTFJFQURZX0VYSVNUUzpcbiAgICAgICAgY2FzZSBDb2RlLlBFUk1JU1NJT05fREVOSUVEOlxuICAgICAgICBjYXNlIENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTjpcbiAgICAgICAgLy8gQWJvcnRlZCBtaWdodCBiZSByZXRyaWVkIGluIHNvbWUgc2NlbmFyaW9zLCBidXQgdGhhdCBpcyBkZXBlbmRlbnQgb25cbiAgICAgICAgLy8gdGhlIGNvbnRleHQgYW5kIHNob3VsZCBoYW5kbGVkIGluZGl2aWR1YWxseSBieSB0aGUgY2FsbGluZyBjb2RlLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2FwaXMvZGVzaWduL2Vycm9ycy5cbiAgICAgICAgY2FzZSBDb2RlLkFCT1JURUQ6XG4gICAgICAgIGNhc2UgQ29kZS5PVVRfT0ZfUkFOR0U6XG4gICAgICAgIGNhc2UgQ29kZS5VTklNUExFTUVOVEVEOlxuICAgICAgICBjYXNlIENvZGUuREFUQV9MT1NTOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgIH1cbn1cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIGVycm9yIGNvZGUgcmVwcmVzZW50cyBhIHBlcm1hbmVudCBlcnJvciB3aGVuIHJlY2VpdmVkXG4gKiBpbiByZXNwb25zZSB0byBhIHdyaXRlIG9wZXJhdGlvbi5cbiAqXG4gKiBXcml0ZSBvcGVyYXRpb25zIG11c3QgYmUgaGFuZGxlZCBzcGVjaWFsbHkgYmVjYXVzZSBhcyBvZiBiLzExOTQzNzc2NCwgQUJPUlRFRFxuICogZXJyb3JzIG9uIHRoZSB3cml0ZSBzdHJlYW0gc2hvdWxkIGJlIHJldHJpZWQgdG9vIChldmVuIHRob3VnaCBBQk9SVEVEIGVycm9yc1xuICogYXJlIG5vdCBnZW5lcmFsbHkgcmV0cnlhYmxlKS5cbiAqXG4gKiBOb3RlIHRoYXQgZHVyaW5nIHRoZSBpbml0aWFsIGhhbmRzaGFrZSBvbiB0aGUgd3JpdGUgc3RyZWFtIGFuIEFCT1JURUQgZXJyb3JcbiAqIHNpZ25hbHMgdGhhdCB3ZSBzaG91bGQgZGlzY2FyZCBvdXIgc3RyZWFtIHRva2VuIChpLmUuIGl0IGlzIHBlcm1hbmVudCkuIFRoaXNcbiAqIG1lYW5zIGEgaGFuZHNoYWtlIGVycm9yIHNob3VsZCBiZSBjbGFzc2lmaWVkIHdpdGggaXNQZXJtYW5lbnRFcnJvciwgYWJvdmUuXG4gKi9cbmZ1bmN0aW9uIGlzUGVybWFuZW50V3JpdGVFcnJvcihjb2RlKSB7XG4gICAgcmV0dXJuIGlzUGVybWFuZW50RXJyb3IoY29kZSkgJiYgY29kZSAhPT0gQ29kZS5BQk9SVEVEO1xufVxuLyoqXG4gKiBNYXBzIGFuIGVycm9yIENvZGUgZnJvbSBHUlBDIHN0YXR1cyBjb2RlIG51bWJlciwgbGlrZSAwLCAxLCBvciAxNC4gVGhlc2VcbiAqIGFyZSBub3QgdGhlIHNhbWUgYXMgSFRUUCBzdGF0dXMgY29kZXMuXG4gKlxuICogQHJldHVybnMgVGhlIENvZGUgZXF1aXZhbGVudCB0byB0aGUgZ2l2ZW4gR1JQQyBzdGF0dXMgY29kZS4gRmFpbHMgaWYgdGhlcmVcbiAqICAgICBpcyBubyBtYXRjaC5cbiAqL1xuZnVuY3Rpb24gbWFwQ29kZUZyb21ScGNDb2RlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkbid0IG5vcm1hbGx5IGhhcHBlbiwgYnV0IGluIGNlcnRhaW4gZXJyb3IgY2FzZXMgKGxpa2UgdHJ5aW5nXG4gICAgICAgIC8vIHRvIHNlbmQgaW52YWxpZCBwcm90byBtZXNzYWdlcykgd2UgbWF5IGdldCBhbiBlcnJvciB3aXRoIG5vIEdSUEMgY29kZS5cbiAgICAgICAgbG9nRXJyb3IoJ0dSUEMgZXJyb3IgaGFzIG5vIC5jb2RlJyk7XG4gICAgICAgIHJldHVybiBDb2RlLlVOS05PV047XG4gICAgfVxuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICBjYXNlIFJwY0NvZGUuT0s6XG4gICAgICAgICAgICByZXR1cm4gQ29kZS5PSztcbiAgICAgICAgY2FzZSBScGNDb2RlLkNBTkNFTExFRDpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLkNBTkNFTExFRDtcbiAgICAgICAgY2FzZSBScGNDb2RlLlVOS05PV046XG4gICAgICAgICAgICByZXR1cm4gQ29kZS5VTktOT1dOO1xuICAgICAgICBjYXNlIFJwY0NvZGUuREVBRExJTkVfRVhDRUVERUQ6XG4gICAgICAgICAgICByZXR1cm4gQ29kZS5ERUFETElORV9FWENFRURFRDtcbiAgICAgICAgY2FzZSBScGNDb2RlLlJFU09VUkNFX0VYSEFVU1RFRDpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLlJFU09VUkNFX0VYSEFVU1RFRDtcbiAgICAgICAgY2FzZSBScGNDb2RlLklOVEVSTkFMOlxuICAgICAgICAgICAgcmV0dXJuIENvZGUuSU5URVJOQUw7XG4gICAgICAgIGNhc2UgUnBjQ29kZS5VTkFWQUlMQUJMRTpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLlVOQVZBSUxBQkxFO1xuICAgICAgICBjYXNlIFJwY0NvZGUuVU5BVVRIRU5USUNBVEVEOlxuICAgICAgICAgICAgcmV0dXJuIENvZGUuVU5BVVRIRU5USUNBVEVEO1xuICAgICAgICBjYXNlIFJwY0NvZGUuSU5WQUxJRF9BUkdVTUVOVDpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLklOVkFMSURfQVJHVU1FTlQ7XG4gICAgICAgIGNhc2UgUnBjQ29kZS5OT1RfRk9VTkQ6XG4gICAgICAgICAgICByZXR1cm4gQ29kZS5OT1RfRk9VTkQ7XG4gICAgICAgIGNhc2UgUnBjQ29kZS5BTFJFQURZX0VYSVNUUzpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLkFMUkVBRFlfRVhJU1RTO1xuICAgICAgICBjYXNlIFJwY0NvZGUuUEVSTUlTU0lPTl9ERU5JRUQ6XG4gICAgICAgICAgICByZXR1cm4gQ29kZS5QRVJNSVNTSU9OX0RFTklFRDtcbiAgICAgICAgY2FzZSBScGNDb2RlLkZBSUxFRF9QUkVDT05ESVRJT046XG4gICAgICAgICAgICByZXR1cm4gQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OO1xuICAgICAgICBjYXNlIFJwY0NvZGUuQUJPUlRFRDpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLkFCT1JURUQ7XG4gICAgICAgIGNhc2UgUnBjQ29kZS5PVVRfT0ZfUkFOR0U6XG4gICAgICAgICAgICByZXR1cm4gQ29kZS5PVVRfT0ZfUkFOR0U7XG4gICAgICAgIGNhc2UgUnBjQ29kZS5VTklNUExFTUVOVEVEOlxuICAgICAgICAgICAgcmV0dXJuIENvZGUuVU5JTVBMRU1FTlRFRDtcbiAgICAgICAgY2FzZSBScGNDb2RlLkRBVEFfTE9TUzpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLkRBVEFfTE9TUztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWlsKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBbiBlcnJvciBlbmNvdW50ZXJlZCB3aGlsZSBkZWNvZGluZyBiYXNlNjQgc3RyaW5nLlxuICovXG5jbGFzcyBCYXNlNjREZWNvZGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0Jhc2U2NERlY29kZUVycm9yJztcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFRoZSBnbG9iYWwsIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBUZXN0aW5nSG9va3NTcGkuXG4gKlxuICogVGhpcyB2YXJpYWJsZSB3aWxsIGJlIGBudWxsYCBpbiBhbGwgY2FzZXMgX2V4Y2VwdF8gd2hlbiBydW5uaW5nIGZyb21cbiAqIGludGVncmF0aW9uIHRlc3RzIHRoYXQgaGF2ZSByZWdpc3RlcmVkIGNhbGxiYWNrcyB0byBiZSBub3RpZmllZCBvZiBldmVudHNcbiAqIHRoYXQgaGFwcGVuIGR1cmluZyB0aGUgdGVzdCBleGVjdXRpb24uXG4gKi9cbmxldCB0ZXN0aW5nSG9va3NTcGkgPSBudWxsO1xuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgYHRlc3RpbmdIb29rc1NwaWAgb2JqZWN0LlxuICogQHBhcmFtIGluc3RhbmNlIHRoZSBpbnN0YW5jZSB0byBzZXQuXG4gKi9cbmZ1bmN0aW9uIHNldFRlc3RpbmdIb29rc1NwaShpbnN0YW5jZSkge1xuICAgIGlmICh0ZXN0aW5nSG9va3NTcGkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhIFRlc3RpbmdIb29rc1NwaSBpbnN0YW5jZSBpcyBhbHJlYWR5IHNldCcpO1xuICAgIH1cbiAgICB0ZXN0aW5nSG9va3NTcGkgPSBpbnN0YW5jZTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgdGhlIFBsYXRmb3JtJ3MgJ1RleHRFbmNvZGVyJyBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gbmV3VGV4dEVuY29kZXIoKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpO1xufVxuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiB0aGUgUGxhdGZvcm0ncyAnVGV4dERlY29kZXInIGltcGxlbWVudGF0aW9uLlxuICovXG5mdW5jdGlvbiBuZXdUZXh0RGVjb2RlcigpIHtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgTUFYXzY0X0JJVF9VTlNJR05FRF9JTlRFR0VSID0gbmV3IEludGVnZXIoWzB4ZmZmZmZmZmYsIDB4ZmZmZmZmZmZdLCAwKTtcbi8vIEhhc2ggYSBzdHJpbmcgdXNpbmcgbWQ1IGhhc2hpbmcgYWxnb3JpdGhtLlxuZnVuY3Rpb24gZ2V0TWQ1SGFzaFZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgZW5jb2RlZFZhbHVlID0gbmV3VGV4dEVuY29kZXIoKS5lbmNvZGUodmFsdWUpO1xuICAgIGNvbnN0IG1kNSA9IG5ldyBNZDUoKTtcbiAgICBtZDUudXBkYXRlKGVuY29kZWRWYWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG1kNS5kaWdlc3QoKSk7XG59XG4vLyBJbnRlcnByZXQgdGhlIDE2IGJ5dGVzIGFycmF5IGFzIHR3byA2NC1iaXQgdW5zaWduZWQgaW50ZWdlcnMsIGVuY29kZWQgdXNpbmdcbi8vIDLigJlzIGNvbXBsZW1lbnQgdXNpbmcgbGl0dGxlIGVuZGlhbi5cbmZ1bmN0aW9uIGdldDY0Qml0VWludHMoQnl0ZXMpIHtcbiAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhCeXRlcy5idWZmZXIpO1xuICAgIGNvbnN0IGNodW5rMSA9IGRhdGFWaWV3LmdldFVpbnQzMigwLCAvKiBsaXR0bGVFbmRpYW49ICovIHRydWUpO1xuICAgIGNvbnN0IGNodW5rMiA9IGRhdGFWaWV3LmdldFVpbnQzMig0LCAvKiBsaXR0bGVFbmRpYW49ICovIHRydWUpO1xuICAgIGNvbnN0IGNodW5rMyA9IGRhdGFWaWV3LmdldFVpbnQzMig4LCAvKiBsaXR0bGVFbmRpYW49ICovIHRydWUpO1xuICAgIGNvbnN0IGNodW5rNCA9IGRhdGFWaWV3LmdldFVpbnQzMigxMiwgLyogbGl0dGxlRW5kaWFuPSAqLyB0cnVlKTtcbiAgICBjb25zdCBpbnRlZ2VyMSA9IG5ldyBJbnRlZ2VyKFtjaHVuazEsIGNodW5rMl0sIDApO1xuICAgIGNvbnN0IGludGVnZXIyID0gbmV3IEludGVnZXIoW2NodW5rMywgY2h1bms0XSwgMCk7XG4gICAgcmV0dXJuIFtpbnRlZ2VyMSwgaW50ZWdlcjJdO1xufVxuY2xhc3MgQmxvb21GaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGJpdG1hcCwgcGFkZGluZywgaGFzaENvdW50KSB7XG4gICAgICAgIHRoaXMuYml0bWFwID0gYml0bWFwO1xuICAgICAgICB0aGlzLnBhZGRpbmcgPSBwYWRkaW5nO1xuICAgICAgICB0aGlzLmhhc2hDb3VudCA9IGhhc2hDb3VudDtcbiAgICAgICAgaWYgKHBhZGRpbmcgPCAwIHx8IHBhZGRpbmcgPj0gOCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJsb29tRmlsdGVyRXJyb3IoYEludmFsaWQgcGFkZGluZzogJHtwYWRkaW5nfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNoQ291bnQgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQmxvb21GaWx0ZXJFcnJvcihgSW52YWxpZCBoYXNoIGNvdW50OiAke2hhc2hDb3VudH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYml0bWFwLmxlbmd0aCA+IDAgJiYgdGhpcy5oYXNoQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIC8vIE9ubHkgZW1wdHkgYmxvb20gZmlsdGVyIGNhbiBoYXZlIDAgaGFzaCBjb3VudC5cbiAgICAgICAgICAgIHRocm93IG5ldyBCbG9vbUZpbHRlckVycm9yKGBJbnZhbGlkIGhhc2ggY291bnQ6ICR7aGFzaENvdW50fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaXRtYXAubGVuZ3RoID09PSAwICYmIHBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgICAgIC8vIEVtcHR5IGJsb29tIGZpbHRlciBzaG91bGQgaGF2ZSAwIHBhZGRpbmcuXG4gICAgICAgICAgICB0aHJvdyBuZXcgQmxvb21GaWx0ZXJFcnJvcihgSW52YWxpZCBwYWRkaW5nIHdoZW4gYml0bWFwIGxlbmd0aCBpcyAwOiAke3BhZGRpbmd9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaXRDb3VudCA9IGJpdG1hcC5sZW5ndGggKiA4IC0gcGFkZGluZztcbiAgICAgICAgLy8gU2V0IHRoZSBiaXQgY291bnQgaW4gSW50ZWdlciB0byBhdm9pZCByZXBldGl0aW9uIGluIG1pZ2h0Q29udGFpbigpLlxuICAgICAgICB0aGlzLmJpdENvdW50SW5JbnRlZ2VyID0gSW50ZWdlci5mcm9tTnVtYmVyKHRoaXMuYml0Q291bnQpO1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGl0aCBoYXNoIHZhbHVlIGJhc2VkIG9uIHRoZSBoYXNoZWQgNjRiaXQgaW50ZWdlcnMsXG4gICAgLy8gYW5kIGNhbGN1bGF0ZSBpdHMgY29ycmVzcG9uZGluZyBiaXQgaW5kZXggaW4gdGhlIGJpdG1hcCB0byBiZSBjaGVja2VkLlxuICAgIGdldEJpdEluZGV4KG51bTEsIG51bTIsIGhhc2hJbmRleCkge1xuICAgICAgICAvLyBDYWxjdWxhdGUgaGFzaGVkIHZhbHVlIGgoaSkgPSBoMSArIChpICogaDIpLlxuICAgICAgICBsZXQgaGFzaFZhbHVlID0gbnVtMS5hZGQobnVtMi5tdWx0aXBseShJbnRlZ2VyLmZyb21OdW1iZXIoaGFzaEluZGV4KSkpO1xuICAgICAgICAvLyBXcmFwIGlmIGhhc2ggdmFsdWUgb3ZlcmZsb3cgNjRiaXQuXG4gICAgICAgIGlmIChoYXNoVmFsdWUuY29tcGFyZShNQVhfNjRfQklUX1VOU0lHTkVEX0lOVEVHRVIpID09PSAxKSB7XG4gICAgICAgICAgICBoYXNoVmFsdWUgPSBuZXcgSW50ZWdlcihbaGFzaFZhbHVlLmdldEJpdHMoMCksIGhhc2hWYWx1ZS5nZXRCaXRzKDEpXSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhc2hWYWx1ZS5tb2R1bG8odGhpcy5iaXRDb3VudEluSW50ZWdlcikudG9OdW1iZXIoKTtcbiAgICB9XG4gICAgLy8gUmV0dXJuIHdoZXRoZXIgdGhlIGJpdCBvbiB0aGUgZ2l2ZW4gaW5kZXggaW4gdGhlIGJpdG1hcCBpcyBzZXQgdG8gMS5cbiAgICBpc0JpdFNldChpbmRleCkge1xuICAgICAgICAvLyBUbyByZXRyaWV2ZSBiaXQgbiwgY2FsY3VsYXRlOiAoYml0bWFwW24gLyA4XSAmICgweDAxIDw8IChuICUgOCkpKS5cbiAgICAgICAgY29uc3QgYnl0ZSA9IHRoaXMuYml0bWFwW01hdGguZmxvb3IoaW5kZXggLyA4KV07XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGluZGV4ICUgODtcbiAgICAgICAgcmV0dXJuIChieXRlICYgKDB4MDEgPDwgb2Zmc2V0KSkgIT09IDA7XG4gICAgfVxuICAgIG1pZ2h0Q29udGFpbih2YWx1ZSkge1xuICAgICAgICAvLyBFbXB0eSBiaXRtYXAgc2hvdWxkIGFsd2F5cyByZXR1cm4gZmFsc2Ugb24gbWVtYmVyc2hpcCBjaGVjay5cbiAgICAgICAgaWYgKHRoaXMuYml0Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZDVIYXNoZWRWYWx1ZSA9IGdldE1kNUhhc2hWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IFtoYXNoMSwgaGFzaDJdID0gZ2V0NjRCaXRVaW50cyhtZDVIYXNoZWRWYWx1ZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5oYXNoQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmdldEJpdEluZGV4KGhhc2gxLCBoYXNoMiwgaSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNCaXRTZXQoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlIGJsb29tIGZpbHRlciBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LiAqL1xuICAgIHN0YXRpYyBjcmVhdGUoYml0Q291bnQsIGhhc2hDb3VudCwgY29udGFpbnMpIHtcbiAgICAgICAgY29uc3QgcGFkZGluZyA9IGJpdENvdW50ICUgOCA9PT0gMCA/IDAgOiA4IC0gKGJpdENvdW50ICUgOCk7XG4gICAgICAgIGNvbnN0IGJpdG1hcCA9IG5ldyBVaW50OEFycmF5KE1hdGguY2VpbChiaXRDb3VudCAvIDgpKTtcbiAgICAgICAgY29uc3QgYmxvb21GaWx0ZXIgPSBuZXcgQmxvb21GaWx0ZXIoYml0bWFwLCBwYWRkaW5nLCBoYXNoQ291bnQpO1xuICAgICAgICBjb250YWlucy5mb3JFYWNoKGl0ZW0gPT4gYmxvb21GaWx0ZXIuaW5zZXJ0KGl0ZW0pKTtcbiAgICAgICAgcmV0dXJuIGJsb29tRmlsdGVyO1xuICAgIH1cbiAgICBpbnNlcnQodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuYml0Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZDVIYXNoZWRWYWx1ZSA9IGdldE1kNUhhc2hWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IFtoYXNoMSwgaGFzaDJdID0gZ2V0NjRCaXRVaW50cyhtZDVIYXNoZWRWYWx1ZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5oYXNoQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmdldEJpdEluZGV4KGhhc2gxLCBoYXNoMiwgaSk7XG4gICAgICAgICAgICB0aGlzLnNldEJpdChpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Qml0KGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGluZGV4T2ZCeXRlID0gTWF0aC5mbG9vcihpbmRleCAvIDgpO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBpbmRleCAlIDg7XG4gICAgICAgIHRoaXMuYml0bWFwW2luZGV4T2ZCeXRlXSB8PSAweDAxIDw8IG9mZnNldDtcbiAgICB9XG59XG5jbGFzcyBCbG9vbUZpbHRlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQmxvb21GaWx0ZXJFcnJvcic7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBbiBldmVudCBmcm9tIHRoZSBSZW1vdGVTdG9yZS4gSXQgaXMgc3BsaXQgaW50byB0YXJnZXRDaGFuZ2VzIChjaGFuZ2VzIHRvIHRoZVxuICogc3RhdGUgb3IgdGhlIHNldCBvZiBkb2N1bWVudHMgaW4gb3VyIHdhdGNoZWQgdGFyZ2V0cykgYW5kIGRvY3VtZW50VXBkYXRlc1xuICogKGNoYW5nZXMgdG8gdGhlIGFjdHVhbCBkb2N1bWVudHMpLlxuICovXG5jbGFzcyBSZW1vdGVFdmVudCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogVGhlIHNuYXBzaG90IHZlcnNpb24gdGhpcyBldmVudCBicmluZ3MgdXMgdXAgdG8sIG9yIE1JTiBpZiBub3Qgc2V0LlxuICAgICAqL1xuICAgIHNuYXBzaG90VmVyc2lvbiwgXG4gICAgLyoqXG4gICAgICogQSBtYXAgZnJvbSB0YXJnZXQgdG8gY2hhbmdlcyB0byB0aGUgdGFyZ2V0LiBTZWUgVGFyZ2V0Q2hhbmdlLlxuICAgICAqL1xuICAgIHRhcmdldENoYW5nZXMsIFxuICAgIC8qKlxuICAgICAqIEEgbWFwIG9mIHRhcmdldHMgdGhhdCBpcyBrbm93biB0byBiZSBpbmNvbnNpc3RlbnQsIGFuZCB0aGUgcHVycG9zZSBmb3JcbiAgICAgKiByZS1saXN0ZW5pbmcuIExpc3RlbnMgZm9yIHRoZXNlIHRhcmdldHMgc2hvdWxkIGJlIHJlLWVzdGFibGlzaGVkIHdpdGhvdXRcbiAgICAgKiByZXN1bWUgdG9rZW5zLlxuICAgICAqL1xuICAgIHRhcmdldE1pc21hdGNoZXMsIFxuICAgIC8qKlxuICAgICAqIEEgc2V0IG9mIHdoaWNoIGRvY3VtZW50cyBoYXZlIGNoYW5nZWQgb3IgYmVlbiBkZWxldGVkLCBhbG9uZyB3aXRoIHRoZVxuICAgICAqIGRvYydzIG5ldyB2YWx1ZXMgKGlmIG5vdCBkZWxldGVkKS5cbiAgICAgKi9cbiAgICBkb2N1bWVudFVwZGF0ZXMsIFxuICAgIC8qKlxuICAgICAqIEEgc2V0IG9mIHdoaWNoIGRvY3VtZW50IHVwZGF0ZXMgYXJlIGR1ZSBvbmx5IHRvIGxpbWJvIHJlc29sdXRpb24gdGFyZ2V0cy5cbiAgICAgKi9cbiAgICByZXNvbHZlZExpbWJvRG9jdW1lbnRzKSB7XG4gICAgICAgIHRoaXMuc25hcHNob3RWZXJzaW9uID0gc25hcHNob3RWZXJzaW9uO1xuICAgICAgICB0aGlzLnRhcmdldENoYW5nZXMgPSB0YXJnZXRDaGFuZ2VzO1xuICAgICAgICB0aGlzLnRhcmdldE1pc21hdGNoZXMgPSB0YXJnZXRNaXNtYXRjaGVzO1xuICAgICAgICB0aGlzLmRvY3VtZW50VXBkYXRlcyA9IGRvY3VtZW50VXBkYXRlcztcbiAgICAgICAgdGhpcy5yZXNvbHZlZExpbWJvRG9jdW1lbnRzID0gcmVzb2x2ZWRMaW1ib0RvY3VtZW50cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSEFDSzogVmlld3MgcmVxdWlyZSBSZW1vdGVFdmVudHMgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHZpZXcgaXNcbiAgICAgKiBDVVJSRU5ULCBidXQgc2Vjb25kYXJ5IHRhYnMgZG9uJ3QgcmVjZWl2ZSByZW1vdGUgZXZlbnRzLiBTbyB0aGlzIG1ldGhvZCBpc1xuICAgICAqIHVzZWQgdG8gY3JlYXRlIGEgc3ludGhlc2l6ZWQgUmVtb3RlRXZlbnQgdGhhdCBjYW4gYmUgdXNlZCB0byBhcHBseSBhXG4gICAgICogQ1VSUkVOVCBzdGF0dXMgY2hhbmdlIHRvIGEgVmlldywgZm9yIHF1ZXJpZXMgZXhlY3V0ZWQgaW4gYSBkaWZmZXJlbnQgdGFiLlxuICAgICAqL1xuICAgIC8vIFBPUlRJTkcgTk9URTogTXVsdGktdGFiIG9ubHlcbiAgICBzdGF0aWMgY3JlYXRlU3ludGhlc2l6ZWRSZW1vdGVFdmVudEZvckN1cnJlbnRDaGFuZ2UodGFyZ2V0SWQsIGN1cnJlbnQsIHJlc3VtZVRva2VuKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldENoYW5nZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRhcmdldENoYW5nZXMuc2V0KHRhcmdldElkLCBUYXJnZXRDaGFuZ2UuY3JlYXRlU3ludGhlc2l6ZWRUYXJnZXRDaGFuZ2VGb3JDdXJyZW50Q2hhbmdlKHRhcmdldElkLCBjdXJyZW50LCByZXN1bWVUb2tlbikpO1xuICAgICAgICByZXR1cm4gbmV3IFJlbW90ZUV2ZW50KFNuYXBzaG90VmVyc2lvbi5taW4oKSwgdGFyZ2V0Q2hhbmdlcywgbmV3IFNvcnRlZE1hcChwcmltaXRpdmVDb21wYXJhdG9yKSwgbXV0YWJsZURvY3VtZW50TWFwKCksIGRvY3VtZW50S2V5U2V0KCkpO1xuICAgIH1cbn1cbi8qKlxuICogQSBUYXJnZXRDaGFuZ2Ugc3BlY2lmaWVzIHRoZSBzZXQgb2YgY2hhbmdlcyBmb3IgYSBzcGVjaWZpYyB0YXJnZXQgYXMgcGFydCBvZlxuICogYSBSZW1vdGVFdmVudC4gVGhlc2UgY2hhbmdlcyB0cmFjayB3aGljaCBkb2N1bWVudHMgYXJlIGFkZGVkLCBtb2RpZmllZCBvclxuICogcmVtb3ZlZCwgYXMgd2VsbCBhcyB0aGUgdGFyZ2V0J3MgcmVzdW1lIHRva2VuIGFuZCB3aGV0aGVyIHRoZSB0YXJnZXQgaXNcbiAqIG1hcmtlZCBDVVJSRU5ULlxuICogVGhlIGFjdHVhbCBjaGFuZ2VzICp0byogZG9jdW1lbnRzIGFyZSBub3QgcGFydCBvZiB0aGUgVGFyZ2V0Q2hhbmdlIHNpbmNlXG4gKiBkb2N1bWVudHMgbWF5IGJlIHBhcnQgb2YgbXVsdGlwbGUgdGFyZ2V0cy5cbiAqL1xuY2xhc3MgVGFyZ2V0Q2hhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBBbiBvcGFxdWUsIHNlcnZlci1hc3NpZ25lZCB0b2tlbiB0aGF0IGFsbG93cyB3YXRjaGluZyBhIHF1ZXJ5IHRvIGJlIHJlc3VtZWRcbiAgICAgKiBhZnRlciBkaXNjb25uZWN0aW5nIHdpdGhvdXQgcmV0cmFuc21pdHRpbmcgYWxsIHRoZSBkYXRhIHRoYXQgbWF0Y2hlcyB0aGVcbiAgICAgKiBxdWVyeS4gVGhlIHJlc3VtZSB0b2tlbiBlc3NlbnRpYWxseSBpZGVudGlmaWVzIGEgcG9pbnQgaW4gdGltZSBmcm9tIHdoaWNoXG4gICAgICogdGhlIHNlcnZlciBzaG91bGQgcmVzdW1lIHNlbmRpbmcgcmVzdWx0cy5cbiAgICAgKi9cbiAgICByZXN1bWVUb2tlbiwgXG4gICAgLyoqXG4gICAgICogVGhlIFwiY3VycmVudFwiIChzeW5jZWQpIHN0YXR1cyBvZiB0aGlzIHRhcmdldC4gTm90ZSB0aGF0IFwiY3VycmVudFwiXG4gICAgICogaGFzIHNwZWNpYWwgbWVhbmluZyBpbiB0aGUgUlBDIHByb3RvY29sIHRoYXQgaW1wbGllcyB0aGF0IGEgdGFyZ2V0IGlzXG4gICAgICogYm90aCB1cC10by1kYXRlIGFuZCBjb25zaXN0ZW50IHdpdGggdGhlIHJlc3Qgb2YgdGhlIHdhdGNoIHN0cmVhbS5cbiAgICAgKi9cbiAgICBjdXJyZW50LCBcbiAgICAvKipcbiAgICAgKiBUaGUgc2V0IG9mIGRvY3VtZW50cyB0aGF0IHdlcmUgbmV3bHkgYXNzaWduZWQgdG8gdGhpcyB0YXJnZXQgYXMgcGFydCBvZlxuICAgICAqIHRoaXMgcmVtb3RlIGV2ZW50LlxuICAgICAqL1xuICAgIGFkZGVkRG9jdW1lbnRzLCBcbiAgICAvKipcbiAgICAgKiBUaGUgc2V0IG9mIGRvY3VtZW50cyB0aGF0IHdlcmUgYWxyZWFkeSBhc3NpZ25lZCB0byB0aGlzIHRhcmdldCBidXQgcmVjZWl2ZWRcbiAgICAgKiBhbiB1cGRhdGUgZHVyaW5nIHRoaXMgcmVtb3RlIGV2ZW50LlxuICAgICAqL1xuICAgIG1vZGlmaWVkRG9jdW1lbnRzLCBcbiAgICAvKipcbiAgICAgKiBUaGUgc2V0IG9mIGRvY3VtZW50cyB0aGF0IHdlcmUgcmVtb3ZlZCBmcm9tIHRoaXMgdGFyZ2V0IGFzIHBhcnQgb2YgdGhpc1xuICAgICAqIHJlbW90ZSBldmVudC5cbiAgICAgKi9cbiAgICByZW1vdmVkRG9jdW1lbnRzKSB7XG4gICAgICAgIHRoaXMucmVzdW1lVG9rZW4gPSByZXN1bWVUb2tlbjtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VycmVudDtcbiAgICAgICAgdGhpcy5hZGRlZERvY3VtZW50cyA9IGFkZGVkRG9jdW1lbnRzO1xuICAgICAgICB0aGlzLm1vZGlmaWVkRG9jdW1lbnRzID0gbW9kaWZpZWREb2N1bWVudHM7XG4gICAgICAgIHRoaXMucmVtb3ZlZERvY3VtZW50cyA9IHJlbW92ZWREb2N1bWVudHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gY3JlYXRlIGEgc3ludGhlc2l6ZWQgVGFyZ2V0Q2hhbmdlcyB0aGF0IGNhbiBiZSB1c2VkIHRvXG4gICAgICogYXBwbHkgYSBDVVJSRU5UIHN0YXR1cyBjaGFuZ2UgdG8gYSBWaWV3IChmb3IgcXVlcmllcyBleGVjdXRlZCBpbiBhIGRpZmZlcmVudFxuICAgICAqIHRhYikgb3IgZm9yIG5ldyBxdWVyaWVzICh0byByYWlzZSBzbmFwc2hvdHMgd2l0aCBjb3JyZWN0IENVUlJFTlQgc3RhdHVzKS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlU3ludGhlc2l6ZWRUYXJnZXRDaGFuZ2VGb3JDdXJyZW50Q2hhbmdlKHRhcmdldElkLCBjdXJyZW50LCByZXN1bWVUb2tlbikge1xuICAgICAgICByZXR1cm4gbmV3IFRhcmdldENoYW5nZShyZXN1bWVUb2tlbiwgY3VycmVudCwgZG9jdW1lbnRLZXlTZXQoKSwgZG9jdW1lbnRLZXlTZXQoKSwgZG9jdW1lbnRLZXlTZXQoKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2hhbmdlZCBkb2N1bWVudCBhbmQgYSBsaXN0IG9mIHRhcmdldCBpZHMgdG8gd2hpY2ggdGhpcyBjaGFuZ2VcbiAqIGFwcGxpZXMuXG4gKlxuICogSWYgZG9jdW1lbnQgaGFzIGJlZW4gZGVsZXRlZCBOb0RvY3VtZW50IHdpbGwgYmUgcHJvdmlkZWQuXG4gKi9cbmNsYXNzIERvY3VtZW50V2F0Y2hDaGFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBUaGUgbmV3IGRvY3VtZW50IGFwcGxpZXMgdG8gYWxsIG9mIHRoZXNlIHRhcmdldHMuICovXG4gICAgdXBkYXRlZFRhcmdldElkcywgXG4gICAgLyoqIFRoZSBuZXcgZG9jdW1lbnQgaXMgcmVtb3ZlZCBmcm9tIGFsbCBvZiB0aGVzZSB0YXJnZXRzLiAqL1xuICAgIHJlbW92ZWRUYXJnZXRJZHMsIFxuICAgIC8qKiBUaGUga2V5IG9mIHRoZSBkb2N1bWVudCBmb3IgdGhpcyBjaGFuZ2UuICovXG4gICAga2V5LCBcbiAgICAvKipcbiAgICAgKiBUaGUgbmV3IGRvY3VtZW50IG9yIE5vRG9jdW1lbnQgaWYgaXQgd2FzIGRlbGV0ZWQuIElzIG51bGwgaWYgdGhlXG4gICAgICogZG9jdW1lbnQgd2VudCBvdXQgb2YgdmlldyB3aXRob3V0IHRoZSBzZXJ2ZXIgc2VuZGluZyBhIG5ldyBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBuZXdEb2MpIHtcbiAgICAgICAgdGhpcy51cGRhdGVkVGFyZ2V0SWRzID0gdXBkYXRlZFRhcmdldElkcztcbiAgICAgICAgdGhpcy5yZW1vdmVkVGFyZ2V0SWRzID0gcmVtb3ZlZFRhcmdldElkcztcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMubmV3RG9jID0gbmV3RG9jO1xuICAgIH1cbn1cbmNsYXNzIEV4aXN0ZW5jZUZpbHRlckNoYW5nZSB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0SWQsIGV4aXN0ZW5jZUZpbHRlcikge1xuICAgICAgICB0aGlzLnRhcmdldElkID0gdGFyZ2V0SWQ7XG4gICAgICAgIHRoaXMuZXhpc3RlbmNlRmlsdGVyID0gZXhpc3RlbmNlRmlsdGVyO1xuICAgIH1cbn1cbmNsYXNzIFdhdGNoVGFyZ2V0Q2hhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKiogV2hhdCBraW5kIG9mIGNoYW5nZSBvY2N1cnJlZCB0byB0aGUgd2F0Y2ggdGFyZ2V0LiAqL1xuICAgIHN0YXRlLCBcbiAgICAvKiogVGhlIHRhcmdldCBJRHMgdGhhdCB3ZXJlIGFkZGVkL3JlbW92ZWQvc2V0LiAqL1xuICAgIHRhcmdldElkcywgXG4gICAgLyoqXG4gICAgICogQW4gb3BhcXVlLCBzZXJ2ZXItYXNzaWduZWQgdG9rZW4gdGhhdCBhbGxvd3Mgd2F0Y2hpbmcgYSB0YXJnZXQgdG8gYmVcbiAgICAgKiByZXN1bWVkIGFmdGVyIGRpc2Nvbm5lY3Rpbmcgd2l0aG91dCByZXRyYW5zbWl0dGluZyBhbGwgdGhlIGRhdGEgdGhhdFxuICAgICAqIG1hdGNoZXMgdGhlIHRhcmdldC4gVGhlIHJlc3VtZSB0b2tlbiBlc3NlbnRpYWxseSBpZGVudGlmaWVzIGEgcG9pbnQgaW5cbiAgICAgKiB0aW1lIGZyb20gd2hpY2ggdGhlIHNlcnZlciBzaG91bGQgcmVzdW1lIHNlbmRpbmcgcmVzdWx0cy5cbiAgICAgKi9cbiAgICByZXN1bWVUb2tlbiA9IEJ5dGVTdHJpbmcuRU1QVFlfQllURV9TVFJJTkcsIFxuICAgIC8qKiBBbiBSUEMgZXJyb3IgaW5kaWNhdGluZyB3aHkgdGhlIHdhdGNoIGZhaWxlZC4gKi9cbiAgICBjYXVzZSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnRhcmdldElkcyA9IHRhcmdldElkcztcbiAgICAgICAgdGhpcy5yZXN1bWVUb2tlbiA9IHJlc3VtZVRva2VuO1xuICAgICAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgfVxufVxuLyoqIFRyYWNrcyB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgYSBXYXRjaCB0YXJnZXQuICovXG5jbGFzcyBUYXJnZXRTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIHBlbmRpbmcgcmVzcG9uc2VzIChhZGRzIG9yIHJlbW92ZXMpIHRoYXQgd2UgYXJlIHdhaXRpbmcgb24uXG4gICAgICAgICAqIFdlIG9ubHkgY29uc2lkZXIgdGFyZ2V0cyBhY3RpdmUgdGhhdCBoYXZlIG5vIHBlbmRpbmcgcmVzcG9uc2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wZW5kaW5nUmVzcG9uc2VzID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBkb2N1bWVudCBjaGFuZ2VzIHNpbmNlIHRoZSBsYXN0IHJhaXNlZCBzbmFwc2hvdC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlc2UgY2hhbmdlcyBhcmUgY29udGludW91c2x5IHVwZGF0ZWQgYXMgd2UgcmVjZWl2ZSBkb2N1bWVudCB1cGRhdGVzIGFuZFxuICAgICAgICAgKiBhbHdheXMgcmVmbGVjdCB0aGUgY3VycmVudCBzZXQgb2YgY2hhbmdlcyBhZ2FpbnN0IHRoZSBsYXN0IGlzc3VlZCBzbmFwc2hvdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZG9jdW1lbnRDaGFuZ2VzID0gc25hcHNob3RDaGFuZ2VzTWFwKCk7XG4gICAgICAgIC8qKiBTZWUgcHVibGljIGdldHRlcnMgZm9yIGV4cGxhbmF0aW9ucyBvZiB0aGVzZSBmaWVsZHMuICovXG4gICAgICAgIHRoaXMuX3Jlc3VtZVRva2VuID0gQnl0ZVN0cmluZy5FTVBUWV9CWVRFX1NUUklORztcbiAgICAgICAgdGhpcy5fY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGlzIHRhcmdldCBzdGF0ZSBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIG5leHQgc25hcHNob3QuIFdlXG4gICAgICAgICAqIGluaXRpYWxpemUgdG8gdHJ1ZSBzbyB0aGF0IG5ld2x5LWFkZGVkIHRhcmdldHMgYXJlIGluY2x1ZGVkIGluIHRoZSBuZXh0XG4gICAgICAgICAqIFJlbW90ZUV2ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faGFzUGVuZGluZ0NoYW5nZXMgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgdGFyZ2V0IGhhcyBiZWVuIG1hcmtlZCAnY3VycmVudCcuXG4gICAgICpcbiAgICAgKiAnQ3VycmVudCcgaGFzIHNwZWNpYWwgbWVhbmluZyBpbiB0aGUgUlBDIHByb3RvY29sOiBJdCBpbXBsaWVzIHRoYXQgdGhlXG4gICAgICogV2F0Y2ggYmFja2VuZCBoYXMgc2VudCB1cyBhbGwgY2hhbmdlcyB1cCB0byB0aGUgcG9pbnQgYXQgd2hpY2ggdGhlIHRhcmdldFxuICAgICAqIHdhcyBhZGRlZCBhbmQgdGhhdCB0aGUgdGFyZ2V0IGlzIGNvbnNpc3RlbnQgd2l0aCB0aGUgcmVzdCBvZiB0aGUgd2F0Y2hcbiAgICAgKiBzdHJlYW0uXG4gICAgICovXG4gICAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50O1xuICAgIH1cbiAgICAvKiogVGhlIGxhc3QgcmVzdW1lIHRva2VuIHNlbnQgdG8gdXMgZm9yIHRoaXMgdGFyZ2V0LiAqL1xuICAgIGdldCByZXN1bWVUb2tlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3VtZVRva2VuO1xuICAgIH1cbiAgICAvKiogV2hldGhlciB0aGlzIHRhcmdldCBoYXMgcGVuZGluZyB0YXJnZXQgYWRkcyBvciB0YXJnZXQgcmVtb3Zlcy4gKi9cbiAgICBnZXQgaXNQZW5kaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZW5kaW5nUmVzcG9uc2VzICE9PSAwO1xuICAgIH1cbiAgICAvKiogV2hldGhlciB3ZSBoYXZlIG1vZGlmaWVkIGFueSBzdGF0ZSB0aGF0IHNob3VsZCB0cmlnZ2VyIGEgc25hcHNob3QuICovXG4gICAgZ2V0IGhhc1BlbmRpbmdDaGFuZ2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzUGVuZGluZ0NoYW5nZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIHJlc3VtZSB0b2tlbiB0byB0aGUgVGFyZ2V0Q2hhbmdlLCBidXQgb25seSB3aGVuIGl0IGhhcyBhIG5ld1xuICAgICAqIHZhbHVlLiBFbXB0eSByZXN1bWVUb2tlbnMgYXJlIGRpc2NhcmRlZC5cbiAgICAgKi9cbiAgICB1cGRhdGVSZXN1bWVUb2tlbihyZXN1bWVUb2tlbikge1xuICAgICAgICBpZiAocmVzdW1lVG9rZW4uYXBwcm94aW1hdGVCeXRlU2l6ZSgpID4gMCkge1xuICAgICAgICAgICAgdGhpcy5faGFzUGVuZGluZ0NoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcmVzdW1lVG9rZW4gPSByZXN1bWVUb2tlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdGFyZ2V0IGNoYW5nZSBmcm9tIHRoZSBjdXJyZW50IHNldCBvZiBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogVG8gcmVzZXQgdGhlIGRvY3VtZW50IGNoYW5nZXMgYWZ0ZXIgcmFpc2luZyB0aGlzIHNuYXBzaG90LCBjYWxsXG4gICAgICogYGNsZWFyUGVuZGluZ0NoYW5nZXMoKWAuXG4gICAgICovXG4gICAgdG9UYXJnZXRDaGFuZ2UoKSB7XG4gICAgICAgIGxldCBhZGRlZERvY3VtZW50cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgIGxldCBtb2RpZmllZERvY3VtZW50cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgIGxldCByZW1vdmVkRG9jdW1lbnRzID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgdGhpcy5kb2N1bWVudENoYW5nZXMuZm9yRWFjaCgoa2V5LCBjaGFuZ2VUeXBlKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoYW5nZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLzpcbiAgICAgICAgICAgICAgICAgICAgYWRkZWREb2N1bWVudHMgPSBhZGRlZERvY3VtZW50cy5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi86XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkRG9jdW1lbnRzID0gbW9kaWZpZWREb2N1bWVudHMuYWRkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBDaGFuZ2VUeXBlLlJlbW92ZWQgKi86XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWREb2N1bWVudHMgPSByZW1vdmVkRG9jdW1lbnRzLmFkZChrZXkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBmYWlsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFRhcmdldENoYW5nZSh0aGlzLl9yZXN1bWVUb2tlbiwgdGhpcy5fY3VycmVudCwgYWRkZWREb2N1bWVudHMsIG1vZGlmaWVkRG9jdW1lbnRzLCByZW1vdmVkRG9jdW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBkb2N1bWVudCBjaGFuZ2VzIGFuZCBzZXRzIGBoYXNQZW5kaW5nQ2hhbmdlc2AgdG8gZmFsc2UuXG4gICAgICovXG4gICAgY2xlYXJQZW5kaW5nQ2hhbmdlcygpIHtcbiAgICAgICAgdGhpcy5faGFzUGVuZGluZ0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kb2N1bWVudENoYW5nZXMgPSBzbmFwc2hvdENoYW5nZXNNYXAoKTtcbiAgICB9XG4gICAgYWRkRG9jdW1lbnRDaGFuZ2Uoa2V5LCBjaGFuZ2VUeXBlKSB7XG4gICAgICAgIHRoaXMuX2hhc1BlbmRpbmdDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kb2N1bWVudENoYW5nZXMgPSB0aGlzLmRvY3VtZW50Q2hhbmdlcy5pbnNlcnQoa2V5LCBjaGFuZ2VUeXBlKTtcbiAgICB9XG4gICAgcmVtb3ZlRG9jdW1lbnRDaGFuZ2Uoa2V5KSB7XG4gICAgICAgIHRoaXMuX2hhc1BlbmRpbmdDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kb2N1bWVudENoYW5nZXMgPSB0aGlzLmRvY3VtZW50Q2hhbmdlcy5yZW1vdmUoa2V5KTtcbiAgICB9XG4gICAgcmVjb3JkUGVuZGluZ1RhcmdldFJlcXVlc3QoKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlcyArPSAxO1xuICAgIH1cbiAgICByZWNvcmRUYXJnZXRSZXNwb25zZSgpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nUmVzcG9uc2VzIC09IDE7XG4gICAgICAgIGhhcmRBc3NlcnQodGhpcy5wZW5kaW5nUmVzcG9uc2VzID49IDApO1xuICAgIH1cbiAgICBtYXJrQ3VycmVudCgpIHtcbiAgICAgICAgdGhpcy5faGFzUGVuZGluZ0NoYW5nZXMgPSB0cnVlO1xuICAgICAgICB0aGlzLl9jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG59XG5jb25zdCBMT0dfVEFHJGcgPSAnV2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yJztcbi8qKlxuICogQSBoZWxwZXIgY2xhc3MgdG8gYWNjdW11bGF0ZSB3YXRjaCBjaGFuZ2VzIGludG8gYSBSZW1vdGVFdmVudC5cbiAqL1xuY2xhc3MgV2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRhZGF0YVByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGFQcm92aWRlciA9IG1ldGFkYXRhUHJvdmlkZXI7XG4gICAgICAgIC8qKiBUaGUgaW50ZXJuYWwgc3RhdGUgb2YgYWxsIHRyYWNrZWQgdGFyZ2V0cy4gKi9cbiAgICAgICAgdGhpcy50YXJnZXRTdGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKiBLZWVwcyB0cmFjayBvZiB0aGUgZG9jdW1lbnRzIHRvIHVwZGF0ZSBzaW5jZSB0aGUgbGFzdCByYWlzZWQgc25hcHNob3QuICovXG4gICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VXBkYXRlcyA9IG11dGFibGVEb2N1bWVudE1hcCgpO1xuICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXNCeVRhcmdldCA9IGRvY3VtZW50VGFyZ2V0TWFwKCk7XG4gICAgICAgIC8qKiBBIG1hcHBpbmcgb2YgZG9jdW1lbnQga2V5cyB0byB0aGVpciBzZXQgb2YgdGFyZ2V0IElEcy4gKi9cbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nID0gZG9jdW1lbnRUYXJnZXRNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWFwIG9mIHRhcmdldHMgd2l0aCBleGlzdGVuY2UgZmlsdGVyIG1pc21hdGNoZXMuIFRoZXNlIHRhcmdldHMgYXJlXG4gICAgICAgICAqIGtub3duIHRvIGJlIGluY29uc2lzdGVudCBhbmQgdGhlaXIgbGlzdGVucyBuZWVkcyB0byBiZSByZS1lc3RhYmxpc2hlZCBieVxuICAgICAgICAgKiBSZW1vdGVTdG9yZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGVuZGluZ1RhcmdldFJlc2V0cyA9IG5ldyBTb3J0ZWRNYXAocHJpbWl0aXZlQ29tcGFyYXRvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyBhbmQgYWRkcyB0aGUgRG9jdW1lbnRXYXRjaENoYW5nZSB0byB0aGUgY3VycmVudCBzZXQgb2YgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBoYW5kbGVEb2N1bWVudENoYW5nZShkb2NDaGFuZ2UpIHtcbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXRJZCBvZiBkb2NDaGFuZ2UudXBkYXRlZFRhcmdldElkcykge1xuICAgICAgICAgICAgaWYgKGRvY0NoYW5nZS5uZXdEb2MgJiYgZG9jQ2hhbmdlLm5ld0RvYy5pc0ZvdW5kRG9jdW1lbnQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRG9jdW1lbnRUb1RhcmdldCh0YXJnZXRJZCwgZG9jQ2hhbmdlLm5ld0RvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZURvY3VtZW50RnJvbVRhcmdldCh0YXJnZXRJZCwgZG9jQ2hhbmdlLmtleSwgZG9jQ2hhbmdlLm5ld0RvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXRJZCBvZiBkb2NDaGFuZ2UucmVtb3ZlZFRhcmdldElkcykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVEb2N1bWVudEZyb21UYXJnZXQodGFyZ2V0SWQsIGRvY0NoYW5nZS5rZXksIGRvY0NoYW5nZS5uZXdEb2MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBQcm9jZXNzZXMgYW5kIGFkZHMgdGhlIFdhdGNoVGFyZ2V0Q2hhbmdlIHRvIHRoZSBjdXJyZW50IHNldCBvZiBjaGFuZ2VzLiAqL1xuICAgIGhhbmRsZVRhcmdldENoYW5nZSh0YXJnZXRDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5mb3JFYWNoVGFyZ2V0KHRhcmdldENoYW5nZSwgdGFyZ2V0SWQgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0U3RhdGUgPSB0aGlzLmVuc3VyZVRhcmdldFN0YXRlKHRhcmdldElkKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFyZ2V0Q2hhbmdlLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwIC8qIFdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUuTm9DaGFuZ2UgKi86XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQWN0aXZlVGFyZ2V0KHRhcmdldElkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U3RhdGUudXBkYXRlUmVzdW1lVG9rZW4odGFyZ2V0Q2hhbmdlLnJlc3VtZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogV2F0Y2hUYXJnZXRDaGFuZ2VTdGF0ZS5BZGRlZCAqLzpcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBkZWNyZW1lbnQgdGhlIG51bWJlciBvZiBwZW5kaW5nIGFja3MgbmVlZGVkIGZyb20gd2F0Y2hcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHRoaXMgdGFyZ2V0SWQuXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFN0YXRlLnJlY29yZFRhcmdldFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0U3RhdGUuaXNQZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGEgZnJlc2hseSBhZGRlZCB0YXJnZXQsIHNvIHdlIG5lZWQgdG8gcmVzZXQgYW55IHN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IHdlIGhhZCBwcmV2aW91c2x5LiBUaGlzIGNhbiBoYXBwZW4gZS5nLiB3aGVuIHJlbW92ZSBhbmQgYWRkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiYWNrIGEgdGFyZ2V0IGZvciBleGlzdGVuY2UgZmlsdGVyIG1pc21hdGNoZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRTdGF0ZS5jbGVhclBlbmRpbmdDaGFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U3RhdGUudXBkYXRlUmVzdW1lVG9rZW4odGFyZ2V0Q2hhbmdlLnJlc3VtZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyIC8qIFdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUuUmVtb3ZlZCAqLzpcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBrZWVwIHRyYWNrIG9mIHJlbW92ZWQgdGFyZ2V0cyB0byB3ZSBjYW4gcG9zdC1maWx0ZXIgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBhbnkgdGFyZ2V0IGNoYW5nZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZGVjcmVtZW50IHRoZSBudW1iZXIgb2YgcGVuZGluZyBhY2tzIG5lZWRlZCBmcm9tIHdhdGNoXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciB0aGlzIHRhcmdldElkLlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRTdGF0ZS5yZWNvcmRUYXJnZXRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldFN0YXRlLmlzUGVuZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVUYXJnZXQodGFyZ2V0SWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBXYXRjaFRhcmdldENoYW5nZVN0YXRlLkN1cnJlbnQgKi86XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQWN0aXZlVGFyZ2V0KHRhcmdldElkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U3RhdGUubWFya0N1cnJlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFN0YXRlLnVwZGF0ZVJlc3VtZVRva2VuKHRhcmdldENoYW5nZS5yZXN1bWVUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0IC8qIFdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUuUmVzZXQgKi86XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQWN0aXZlVGFyZ2V0KHRhcmdldElkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHRhcmdldCBhbmQgc3ludGhlc2l6ZXMgcmVtb3ZlcyBmb3IgYWxsIGV4aXN0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb2N1bWVudHMuIFRoZSBiYWNrZW5kIHdpbGwgcmUtYWRkIGFueSBkb2N1bWVudHMgdGhhdCBzdGlsbFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2ggdGhlIHRhcmdldCBiZWZvcmUgaXQgc2VuZHMgdGhlIG5leHQgZ2xvYmFsIHNuYXBzaG90LlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldFRhcmdldCh0YXJnZXRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRTdGF0ZS51cGRhdGVSZXN1bWVUb2tlbih0YXJnZXRDaGFuZ2UucmVzdW1lVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGZhaWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgYWxsIHRhcmdldElkcyB0aGF0IHRoZSB3YXRjaCBjaGFuZ2UgYXBwbGllcyB0bzogZWl0aGVyIHRoZVxuICAgICAqIHRhcmdldElkcyBleHBsaWNpdGx5IGxpc3RlZCBpbiB0aGUgY2hhbmdlIG9yIHRoZSB0YXJnZXRJZHMgb2YgYWxsIGN1cnJlbnRseVxuICAgICAqIGFjdGl2ZSB0YXJnZXRzLlxuICAgICAqL1xuICAgIGZvckVhY2hUYXJnZXQodGFyZ2V0Q2hhbmdlLCBmbikge1xuICAgICAgICBpZiAodGFyZ2V0Q2hhbmdlLnRhcmdldElkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0YXJnZXRDaGFuZ2UudGFyZ2V0SWRzLmZvckVhY2goZm4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50YXJnZXRTdGF0ZXMuZm9yRWFjaCgoXywgdGFyZ2V0SWQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZVRhcmdldCh0YXJnZXRJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm4odGFyZ2V0SWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgZXhpc3RlbmNlIGZpbHRlcnMgYW5kIHN5bnRoZXNpemVzIGRlbGV0ZXMgZm9yIGZpbHRlciBtaXNtYXRjaGVzLlxuICAgICAqIFRhcmdldHMgdGhhdCBhcmUgaW52YWxpZGF0ZWQgYnkgZmlsdGVyIG1pc21hdGNoZXMgYXJlIGFkZGVkIHRvXG4gICAgICogYHBlbmRpbmdUYXJnZXRSZXNldHNgLlxuICAgICAqL1xuICAgIGhhbmRsZUV4aXN0ZW5jZUZpbHRlcih3YXRjaENoYW5nZSkge1xuICAgICAgICBjb25zdCB0YXJnZXRJZCA9IHdhdGNoQ2hhbmdlLnRhcmdldElkO1xuICAgICAgICBjb25zdCBleHBlY3RlZENvdW50ID0gd2F0Y2hDaGFuZ2UuZXhpc3RlbmNlRmlsdGVyLmNvdW50O1xuICAgICAgICBjb25zdCB0YXJnZXREYXRhID0gdGhpcy50YXJnZXREYXRhRm9yQWN0aXZlVGFyZ2V0KHRhcmdldElkKTtcbiAgICAgICAgaWYgKHRhcmdldERhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldERhdGEudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKHRhcmdldElzRG9jdW1lbnRUYXJnZXQodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGlmIChleHBlY3RlZENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBleGlzdGVuY2UgZmlsdGVyIHRvbGQgdXMgdGhlIGRvY3VtZW50IGRvZXMgbm90IGV4aXN0LiBXZSBkZWR1Y2VcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCB0aGlzIGRvY3VtZW50IGRvZXMgbm90IGV4aXN0IGFuZCBhcHBseSBhIGRlbGV0ZWQgZG9jdW1lbnQgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gb3VyIHVwZGF0ZXMuIFdpdGhvdXQgYXBwbHlpbmcgdGhpcyBkZWxldGVkIGRvY3VtZW50IHRoZXJlIG1pZ2h0IGJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGFub3RoZXIgcXVlcnkgdGhhdCB3aWxsIHJhaXNlIHRoaXMgZG9jdW1lbnQgYXMgcGFydCBvZiBhIHNuYXBzaG90XG4gICAgICAgICAgICAgICAgICAgIC8vIHVudGlsIGl0IGlzIHJlc29sdmVkLCBlc3NlbnRpYWxseSBleHBvc2luZyBpbmNvbnNpc3RlbmN5IGJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gcXVlcmllcy5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gbmV3IERvY3VtZW50S2V5KHRhcmdldC5wYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVEb2N1bWVudEZyb21UYXJnZXQodGFyZ2V0SWQsIGtleSwgTXV0YWJsZURvY3VtZW50Lm5ld05vRG9jdW1lbnQoa2V5LCBTbmFwc2hvdFZlcnNpb24ubWluKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQoZXhwZWN0ZWRDb3VudCA9PT0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFNpemUgPSB0aGlzLmdldEN1cnJlbnREb2N1bWVudENvdW50Rm9yVGFyZ2V0KHRhcmdldElkKTtcbiAgICAgICAgICAgICAgICAvLyBFeGlzdGVuY2UgZmlsdGVyIG1pc21hdGNoLiBNYXJrIHRoZSBkb2N1bWVudHMgYXMgYmVpbmcgaW4gbGltYm8sIGFuZFxuICAgICAgICAgICAgICAgIC8vIHJhaXNlIGEgc25hcHNob3Qgd2l0aCBgaXNGcm9tQ2FjaGU6dHJ1ZWAuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTaXplICE9PSBleHBlY3RlZENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGJsb29tIGZpbHRlciB0byBpZGVudGlmeSBhbmQgbWFyayByZW1vdmVkIGRvY3VtZW50cy5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvb21GaWx0ZXIgPSB0aGlzLnBhcnNlQmxvb21GaWx0ZXIod2F0Y2hDaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBibG9vbUZpbHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmFwcGx5Qmxvb21GaWx0ZXIoYmxvb21GaWx0ZXIsIHdhdGNoQ2hhbmdlLCBjdXJyZW50U2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogMSAvKiBCbG9vbUZpbHRlckFwcGxpY2F0aW9uU3RhdHVzLlNraXBwZWQgKi87XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgIT09IDAgLyogQmxvb21GaWx0ZXJBcHBsaWNhdGlvblN0YXR1cy5TdWNjZXNzICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBibG9vbSBmaWx0ZXIgYXBwbGljYXRpb24gZmFpbHMsIHdlIHJlc2V0IHRoZSBtYXBwaW5nIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJpZ2dlciByZS1ydW4gb2YgdGhlIHF1ZXJ5LlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldFRhcmdldCh0YXJnZXRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwdXJwb3NlID0gc3RhdHVzID09PSAyIC8qIEJsb29tRmlsdGVyQXBwbGljYXRpb25TdGF0dXMuRmFsc2VQb3NpdGl2ZSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCJUYXJnZXRQdXJwb3NlRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2hCbG9vbVwiIC8qIFRhcmdldFB1cnBvc2UuRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2hCbG9vbSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJUYXJnZXRQdXJwb3NlRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2hcIiAvKiBUYXJnZXRQdXJwb3NlLkV4aXN0ZW5jZUZpbHRlck1pc21hdGNoICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nVGFyZ2V0UmVzZXRzID0gdGhpcy5wZW5kaW5nVGFyZ2V0UmVzZXRzLmluc2VydCh0YXJnZXRJZCwgcHVycG9zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGVzdGluZ0hvb2tzU3BpID09PSBudWxsIHx8IHRlc3RpbmdIb29rc1NwaSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGVzdGluZ0hvb2tzU3BpLm5vdGlmeU9uRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2goY3JlYXRlRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2hJbmZvRm9yVGVzdGluZ0hvb2tzKGN1cnJlbnRTaXplLCB3YXRjaENoYW5nZS5leGlzdGVuY2VGaWx0ZXIsIHRoaXMubWV0YWRhdGFQcm92aWRlci5nZXREYXRhYmFzZUlkKCksIGJsb29tRmlsdGVyLCBzdGF0dXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgdGhlIGJsb29tIGZpbHRlciBmcm9tIHRoZSBcInVuY2hhbmdlZF9uYW1lc1wiIGZpZWxkIG9mIGFuIGV4aXN0ZW5jZVxuICAgICAqIGZpbHRlci5cbiAgICAgKi9cbiAgICBwYXJzZUJsb29tRmlsdGVyKHdhdGNoQ2hhbmdlKSB7XG4gICAgICAgIGNvbnN0IHVuY2hhbmdlZE5hbWVzID0gd2F0Y2hDaGFuZ2UuZXhpc3RlbmNlRmlsdGVyLnVuY2hhbmdlZE5hbWVzO1xuICAgICAgICBpZiAoIXVuY2hhbmdlZE5hbWVzIHx8ICF1bmNoYW5nZWROYW1lcy5iaXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGJpdHM6IHsgYml0bWFwID0gJycsIHBhZGRpbmcgPSAwIH0sIGhhc2hDb3VudCA9IDAgfSA9IHVuY2hhbmdlZE5hbWVzO1xuICAgICAgICBsZXQgbm9ybWFsaXplZEJpdG1hcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRCaXRtYXAgPSBub3JtYWxpemVCeXRlU3RyaW5nKGJpdG1hcCkudG9VaW50OEFycmF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEJhc2U2NERlY29kZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgbG9nV2FybignRGVjb2RpbmcgdGhlIGJhc2U2NCBibG9vbSBmaWx0ZXIgaW4gZXhpc3RlbmNlIGZpbHRlciBmYWlsZWQgKCcgK1xuICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSArXG4gICAgICAgICAgICAgICAgICAgICcpOyBpZ25vcmluZyB0aGUgYmxvb20gZmlsdGVyIGFuZCBmYWxsaW5nIGJhY2sgdG8gZnVsbCByZS1xdWVyeS4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgYmxvb21GaWx0ZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBCbG9vbUZpbHRlciB0aHJvd3MgZXJyb3IgaWYgdGhlIGlucHV0cyBhcmUgaW52YWxpZC5cbiAgICAgICAgICAgIGJsb29tRmlsdGVyID0gbmV3IEJsb29tRmlsdGVyKG5vcm1hbGl6ZWRCaXRtYXAsIHBhZGRpbmcsIGhhc2hDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEJsb29tRmlsdGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2dXYXJuKCdCbG9vbUZpbHRlciBlcnJvcjogJywgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ1dhcm4oJ0FwcGx5aW5nIGJsb29tIGZpbHRlciBmYWlsZWQ6ICcsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvb21GaWx0ZXIuYml0Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibG9vbUZpbHRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbHkgYmxvb20gZmlsdGVyIHRvIHJlbW92ZSB0aGUgZGVsZXRlZCBkb2N1bWVudHMsIGFuZCByZXR1cm4gdGhlXG4gICAgICogYXBwbGljYXRpb24gc3RhdHVzLlxuICAgICAqL1xuICAgIGFwcGx5Qmxvb21GaWx0ZXIoYmxvb21GaWx0ZXIsIHdhdGNoQ2hhbmdlLCBjdXJyZW50Q291bnQpIHtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRDb3VudCA9IHdhdGNoQ2hhbmdlLmV4aXN0ZW5jZUZpbHRlci5jb3VudDtcbiAgICAgICAgY29uc3QgcmVtb3ZlZERvY3VtZW50Q291bnQgPSB0aGlzLmZpbHRlclJlbW92ZWREb2N1bWVudHMoYmxvb21GaWx0ZXIsIHdhdGNoQ2hhbmdlLnRhcmdldElkKTtcbiAgICAgICAgcmV0dXJuIGV4cGVjdGVkQ291bnQgPT09IGN1cnJlbnRDb3VudCAtIHJlbW92ZWREb2N1bWVudENvdW50XG4gICAgICAgICAgICA/IDAgLyogQmxvb21GaWx0ZXJBcHBsaWNhdGlvblN0YXR1cy5TdWNjZXNzICovXG4gICAgICAgICAgICA6IDIgLyogQmxvb21GaWx0ZXJBcHBsaWNhdGlvblN0YXR1cy5GYWxzZVBvc2l0aXZlICovO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgb3V0IHJlbW92ZWQgZG9jdW1lbnRzIGJhc2VkIG9uIGJsb29tIGZpbHRlciBtZW1iZXJzaGlwIHJlc3VsdCBhbmRcbiAgICAgKiByZXR1cm4gbnVtYmVyIG9mIGRvY3VtZW50cyByZW1vdmVkLlxuICAgICAqL1xuICAgIGZpbHRlclJlbW92ZWREb2N1bWVudHMoYmxvb21GaWx0ZXIsIHRhcmdldElkKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nS2V5cyA9IHRoaXMubWV0YWRhdGFQcm92aWRlci5nZXRSZW1vdGVLZXlzRm9yVGFyZ2V0KHRhcmdldElkKTtcbiAgICAgICAgbGV0IHJlbW92YWxDb3VudCA9IDA7XG4gICAgICAgIGV4aXN0aW5nS2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXRhYmFzZUlkID0gdGhpcy5tZXRhZGF0YVByb3ZpZGVyLmdldERhdGFiYXNlSWQoKTtcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50UGF0aCA9IGBwcm9qZWN0cy8ke2RhdGFiYXNlSWQucHJvamVjdElkfWAgK1xuICAgICAgICAgICAgICAgIGAvZGF0YWJhc2VzLyR7ZGF0YWJhc2VJZC5kYXRhYmFzZX1gICtcbiAgICAgICAgICAgICAgICBgL2RvY3VtZW50cy8ke2tleS5wYXRoLmNhbm9uaWNhbFN0cmluZygpfWA7XG4gICAgICAgICAgICBpZiAoIWJsb29tRmlsdGVyLm1pZ2h0Q29udGFpbihkb2N1bWVudFBhdGgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVEb2N1bWVudEZyb21UYXJnZXQodGFyZ2V0SWQsIGtleSwgLyp1cGRhdGVkRG9jdW1lbnQ9Ki8gbnVsbCk7XG4gICAgICAgICAgICAgICAgcmVtb3ZhbENvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVtb3ZhbENvdW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgY3VycmVudGx5IGFjY3VtdWxhdGVkIHN0YXRlIGludG8gYSByZW1vdGUgZXZlbnQgYXQgdGhlXG4gICAgICogcHJvdmlkZWQgc25hcHNob3QgdmVyc2lvbi4gUmVzZXRzIHRoZSBhY2N1bXVsYXRlZCBjaGFuZ2VzIGJlZm9yZSByZXR1cm5pbmcuXG4gICAgICovXG4gICAgY3JlYXRlUmVtb3RlRXZlbnQoc25hcHNob3RWZXJzaW9uKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldENoYW5nZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMudGFyZ2V0U3RhdGVzLmZvckVhY2goKHRhcmdldFN0YXRlLCB0YXJnZXRJZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0RGF0YSA9IHRoaXMudGFyZ2V0RGF0YUZvckFjdGl2ZVRhcmdldCh0YXJnZXRJZCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0RGF0YSkge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRTdGF0ZS5jdXJyZW50ICYmIHRhcmdldElzRG9jdW1lbnRUYXJnZXQodGFyZ2V0RGF0YS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvY3VtZW50IHF1ZXJpZXMgZm9yIGRvY3VtZW50IHRoYXQgZG9uJ3QgZXhpc3QgY2FuIHByb2R1Y2UgYW4gZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzdWx0IHNldC4gVG8gdXBkYXRlIG91ciBsb2NhbCBjYWNoZSwgd2Ugc3ludGhlc2l6ZSBhIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBpZiB3ZSBoYXZlIG5vdCBwcmV2aW91c2x5IHJlY2VpdmVkIHRoZSBkb2N1bWVudCBmb3IgdGhpc1xuICAgICAgICAgICAgICAgICAgICAvLyB0YXJnZXQuIFRoaXMgcmVzb2x2ZXMgdGhlIGxpbWJvIHN0YXRlIG9mIHRoZSBkb2N1bWVudCwgcmVtb3ZpbmcgaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSBsaW1ib0RvY3VtZW50UmVmcy5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhkaW1vbmQpOiBJZGVhbGx5IHdlIHdvdWxkIGhhdmUgYW4gZXhwbGljaXQgbG9va3VwIHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAvLyBpbnN0ZWFkIHJlc3VsdGluZyBpbiBhbiBleHBsaWNpdCBkZWxldGUgbWVzc2FnZSBhbmQgd2UgY291bGRcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoaXMgc3BlY2lhbCBsb2dpYy5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gbmV3IERvY3VtZW50S2V5KHRhcmdldERhdGEudGFyZ2V0LnBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZW5zdXJlRG9jdW1lbnRVcGRhdGVCeVRhcmdldChrZXkpLmhhcyh0YXJnZXRJZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLnRhcmdldENvbnRhaW5zRG9jdW1lbnQodGFyZ2V0SWQsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRG9jdW1lbnRGcm9tVGFyZ2V0KHRhcmdldElkLCBrZXksIE11dGFibGVEb2N1bWVudC5uZXdOb0RvY3VtZW50KGtleSwgc25hcHNob3RWZXJzaW9uKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldFN0YXRlLmhhc1BlbmRpbmdDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldENoYW5nZXMuc2V0KHRhcmdldElkLCB0YXJnZXRTdGF0ZS50b1RhcmdldENoYW5nZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U3RhdGUuY2xlYXJQZW5kaW5nQ2hhbmdlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxldCByZXNvbHZlZExpbWJvRG9jdW1lbnRzID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgLy8gV2UgZXh0cmFjdCB0aGUgc2V0IG9mIGxpbWJvLW9ubHkgZG9jdW1lbnQgdXBkYXRlcyBhcyB0aGUgR0MgbG9naWNcbiAgICAgICAgLy8gc3BlY2lhbC1jYXNlcyBkb2N1bWVudHMgdGhhdCBkbyBub3QgYXBwZWFyIGluIHRoZSB0YXJnZXQgY2FjaGUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRPRE8oZ3NvbHRpcyk6IEV4cGFuZCBvbiB0aGlzIGNvbW1lbnQgb25jZSBHQyBpcyBhdmFpbGFibGUgaW4gdGhlIEpTXG4gICAgICAgIC8vIGNsaWVudC5cbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nLmZvckVhY2goKGtleSwgdGFyZ2V0cykgPT4ge1xuICAgICAgICAgICAgbGV0IGlzT25seUxpbWJvVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRhcmdldHMuZm9yRWFjaFdoaWxlKHRhcmdldElkID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXREYXRhID0gdGhpcy50YXJnZXREYXRhRm9yQWN0aXZlVGFyZ2V0KHRhcmdldElkKTtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RGF0YSAmJlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXREYXRhLnB1cnBvc2UgIT09IFwiVGFyZ2V0UHVycG9zZUxpbWJvUmVzb2x1dGlvblwiIC8qIFRhcmdldFB1cnBvc2UuTGltYm9SZXNvbHV0aW9uICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzT25seUxpbWJvVGFyZ2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpc09ubHlMaW1ib1RhcmdldCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkTGltYm9Eb2N1bWVudHMgPSByZXNvbHZlZExpbWJvRG9jdW1lbnRzLmFkZChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRVcGRhdGVzLmZvckVhY2goKF8sIGRvYykgPT4gZG9jLnNldFJlYWRUaW1lKHNuYXBzaG90VmVyc2lvbikpO1xuICAgICAgICBjb25zdCByZW1vdGVFdmVudCA9IG5ldyBSZW1vdGVFdmVudChzbmFwc2hvdFZlcnNpb24sIHRhcmdldENoYW5nZXMsIHRoaXMucGVuZGluZ1RhcmdldFJlc2V0cywgdGhpcy5wZW5kaW5nRG9jdW1lbnRVcGRhdGVzLCByZXNvbHZlZExpbWJvRG9jdW1lbnRzKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRVcGRhdGVzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XG4gICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VXBkYXRlc0J5VGFyZ2V0ID0gZG9jdW1lbnRUYXJnZXRNYXAoKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nID0gZG9jdW1lbnRUYXJnZXRNYXAoKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nVGFyZ2V0UmVzZXRzID0gbmV3IFNvcnRlZE1hcChwcmltaXRpdmVDb21wYXJhdG9yKTtcbiAgICAgICAgcmV0dXJuIHJlbW90ZUV2ZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBwcm92aWRlZCBkb2N1bWVudCB0byB0aGUgaW50ZXJuYWwgbGlzdCBvZiBkb2N1bWVudCB1cGRhdGVzIGFuZFxuICAgICAqIGl0cyBkb2N1bWVudCBrZXkgdG8gdGhlIGdpdmVuIHRhcmdldCdzIG1hcHBpbmcuXG4gICAgICovXG4gICAgLy8gVmlzaWJsZSBmb3IgdGVzdGluZy5cbiAgICBhZGREb2N1bWVudFRvVGFyZ2V0KHRhcmdldElkLCBkb2N1bWVudCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmVUYXJnZXQodGFyZ2V0SWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhbmdlVHlwZSA9IHRoaXMudGFyZ2V0Q29udGFpbnNEb2N1bWVudCh0YXJnZXRJZCwgZG9jdW1lbnQua2V5KVxuICAgICAgICAgICAgPyAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi9cbiAgICAgICAgICAgIDogMCAvKiBDaGFuZ2VUeXBlLkFkZGVkICovO1xuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IHRoaXMuZW5zdXJlVGFyZ2V0U3RhdGUodGFyZ2V0SWQpO1xuICAgICAgICB0YXJnZXRTdGF0ZS5hZGREb2N1bWVudENoYW5nZShkb2N1bWVudC5rZXksIGNoYW5nZVR5cGUpO1xuICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXMgPSB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXMuaW5zZXJ0KGRvY3VtZW50LmtleSwgZG9jdW1lbnQpO1xuICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXNCeVRhcmdldCA9XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXNCeVRhcmdldC5pbnNlcnQoZG9jdW1lbnQua2V5LCB0aGlzLmVuc3VyZURvY3VtZW50VXBkYXRlQnlUYXJnZXQoZG9jdW1lbnQua2V5KS5hZGQodGFyZ2V0SWQpKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nID1cbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VGFyZ2V0TWFwcGluZy5pbnNlcnQoZG9jdW1lbnQua2V5LCB0aGlzLmVuc3VyZURvY3VtZW50VGFyZ2V0TWFwcGluZyhkb2N1bWVudC5rZXkpLmFkZCh0YXJnZXRJZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBwcm92aWRlZCBkb2N1bWVudCBmcm9tIHRoZSB0YXJnZXQgbWFwcGluZy4gSWYgdGhlXG4gICAgICogZG9jdW1lbnQgbm8gbG9uZ2VyIG1hdGNoZXMgdGhlIHRhcmdldCwgYnV0IHRoZSBkb2N1bWVudCdzIHN0YXRlIGlzIHN0aWxsXG4gICAgICoga25vd24gKGUuZy4gd2Uga25vdyB0aGF0IHRoZSBkb2N1bWVudCB3YXMgZGVsZXRlZCBvciB3ZSByZWNlaXZlZCB0aGUgY2hhbmdlXG4gICAgICogdGhhdCBjYXVzZWQgdGhlIGZpbHRlciBtaXNtYXRjaCksIHRoZSBuZXcgZG9jdW1lbnQgY2FuIGJlIHByb3ZpZGVkXG4gICAgICogdG8gdXBkYXRlIHRoZSByZW1vdGUgZG9jdW1lbnQgY2FjaGUuXG4gICAgICovXG4gICAgLy8gVmlzaWJsZSBmb3IgdGVzdGluZy5cbiAgICByZW1vdmVEb2N1bWVudEZyb21UYXJnZXQodGFyZ2V0SWQsIGtleSwgdXBkYXRlZERvY3VtZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZVRhcmdldCh0YXJnZXRJZCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IHRoaXMuZW5zdXJlVGFyZ2V0U3RhdGUodGFyZ2V0SWQpO1xuICAgICAgICBpZiAodGhpcy50YXJnZXRDb250YWluc0RvY3VtZW50KHRhcmdldElkLCBrZXkpKSB7XG4gICAgICAgICAgICB0YXJnZXRTdGF0ZS5hZGREb2N1bWVudENoYW5nZShrZXksIDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZSBkb2N1bWVudCBtYXkgaGF2ZSBlbnRlcmVkIGFuZCBsZWZ0IHRoZSB0YXJnZXQgYmVmb3JlIHdlIHJhaXNlZCBhXG4gICAgICAgICAgICAvLyBzbmFwc2hvdCwgc28gd2UgY2FuIGp1c3QgaWdub3JlIHRoZSBjaGFuZ2UuXG4gICAgICAgICAgICB0YXJnZXRTdGF0ZS5yZW1vdmVEb2N1bWVudENoYW5nZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VGFyZ2V0TWFwcGluZyA9XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFRhcmdldE1hcHBpbmcuaW5zZXJ0KGtleSwgdGhpcy5lbnN1cmVEb2N1bWVudFRhcmdldE1hcHBpbmcoa2V5KS5kZWxldGUodGFyZ2V0SWQpKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nID1cbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VGFyZ2V0TWFwcGluZy5pbnNlcnQoa2V5LCB0aGlzLmVuc3VyZURvY3VtZW50VGFyZ2V0TWFwcGluZyhrZXkpLmFkZCh0YXJnZXRJZCkpO1xuICAgICAgICBpZiAodXBkYXRlZERvY3VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXMgPSB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXMuaW5zZXJ0KGtleSwgdXBkYXRlZERvY3VtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVUYXJnZXQodGFyZ2V0SWQpIHtcbiAgICAgICAgdGhpcy50YXJnZXRTdGF0ZXMuZGVsZXRlKHRhcmdldElkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBjb3VudCBvZiBkb2N1bWVudHMgaW4gdGhlIHRhcmdldC4gVGhpcyBpbmNsdWRlcyBib3RoXG4gICAgICogdGhlIG51bWJlciBvZiBkb2N1bWVudHMgdGhhdCB0aGUgTG9jYWxTdG9yZSBjb25zaWRlcnMgdG8gYmUgcGFydCBvZiB0aGVcbiAgICAgKiB0YXJnZXQgYXMgd2VsbCBhcyBhbnkgYWNjdW11bGF0ZWQgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBnZXRDdXJyZW50RG9jdW1lbnRDb3VudEZvclRhcmdldCh0YXJnZXRJZCkge1xuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IHRoaXMuZW5zdXJlVGFyZ2V0U3RhdGUodGFyZ2V0SWQpO1xuICAgICAgICBjb25zdCB0YXJnZXRDaGFuZ2UgPSB0YXJnZXRTdGF0ZS50b1RhcmdldENoYW5nZSgpO1xuICAgICAgICByZXR1cm4gKHRoaXMubWV0YWRhdGFQcm92aWRlci5nZXRSZW1vdGVLZXlzRm9yVGFyZ2V0KHRhcmdldElkKS5zaXplICtcbiAgICAgICAgICAgIHRhcmdldENoYW5nZS5hZGRlZERvY3VtZW50cy5zaXplIC1cbiAgICAgICAgICAgIHRhcmdldENoYW5nZS5yZW1vdmVkRG9jdW1lbnRzLnNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmNyZW1lbnQgdGhlIG51bWJlciBvZiBhY2tzIG5lZWRlZCBmcm9tIHdhdGNoIGJlZm9yZSB3ZSBjYW4gY29uc2lkZXIgdGhlXG4gICAgICogc2VydmVyIHRvIGJlICdpbi1zeW5jJyB3aXRoIHRoZSBjbGllbnQncyBhY3RpdmUgdGFyZ2V0cy5cbiAgICAgKi9cbiAgICByZWNvcmRQZW5kaW5nVGFyZ2V0UmVxdWVzdCh0YXJnZXRJZCkge1xuICAgICAgICAvLyBGb3IgZWFjaCByZXF1ZXN0IHdlIGdldCB3ZSBuZWVkIHRvIHJlY29yZCB3ZSBuZWVkIGEgcmVzcG9uc2UgZm9yIGl0LlxuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IHRoaXMuZW5zdXJlVGFyZ2V0U3RhdGUodGFyZ2V0SWQpO1xuICAgICAgICB0YXJnZXRTdGF0ZS5yZWNvcmRQZW5kaW5nVGFyZ2V0UmVxdWVzdCgpO1xuICAgIH1cbiAgICBlbnN1cmVUYXJnZXRTdGF0ZSh0YXJnZXRJZCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy50YXJnZXRTdGF0ZXMuZ2V0KHRhcmdldElkKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBUYXJnZXRTdGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRTdGF0ZXMuc2V0KHRhcmdldElkLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVuc3VyZURvY3VtZW50VGFyZ2V0TWFwcGluZyhrZXkpIHtcbiAgICAgICAgbGV0IHRhcmdldE1hcHBpbmcgPSB0aGlzLnBlbmRpbmdEb2N1bWVudFRhcmdldE1hcHBpbmcuZ2V0KGtleSk7XG4gICAgICAgIGlmICghdGFyZ2V0TWFwcGluZykge1xuICAgICAgICAgICAgdGFyZ2V0TWFwcGluZyA9IG5ldyBTb3J0ZWRTZXQocHJpbWl0aXZlQ29tcGFyYXRvcik7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFRhcmdldE1hcHBpbmcgPVxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VGFyZ2V0TWFwcGluZy5pbnNlcnQoa2V5LCB0YXJnZXRNYXBwaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0TWFwcGluZztcbiAgICB9XG4gICAgZW5zdXJlRG9jdW1lbnRVcGRhdGVCeVRhcmdldChrZXkpIHtcbiAgICAgICAgbGV0IHRhcmdldE1hcHBpbmcgPSB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXNCeVRhcmdldC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCF0YXJnZXRNYXBwaW5nKSB7XG4gICAgICAgICAgICB0YXJnZXRNYXBwaW5nID0gbmV3IFNvcnRlZFNldChwcmltaXRpdmVDb21wYXJhdG9yKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VXBkYXRlc0J5VGFyZ2V0ID1cbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXNCeVRhcmdldC5pbnNlcnQoa2V5LCB0YXJnZXRNYXBwaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0TWFwcGluZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgdGhhdCB0aGUgdXNlciBpcyBzdGlsbCBpbnRlcmVzdGVkIGluIHRoaXMgdGFyZ2V0IChieSBjYWxsaW5nXG4gICAgICogYGdldFRhcmdldERhdGFGb3JUYXJnZXQoKWApIGFuZCB0aGF0IHdlIGFyZSBub3Qgd2FpdGluZyBmb3IgcGVuZGluZyBBRERzXG4gICAgICogZnJvbSB3YXRjaC5cbiAgICAgKi9cbiAgICBpc0FjdGl2ZVRhcmdldCh0YXJnZXRJZCkge1xuICAgICAgICBjb25zdCB0YXJnZXRBY3RpdmUgPSB0aGlzLnRhcmdldERhdGFGb3JBY3RpdmVUYXJnZXQodGFyZ2V0SWQpICE9PSBudWxsO1xuICAgICAgICBpZiAoIXRhcmdldEFjdGl2ZSkge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRnLCAnRGV0ZWN0ZWQgaW5hY3RpdmUgdGFyZ2V0JywgdGFyZ2V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXRBY3RpdmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFRhcmdldERhdGEgZm9yIGFuIGFjdGl2ZSB0YXJnZXQgKGkuZS4gYSB0YXJnZXQgdGhhdCB0aGUgdXNlclxuICAgICAqIGlzIHN0aWxsIGludGVyZXN0ZWQgaW4gdGhhdCBoYXMgbm8gb3V0c3RhbmRpbmcgdGFyZ2V0IGNoYW5nZSByZXF1ZXN0cykuXG4gICAgICovXG4gICAgdGFyZ2V0RGF0YUZvckFjdGl2ZVRhcmdldCh0YXJnZXRJZCkge1xuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IHRoaXMudGFyZ2V0U3RhdGVzLmdldCh0YXJnZXRJZCk7XG4gICAgICAgIHJldHVybiB0YXJnZXRTdGF0ZSAmJiB0YXJnZXRTdGF0ZS5pc1BlbmRpbmdcbiAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgOiB0aGlzLm1ldGFkYXRhUHJvdmlkZXIuZ2V0VGFyZ2V0RGF0YUZvclRhcmdldCh0YXJnZXRJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgc3RhdGUgb2YgYSBXYXRjaCB0YXJnZXQgdG8gaXRzIGluaXRpYWwgc3RhdGUgKGUuZy4gc2V0c1xuICAgICAqICdjdXJyZW50JyB0byBmYWxzZSwgY2xlYXJzIHRoZSByZXN1bWUgdG9rZW4gYW5kIHJlbW92ZXMgaXRzIHRhcmdldCBtYXBwaW5nXG4gICAgICogZnJvbSBhbGwgZG9jdW1lbnRzKS5cbiAgICAgKi9cbiAgICByZXNldFRhcmdldCh0YXJnZXRJZCkge1xuICAgICAgICB0aGlzLnRhcmdldFN0YXRlcy5zZXQodGFyZ2V0SWQsIG5ldyBUYXJnZXRTdGF0ZSgpKTtcbiAgICAgICAgLy8gVHJpZ2dlciByZW1vdmFsIGZvciBhbnkgZG9jdW1lbnRzIGN1cnJlbnRseSBtYXBwZWQgdG8gdGhpcyB0YXJnZXQuXG4gICAgICAgIC8vIFRoZXNlIHJlbW92YWxzIHdpbGwgYmUgcGFydCBvZiB0aGUgaW5pdGlhbCBzbmFwc2hvdCBpZiBXYXRjaCBkb2VzIG5vdFxuICAgICAgICAvLyByZXNlbmQgdGhlc2UgZG9jdW1lbnRzLlxuICAgICAgICBjb25zdCBleGlzdGluZ0tleXMgPSB0aGlzLm1ldGFkYXRhUHJvdmlkZXIuZ2V0UmVtb3RlS2V5c0ZvclRhcmdldCh0YXJnZXRJZCk7XG4gICAgICAgIGV4aXN0aW5nS2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZURvY3VtZW50RnJvbVRhcmdldCh0YXJnZXRJZCwga2V5LCAvKnVwZGF0ZWREb2N1bWVudD0qLyBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgTG9jYWxTdG9yZSBjb25zaWRlcnMgdGhlIGRvY3VtZW50IHRvIGJlIHBhcnQgb2YgdGhlXG4gICAgICogc3BlY2lmaWVkIHRhcmdldC5cbiAgICAgKi9cbiAgICB0YXJnZXRDb250YWluc0RvY3VtZW50KHRhcmdldElkLCBrZXkpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdLZXlzID0gdGhpcy5tZXRhZGF0YVByb3ZpZGVyLmdldFJlbW90ZUtleXNGb3JUYXJnZXQodGFyZ2V0SWQpO1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdLZXlzLmhhcyhrZXkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRvY3VtZW50VGFyZ2V0TWFwKCkge1xuICAgIHJldHVybiBuZXcgU29ydGVkTWFwKERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xufVxuZnVuY3Rpb24gc25hcHNob3RDaGFuZ2VzTWFwKCkge1xuICAgIHJldHVybiBuZXcgU29ydGVkTWFwKERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xufVxuZnVuY3Rpb24gY3JlYXRlRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2hJbmZvRm9yVGVzdGluZ0hvb2tzKGxvY2FsQ2FjaGVDb3VudCwgZXhpc3RlbmNlRmlsdGVyLCBkYXRhYmFzZUlkLCBibG9vbUZpbHRlciwgYmxvb21GaWx0ZXJTdGF0dXMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIGxvY2FsQ2FjaGVDb3VudCxcbiAgICAgICAgZXhpc3RlbmNlRmlsdGVyQ291bnQ6IGV4aXN0ZW5jZUZpbHRlci5jb3VudCxcbiAgICAgICAgZGF0YWJhc2VJZDogZGF0YWJhc2VJZC5kYXRhYmFzZSxcbiAgICAgICAgcHJvamVjdElkOiBkYXRhYmFzZUlkLnByb2plY3RJZFxuICAgIH07XG4gICAgY29uc3QgdW5jaGFuZ2VkTmFtZXMgPSBleGlzdGVuY2VGaWx0ZXIudW5jaGFuZ2VkTmFtZXM7XG4gICAgaWYgKHVuY2hhbmdlZE5hbWVzKSB7XG4gICAgICAgIHJlc3VsdC5ibG9vbUZpbHRlciA9IHtcbiAgICAgICAgICAgIGFwcGxpZWQ6IGJsb29tRmlsdGVyU3RhdHVzID09PSAwIC8qIEJsb29tRmlsdGVyQXBwbGljYXRpb25TdGF0dXMuU3VjY2VzcyAqLyxcbiAgICAgICAgICAgIGhhc2hDb3VudDogKF9hID0gdW5jaGFuZ2VkTmFtZXMgPT09IG51bGwgfHwgdW5jaGFuZ2VkTmFtZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVuY2hhbmdlZE5hbWVzLmhhc2hDb3VudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCxcbiAgICAgICAgICAgIGJpdG1hcExlbmd0aDogKF9kID0gKF9jID0gKF9iID0gdW5jaGFuZ2VkTmFtZXMgPT09IG51bGwgfHwgdW5jaGFuZ2VkTmFtZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVuY2hhbmdlZE5hbWVzLmJpdHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5iaXRtYXApID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5sZW5ndGgpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDAsXG4gICAgICAgICAgICBwYWRkaW5nOiAoX2YgPSAoX2UgPSB1bmNoYW5nZWROYW1lcyA9PT0gbnVsbCB8fCB1bmNoYW5nZWROYW1lcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdW5jaGFuZ2VkTmFtZXMuYml0cykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnBhZGRpbmcpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IDAsXG4gICAgICAgICAgICBtaWdodENvbnRhaW46ICh2YWx1ZSkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBibG9vbUZpbHRlciA9PT0gbnVsbCB8fCBibG9vbUZpbHRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmxvb21GaWx0ZXIubWlnaHRDb250YWluKHZhbHVlKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7IH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IERJUkVDVElPTlMgPSAoKCkgPT4ge1xuICAgIGNvbnN0IGRpcnMgPSB7fTtcbiAgICBkaXJzW1wiYXNjXCIgLyogRGlyZWN0aW9uLkFTQ0VORElORyAqL10gPSAnQVNDRU5ESU5HJztcbiAgICBkaXJzW1wiZGVzY1wiIC8qIERpcmVjdGlvbi5ERVNDRU5ESU5HICovXSA9ICdERVNDRU5ESU5HJztcbiAgICByZXR1cm4gZGlycztcbn0pKCk7XG5jb25zdCBPUEVSQVRPUlMgPSAoKCkgPT4ge1xuICAgIGNvbnN0IG9wcyA9IHt9O1xuICAgIG9wc1tcIjxcIiAvKiBPcGVyYXRvci5MRVNTX1RIQU4gKi9dID0gJ0xFU1NfVEhBTic7XG4gICAgb3BzW1wiPD1cIiAvKiBPcGVyYXRvci5MRVNTX1RIQU5fT1JfRVFVQUwgKi9dID0gJ0xFU1NfVEhBTl9PUl9FUVVBTCc7XG4gICAgb3BzW1wiPlwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTiAqL10gPSAnR1JFQVRFUl9USEFOJztcbiAgICBvcHNbXCI+PVwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTl9PUl9FUVVBTCAqL10gPSAnR1JFQVRFUl9USEFOX09SX0VRVUFMJztcbiAgICBvcHNbXCI9PVwiIC8qIE9wZXJhdG9yLkVRVUFMICovXSA9ICdFUVVBTCc7XG4gICAgb3BzW1wiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi9dID0gJ05PVF9FUVVBTCc7XG4gICAgb3BzW1wiYXJyYXktY29udGFpbnNcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOUyAqL10gPSAnQVJSQVlfQ09OVEFJTlMnO1xuICAgIG9wc1tcImluXCIgLyogT3BlcmF0b3IuSU4gKi9dID0gJ0lOJztcbiAgICBvcHNbXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi9dID0gJ05PVF9JTic7XG4gICAgb3BzW1wiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovXSA9ICdBUlJBWV9DT05UQUlOU19BTlknO1xuICAgIHJldHVybiBvcHM7XG59KSgpO1xuY29uc3QgQ09NUE9TSVRFX09QRVJBVE9SUyA9ICgoKSA9PiB7XG4gICAgY29uc3Qgb3BzID0ge307XG4gICAgb3BzW1wiYW5kXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuQU5EICovXSA9ICdBTkQnO1xuICAgIG9wc1tcIm9yXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuT1IgKi9dID0gJ09SJztcbiAgICByZXR1cm4gb3BzO1xufSkoKTtcbmZ1bmN0aW9uIGFzc2VydFByZXNlbnQodmFsdWUsIGRlc2NyaXB0aW9uKSB7XG59XG4vKipcbiAqIFRoaXMgY2xhc3MgZ2VuZXJhdGVzIEpzb25PYmplY3QgdmFsdWVzIGZvciB0aGUgRGF0YXN0b3JlIEFQSSBzdWl0YWJsZSBmb3JcbiAqIHNlbmRpbmcgdG8gZWl0aGVyIEdSUEMgc3R1YiBtZXRob2RzIG9yIHZpYSB0aGUgSlNPTi9IVFRQIFJFU1QgQVBJLlxuICpcbiAqIFRoZSBzZXJpYWxpemVyIHN1cHBvcnRzIGJvdGggUHJvdG9idWYuanMgYW5kIFByb3RvMyBKU09OIGZvcm1hdHMuIEJ5XG4gKiBzZXR0aW5nIGB1c2VQcm90bzNKc29uYCB0byB0cnVlLCB0aGUgc2VyaWFsaXplciB3aWxsIHVzZSB0aGUgUHJvdG8zIEpTT05cbiAqIGZvcm1hdC5cbiAqXG4gKiBGb3IgYSBkZXNjcmlwdGlvbiBvZiB0aGUgUHJvdG8zIEpTT04gZm9ybWF0IGNoZWNrXG4gKiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9wcm90b2NvbC1idWZmZXJzL2RvY3MvcHJvdG8zI2pzb25cbiAqXG4gKiBUT0RPKGtsaW10KTogV2UgY2FuIHJlbW92ZSB0aGUgZGF0YWJhc2VJZCBhcmd1bWVudCBpZiB3ZSBrZWVwIHRoZSBmdWxsXG4gKiByZXNvdXJjZSBuYW1lIGluIGRvY3VtZW50cy5cbiAqL1xuY2xhc3MgSnNvblByb3RvU2VyaWFsaXplciB7XG4gICAgY29uc3RydWN0b3IoZGF0YWJhc2VJZCwgdXNlUHJvdG8zSnNvbikge1xuICAgICAgICB0aGlzLmRhdGFiYXNlSWQgPSBkYXRhYmFzZUlkO1xuICAgICAgICB0aGlzLnVzZVByb3RvM0pzb24gPSB1c2VQcm90bzNKc29uO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZyb21ScGNTdGF0dXMoc3RhdHVzKSB7XG4gICAgY29uc3QgY29kZSA9IHN0YXR1cy5jb2RlID09PSB1bmRlZmluZWQgPyBDb2RlLlVOS05PV04gOiBtYXBDb2RlRnJvbVJwY0NvZGUoc3RhdHVzLmNvZGUpO1xuICAgIHJldHVybiBuZXcgRmlyZXN0b3JlRXJyb3IoY29kZSwgc3RhdHVzLm1lc3NhZ2UgfHwgJycpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgdmFsdWUgZm9yIGEgbnVtYmVyIChvciBudWxsKSB0aGF0J3MgYXBwcm9wcmlhdGUgdG8gcHV0IGludG9cbiAqIGEgZ29vZ2xlLnByb3RvYnVmLkludDMyVmFsdWUgcHJvdG8uXG4gKiBETyBOT1QgVVNFIFRISVMgRk9SIEFOWVRISU5HIEVMU0UuXG4gKiBUaGlzIG1ldGhvZCBjaGVhdHMuIEl0J3MgdHlwZWQgYXMgcmV0dXJuaW5nIFwibnVtYmVyXCIgYmVjYXVzZSB0aGF0J3Mgd2hhdFxuICogb3VyIGdlbmVyYXRlZCBwcm90byBpbnRlcmZhY2VzIHNheSBJbnQzMlZhbHVlIG11c3QgYmUuIEJ1dCBHUlBDIGFjdHVhbGx5XG4gKiBleHBlY3RzIGEgeyB2YWx1ZTogPG51bWJlcj4gfSBzdHJ1Y3QuXG4gKi9cbmZ1bmN0aW9uIHRvSW50MzJQcm90byhzZXJpYWxpemVyLCB2YWwpIHtcbiAgICBpZiAoc2VyaWFsaXplci51c2VQcm90bzNKc29uIHx8IGlzTnVsbE9yVW5kZWZpbmVkKHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWwgfTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgYSBudW1iZXIgKG9yIG51bGwpIGZyb20gYSBnb29nbGUucHJvdG9idWYuSW50MzJWYWx1ZSBwcm90by5cbiAqL1xuZnVuY3Rpb24gZnJvbUludDMyUHJvdG8odmFsKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmVzdWx0ID0gdmFsLnZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gaXNOdWxsT3JVbmRlZmluZWQocmVzdWx0KSA/IG51bGwgOiByZXN1bHQ7XG59XG4vKipcbiAqIFJldHVybnMgYSB2YWx1ZSBmb3IgYSBEYXRlIHRoYXQncyBhcHByb3ByaWF0ZSB0byBwdXQgaW50byBhIHByb3RvLlxuICovXG5mdW5jdGlvbiB0b1RpbWVzdGFtcChzZXJpYWxpemVyLCB0aW1lc3RhbXApIHtcbiAgICBpZiAoc2VyaWFsaXplci51c2VQcm90bzNKc29uKSB7XG4gICAgICAgIC8vIFNlcmlhbGl6ZSB0byBJU08tODYwMSBkYXRlIGZvcm1hdCwgYnV0IHdpdGggZnVsbCBuYW5vIHJlc29sdXRpb24uXG4gICAgICAgIC8vIFNpbmNlIEpTIERhdGUgaGFzIG9ubHkgbWlsbGlzLCBsZXQncyBvbmx5IHVzZSBpdCBmb3IgdGhlIHNlY29uZHMgYW5kXG4gICAgICAgIC8vIHRoZW4gbWFudWFsbHkgYWRkIHRoZSBmcmFjdGlvbnMgdG8gdGhlIGVuZC5cbiAgICAgICAgY29uc3QganNEYXRlU3RyID0gbmV3IERhdGUodGltZXN0YW1wLnNlY29uZHMgKiAxMDAwKS50b0lTT1N0cmluZygpO1xuICAgICAgICAvLyBSZW1vdmUgLnh4eCBmcmFjIHBhcnQgYW5kIFogaW4gdGhlIGVuZC5cbiAgICAgICAgY29uc3Qgc3RyVW50aWxTZWNvbmRzID0ganNEYXRlU3RyLnJlcGxhY2UoL1xcLlxcZCovLCAnJykucmVwbGFjZSgnWicsICcnKTtcbiAgICAgICAgLy8gUGFkIHRoZSBmcmFjdGlvbiBvdXQgdG8gOSBkaWdpdHMgKG5hbm9zKS5cbiAgICAgICAgY29uc3QgbmFub1N0ciA9ICgnMDAwMDAwMDAwJyArIHRpbWVzdGFtcC5uYW5vc2Vjb25kcykuc2xpY2UoLTkpO1xuICAgICAgICByZXR1cm4gYCR7c3RyVW50aWxTZWNvbmRzfS4ke25hbm9TdHJ9WmA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2Vjb25kczogJycgKyB0aW1lc3RhbXAuc2Vjb25kcyxcbiAgICAgICAgICAgIG5hbm9zOiB0aW1lc3RhbXAubmFub3NlY29uZHNcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gZnJvbVRpbWVzdGFtcChkYXRlKSB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gbm9ybWFsaXplVGltZXN0YW1wKGRhdGUpO1xuICAgIHJldHVybiBuZXcgVGltZXN0YW1wKHRpbWVzdGFtcC5zZWNvbmRzLCB0aW1lc3RhbXAubmFub3MpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgdmFsdWUgZm9yIGJ5dGVzIHRoYXQncyBhcHByb3ByaWF0ZSB0byBwdXQgaW4gYSBwcm90by5cbiAqXG4gKiBWaXNpYmxlIGZvciB0ZXN0aW5nLlxuICovXG5mdW5jdGlvbiB0b0J5dGVzKHNlcmlhbGl6ZXIsIGJ5dGVzKSB7XG4gICAgaWYgKHNlcmlhbGl6ZXIudXNlUHJvdG8zSnNvbikge1xuICAgICAgICByZXR1cm4gYnl0ZXMudG9CYXNlNjQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBieXRlcy50b1VpbnQ4QXJyYXkoKTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgYSBCeXRlU3RyaW5nIGJhc2VkIG9uIHRoZSBwcm90byBzdHJpbmcgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGZyb21CeXRlcyhzZXJpYWxpemVyLCB2YWx1ZSkge1xuICAgIGlmIChzZXJpYWxpemVyLnVzZVByb3RvM0pzb24pIHtcbiAgICAgICAgaGFyZEFzc2VydCh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpO1xuICAgICAgICByZXR1cm4gQnl0ZVN0cmluZy5mcm9tQmFzZTY0U3RyaW5nKHZhbHVlID8gdmFsdWUgOiAnJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBoYXJkQXNzZXJ0KHZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSB2YWx1ZSBpcyBhbiBpbnN0YW5jZSBvZiBib3RoIEJ1ZmZlciBhbmQgVWludDhBcnJheSxcbiAgICAgICAgICAgIC8vIGRlc3BpdGUgdGhlIGZhY3QgdGhhdCBCdWZmZXIgZXh0ZW5kcyBVaW50OEFycmF5LiBJbiBzb21lXG4gICAgICAgICAgICAvLyBlbnZpcm9ubWVudHMsIHN1Y2ggYXMganNkb20sIHRoZSBwcm90b3R5cGUgY2hhaW4gb2YgQnVmZmVyXG4gICAgICAgICAgICAvLyBkb2VzIG5vdCBpbmRpY2F0ZSB0aGF0IGl0IGV4dGVuZHMgVWludDhBcnJheS5cbiAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgQnVmZmVyIHx8XG4gICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpO1xuICAgICAgICByZXR1cm4gQnl0ZVN0cmluZy5mcm9tVWludDhBcnJheSh2YWx1ZSA/IHZhbHVlIDogbmV3IFVpbnQ4QXJyYXkoKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdG9WZXJzaW9uKHNlcmlhbGl6ZXIsIHZlcnNpb24pIHtcbiAgICByZXR1cm4gdG9UaW1lc3RhbXAoc2VyaWFsaXplciwgdmVyc2lvbi50b1RpbWVzdGFtcCgpKTtcbn1cbmZ1bmN0aW9uIGZyb21WZXJzaW9uKHZlcnNpb24pIHtcbiAgICBoYXJkQXNzZXJ0KCEhdmVyc2lvbik7XG4gICAgcmV0dXJuIFNuYXBzaG90VmVyc2lvbi5mcm9tVGltZXN0YW1wKGZyb21UaW1lc3RhbXAodmVyc2lvbikpO1xufVxuZnVuY3Rpb24gdG9SZXNvdXJjZU5hbWUoZGF0YWJhc2VJZCwgcGF0aCkge1xuICAgIHJldHVybiB0b1Jlc291cmNlUGF0aChkYXRhYmFzZUlkLCBwYXRoKS5jYW5vbmljYWxTdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIHRvUmVzb3VyY2VQYXRoKGRhdGFiYXNlSWQsIHBhdGgpIHtcbiAgICBjb25zdCByZXNvdXJjZVBhdGggPSBmdWxseVF1YWxpZmllZFByZWZpeFBhdGgoZGF0YWJhc2VJZCkuY2hpbGQoJ2RvY3VtZW50cycpO1xuICAgIHJldHVybiBwYXRoID09PSB1bmRlZmluZWQgPyByZXNvdXJjZVBhdGggOiByZXNvdXJjZVBhdGguY2hpbGQocGF0aCk7XG59XG5mdW5jdGlvbiBmcm9tUmVzb3VyY2VOYW1lKG5hbWUpIHtcbiAgICBjb25zdCByZXNvdXJjZSA9IFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKG5hbWUpO1xuICAgIGhhcmRBc3NlcnQoaXNWYWxpZFJlc291cmNlTmFtZShyZXNvdXJjZSkpO1xuICAgIHJldHVybiByZXNvdXJjZTtcbn1cbmZ1bmN0aW9uIHRvTmFtZShzZXJpYWxpemVyLCBrZXkpIHtcbiAgICByZXR1cm4gdG9SZXNvdXJjZU5hbWUoc2VyaWFsaXplci5kYXRhYmFzZUlkLCBrZXkucGF0aCk7XG59XG5mdW5jdGlvbiBmcm9tTmFtZShzZXJpYWxpemVyLCBuYW1lKSB7XG4gICAgY29uc3QgcmVzb3VyY2UgPSBmcm9tUmVzb3VyY2VOYW1lKG5hbWUpO1xuICAgIGlmIChyZXNvdXJjZS5nZXQoMSkgIT09IHNlcmlhbGl6ZXIuZGF0YWJhc2VJZC5wcm9qZWN0SWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1RyaWVkIHRvIGRlc2VyaWFsaXplIGtleSBmcm9tIGRpZmZlcmVudCBwcm9qZWN0OiAnICtcbiAgICAgICAgICAgIHJlc291cmNlLmdldCgxKSArXG4gICAgICAgICAgICAnIHZzICcgK1xuICAgICAgICAgICAgc2VyaWFsaXplci5kYXRhYmFzZUlkLnByb2plY3RJZCk7XG4gICAgfVxuICAgIGlmIChyZXNvdXJjZS5nZXQoMykgIT09IHNlcmlhbGl6ZXIuZGF0YWJhc2VJZC5kYXRhYmFzZSkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnVHJpZWQgdG8gZGVzZXJpYWxpemUga2V5IGZyb20gZGlmZmVyZW50IGRhdGFiYXNlOiAnICtcbiAgICAgICAgICAgIHJlc291cmNlLmdldCgzKSArXG4gICAgICAgICAgICAnIHZzICcgK1xuICAgICAgICAgICAgc2VyaWFsaXplci5kYXRhYmFzZUlkLmRhdGFiYXNlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEb2N1bWVudEtleShleHRyYWN0TG9jYWxQYXRoRnJvbVJlc291cmNlTmFtZShyZXNvdXJjZSkpO1xufVxuZnVuY3Rpb24gdG9RdWVyeVBhdGgoc2VyaWFsaXplciwgcGF0aCkge1xuICAgIHJldHVybiB0b1Jlc291cmNlTmFtZShzZXJpYWxpemVyLmRhdGFiYXNlSWQsIHBhdGgpO1xufVxuZnVuY3Rpb24gZnJvbVF1ZXJ5UGF0aChuYW1lKSB7XG4gICAgY29uc3QgcmVzb3VyY2VOYW1lID0gZnJvbVJlc291cmNlTmFtZShuYW1lKTtcbiAgICAvLyBJbiB2MWJldGExIHF1ZXJpZXMgZm9yIGNvbGxlY3Rpb25zIGF0IHRoZSByb290IGRpZCBub3QgaGF2ZSBhIHRyYWlsaW5nXG4gICAgLy8gXCIvZG9jdW1lbnRzXCIuIEluIHYxIGFsbCByZXNvdXJjZSBwYXRocyBjb250YWluIFwiL2RvY3VtZW50c1wiLiBQcmVzZXJ2ZSB0aGVcbiAgICAvLyBhYmlsaXR5IHRvIHJlYWQgdGhlIHYxYmV0YTEgZm9ybSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHF1ZXJpZXMgcGVyc2lzdGVkXG4gICAgLy8gaW4gdGhlIGxvY2FsIHRhcmdldCBjYWNoZS5cbiAgICBpZiAocmVzb3VyY2VOYW1lLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICByZXR1cm4gUmVzb3VyY2VQYXRoLmVtcHR5UGF0aCgpO1xuICAgIH1cbiAgICByZXR1cm4gZXh0cmFjdExvY2FsUGF0aEZyb21SZXNvdXJjZU5hbWUocmVzb3VyY2VOYW1lKTtcbn1cbmZ1bmN0aW9uIGdldEVuY29kZWREYXRhYmFzZUlkKHNlcmlhbGl6ZXIpIHtcbiAgICBjb25zdCBwYXRoID0gbmV3IFJlc291cmNlUGF0aChbXG4gICAgICAgICdwcm9qZWN0cycsXG4gICAgICAgIHNlcmlhbGl6ZXIuZGF0YWJhc2VJZC5wcm9qZWN0SWQsXG4gICAgICAgICdkYXRhYmFzZXMnLFxuICAgICAgICBzZXJpYWxpemVyLmRhdGFiYXNlSWQuZGF0YWJhc2VcbiAgICBdKTtcbiAgICByZXR1cm4gcGF0aC5jYW5vbmljYWxTdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGZ1bGx5UXVhbGlmaWVkUHJlZml4UGF0aChkYXRhYmFzZUlkKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNvdXJjZVBhdGgoW1xuICAgICAgICAncHJvamVjdHMnLFxuICAgICAgICBkYXRhYmFzZUlkLnByb2plY3RJZCxcbiAgICAgICAgJ2RhdGFiYXNlcycsXG4gICAgICAgIGRhdGFiYXNlSWQuZGF0YWJhc2VcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RMb2NhbFBhdGhGcm9tUmVzb3VyY2VOYW1lKHJlc291cmNlTmFtZSkge1xuICAgIGhhcmRBc3NlcnQocmVzb3VyY2VOYW1lLmxlbmd0aCA+IDQgJiYgcmVzb3VyY2VOYW1lLmdldCg0KSA9PT0gJ2RvY3VtZW50cycpO1xuICAgIHJldHVybiByZXNvdXJjZU5hbWUucG9wRmlyc3QoNSk7XG59XG4vKiogQ3JlYXRlcyBhIERvY3VtZW50IHByb3RvIGZyb20ga2V5IGFuZCBmaWVsZHMgKGJ1dCBubyBjcmVhdGUvdXBkYXRlIHRpbWUpICovXG5mdW5jdGlvbiB0b011dGF0aW9uRG9jdW1lbnQoc2VyaWFsaXplciwga2V5LCBmaWVsZHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiB0b05hbWUoc2VyaWFsaXplciwga2V5KSxcbiAgICAgICAgZmllbGRzOiBmaWVsZHMudmFsdWUubWFwVmFsdWUuZmllbGRzXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvRG9jdW1lbnQoc2VyaWFsaXplciwgZG9jdW1lbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiB0b05hbWUoc2VyaWFsaXplciwgZG9jdW1lbnQua2V5KSxcbiAgICAgICAgZmllbGRzOiBkb2N1bWVudC5kYXRhLnZhbHVlLm1hcFZhbHVlLmZpZWxkcyxcbiAgICAgICAgdXBkYXRlVGltZTogdG9UaW1lc3RhbXAoc2VyaWFsaXplciwgZG9jdW1lbnQudmVyc2lvbi50b1RpbWVzdGFtcCgpKSxcbiAgICAgICAgY3JlYXRlVGltZTogdG9UaW1lc3RhbXAoc2VyaWFsaXplciwgZG9jdW1lbnQuY3JlYXRlVGltZS50b1RpbWVzdGFtcCgpKVxuICAgIH07XG59XG5mdW5jdGlvbiBmcm9tRG9jdW1lbnQoc2VyaWFsaXplciwgZG9jdW1lbnQsIGhhc0NvbW1pdHRlZE11dGF0aW9ucykge1xuICAgIGNvbnN0IGtleSA9IGZyb21OYW1lKHNlcmlhbGl6ZXIsIGRvY3VtZW50Lm5hbWUpO1xuICAgIGNvbnN0IHZlcnNpb24gPSBmcm9tVmVyc2lvbihkb2N1bWVudC51cGRhdGVUaW1lKTtcbiAgICAvLyBJZiB3ZSByZWFkIGEgZG9jdW1lbnQgZnJvbSBwZXJzaXN0ZW5jZSB0aGF0IGlzIG1pc3NpbmcgY3JlYXRlVGltZSwgaXQncyBkdWVcbiAgICAvLyB0byBvbGRlciBTREsgdmVyc2lvbnMgbm90IHN0b3JpbmcgdGhpcyBpbmZvcm1hdGlvbi4gSW4gc3VjaCBjYXNlcywgd2UnbGxcbiAgICAvLyBzZXQgdGhlIGNyZWF0ZVRpbWUgdG8gemVyby4gVGhpcyBjYW4gYmUgcmVtb3ZlZCBpbiB0aGUgbG9uZyB0ZXJtLlxuICAgIGNvbnN0IGNyZWF0ZVRpbWUgPSBkb2N1bWVudC5jcmVhdGVUaW1lXG4gICAgICAgID8gZnJvbVZlcnNpb24oZG9jdW1lbnQuY3JlYXRlVGltZSlcbiAgICAgICAgOiBTbmFwc2hvdFZlcnNpb24ubWluKCk7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBPYmplY3RWYWx1ZSh7IG1hcFZhbHVlOiB7IGZpZWxkczogZG9jdW1lbnQuZmllbGRzIH0gfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gTXV0YWJsZURvY3VtZW50Lm5ld0ZvdW5kRG9jdW1lbnQoa2V5LCB2ZXJzaW9uLCBjcmVhdGVUaW1lLCBkYXRhKTtcbiAgICBpZiAoaGFzQ29tbWl0dGVkTXV0YXRpb25zKSB7XG4gICAgICAgIHJlc3VsdC5zZXRIYXNDb21taXR0ZWRNdXRhdGlvbnMoKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc0NvbW1pdHRlZE11dGF0aW9ucyA/IHJlc3VsdC5zZXRIYXNDb21taXR0ZWRNdXRhdGlvbnMoKSA6IHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZyb21Gb3VuZChzZXJpYWxpemVyLCBkb2MpIHtcbiAgICBoYXJkQXNzZXJ0KCEhZG9jLmZvdW5kKTtcbiAgICBhc3NlcnRQcmVzZW50KGRvYy5mb3VuZC5uYW1lKTtcbiAgICBhc3NlcnRQcmVzZW50KGRvYy5mb3VuZC51cGRhdGVUaW1lKTtcbiAgICBjb25zdCBrZXkgPSBmcm9tTmFtZShzZXJpYWxpemVyLCBkb2MuZm91bmQubmFtZSk7XG4gICAgY29uc3QgdmVyc2lvbiA9IGZyb21WZXJzaW9uKGRvYy5mb3VuZC51cGRhdGVUaW1lKTtcbiAgICBjb25zdCBjcmVhdGVUaW1lID0gZG9jLmZvdW5kLmNyZWF0ZVRpbWVcbiAgICAgICAgPyBmcm9tVmVyc2lvbihkb2MuZm91bmQuY3JlYXRlVGltZSlcbiAgICAgICAgOiBTbmFwc2hvdFZlcnNpb24ubWluKCk7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBPYmplY3RWYWx1ZSh7IG1hcFZhbHVlOiB7IGZpZWxkczogZG9jLmZvdW5kLmZpZWxkcyB9IH0pO1xuICAgIHJldHVybiBNdXRhYmxlRG9jdW1lbnQubmV3Rm91bmREb2N1bWVudChrZXksIHZlcnNpb24sIGNyZWF0ZVRpbWUsIGRhdGEpO1xufVxuZnVuY3Rpb24gZnJvbU1pc3Npbmcoc2VyaWFsaXplciwgcmVzdWx0KSB7XG4gICAgaGFyZEFzc2VydCghIXJlc3VsdC5taXNzaW5nKTtcbiAgICBoYXJkQXNzZXJ0KCEhcmVzdWx0LnJlYWRUaW1lKTtcbiAgICBjb25zdCBrZXkgPSBmcm9tTmFtZShzZXJpYWxpemVyLCByZXN1bHQubWlzc2luZyk7XG4gICAgY29uc3QgdmVyc2lvbiA9IGZyb21WZXJzaW9uKHJlc3VsdC5yZWFkVGltZSk7XG4gICAgcmV0dXJuIE11dGFibGVEb2N1bWVudC5uZXdOb0RvY3VtZW50KGtleSwgdmVyc2lvbik7XG59XG5mdW5jdGlvbiBmcm9tQmF0Y2hHZXREb2N1bWVudHNSZXNwb25zZShzZXJpYWxpemVyLCByZXN1bHQpIHtcbiAgICBpZiAoJ2ZvdW5kJyBpbiByZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIGZyb21Gb3VuZChzZXJpYWxpemVyLCByZXN1bHQpO1xuICAgIH1cbiAgICBlbHNlIGlmICgnbWlzc2luZycgaW4gcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBmcm9tTWlzc2luZyhzZXJpYWxpemVyLCByZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gZmFpbCgpO1xufVxuZnVuY3Rpb24gZnJvbVdhdGNoQ2hhbmdlKHNlcmlhbGl6ZXIsIGNoYW5nZSkge1xuICAgIGxldCB3YXRjaENoYW5nZTtcbiAgICBpZiAoJ3RhcmdldENoYW5nZScgaW4gY2hhbmdlKSB7XG4gICAgICAgIGFzc2VydFByZXNlbnQoY2hhbmdlLnRhcmdldENoYW5nZSk7XG4gICAgICAgIC8vIHByb3RvMyBkZWZhdWx0IHZhbHVlIGlzIHVuc2V0IGluIEpTT04gKHVuZGVmaW5lZCksIHNvIHVzZSAnTk9fQ0hBTkdFJ1xuICAgICAgICAvLyBpZiB1bnNldFxuICAgICAgICBjb25zdCBzdGF0ZSA9IGZyb21XYXRjaFRhcmdldENoYW5nZVN0YXRlKGNoYW5nZS50YXJnZXRDaGFuZ2UudGFyZ2V0Q2hhbmdlVHlwZSB8fCAnTk9fQ0hBTkdFJyk7XG4gICAgICAgIGNvbnN0IHRhcmdldElkcyA9IGNoYW5nZS50YXJnZXRDaGFuZ2UudGFyZ2V0SWRzIHx8IFtdO1xuICAgICAgICBjb25zdCByZXN1bWVUb2tlbiA9IGZyb21CeXRlcyhzZXJpYWxpemVyLCBjaGFuZ2UudGFyZ2V0Q2hhbmdlLnJlc3VtZVRva2VuKTtcbiAgICAgICAgY29uc3QgY2F1c2VQcm90byA9IGNoYW5nZS50YXJnZXRDaGFuZ2UuY2F1c2U7XG4gICAgICAgIGNvbnN0IGNhdXNlID0gY2F1c2VQcm90byAmJiBmcm9tUnBjU3RhdHVzKGNhdXNlUHJvdG8pO1xuICAgICAgICB3YXRjaENoYW5nZSA9IG5ldyBXYXRjaFRhcmdldENoYW5nZShzdGF0ZSwgdGFyZ2V0SWRzLCByZXN1bWVUb2tlbiwgY2F1c2UgfHwgbnVsbCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdkb2N1bWVudENoYW5nZScgaW4gY2hhbmdlKSB7XG4gICAgICAgIGFzc2VydFByZXNlbnQoY2hhbmdlLmRvY3VtZW50Q2hhbmdlKTtcbiAgICAgICAgY29uc3QgZW50aXR5Q2hhbmdlID0gY2hhbmdlLmRvY3VtZW50Q2hhbmdlO1xuICAgICAgICBhc3NlcnRQcmVzZW50KGVudGl0eUNoYW5nZS5kb2N1bWVudCk7XG4gICAgICAgIGFzc2VydFByZXNlbnQoZW50aXR5Q2hhbmdlLmRvY3VtZW50Lm5hbWUpO1xuICAgICAgICBhc3NlcnRQcmVzZW50KGVudGl0eUNoYW5nZS5kb2N1bWVudC51cGRhdGVUaW1lKTtcbiAgICAgICAgY29uc3Qga2V5ID0gZnJvbU5hbWUoc2VyaWFsaXplciwgZW50aXR5Q2hhbmdlLmRvY3VtZW50Lm5hbWUpO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gZnJvbVZlcnNpb24oZW50aXR5Q2hhbmdlLmRvY3VtZW50LnVwZGF0ZVRpbWUpO1xuICAgICAgICBjb25zdCBjcmVhdGVUaW1lID0gZW50aXR5Q2hhbmdlLmRvY3VtZW50LmNyZWF0ZVRpbWVcbiAgICAgICAgICAgID8gZnJvbVZlcnNpb24oZW50aXR5Q2hhbmdlLmRvY3VtZW50LmNyZWF0ZVRpbWUpXG4gICAgICAgICAgICA6IFNuYXBzaG90VmVyc2lvbi5taW4oKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBPYmplY3RWYWx1ZSh7XG4gICAgICAgICAgICBtYXBWYWx1ZTogeyBmaWVsZHM6IGVudGl0eUNoYW5nZS5kb2N1bWVudC5maWVsZHMgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZG9jID0gTXV0YWJsZURvY3VtZW50Lm5ld0ZvdW5kRG9jdW1lbnQoa2V5LCB2ZXJzaW9uLCBjcmVhdGVUaW1lLCBkYXRhKTtcbiAgICAgICAgY29uc3QgdXBkYXRlZFRhcmdldElkcyA9IGVudGl0eUNoYW5nZS50YXJnZXRJZHMgfHwgW107XG4gICAgICAgIGNvbnN0IHJlbW92ZWRUYXJnZXRJZHMgPSBlbnRpdHlDaGFuZ2UucmVtb3ZlZFRhcmdldElkcyB8fCBbXTtcbiAgICAgICAgd2F0Y2hDaGFuZ2UgPSBuZXcgRG9jdW1lbnRXYXRjaENoYW5nZSh1cGRhdGVkVGFyZ2V0SWRzLCByZW1vdmVkVGFyZ2V0SWRzLCBkb2Mua2V5LCBkb2MpO1xuICAgIH1cbiAgICBlbHNlIGlmICgnZG9jdW1lbnREZWxldGUnIGluIGNoYW5nZSkge1xuICAgICAgICBhc3NlcnRQcmVzZW50KGNoYW5nZS5kb2N1bWVudERlbGV0ZSk7XG4gICAgICAgIGNvbnN0IGRvY0RlbGV0ZSA9IGNoYW5nZS5kb2N1bWVudERlbGV0ZTtcbiAgICAgICAgYXNzZXJ0UHJlc2VudChkb2NEZWxldGUuZG9jdW1lbnQpO1xuICAgICAgICBjb25zdCBrZXkgPSBmcm9tTmFtZShzZXJpYWxpemVyLCBkb2NEZWxldGUuZG9jdW1lbnQpO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gZG9jRGVsZXRlLnJlYWRUaW1lXG4gICAgICAgICAgICA/IGZyb21WZXJzaW9uKGRvY0RlbGV0ZS5yZWFkVGltZSlcbiAgICAgICAgICAgIDogU25hcHNob3RWZXJzaW9uLm1pbigpO1xuICAgICAgICBjb25zdCBkb2MgPSBNdXRhYmxlRG9jdW1lbnQubmV3Tm9Eb2N1bWVudChrZXksIHZlcnNpb24pO1xuICAgICAgICBjb25zdCByZW1vdmVkVGFyZ2V0SWRzID0gZG9jRGVsZXRlLnJlbW92ZWRUYXJnZXRJZHMgfHwgW107XG4gICAgICAgIHdhdGNoQ2hhbmdlID0gbmV3IERvY3VtZW50V2F0Y2hDaGFuZ2UoW10sIHJlbW92ZWRUYXJnZXRJZHMsIGRvYy5rZXksIGRvYyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdkb2N1bWVudFJlbW92ZScgaW4gY2hhbmdlKSB7XG4gICAgICAgIGFzc2VydFByZXNlbnQoY2hhbmdlLmRvY3VtZW50UmVtb3ZlKTtcbiAgICAgICAgY29uc3QgZG9jUmVtb3ZlID0gY2hhbmdlLmRvY3VtZW50UmVtb3ZlO1xuICAgICAgICBhc3NlcnRQcmVzZW50KGRvY1JlbW92ZS5kb2N1bWVudCk7XG4gICAgICAgIGNvbnN0IGtleSA9IGZyb21OYW1lKHNlcmlhbGl6ZXIsIGRvY1JlbW92ZS5kb2N1bWVudCk7XG4gICAgICAgIGNvbnN0IHJlbW92ZWRUYXJnZXRJZHMgPSBkb2NSZW1vdmUucmVtb3ZlZFRhcmdldElkcyB8fCBbXTtcbiAgICAgICAgd2F0Y2hDaGFuZ2UgPSBuZXcgRG9jdW1lbnRXYXRjaENoYW5nZShbXSwgcmVtb3ZlZFRhcmdldElkcywga2V5LCBudWxsKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2ZpbHRlcicgaW4gY2hhbmdlKSB7XG4gICAgICAgIC8vIFRPRE8oZGltb25kKTogaW1wbGVtZW50IGV4aXN0ZW5jZSBmaWx0ZXIgcGFyc2luZyB3aXRoIHN0cmF0ZWd5LlxuICAgICAgICBhc3NlcnRQcmVzZW50KGNoYW5nZS5maWx0ZXIpO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSBjaGFuZ2UuZmlsdGVyO1xuICAgICAgICBhc3NlcnRQcmVzZW50KGZpbHRlci50YXJnZXRJZCk7XG4gICAgICAgIGNvbnN0IHsgY291bnQgPSAwLCB1bmNoYW5nZWROYW1lcyB9ID0gZmlsdGVyO1xuICAgICAgICBjb25zdCBleGlzdGVuY2VGaWx0ZXIgPSBuZXcgRXhpc3RlbmNlRmlsdGVyKGNvdW50LCB1bmNoYW5nZWROYW1lcyk7XG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gZmlsdGVyLnRhcmdldElkO1xuICAgICAgICB3YXRjaENoYW5nZSA9IG5ldyBFeGlzdGVuY2VGaWx0ZXJDaGFuZ2UodGFyZ2V0SWQsIGV4aXN0ZW5jZUZpbHRlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgIH1cbiAgICByZXR1cm4gd2F0Y2hDaGFuZ2U7XG59XG5mdW5jdGlvbiBmcm9tV2F0Y2hUYXJnZXRDaGFuZ2VTdGF0ZShzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSA9PT0gJ05PX0NIQU5HRScpIHtcbiAgICAgICAgcmV0dXJuIDAgLyogV2F0Y2hUYXJnZXRDaGFuZ2VTdGF0ZS5Ob0NoYW5nZSAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGUgPT09ICdBREQnKSB7XG4gICAgICAgIHJldHVybiAxIC8qIFdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUuQWRkZWQgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXRlID09PSAnUkVNT1ZFJykge1xuICAgICAgICByZXR1cm4gMiAvKiBXYXRjaFRhcmdldENoYW5nZVN0YXRlLlJlbW92ZWQgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXRlID09PSAnQ1VSUkVOVCcpIHtcbiAgICAgICAgcmV0dXJuIDMgLyogV2F0Y2hUYXJnZXRDaGFuZ2VTdGF0ZS5DdXJyZW50ICovO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZSA9PT0gJ1JFU0VUJykge1xuICAgICAgICByZXR1cm4gNCAvKiBXYXRjaFRhcmdldENoYW5nZVN0YXRlLlJlc2V0ICovO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2ZXJzaW9uRnJvbUxpc3RlblJlc3BvbnNlKGNoYW5nZSkge1xuICAgIC8vIFdlIGhhdmUgb25seSByZWFjaGVkIGEgY29uc2lzdGVudCBzbmFwc2hvdCBmb3IgdGhlIGVudGlyZSBzdHJlYW0gaWYgdGhlcmVcbiAgICAvLyBpcyBhIHJlYWRfdGltZSBzZXQgYW5kIGl0IGFwcGxpZXMgdG8gYWxsIHRhcmdldHMgKGkuZS4gdGhlIGxpc3Qgb2ZcbiAgICAvLyB0YXJnZXRzIGlzIGVtcHR5KS4gVGhlIGJhY2tlbmQgaXMgZ3VhcmFudGVlZCB0byBzZW5kIHN1Y2ggcmVzcG9uc2VzLlxuICAgIGlmICghKCd0YXJnZXRDaGFuZ2UnIGluIGNoYW5nZSkpIHtcbiAgICAgICAgcmV0dXJuIFNuYXBzaG90VmVyc2lvbi5taW4oKTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0Q2hhbmdlID0gY2hhbmdlLnRhcmdldENoYW5nZTtcbiAgICBpZiAodGFyZ2V0Q2hhbmdlLnRhcmdldElkcyAmJiB0YXJnZXRDaGFuZ2UudGFyZ2V0SWRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gU25hcHNob3RWZXJzaW9uLm1pbigpO1xuICAgIH1cbiAgICBpZiAoIXRhcmdldENoYW5nZS5yZWFkVGltZSkge1xuICAgICAgICByZXR1cm4gU25hcHNob3RWZXJzaW9uLm1pbigpO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbVZlcnNpb24odGFyZ2V0Q2hhbmdlLnJlYWRUaW1lKTtcbn1cbmZ1bmN0aW9uIHRvTXV0YXRpb24oc2VyaWFsaXplciwgbXV0YXRpb24pIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChtdXRhdGlvbiBpbnN0YW5jZW9mIFNldE11dGF0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHVwZGF0ZTogdG9NdXRhdGlvbkRvY3VtZW50KHNlcmlhbGl6ZXIsIG11dGF0aW9uLmtleSwgbXV0YXRpb24udmFsdWUpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG11dGF0aW9uIGluc3RhbmNlb2YgRGVsZXRlTXV0YXRpb24pIHtcbiAgICAgICAgcmVzdWx0ID0geyBkZWxldGU6IHRvTmFtZShzZXJpYWxpemVyLCBtdXRhdGlvbi5rZXkpIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG11dGF0aW9uIGluc3RhbmNlb2YgUGF0Y2hNdXRhdGlvbikge1xuICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICB1cGRhdGU6IHRvTXV0YXRpb25Eb2N1bWVudChzZXJpYWxpemVyLCBtdXRhdGlvbi5rZXksIG11dGF0aW9uLmRhdGEpLFxuICAgICAgICAgICAgdXBkYXRlTWFzazogdG9Eb2N1bWVudE1hc2sobXV0YXRpb24uZmllbGRNYXNrKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChtdXRhdGlvbiBpbnN0YW5jZW9mIFZlcmlmeU11dGF0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHZlcmlmeTogdG9OYW1lKHNlcmlhbGl6ZXIsIG11dGF0aW9uLmtleSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWlsKCk7XG4gICAgfVxuICAgIGlmIChtdXRhdGlvbi5maWVsZFRyYW5zZm9ybXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXN1bHQudXBkYXRlVHJhbnNmb3JtcyA9IG11dGF0aW9uLmZpZWxkVHJhbnNmb3Jtcy5tYXAodHJhbnNmb3JtID0+IHRvRmllbGRUcmFuc2Zvcm0oc2VyaWFsaXplciwgdHJhbnNmb3JtKSk7XG4gICAgfVxuICAgIGlmICghbXV0YXRpb24ucHJlY29uZGl0aW9uLmlzTm9uZSkge1xuICAgICAgICByZXN1bHQuY3VycmVudERvY3VtZW50ID0gdG9QcmVjb25kaXRpb24oc2VyaWFsaXplciwgbXV0YXRpb24ucHJlY29uZGl0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZyb21NdXRhdGlvbihzZXJpYWxpemVyLCBwcm90bykge1xuICAgIGNvbnN0IHByZWNvbmRpdGlvbiA9IHByb3RvLmN1cnJlbnREb2N1bWVudFxuICAgICAgICA/IGZyb21QcmVjb25kaXRpb24ocHJvdG8uY3VycmVudERvY3VtZW50KVxuICAgICAgICA6IFByZWNvbmRpdGlvbi5ub25lKCk7XG4gICAgY29uc3QgZmllbGRUcmFuc2Zvcm1zID0gcHJvdG8udXBkYXRlVHJhbnNmb3Jtc1xuICAgICAgICA/IHByb3RvLnVwZGF0ZVRyYW5zZm9ybXMubWFwKHRyYW5zZm9ybSA9PiBmcm9tRmllbGRUcmFuc2Zvcm0oc2VyaWFsaXplciwgdHJhbnNmb3JtKSlcbiAgICAgICAgOiBbXTtcbiAgICBpZiAocHJvdG8udXBkYXRlKSB7XG4gICAgICAgIGFzc2VydFByZXNlbnQocHJvdG8udXBkYXRlLm5hbWUpO1xuICAgICAgICBjb25zdCBrZXkgPSBmcm9tTmFtZShzZXJpYWxpemVyLCBwcm90by51cGRhdGUubmFtZSk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbmV3IE9iamVjdFZhbHVlKHtcbiAgICAgICAgICAgIG1hcFZhbHVlOiB7IGZpZWxkczogcHJvdG8udXBkYXRlLmZpZWxkcyB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJvdG8udXBkYXRlTWFzaykge1xuICAgICAgICAgICAgY29uc3QgZmllbGRNYXNrID0gZnJvbURvY3VtZW50TWFzayhwcm90by51cGRhdGVNYXNrKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGF0Y2hNdXRhdGlvbihrZXksIHZhbHVlLCBmaWVsZE1hc2ssIHByZWNvbmRpdGlvbiwgZmllbGRUcmFuc2Zvcm1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2V0TXV0YXRpb24oa2V5LCB2YWx1ZSwgcHJlY29uZGl0aW9uLCBmaWVsZFRyYW5zZm9ybXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb3RvLmRlbGV0ZSkge1xuICAgICAgICBjb25zdCBrZXkgPSBmcm9tTmFtZShzZXJpYWxpemVyLCBwcm90by5kZWxldGUpO1xuICAgICAgICByZXR1cm4gbmV3IERlbGV0ZU11dGF0aW9uKGtleSwgcHJlY29uZGl0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvdG8udmVyaWZ5KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGZyb21OYW1lKHNlcmlhbGl6ZXIsIHByb3RvLnZlcmlmeSk7XG4gICAgICAgIHJldHVybiBuZXcgVmVyaWZ5TXV0YXRpb24oa2V5LCBwcmVjb25kaXRpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b1ByZWNvbmRpdGlvbihzZXJpYWxpemVyLCBwcmVjb25kaXRpb24pIHtcbiAgICBpZiAocHJlY29uZGl0aW9uLnVwZGF0ZVRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXBkYXRlVGltZTogdG9WZXJzaW9uKHNlcmlhbGl6ZXIsIHByZWNvbmRpdGlvbi51cGRhdGVUaW1lKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChwcmVjb25kaXRpb24uZXhpc3RzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHsgZXhpc3RzOiBwcmVjb25kaXRpb24uZXhpc3RzIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZyb21QcmVjb25kaXRpb24ocHJlY29uZGl0aW9uKSB7XG4gICAgaWYgKHByZWNvbmRpdGlvbi51cGRhdGVUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFByZWNvbmRpdGlvbi51cGRhdGVUaW1lKGZyb21WZXJzaW9uKHByZWNvbmRpdGlvbi51cGRhdGVUaW1lKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByZWNvbmRpdGlvbi5leGlzdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gUHJlY29uZGl0aW9uLmV4aXN0cyhwcmVjb25kaXRpb24uZXhpc3RzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBQcmVjb25kaXRpb24ubm9uZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZyb21Xcml0ZVJlc3VsdChwcm90bywgY29tbWl0VGltZSkge1xuICAgIC8vIE5PVEU6IERlbGV0ZXMgZG9uJ3QgaGF2ZSBhbiB1cGRhdGVUaW1lLlxuICAgIGxldCB2ZXJzaW9uID0gcHJvdG8udXBkYXRlVGltZVxuICAgICAgICA/IGZyb21WZXJzaW9uKHByb3RvLnVwZGF0ZVRpbWUpXG4gICAgICAgIDogZnJvbVZlcnNpb24oY29tbWl0VGltZSk7XG4gICAgaWYgKHZlcnNpb24uaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpKSB7XG4gICAgICAgIC8vIFRoZSBGaXJlc3RvcmUgRW11bGF0b3IgY3VycmVudGx5IHJldHVybnMgYW4gdXBkYXRlIHRpbWUgb2YgMCBmb3JcbiAgICAgICAgLy8gZGVsZXRlcyBvZiBub24tZXhpc3RpbmcgZG9jdW1lbnRzIChyYXRoZXIgdGhhbiBudWxsKS4gVGhpcyBicmVha3MgdGhlXG4gICAgICAgIC8vIHRlc3QgXCJnZXQgZGVsZXRlZCBkb2Mgd2hpbGUgb2ZmbGluZSB3aXRoIHNvdXJjZT1jYWNoZVwiIGFzIE5vRG9jdW1lbnRzXG4gICAgICAgIC8vIHdpdGggdmVyc2lvbiAwIGFyZSBmaWx0ZXJlZCBieSBJbmRleGVkRGIncyBSZW1vdGVEb2N1bWVudENhY2hlLlxuICAgICAgICAvLyBUT0RPKCMyMTQ5KTogUmVtb3ZlIHRoaXMgd2hlbiBFbXVsYXRvciBpcyBmaXhlZFxuICAgICAgICB2ZXJzaW9uID0gZnJvbVZlcnNpb24oY29tbWl0VGltZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTXV0YXRpb25SZXN1bHQodmVyc2lvbiwgcHJvdG8udHJhbnNmb3JtUmVzdWx0cyB8fCBbXSk7XG59XG5mdW5jdGlvbiBmcm9tV3JpdGVSZXN1bHRzKHByb3RvcywgY29tbWl0VGltZSkge1xuICAgIGlmIChwcm90b3MgJiYgcHJvdG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaGFyZEFzc2VydChjb21taXRUaW1lICE9PSB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gcHJvdG9zLm1hcChwcm90byA9PiBmcm9tV3JpdGVSZXN1bHQocHJvdG8sIGNvbW1pdFRpbWUpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b0ZpZWxkVHJhbnNmb3JtKHNlcmlhbGl6ZXIsIGZpZWxkVHJhbnNmb3JtKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gZmllbGRUcmFuc2Zvcm0udHJhbnNmb3JtO1xuICAgIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBTZXJ2ZXJUaW1lc3RhbXBUcmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpZWxkUGF0aDogZmllbGRUcmFuc2Zvcm0uZmllbGQuY2Fub25pY2FsU3RyaW5nKCksXG4gICAgICAgICAgICBzZXRUb1NlcnZlclZhbHVlOiAnUkVRVUVTVF9USU1FJ1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaWVsZFBhdGg6IGZpZWxkVHJhbnNmb3JtLmZpZWxkLmNhbm9uaWNhbFN0cmluZygpLFxuICAgICAgICAgICAgYXBwZW5kTWlzc2luZ0VsZW1lbnRzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiB0cmFuc2Zvcm0uZWxlbWVudHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHJhbnNmb3JtIGluc3RhbmNlb2YgQXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpZWxkUGF0aDogZmllbGRUcmFuc2Zvcm0uZmllbGQuY2Fub25pY2FsU3RyaW5nKCksXG4gICAgICAgICAgICByZW1vdmVBbGxGcm9tQXJyYXk6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHRyYW5zZm9ybS5lbGVtZW50c1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaWVsZFBhdGg6IGZpZWxkVHJhbnNmb3JtLmZpZWxkLmNhbm9uaWNhbFN0cmluZygpLFxuICAgICAgICAgICAgaW5jcmVtZW50OiB0cmFuc2Zvcm0ub3BlcmFuZFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgZmFpbCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZyb21GaWVsZFRyYW5zZm9ybShzZXJpYWxpemVyLCBwcm90bykge1xuICAgIGxldCB0cmFuc2Zvcm0gPSBudWxsO1xuICAgIGlmICgnc2V0VG9TZXJ2ZXJWYWx1ZScgaW4gcHJvdG8pIHtcbiAgICAgICAgaGFyZEFzc2VydChwcm90by5zZXRUb1NlcnZlclZhbHVlID09PSAnUkVRVUVTVF9USU1FJyk7XG4gICAgICAgIHRyYW5zZm9ybSA9IG5ldyBTZXJ2ZXJUaW1lc3RhbXBUcmFuc2Zvcm0oKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2FwcGVuZE1pc3NpbmdFbGVtZW50cycgaW4gcHJvdG8pIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gcHJvdG8uYXBwZW5kTWlzc2luZ0VsZW1lbnRzLnZhbHVlcyB8fCBbXTtcbiAgICAgICAgdHJhbnNmb3JtID0gbmV3IEFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24odmFsdWVzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ3JlbW92ZUFsbEZyb21BcnJheScgaW4gcHJvdG8pIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gcHJvdG8ucmVtb3ZlQWxsRnJvbUFycmF5LnZhbHVlcyB8fCBbXTtcbiAgICAgICAgdHJhbnNmb3JtID0gbmV3IEFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uKHZhbHVlcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdpbmNyZW1lbnQnIGluIHByb3RvKSB7XG4gICAgICAgIHRyYW5zZm9ybSA9IG5ldyBOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uKHNlcmlhbGl6ZXIsIHByb3RvLmluY3JlbWVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmYWlsKCk7XG4gICAgfVxuICAgIGNvbnN0IGZpZWxkUGF0aCA9IEZpZWxkUGF0aCQxLmZyb21TZXJ2ZXJGb3JtYXQocHJvdG8uZmllbGRQYXRoKTtcbiAgICByZXR1cm4gbmV3IEZpZWxkVHJhbnNmb3JtKGZpZWxkUGF0aCwgdHJhbnNmb3JtKTtcbn1cbmZ1bmN0aW9uIHRvRG9jdW1lbnRzVGFyZ2V0KHNlcmlhbGl6ZXIsIHRhcmdldCkge1xuICAgIHJldHVybiB7IGRvY3VtZW50czogW3RvUXVlcnlQYXRoKHNlcmlhbGl6ZXIsIHRhcmdldC5wYXRoKV0gfTtcbn1cbmZ1bmN0aW9uIGZyb21Eb2N1bWVudHNUYXJnZXQoZG9jdW1lbnRzVGFyZ2V0KSB7XG4gICAgY29uc3QgY291bnQgPSBkb2N1bWVudHNUYXJnZXQuZG9jdW1lbnRzLmxlbmd0aDtcbiAgICBoYXJkQXNzZXJ0KGNvdW50ID09PSAxKTtcbiAgICBjb25zdCBuYW1lID0gZG9jdW1lbnRzVGFyZ2V0LmRvY3VtZW50c1swXTtcbiAgICByZXR1cm4gcXVlcnlUb1RhcmdldChuZXdRdWVyeUZvclBhdGgoZnJvbVF1ZXJ5UGF0aChuYW1lKSkpO1xufVxuZnVuY3Rpb24gdG9RdWVyeVRhcmdldChzZXJpYWxpemVyLCB0YXJnZXQpIHtcbiAgICAvLyBEaXNzZWN0IHRoZSBwYXRoIGludG8gcGFyZW50LCBjb2xsZWN0aW9uSWQsIGFuZCBvcHRpb25hbCBrZXkgZmlsdGVyLlxuICAgIGNvbnN0IHF1ZXJ5VGFyZ2V0ID0geyBzdHJ1Y3R1cmVkUXVlcnk6IHt9IH07XG4gICAgY29uc3QgcGF0aCA9IHRhcmdldC5wYXRoO1xuICAgIGxldCBwYXJlbnQ7XG4gICAgaWYgKHRhcmdldC5jb2xsZWN0aW9uR3JvdXAgIT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50ID0gcGF0aDtcbiAgICAgICAgcXVlcnlUYXJnZXQuc3RydWN0dXJlZFF1ZXJ5LmZyb20gPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbklkOiB0YXJnZXQuY29sbGVjdGlvbkdyb3VwLFxuICAgICAgICAgICAgICAgIGFsbERlc2NlbmRhbnRzOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwYXJlbnQgPSBwYXRoLnBvcExhc3QoKTtcbiAgICAgICAgcXVlcnlUYXJnZXQuc3RydWN0dXJlZFF1ZXJ5LmZyb20gPSBbeyBjb2xsZWN0aW9uSWQ6IHBhdGgubGFzdFNlZ21lbnQoKSB9XTtcbiAgICB9XG4gICAgcXVlcnlUYXJnZXQucGFyZW50ID0gdG9RdWVyeVBhdGgoc2VyaWFsaXplciwgcGFyZW50KTtcbiAgICBjb25zdCB3aGVyZSA9IHRvRmlsdGVycyh0YXJnZXQuZmlsdGVycyk7XG4gICAgaWYgKHdoZXJlKSB7XG4gICAgICAgIHF1ZXJ5VGFyZ2V0LnN0cnVjdHVyZWRRdWVyeS53aGVyZSA9IHdoZXJlO1xuICAgIH1cbiAgICBjb25zdCBvcmRlckJ5ID0gdG9PcmRlcih0YXJnZXQub3JkZXJCeSk7XG4gICAgaWYgKG9yZGVyQnkpIHtcbiAgICAgICAgcXVlcnlUYXJnZXQuc3RydWN0dXJlZFF1ZXJ5Lm9yZGVyQnkgPSBvcmRlckJ5O1xuICAgIH1cbiAgICBjb25zdCBsaW1pdCA9IHRvSW50MzJQcm90byhzZXJpYWxpemVyLCB0YXJnZXQubGltaXQpO1xuICAgIGlmIChsaW1pdCAhPT0gbnVsbCkge1xuICAgICAgICBxdWVyeVRhcmdldC5zdHJ1Y3R1cmVkUXVlcnkubGltaXQgPSBsaW1pdDtcbiAgICB9XG4gICAgaWYgKHRhcmdldC5zdGFydEF0KSB7XG4gICAgICAgIHF1ZXJ5VGFyZ2V0LnN0cnVjdHVyZWRRdWVyeS5zdGFydEF0ID0gdG9TdGFydEF0Q3Vyc29yKHRhcmdldC5zdGFydEF0KTtcbiAgICB9XG4gICAgaWYgKHRhcmdldC5lbmRBdCkge1xuICAgICAgICBxdWVyeVRhcmdldC5zdHJ1Y3R1cmVkUXVlcnkuZW5kQXQgPSB0b0VuZEF0Q3Vyc29yKHRhcmdldC5lbmRBdCk7XG4gICAgfVxuICAgIHJldHVybiB7IHF1ZXJ5VGFyZ2V0LCBwYXJlbnQgfTtcbn1cbmZ1bmN0aW9uIHRvUnVuQWdncmVnYXRpb25RdWVyeVJlcXVlc3Qoc2VyaWFsaXplciwgdGFyZ2V0LCBhZ2dyZWdhdGVzLCBza2lwQWxpYXNpbmcpIHtcbiAgICBjb25zdCB7IHF1ZXJ5VGFyZ2V0LCBwYXJlbnQgfSA9IHRvUXVlcnlUYXJnZXQoc2VyaWFsaXplciwgdGFyZ2V0KTtcbiAgICBjb25zdCBhbGlhc01hcCA9IHt9O1xuICAgIGNvbnN0IGFnZ3JlZ2F0aW9ucyA9IFtdO1xuICAgIGxldCBhZ2dyZWdhdGlvbk51bSA9IDA7XG4gICAgYWdncmVnYXRlcy5mb3JFYWNoKGFnZ3JlZ2F0ZSA9PiB7XG4gICAgICAgIC8vIE1hcCBhbGwgY2xpZW50LXNpZGUgYWxpYXNlcyB0byBhIHVuaXF1ZSBzaG9ydC1mb3JtXG4gICAgICAgIC8vIGFsaWFzLiBUaGlzIGF2b2lkcyBpc3N1ZXMgd2l0aCBjbGllbnQtc2lkZSBhbGlhc2VzIHRoYXRcbiAgICAgICAgLy8gZXhjZWVkIHRoZSAxNTAwLWJ5dGUgc3RyaW5nIHNpemUgbGltaXQuXG4gICAgICAgIGNvbnN0IHNlcnZlckFsaWFzID0gc2tpcEFsaWFzaW5nXG4gICAgICAgICAgICA/IGFnZ3JlZ2F0ZS5hbGlhc1xuICAgICAgICAgICAgOiBgYWdncmVnYXRlXyR7YWdncmVnYXRpb25OdW0rK31gO1xuICAgICAgICBhbGlhc01hcFtzZXJ2ZXJBbGlhc10gPSBhZ2dyZWdhdGUuYWxpYXM7XG4gICAgICAgIGlmIChhZ2dyZWdhdGUuYWdncmVnYXRlVHlwZSA9PT0gJ2NvdW50Jykge1xuICAgICAgICAgICAgYWdncmVnYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIGFsaWFzOiBzZXJ2ZXJBbGlhcyxcbiAgICAgICAgICAgICAgICBjb3VudDoge31cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFnZ3JlZ2F0ZS5hZ2dyZWdhdGVUeXBlID09PSAnYXZnJykge1xuICAgICAgICAgICAgYWdncmVnYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIGFsaWFzOiBzZXJ2ZXJBbGlhcyxcbiAgICAgICAgICAgICAgICBhdmc6IHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHRvRmllbGRQYXRoUmVmZXJlbmNlKGFnZ3JlZ2F0ZS5maWVsZFBhdGgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWdncmVnYXRlLmFnZ3JlZ2F0ZVR5cGUgPT09ICdzdW0nKSB7XG4gICAgICAgICAgICBhZ2dyZWdhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgYWxpYXM6IHNlcnZlckFsaWFzLFxuICAgICAgICAgICAgICAgIHN1bToge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZDogdG9GaWVsZFBhdGhSZWZlcmVuY2UoYWdncmVnYXRlLmZpZWxkUGF0aClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgICAgIHN0cnVjdHVyZWRBZ2dyZWdhdGlvblF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgYWdncmVnYXRpb25zLFxuICAgICAgICAgICAgICAgIHN0cnVjdHVyZWRRdWVyeTogcXVlcnlUYXJnZXQuc3RydWN0dXJlZFF1ZXJ5XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyZW50OiBxdWVyeVRhcmdldC5wYXJlbnRcbiAgICAgICAgfSxcbiAgICAgICAgYWxpYXNNYXAsXG4gICAgICAgIHBhcmVudFxuICAgIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0UXVlcnlUYXJnZXRUb1F1ZXJ5KHRhcmdldCkge1xuICAgIGxldCBwYXRoID0gZnJvbVF1ZXJ5UGF0aCh0YXJnZXQucGFyZW50KTtcbiAgICBjb25zdCBxdWVyeSA9IHRhcmdldC5zdHJ1Y3R1cmVkUXVlcnk7XG4gICAgY29uc3QgZnJvbUNvdW50ID0gcXVlcnkuZnJvbSA/IHF1ZXJ5LmZyb20ubGVuZ3RoIDogMDtcbiAgICBsZXQgY29sbGVjdGlvbkdyb3VwID0gbnVsbDtcbiAgICBpZiAoZnJvbUNvdW50ID4gMCkge1xuICAgICAgICBoYXJkQXNzZXJ0KGZyb21Db3VudCA9PT0gMSk7XG4gICAgICAgIGNvbnN0IGZyb20gPSBxdWVyeS5mcm9tWzBdO1xuICAgICAgICBpZiAoZnJvbS5hbGxEZXNjZW5kYW50cykge1xuICAgICAgICAgICAgY29sbGVjdGlvbkdyb3VwID0gZnJvbS5jb2xsZWN0aW9uSWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5jaGlsZChmcm9tLmNvbGxlY3Rpb25JZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGZpbHRlckJ5ID0gW107XG4gICAgaWYgKHF1ZXJ5LndoZXJlKSB7XG4gICAgICAgIGZpbHRlckJ5ID0gZnJvbUZpbHRlcnMocXVlcnkud2hlcmUpO1xuICAgIH1cbiAgICBsZXQgb3JkZXJCeSA9IFtdO1xuICAgIGlmIChxdWVyeS5vcmRlckJ5KSB7XG4gICAgICAgIG9yZGVyQnkgPSBmcm9tT3JkZXIocXVlcnkub3JkZXJCeSk7XG4gICAgfVxuICAgIGxldCBsaW1pdCA9IG51bGw7XG4gICAgaWYgKHF1ZXJ5LmxpbWl0KSB7XG4gICAgICAgIGxpbWl0ID0gZnJvbUludDMyUHJvdG8ocXVlcnkubGltaXQpO1xuICAgIH1cbiAgICBsZXQgc3RhcnRBdCA9IG51bGw7XG4gICAgaWYgKHF1ZXJ5LnN0YXJ0QXQpIHtcbiAgICAgICAgc3RhcnRBdCA9IGZyb21TdGFydEF0Q3Vyc29yKHF1ZXJ5LnN0YXJ0QXQpO1xuICAgIH1cbiAgICBsZXQgZW5kQXQgPSBudWxsO1xuICAgIGlmIChxdWVyeS5lbmRBdCkge1xuICAgICAgICBlbmRBdCA9IGZyb21FbmRBdEN1cnNvcihxdWVyeS5lbmRBdCk7XG4gICAgfVxuICAgIHJldHVybiBuZXdRdWVyeShwYXRoLCBjb2xsZWN0aW9uR3JvdXAsIG9yZGVyQnksIGZpbHRlckJ5LCBsaW1pdCwgXCJGXCIgLyogTGltaXRUeXBlLkZpcnN0ICovLCBzdGFydEF0LCBlbmRBdCk7XG59XG5mdW5jdGlvbiBmcm9tUXVlcnlUYXJnZXQodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHF1ZXJ5VG9UYXJnZXQoY29udmVydFF1ZXJ5VGFyZ2V0VG9RdWVyeSh0YXJnZXQpKTtcbn1cbmZ1bmN0aW9uIHRvTGlzdGVuUmVxdWVzdExhYmVscyhzZXJpYWxpemVyLCB0YXJnZXREYXRhKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0b0xhYmVsKHRhcmdldERhdGEucHVycG9zZSk7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2dvb2ctbGlzdGVuLXRhZ3MnOiB2YWx1ZVxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvTGFiZWwocHVycG9zZSkge1xuICAgIHN3aXRjaCAocHVycG9zZSkge1xuICAgICAgICBjYXNlIFwiVGFyZ2V0UHVycG9zZUxpc3RlblwiIC8qIFRhcmdldFB1cnBvc2UuTGlzdGVuICovOlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgXCJUYXJnZXRQdXJwb3NlRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2hcIiAvKiBUYXJnZXRQdXJwb3NlLkV4aXN0ZW5jZUZpbHRlck1pc21hdGNoICovOlxuICAgICAgICAgICAgcmV0dXJuICdleGlzdGVuY2UtZmlsdGVyLW1pc21hdGNoJztcbiAgICAgICAgY2FzZSBcIlRhcmdldFB1cnBvc2VFeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaEJsb29tXCIgLyogVGFyZ2V0UHVycG9zZS5FeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaEJsb29tICovOlxuICAgICAgICAgICAgcmV0dXJuICdleGlzdGVuY2UtZmlsdGVyLW1pc21hdGNoLWJsb29tJztcbiAgICAgICAgY2FzZSBcIlRhcmdldFB1cnBvc2VMaW1ib1Jlc29sdXRpb25cIiAvKiBUYXJnZXRQdXJwb3NlLkxpbWJvUmVzb2x1dGlvbiAqLzpcbiAgICAgICAgICAgIHJldHVybiAnbGltYm8tZG9jdW1lbnQnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b1RhcmdldChzZXJpYWxpemVyLCB0YXJnZXREYXRhKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXREYXRhLnRhcmdldDtcbiAgICBpZiAodGFyZ2V0SXNEb2N1bWVudFRhcmdldCh0YXJnZXQpKSB7XG4gICAgICAgIHJlc3VsdCA9IHsgZG9jdW1lbnRzOiB0b0RvY3VtZW50c1RhcmdldChzZXJpYWxpemVyLCB0YXJnZXQpIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB7IHF1ZXJ5OiB0b1F1ZXJ5VGFyZ2V0KHNlcmlhbGl6ZXIsIHRhcmdldCkucXVlcnlUYXJnZXQgfTtcbiAgICB9XG4gICAgcmVzdWx0LnRhcmdldElkID0gdGFyZ2V0RGF0YS50YXJnZXRJZDtcbiAgICBpZiAodGFyZ2V0RGF0YS5yZXN1bWVUb2tlbi5hcHByb3hpbWF0ZUJ5dGVTaXplKCkgPiAwKSB7XG4gICAgICAgIHJlc3VsdC5yZXN1bWVUb2tlbiA9IHRvQnl0ZXMoc2VyaWFsaXplciwgdGFyZ2V0RGF0YS5yZXN1bWVUb2tlbik7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkQ291bnQgPSB0b0ludDMyUHJvdG8oc2VyaWFsaXplciwgdGFyZ2V0RGF0YS5leHBlY3RlZENvdW50KTtcbiAgICAgICAgaWYgKGV4cGVjdGVkQ291bnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5leHBlY3RlZENvdW50ID0gZXhwZWN0ZWRDb3VudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0YXJnZXREYXRhLnNuYXBzaG90VmVyc2lvbi5jb21wYXJlVG8oU25hcHNob3RWZXJzaW9uLm1pbigpKSA+IDApIHtcbiAgICAgICAgLy8gVE9ETyh3dWFuZHkpOiBDb25zaWRlciByZW1vdmluZyBhYm92ZSBjaGVjayBiZWNhdXNlIGl0IGlzIG1vc3QgbGlrZWx5IHRydWUuXG4gICAgICAgIC8vIFJpZ2h0IG5vdywgbWFueSB0ZXN0cyBkZXBlbmQgb24gdGhpcyBiZWhhdmlvdXIgdGhvdWdoIChsZWF2aW5nIG1pbigpIG91dFxuICAgICAgICAvLyBvZiBzZXJpYWxpemF0aW9uKS5cbiAgICAgICAgcmVzdWx0LnJlYWRUaW1lID0gdG9UaW1lc3RhbXAoc2VyaWFsaXplciwgdGFyZ2V0RGF0YS5zbmFwc2hvdFZlcnNpb24udG9UaW1lc3RhbXAoKSk7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkQ291bnQgPSB0b0ludDMyUHJvdG8oc2VyaWFsaXplciwgdGFyZ2V0RGF0YS5leHBlY3RlZENvdW50KTtcbiAgICAgICAgaWYgKGV4cGVjdGVkQ291bnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5leHBlY3RlZENvdW50ID0gZXhwZWN0ZWRDb3VudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdG9GaWx0ZXJzKGZpbHRlcnMpIHtcbiAgICBpZiAoZmlsdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdG9GaWx0ZXIoQ29tcG9zaXRlRmlsdGVyLmNyZWF0ZShmaWx0ZXJzLCBcImFuZFwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLkFORCAqLykpO1xufVxuZnVuY3Rpb24gZnJvbUZpbHRlcnMoZmlsdGVyKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZnJvbUZpbHRlcihmaWx0ZXIpO1xuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIgJiZcbiAgICAgICAgY29tcG9zaXRlRmlsdGVySXNGbGF0Q29uanVuY3Rpb24ocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmdldEZpbHRlcnMoKTtcbiAgICB9XG4gICAgcmV0dXJuIFtyZXN1bHRdO1xufVxuZnVuY3Rpb24gZnJvbUZpbHRlcihmaWx0ZXIpIHtcbiAgICBpZiAoZmlsdGVyLnVuYXJ5RmlsdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZyb21VbmFyeUZpbHRlcihmaWx0ZXIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChmaWx0ZXIuZmllbGRGaWx0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZnJvbUZpZWxkRmlsdGVyKGZpbHRlcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpbHRlci5jb21wb3NpdGVGaWx0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZnJvbUNvbXBvc2l0ZUZpbHRlcihmaWx0ZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b09yZGVyKG9yZGVyQnlzKSB7XG4gICAgaWYgKG9yZGVyQnlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBvcmRlckJ5cy5tYXAob3JkZXIgPT4gdG9Qcm9wZXJ0eU9yZGVyKG9yZGVyKSk7XG59XG5mdW5jdGlvbiBmcm9tT3JkZXIob3JkZXJCeXMpIHtcbiAgICByZXR1cm4gb3JkZXJCeXMubWFwKG9yZGVyID0+IGZyb21Qcm9wZXJ0eU9yZGVyKG9yZGVyKSk7XG59XG5mdW5jdGlvbiB0b1N0YXJ0QXRDdXJzb3IoY3Vyc29yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmVmb3JlOiBjdXJzb3IuaW5jbHVzaXZlLFxuICAgICAgICB2YWx1ZXM6IGN1cnNvci5wb3NpdGlvblxuICAgIH07XG59XG5mdW5jdGlvbiB0b0VuZEF0Q3Vyc29yKGN1cnNvcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGJlZm9yZTogIWN1cnNvci5pbmNsdXNpdmUsXG4gICAgICAgIHZhbHVlczogY3Vyc29yLnBvc2l0aW9uXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZyb21TdGFydEF0Q3Vyc29yKGN1cnNvcikge1xuICAgIGNvbnN0IGluY2x1c2l2ZSA9ICEhY3Vyc29yLmJlZm9yZTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGN1cnNvci52YWx1ZXMgfHwgW107XG4gICAgcmV0dXJuIG5ldyBCb3VuZChwb3NpdGlvbiwgaW5jbHVzaXZlKTtcbn1cbmZ1bmN0aW9uIGZyb21FbmRBdEN1cnNvcihjdXJzb3IpIHtcbiAgICBjb25zdCBpbmNsdXNpdmUgPSAhY3Vyc29yLmJlZm9yZTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGN1cnNvci52YWx1ZXMgfHwgW107XG4gICAgcmV0dXJuIG5ldyBCb3VuZChwb3NpdGlvbiwgaW5jbHVzaXZlKTtcbn1cbi8vIHZpc2libGUgZm9yIHRlc3RpbmdcbmZ1bmN0aW9uIHRvRGlyZWN0aW9uKGRpcikge1xuICAgIHJldHVybiBESVJFQ1RJT05TW2Rpcl07XG59XG4vLyB2aXNpYmxlIGZvciB0ZXN0aW5nXG5mdW5jdGlvbiBmcm9tRGlyZWN0aW9uKGRpcikge1xuICAgIHN3aXRjaCAoZGlyKSB7XG4gICAgICAgIGNhc2UgJ0FTQ0VORElORyc6XG4gICAgICAgICAgICByZXR1cm4gXCJhc2NcIiAvKiBEaXJlY3Rpb24uQVNDRU5ESU5HICovO1xuICAgICAgICBjYXNlICdERVNDRU5ESU5HJzpcbiAgICAgICAgICAgIHJldHVybiBcImRlc2NcIiAvKiBEaXJlY3Rpb24uREVTQ0VORElORyAqLztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuLy8gdmlzaWJsZSBmb3IgdGVzdGluZ1xuZnVuY3Rpb24gdG9PcGVyYXRvck5hbWUob3ApIHtcbiAgICByZXR1cm4gT1BFUkFUT1JTW29wXTtcbn1cbmZ1bmN0aW9uIHRvQ29tcG9zaXRlT3BlcmF0b3JOYW1lKG9wKSB7XG4gICAgcmV0dXJuIENPTVBPU0lURV9PUEVSQVRPUlNbb3BdO1xufVxuZnVuY3Rpb24gZnJvbU9wZXJhdG9yTmFtZShvcCkge1xuICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgY2FzZSAnRVFVQUwnOlxuICAgICAgICAgICAgcmV0dXJuIFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLztcbiAgICAgICAgY2FzZSAnTk9UX0VRVUFMJzpcbiAgICAgICAgICAgIHJldHVybiBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovO1xuICAgICAgICBjYXNlICdHUkVBVEVSX1RIQU4nOlxuICAgICAgICAgICAgcmV0dXJuIFwiPlwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTiAqLztcbiAgICAgICAgY2FzZSAnR1JFQVRFUl9USEFOX09SX0VRVUFMJzpcbiAgICAgICAgICAgIHJldHVybiBcIj49XCIgLyogT3BlcmF0b3IuR1JFQVRFUl9USEFOX09SX0VRVUFMICovO1xuICAgICAgICBjYXNlICdMRVNTX1RIQU4nOlxuICAgICAgICAgICAgcmV0dXJuIFwiPFwiIC8qIE9wZXJhdG9yLkxFU1NfVEhBTiAqLztcbiAgICAgICAgY2FzZSAnTEVTU19USEFOX09SX0VRVUFMJzpcbiAgICAgICAgICAgIHJldHVybiBcIjw9XCIgLyogT3BlcmF0b3IuTEVTU19USEFOX09SX0VRVUFMICovO1xuICAgICAgICBjYXNlICdBUlJBWV9DT05UQUlOUyc6XG4gICAgICAgICAgICByZXR1cm4gXCJhcnJheS1jb250YWluc1wiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TICovO1xuICAgICAgICBjYXNlICdJTic6XG4gICAgICAgICAgICByZXR1cm4gXCJpblwiIC8qIE9wZXJhdG9yLklOICovO1xuICAgICAgICBjYXNlICdOT1RfSU4nOlxuICAgICAgICAgICAgcmV0dXJuIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovO1xuICAgICAgICBjYXNlICdBUlJBWV9DT05UQUlOU19BTlknOlxuICAgICAgICAgICAgcmV0dXJuIFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovO1xuICAgICAgICBjYXNlICdPUEVSQVRPUl9VTlNQRUNJRklFRCc6XG4gICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmcm9tQ29tcG9zaXRlT3BlcmF0b3JOYW1lKG9wKSB7XG4gICAgc3dpdGNoIChvcCkge1xuICAgICAgICBjYXNlICdBTkQnOlxuICAgICAgICAgICAgcmV0dXJuIFwiYW5kXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuQU5EICovO1xuICAgICAgICBjYXNlICdPUic6XG4gICAgICAgICAgICByZXR1cm4gXCJvclwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLk9SICovO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b0ZpZWxkUGF0aFJlZmVyZW5jZShwYXRoKSB7XG4gICAgcmV0dXJuIHsgZmllbGRQYXRoOiBwYXRoLmNhbm9uaWNhbFN0cmluZygpIH07XG59XG5mdW5jdGlvbiBmcm9tRmllbGRQYXRoUmVmZXJlbmNlKGZpZWxkUmVmZXJlbmNlKSB7XG4gICAgcmV0dXJuIEZpZWxkUGF0aCQxLmZyb21TZXJ2ZXJGb3JtYXQoZmllbGRSZWZlcmVuY2UuZmllbGRQYXRoKTtcbn1cbi8vIHZpc2libGUgZm9yIHRlc3RpbmdcbmZ1bmN0aW9uIHRvUHJvcGVydHlPcmRlcihvcmRlckJ5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmllbGQ6IHRvRmllbGRQYXRoUmVmZXJlbmNlKG9yZGVyQnkuZmllbGQpLFxuICAgICAgICBkaXJlY3Rpb246IHRvRGlyZWN0aW9uKG9yZGVyQnkuZGlyKVxuICAgIH07XG59XG5mdW5jdGlvbiBmcm9tUHJvcGVydHlPcmRlcihvcmRlckJ5KSB7XG4gICAgcmV0dXJuIG5ldyBPcmRlckJ5KGZyb21GaWVsZFBhdGhSZWZlcmVuY2Uob3JkZXJCeS5maWVsZCksIGZyb21EaXJlY3Rpb24ob3JkZXJCeS5kaXJlY3Rpb24pKTtcbn1cbi8vIHZpc2libGUgZm9yIHRlc3RpbmdcbmZ1bmN0aW9uIHRvRmlsdGVyKGZpbHRlcikge1xuICAgIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBGaWVsZEZpbHRlcikge1xuICAgICAgICByZXR1cm4gdG9VbmFyeU9yRmllbGRGaWx0ZXIoZmlsdGVyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlsdGVyIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyKSB7XG4gICAgICAgIHJldHVybiB0b0NvbXBvc2l0ZUZpbHRlcihmaWx0ZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b0NvbXBvc2l0ZUZpbHRlcihmaWx0ZXIpIHtcbiAgICBjb25zdCBwcm90b3MgPSBmaWx0ZXIuZ2V0RmlsdGVycygpLm1hcChmaWx0ZXIgPT4gdG9GaWx0ZXIoZmlsdGVyKSk7XG4gICAgaWYgKHByb3Rvcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHByb3Rvc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29tcG9zaXRlRmlsdGVyOiB7XG4gICAgICAgICAgICBvcDogdG9Db21wb3NpdGVPcGVyYXRvck5hbWUoZmlsdGVyLm9wKSxcbiAgICAgICAgICAgIGZpbHRlcnM6IHByb3Rvc1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvVW5hcnlPckZpZWxkRmlsdGVyKGZpbHRlcikge1xuICAgIGlmIChmaWx0ZXIub3AgPT09IFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLykge1xuICAgICAgICBpZiAoaXNOYW5WYWx1ZShmaWx0ZXIudmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVuYXJ5RmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiB0b0ZpZWxkUGF0aFJlZmVyZW5jZShmaWx0ZXIuZmllbGQpLFxuICAgICAgICAgICAgICAgICAgICBvcDogJ0lTX05BTidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTnVsbFZhbHVlKGZpbHRlci52YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdW5hcnlGaWx0ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHRvRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci5maWVsZCksXG4gICAgICAgICAgICAgICAgICAgIG9wOiAnSVNfTlVMTCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpbHRlci5vcCA9PT0gXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqLykge1xuICAgICAgICBpZiAoaXNOYW5WYWx1ZShmaWx0ZXIudmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVuYXJ5RmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiB0b0ZpZWxkUGF0aFJlZmVyZW5jZShmaWx0ZXIuZmllbGQpLFxuICAgICAgICAgICAgICAgICAgICBvcDogJ0lTX05PVF9OQU4nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc051bGxWYWx1ZShmaWx0ZXIudmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVuYXJ5RmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiB0b0ZpZWxkUGF0aFJlZmVyZW5jZShmaWx0ZXIuZmllbGQpLFxuICAgICAgICAgICAgICAgICAgICBvcDogJ0lTX05PVF9OVUxMJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmllbGRGaWx0ZXI6IHtcbiAgICAgICAgICAgIGZpZWxkOiB0b0ZpZWxkUGF0aFJlZmVyZW5jZShmaWx0ZXIuZmllbGQpLFxuICAgICAgICAgICAgb3A6IHRvT3BlcmF0b3JOYW1lKGZpbHRlci5vcCksXG4gICAgICAgICAgICB2YWx1ZTogZmlsdGVyLnZhbHVlXG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gZnJvbVVuYXJ5RmlsdGVyKGZpbHRlcikge1xuICAgIHN3aXRjaCAoZmlsdGVyLnVuYXJ5RmlsdGVyLm9wKSB7XG4gICAgICAgIGNhc2UgJ0lTX05BTic6XG4gICAgICAgICAgICBjb25zdCBuYW5GaWVsZCA9IGZyb21GaWVsZFBhdGhSZWZlcmVuY2UoZmlsdGVyLnVuYXJ5RmlsdGVyLmZpZWxkKTtcbiAgICAgICAgICAgIHJldHVybiBGaWVsZEZpbHRlci5jcmVhdGUobmFuRmllbGQsIFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLywge1xuICAgICAgICAgICAgICAgIGRvdWJsZVZhbHVlOiBOYU5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlICdJU19OVUxMJzpcbiAgICAgICAgICAgIGNvbnN0IG51bGxGaWVsZCA9IGZyb21GaWVsZFBhdGhSZWZlcmVuY2UoZmlsdGVyLnVuYXJ5RmlsdGVyLmZpZWxkKTtcbiAgICAgICAgICAgIHJldHVybiBGaWVsZEZpbHRlci5jcmVhdGUobnVsbEZpZWxkLCBcIj09XCIgLyogT3BlcmF0b3IuRVFVQUwgKi8sIHtcbiAgICAgICAgICAgICAgICBudWxsVmFsdWU6ICdOVUxMX1ZBTFVFJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgJ0lTX05PVF9OQU4nOlxuICAgICAgICAgICAgY29uc3Qgbm90TmFuRmllbGQgPSBmcm9tRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci51bmFyeUZpbHRlci5maWVsZCk7XG4gICAgICAgICAgICByZXR1cm4gRmllbGRGaWx0ZXIuY3JlYXRlKG5vdE5hbkZpZWxkLCBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovLCB7XG4gICAgICAgICAgICAgICAgZG91YmxlVmFsdWU6IE5hTlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgJ0lTX05PVF9OVUxMJzpcbiAgICAgICAgICAgIGNvbnN0IG5vdE51bGxGaWVsZCA9IGZyb21GaWVsZFBhdGhSZWZlcmVuY2UoZmlsdGVyLnVuYXJ5RmlsdGVyLmZpZWxkKTtcbiAgICAgICAgICAgIHJldHVybiBGaWVsZEZpbHRlci5jcmVhdGUobm90TnVsbEZpZWxkLCBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovLCB7XG4gICAgICAgICAgICAgICAgbnVsbFZhbHVlOiAnTlVMTF9WQUxVRSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlICdPUEVSQVRPUl9VTlNQRUNJRklFRCc6XG4gICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmcm9tRmllbGRGaWx0ZXIoZmlsdGVyKSB7XG4gICAgcmV0dXJuIEZpZWxkRmlsdGVyLmNyZWF0ZShmcm9tRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci5maWVsZEZpbHRlci5maWVsZCksIGZyb21PcGVyYXRvck5hbWUoZmlsdGVyLmZpZWxkRmlsdGVyLm9wKSwgZmlsdGVyLmZpZWxkRmlsdGVyLnZhbHVlKTtcbn1cbmZ1bmN0aW9uIGZyb21Db21wb3NpdGVGaWx0ZXIoZmlsdGVyKSB7XG4gICAgcmV0dXJuIENvbXBvc2l0ZUZpbHRlci5jcmVhdGUoZmlsdGVyLmNvbXBvc2l0ZUZpbHRlci5maWx0ZXJzLm1hcChmaWx0ZXIgPT4gZnJvbUZpbHRlcihmaWx0ZXIpKSwgZnJvbUNvbXBvc2l0ZU9wZXJhdG9yTmFtZShmaWx0ZXIuY29tcG9zaXRlRmlsdGVyLm9wKSk7XG59XG5mdW5jdGlvbiB0b0RvY3VtZW50TWFzayhmaWVsZE1hc2spIHtcbiAgICBjb25zdCBjYW5vbmljYWxGaWVsZHMgPSBbXTtcbiAgICBmaWVsZE1hc2suZmllbGRzLmZvckVhY2goZmllbGQgPT4gY2Fub25pY2FsRmllbGRzLnB1c2goZmllbGQuY2Fub25pY2FsU3RyaW5nKCkpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmaWVsZFBhdGhzOiBjYW5vbmljYWxGaWVsZHNcbiAgICB9O1xufVxuZnVuY3Rpb24gZnJvbURvY3VtZW50TWFzayhwcm90bykge1xuICAgIGNvbnN0IHBhdGhzID0gcHJvdG8uZmllbGRQYXRocyB8fCBbXTtcbiAgICByZXR1cm4gbmV3IEZpZWxkTWFzayhwYXRocy5tYXAocGF0aCA9PiBGaWVsZFBhdGgkMS5mcm9tU2VydmVyRm9ybWF0KHBhdGgpKSk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkUmVzb3VyY2VOYW1lKHBhdGgpIHtcbiAgICAvLyBSZXNvdXJjZSBuYW1lcyBoYXZlIGF0IGxlYXN0IDQgY29tcG9uZW50cyAocHJvamVjdCBJRCwgZGF0YWJhc2UgSUQpXG4gICAgcmV0dXJuIChwYXRoLmxlbmd0aCA+PSA0ICYmXG4gICAgICAgIHBhdGguZ2V0KDApID09PSAncHJvamVjdHMnICYmXG4gICAgICAgIHBhdGguZ2V0KDIpID09PSAnZGF0YWJhc2VzJyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFuIGltbXV0YWJsZSBzZXQgb2YgbWV0YWRhdGEgdGhhdCB0aGUgbG9jYWwgc3RvcmUgdHJhY2tzIGZvciBlYWNoIHRhcmdldC5cbiAqL1xuY2xhc3MgVGFyZ2V0RGF0YSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqIFRoZSB0YXJnZXQgYmVpbmcgbGlzdGVuZWQgdG8uICovXG4gICAgdGFyZ2V0LCBcbiAgICAvKipcbiAgICAgKiBUaGUgdGFyZ2V0IElEIHRvIHdoaWNoIHRoZSB0YXJnZXQgY29ycmVzcG9uZHM7IEFzc2lnbmVkIGJ5IHRoZVxuICAgICAqIExvY2FsU3RvcmUgZm9yIHVzZXIgbGlzdGVucyBhbmQgYnkgdGhlIFN5bmNFbmdpbmUgZm9yIGxpbWJvIHdhdGNoZXMuXG4gICAgICovXG4gICAgdGFyZ2V0SWQsIFxuICAgIC8qKiBUaGUgcHVycG9zZSBvZiB0aGUgdGFyZ2V0LiAqL1xuICAgIHB1cnBvc2UsIFxuICAgIC8qKlxuICAgICAqIFRoZSBzZXF1ZW5jZSBudW1iZXIgb2YgdGhlIGxhc3QgdHJhbnNhY3Rpb24gZHVyaW5nIHdoaWNoIHRoaXMgdGFyZ2V0IGRhdGFcbiAgICAgKiB3YXMgbW9kaWZpZWQuXG4gICAgICovXG4gICAgc2VxdWVuY2VOdW1iZXIsIFxuICAgIC8qKiBUaGUgbGF0ZXN0IHNuYXBzaG90IHZlcnNpb24gc2VlbiBmb3IgdGhpcyB0YXJnZXQuICovXG4gICAgc25hcHNob3RWZXJzaW9uID0gU25hcHNob3RWZXJzaW9uLm1pbigpLCBcbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSBzbmFwc2hvdCB2ZXJzaW9uIGF0IHdoaWNoIHRoZSBhc3NvY2lhdGVkIHZpZXdcbiAgICAgKiBjb250YWluZWQgbm8gbGltYm8gZG9jdW1lbnRzLlxuICAgICAqL1xuICAgIGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24gPSBTbmFwc2hvdFZlcnNpb24ubWluKCksIFxuICAgIC8qKlxuICAgICAqIEFuIG9wYXF1ZSwgc2VydmVyLWFzc2lnbmVkIHRva2VuIHRoYXQgYWxsb3dzIHdhdGNoaW5nIGEgdGFyZ2V0IHRvIGJlXG4gICAgICogcmVzdW1lZCBhZnRlciBkaXNjb25uZWN0aW5nIHdpdGhvdXQgcmV0cmFuc21pdHRpbmcgYWxsIHRoZSBkYXRhIHRoYXRcbiAgICAgKiBtYXRjaGVzIHRoZSB0YXJnZXQuIFRoZSByZXN1bWUgdG9rZW4gZXNzZW50aWFsbHkgaWRlbnRpZmllcyBhIHBvaW50IGluXG4gICAgICogdGltZSBmcm9tIHdoaWNoIHRoZSBzZXJ2ZXIgc2hvdWxkIHJlc3VtZSBzZW5kaW5nIHJlc3VsdHMuXG4gICAgICovXG4gICAgcmVzdW1lVG9rZW4gPSBCeXRlU3RyaW5nLkVNUFRZX0JZVEVfU1RSSU5HLCBcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGRvY3VtZW50cyB0aGF0IGxhc3QgbWF0Y2hlZCB0aGUgcXVlcnkgYXQgdGhlIHJlc3VtZSB0b2tlbiBvclxuICAgICAqIHJlYWQgdGltZS4gRG9jdW1lbnRzIGFyZSBjb3VudGVkIG9ubHkgd2hlbiBtYWtpbmcgYSBsaXN0ZW4gcmVxdWVzdCB3aXRoXG4gICAgICogcmVzdW1lIHRva2VuIG9yIHJlYWQgdGltZSwgb3RoZXJ3aXNlLCBrZWVwIGl0IG51bGwuXG4gICAgICovXG4gICAgZXhwZWN0ZWRDb3VudCA9IG51bGwpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMudGFyZ2V0SWQgPSB0YXJnZXRJZDtcbiAgICAgICAgdGhpcy5wdXJwb3NlID0gcHVycG9zZTtcbiAgICAgICAgdGhpcy5zZXF1ZW5jZU51bWJlciA9IHNlcXVlbmNlTnVtYmVyO1xuICAgICAgICB0aGlzLnNuYXBzaG90VmVyc2lvbiA9IHNuYXBzaG90VmVyc2lvbjtcbiAgICAgICAgdGhpcy5sYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uID0gbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbjtcbiAgICAgICAgdGhpcy5yZXN1bWVUb2tlbiA9IHJlc3VtZVRva2VuO1xuICAgICAgICB0aGlzLmV4cGVjdGVkQ291bnQgPSBleHBlY3RlZENvdW50O1xuICAgIH1cbiAgICAvKiogQ3JlYXRlcyBhIG5ldyB0YXJnZXQgZGF0YSBpbnN0YW5jZSB3aXRoIGFuIHVwZGF0ZWQgc2VxdWVuY2UgbnVtYmVyLiAqL1xuICAgIHdpdGhTZXF1ZW5jZU51bWJlcihzZXF1ZW5jZU51bWJlcikge1xuICAgICAgICByZXR1cm4gbmV3IFRhcmdldERhdGEodGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0SWQsIHRoaXMucHVycG9zZSwgc2VxdWVuY2VOdW1iZXIsIHRoaXMuc25hcHNob3RWZXJzaW9uLCB0aGlzLmxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24sIHRoaXMucmVzdW1lVG9rZW4sIHRoaXMuZXhwZWN0ZWRDb3VudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdGFyZ2V0IGRhdGEgaW5zdGFuY2Ugd2l0aCBhbiB1cGRhdGVkIHJlc3VtZSB0b2tlbiBhbmRcbiAgICAgKiBzbmFwc2hvdCB2ZXJzaW9uLlxuICAgICAqL1xuICAgIHdpdGhSZXN1bWVUb2tlbihyZXN1bWVUb2tlbiwgc25hcHNob3RWZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGFyZ2V0RGF0YSh0aGlzLnRhcmdldCwgdGhpcy50YXJnZXRJZCwgdGhpcy5wdXJwb3NlLCB0aGlzLnNlcXVlbmNlTnVtYmVyLCBzbmFwc2hvdFZlcnNpb24sIHRoaXMubGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiwgcmVzdW1lVG9rZW4sIFxuICAgICAgICAvKiBleHBlY3RlZENvdW50PSAqLyBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0YXJnZXQgZGF0YSBpbnN0YW5jZSB3aXRoIGFuIHVwZGF0ZWQgZXhwZWN0ZWQgY291bnQuXG4gICAgICovXG4gICAgd2l0aEV4cGVjdGVkQ291bnQoZXhwZWN0ZWRDb3VudCkge1xuICAgICAgICByZXR1cm4gbmV3IFRhcmdldERhdGEodGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0SWQsIHRoaXMucHVycG9zZSwgdGhpcy5zZXF1ZW5jZU51bWJlciwgdGhpcy5zbmFwc2hvdFZlcnNpb24sIHRoaXMubGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiwgdGhpcy5yZXN1bWVUb2tlbiwgZXhwZWN0ZWRDb3VudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdGFyZ2V0IGRhdGEgaW5zdGFuY2Ugd2l0aCBhbiB1cGRhdGVkIGxhc3QgbGltYm8gZnJlZVxuICAgICAqIHNuYXBzaG90IHZlcnNpb24gbnVtYmVyLlxuICAgICAqL1xuICAgIHdpdGhMYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uKGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXREYXRhKHRoaXMudGFyZ2V0LCB0aGlzLnRhcmdldElkLCB0aGlzLnB1cnBvc2UsIHRoaXMuc2VxdWVuY2VOdW1iZXIsIHRoaXMuc25hcHNob3RWZXJzaW9uLCBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uLCB0aGlzLnJlc3VtZVRva2VuLCB0aGlzLmV4cGVjdGVkQ291bnQpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKiBTZXJpYWxpemVyIGZvciB2YWx1ZXMgc3RvcmVkIGluIHRoZSBMb2NhbFN0b3JlLiAqL1xuY2xhc3MgTG9jYWxTZXJpYWxpemVyIHtcbiAgICBjb25zdHJ1Y3RvcihyZW1vdGVTZXJpYWxpemVyKSB7XG4gICAgICAgIHRoaXMucmVtb3RlU2VyaWFsaXplciA9IHJlbW90ZVNlcmlhbGl6ZXI7XG4gICAgfVxufVxuLyoqIERlY29kZXMgYSByZW1vdGUgZG9jdW1lbnQgZnJvbSBzdG9yYWdlIGxvY2FsbHkgdG8gYSBEb2N1bWVudC4gKi9cbmZ1bmN0aW9uIGZyb21EYlJlbW90ZURvY3VtZW50KGxvY2FsU2VyaWFsaXplciwgcmVtb3RlRG9jKSB7XG4gICAgbGV0IGRvYztcbiAgICBpZiAocmVtb3RlRG9jLmRvY3VtZW50KSB7XG4gICAgICAgIGRvYyA9IGZyb21Eb2N1bWVudChsb2NhbFNlcmlhbGl6ZXIucmVtb3RlU2VyaWFsaXplciwgcmVtb3RlRG9jLmRvY3VtZW50LCAhIXJlbW90ZURvYy5oYXNDb21taXR0ZWRNdXRhdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZW1vdGVEb2Mubm9Eb2N1bWVudCkge1xuICAgICAgICBjb25zdCBrZXkgPSBEb2N1bWVudEtleS5mcm9tU2VnbWVudHMocmVtb3RlRG9jLm5vRG9jdW1lbnQucGF0aCk7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBmcm9tRGJUaW1lc3RhbXAocmVtb3RlRG9jLm5vRG9jdW1lbnQucmVhZFRpbWUpO1xuICAgICAgICBkb2MgPSBNdXRhYmxlRG9jdW1lbnQubmV3Tm9Eb2N1bWVudChrZXksIHZlcnNpb24pO1xuICAgICAgICBpZiAocmVtb3RlRG9jLmhhc0NvbW1pdHRlZE11dGF0aW9ucykge1xuICAgICAgICAgICAgZG9jLnNldEhhc0NvbW1pdHRlZE11dGF0aW9ucygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlbW90ZURvYy51bmtub3duRG9jdW1lbnQpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gRG9jdW1lbnRLZXkuZnJvbVNlZ21lbnRzKHJlbW90ZURvYy51bmtub3duRG9jdW1lbnQucGF0aCk7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBmcm9tRGJUaW1lc3RhbXAocmVtb3RlRG9jLnVua25vd25Eb2N1bWVudC52ZXJzaW9uKTtcbiAgICAgICAgZG9jID0gTXV0YWJsZURvY3VtZW50Lm5ld1Vua25vd25Eb2N1bWVudChrZXksIHZlcnNpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG4gICAgaWYgKHJlbW90ZURvYy5yZWFkVGltZSkge1xuICAgICAgICBkb2Muc2V0UmVhZFRpbWUoZnJvbURiVGltZXN0YW1wS2V5KHJlbW90ZURvYy5yZWFkVGltZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZG9jO1xufVxuLyoqIEVuY29kZXMgYSBkb2N1bWVudCBmb3Igc3RvcmFnZSBsb2NhbGx5LiAqL1xuZnVuY3Rpb24gdG9EYlJlbW90ZURvY3VtZW50KGxvY2FsU2VyaWFsaXplciwgZG9jdW1lbnQpIHtcbiAgICBjb25zdCBrZXkgPSBkb2N1bWVudC5rZXk7XG4gICAgY29uc3QgcmVtb3RlRG9jID0ge1xuICAgICAgICBwcmVmaXhQYXRoOiBrZXkuZ2V0Q29sbGVjdGlvblBhdGgoKS5wb3BMYXN0KCkudG9BcnJheSgpLFxuICAgICAgICBjb2xsZWN0aW9uR3JvdXA6IGtleS5jb2xsZWN0aW9uR3JvdXAsXG4gICAgICAgIGRvY3VtZW50SWQ6IGtleS5wYXRoLmxhc3RTZWdtZW50KCksXG4gICAgICAgIHJlYWRUaW1lOiB0b0RiVGltZXN0YW1wS2V5KGRvY3VtZW50LnJlYWRUaW1lKSxcbiAgICAgICAgaGFzQ29tbWl0dGVkTXV0YXRpb25zOiBkb2N1bWVudC5oYXNDb21taXR0ZWRNdXRhdGlvbnNcbiAgICB9O1xuICAgIGlmIChkb2N1bWVudC5pc0ZvdW5kRG9jdW1lbnQoKSkge1xuICAgICAgICByZW1vdGVEb2MuZG9jdW1lbnQgPSB0b0RvY3VtZW50KGxvY2FsU2VyaWFsaXplci5yZW1vdGVTZXJpYWxpemVyLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvY3VtZW50LmlzTm9Eb2N1bWVudCgpKSB7XG4gICAgICAgIHJlbW90ZURvYy5ub0RvY3VtZW50ID0ge1xuICAgICAgICAgICAgcGF0aDoga2V5LnBhdGgudG9BcnJheSgpLFxuICAgICAgICAgICAgcmVhZFRpbWU6IHRvRGJUaW1lc3RhbXAoZG9jdW1lbnQudmVyc2lvbilcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZG9jdW1lbnQuaXNVbmtub3duRG9jdW1lbnQoKSkge1xuICAgICAgICByZW1vdGVEb2MudW5rbm93bkRvY3VtZW50ID0ge1xuICAgICAgICAgICAgcGF0aDoga2V5LnBhdGgudG9BcnJheSgpLFxuICAgICAgICAgICAgdmVyc2lvbjogdG9EYlRpbWVzdGFtcChkb2N1bWVudC52ZXJzaW9uKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlbW90ZURvYztcbn1cbmZ1bmN0aW9uIHRvRGJUaW1lc3RhbXBLZXkoc25hcHNob3RWZXJzaW9uKSB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gc25hcHNob3RWZXJzaW9uLnRvVGltZXN0YW1wKCk7XG4gICAgcmV0dXJuIFt0aW1lc3RhbXAuc2Vjb25kcywgdGltZXN0YW1wLm5hbm9zZWNvbmRzXTtcbn1cbmZ1bmN0aW9uIGZyb21EYlRpbWVzdGFtcEtleShkYlRpbWVzdGFtcEtleSkge1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBUaW1lc3RhbXAoZGJUaW1lc3RhbXBLZXlbMF0sIGRiVGltZXN0YW1wS2V5WzFdKTtcbiAgICByZXR1cm4gU25hcHNob3RWZXJzaW9uLmZyb21UaW1lc3RhbXAodGltZXN0YW1wKTtcbn1cbmZ1bmN0aW9uIHRvRGJUaW1lc3RhbXAoc25hcHNob3RWZXJzaW9uKSB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gc25hcHNob3RWZXJzaW9uLnRvVGltZXN0YW1wKCk7XG4gICAgcmV0dXJuIHsgc2Vjb25kczogdGltZXN0YW1wLnNlY29uZHMsIG5hbm9zZWNvbmRzOiB0aW1lc3RhbXAubmFub3NlY29uZHMgfTtcbn1cbmZ1bmN0aW9uIGZyb21EYlRpbWVzdGFtcChkYlRpbWVzdGFtcCkge1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBUaW1lc3RhbXAoZGJUaW1lc3RhbXAuc2Vjb25kcywgZGJUaW1lc3RhbXAubmFub3NlY29uZHMpO1xuICAgIHJldHVybiBTbmFwc2hvdFZlcnNpb24uZnJvbVRpbWVzdGFtcCh0aW1lc3RhbXApO1xufVxuLyoqIEVuY29kZXMgYSBiYXRjaCBvZiBtdXRhdGlvbnMgaW50byBhIERiTXV0YXRpb25CYXRjaCBmb3IgbG9jYWwgc3RvcmFnZS4gKi9cbmZ1bmN0aW9uIHRvRGJNdXRhdGlvbkJhdGNoKGxvY2FsU2VyaWFsaXplciwgdXNlcklkLCBiYXRjaCkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRCYXNlTXV0YXRpb25zID0gYmF0Y2guYmFzZU11dGF0aW9ucy5tYXAobSA9PiB0b011dGF0aW9uKGxvY2FsU2VyaWFsaXplci5yZW1vdGVTZXJpYWxpemVyLCBtKSk7XG4gICAgY29uc3Qgc2VyaWFsaXplZE11dGF0aW9ucyA9IGJhdGNoLm11dGF0aW9ucy5tYXAobSA9PiB0b011dGF0aW9uKGxvY2FsU2VyaWFsaXplci5yZW1vdGVTZXJpYWxpemVyLCBtKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlcklkLFxuICAgICAgICBiYXRjaElkOiBiYXRjaC5iYXRjaElkLFxuICAgICAgICBsb2NhbFdyaXRlVGltZU1zOiBiYXRjaC5sb2NhbFdyaXRlVGltZS50b01pbGxpcygpLFxuICAgICAgICBiYXNlTXV0YXRpb25zOiBzZXJpYWxpemVkQmFzZU11dGF0aW9ucyxcbiAgICAgICAgbXV0YXRpb25zOiBzZXJpYWxpemVkTXV0YXRpb25zXG4gICAgfTtcbn1cbi8qKiBEZWNvZGVzIGEgRGJNdXRhdGlvbkJhdGNoIGludG8gYSBNdXRhdGlvbkJhdGNoICovXG5mdW5jdGlvbiBmcm9tRGJNdXRhdGlvbkJhdGNoKGxvY2FsU2VyaWFsaXplciwgZGJCYXRjaCkge1xuICAgIGNvbnN0IGJhc2VNdXRhdGlvbnMgPSAoZGJCYXRjaC5iYXNlTXV0YXRpb25zIHx8IFtdKS5tYXAobSA9PiBmcm9tTXV0YXRpb24obG9jYWxTZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIsIG0pKTtcbiAgICAvLyBTcXVhc2ggb2xkIHRyYW5zZm9ybSBtdXRhdGlvbnMgaW50byBleGlzdGluZyBwYXRjaCBvciBzZXQgbXV0YXRpb25zLlxuICAgIC8vIFRoZSByZXBsYWNlbWVudCBvZiByZXByZXNlbnRpbmcgYHRyYW5zZm9ybXNgIHdpdGggYHVwZGF0ZV90cmFuc2Zvcm1zYFxuICAgIC8vIG9uIHRoZSBTREsgbWVhbnMgdGhhdCBvbGQgYHRyYW5zZm9ybWAgbXV0YXRpb25zIHN0b3JlZCBpbiBJbmRleGVkREIgbmVlZFxuICAgIC8vIHRvIGJlIHVwZGF0ZWQgdG8gYHVwZGF0ZV90cmFuc2Zvcm1zYC5cbiAgICAvLyBUT0RPKGIvMTc0NjA4Mzc0KTogUmVtb3ZlIHRoaXMgY29kZSBvbmNlIHdlIHBlcmZvcm0gYSBzY2hlbWEgbWlncmF0aW9uLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGJCYXRjaC5tdXRhdGlvbnMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRNdXRhdGlvbiA9IGRiQmF0Y2gubXV0YXRpb25zW2ldO1xuICAgICAgICBjb25zdCBoYXNUcmFuc2Zvcm0gPSBpICsgMSA8IGRiQmF0Y2gubXV0YXRpb25zLmxlbmd0aCAmJlxuICAgICAgICAgICAgZGJCYXRjaC5tdXRhdGlvbnNbaSArIDFdLnRyYW5zZm9ybSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaGFzVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1NdXRhdGlvbiA9IGRiQmF0Y2gubXV0YXRpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIGN1cnJlbnRNdXRhdGlvbi51cGRhdGVUcmFuc2Zvcm1zID1cbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1NdXRhdGlvbi50cmFuc2Zvcm0uZmllbGRUcmFuc2Zvcm1zO1xuICAgICAgICAgICAgZGJCYXRjaC5tdXRhdGlvbnMuc3BsaWNlKGkgKyAxLCAxKTtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtdXRhdGlvbnMgPSBkYkJhdGNoLm11dGF0aW9ucy5tYXAobSA9PiBmcm9tTXV0YXRpb24obG9jYWxTZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIsIG0pKTtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBUaW1lc3RhbXAuZnJvbU1pbGxpcyhkYkJhdGNoLmxvY2FsV3JpdGVUaW1lTXMpO1xuICAgIHJldHVybiBuZXcgTXV0YXRpb25CYXRjaChkYkJhdGNoLmJhdGNoSWQsIHRpbWVzdGFtcCwgYmFzZU11dGF0aW9ucywgbXV0YXRpb25zKTtcbn1cbi8qKiBEZWNvZGVzIGEgRGJUYXJnZXQgaW50byBUYXJnZXREYXRhICovXG5mdW5jdGlvbiBmcm9tRGJUYXJnZXQoZGJUYXJnZXQpIHtcbiAgICBjb25zdCB2ZXJzaW9uID0gZnJvbURiVGltZXN0YW1wKGRiVGFyZ2V0LnJlYWRUaW1lKTtcbiAgICBjb25zdCBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uID0gZGJUYXJnZXQubGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gZnJvbURiVGltZXN0YW1wKGRiVGFyZ2V0Lmxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24pXG4gICAgICAgIDogU25hcHNob3RWZXJzaW9uLm1pbigpO1xuICAgIGxldCB0YXJnZXQ7XG4gICAgaWYgKGlzRG9jdW1lbnRRdWVyeShkYlRhcmdldC5xdWVyeSkpIHtcbiAgICAgICAgdGFyZ2V0ID0gZnJvbURvY3VtZW50c1RhcmdldChkYlRhcmdldC5xdWVyeSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0YXJnZXQgPSBmcm9tUXVlcnlUYXJnZXQoZGJUYXJnZXQucXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRhcmdldERhdGEodGFyZ2V0LCBkYlRhcmdldC50YXJnZXRJZCwgXCJUYXJnZXRQdXJwb3NlTGlzdGVuXCIgLyogVGFyZ2V0UHVycG9zZS5MaXN0ZW4gKi8sIGRiVGFyZ2V0Lmxhc3RMaXN0ZW5TZXF1ZW5jZU51bWJlciwgdmVyc2lvbiwgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiwgQnl0ZVN0cmluZy5mcm9tQmFzZTY0U3RyaW5nKGRiVGFyZ2V0LnJlc3VtZVRva2VuKSk7XG59XG4vKiogRW5jb2RlcyBUYXJnZXREYXRhIGludG8gYSBEYlRhcmdldCBmb3Igc3RvcmFnZSBsb2NhbGx5LiAqL1xuZnVuY3Rpb24gdG9EYlRhcmdldChsb2NhbFNlcmlhbGl6ZXIsIHRhcmdldERhdGEpIHtcbiAgICBjb25zdCBkYlRpbWVzdGFtcCA9IHRvRGJUaW1lc3RhbXAodGFyZ2V0RGF0YS5zbmFwc2hvdFZlcnNpb24pO1xuICAgIGNvbnN0IGRiTGFzdExpbWJvRnJlZVRpbWVzdGFtcCA9IHRvRGJUaW1lc3RhbXAodGFyZ2V0RGF0YS5sYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uKTtcbiAgICBsZXQgcXVlcnlQcm90bztcbiAgICBpZiAodGFyZ2V0SXNEb2N1bWVudFRhcmdldCh0YXJnZXREYXRhLnRhcmdldCkpIHtcbiAgICAgICAgcXVlcnlQcm90byA9IHRvRG9jdW1lbnRzVGFyZ2V0KGxvY2FsU2VyaWFsaXplci5yZW1vdGVTZXJpYWxpemVyLCB0YXJnZXREYXRhLnRhcmdldCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBxdWVyeVByb3RvID0gdG9RdWVyeVRhcmdldChsb2NhbFNlcmlhbGl6ZXIucmVtb3RlU2VyaWFsaXplciwgdGFyZ2V0RGF0YS50YXJnZXQpLnF1ZXJ5VGFyZ2V0O1xuICAgIH1cbiAgICAvLyBXZSBjYW4ndCBzdG9yZSB0aGUgcmVzdW1lVG9rZW4gYXMgYSBCeXRlU3RyaW5nIGluIEluZGV4ZWREYiwgc28gd2VcbiAgICAvLyBjb252ZXJ0IGl0IHRvIGEgYmFzZTY0IHN0cmluZyBmb3Igc3RvcmFnZS5cbiAgICBjb25zdCByZXN1bWVUb2tlbiA9IHRhcmdldERhdGEucmVzdW1lVG9rZW4udG9CYXNlNjQoKTtcbiAgICAvLyBsYXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIgaXMgYWx3YXlzIDAgdW50aWwgd2UgZG8gcmVhbCBHQy5cbiAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXRJZDogdGFyZ2V0RGF0YS50YXJnZXRJZCxcbiAgICAgICAgY2Fub25pY2FsSWQ6IGNhbm9uaWZ5VGFyZ2V0KHRhcmdldERhdGEudGFyZ2V0KSxcbiAgICAgICAgcmVhZFRpbWU6IGRiVGltZXN0YW1wLFxuICAgICAgICByZXN1bWVUb2tlbixcbiAgICAgICAgbGFzdExpc3RlblNlcXVlbmNlTnVtYmVyOiB0YXJnZXREYXRhLnNlcXVlbmNlTnVtYmVyLFxuICAgICAgICBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uOiBkYkxhc3RMaW1ib0ZyZWVUaW1lc3RhbXAsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeVByb3RvXG4gICAgfTtcbn1cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gZm9yIGZpZ3VyaW5nIG91dCB3aGF0IGtpbmQgb2YgcXVlcnkgaGFzIGJlZW4gc3RvcmVkLlxuICovXG5mdW5jdGlvbiBpc0RvY3VtZW50UXVlcnkoZGJRdWVyeSkge1xuICAgIHJldHVybiBkYlF1ZXJ5LmRvY3VtZW50cyAhPT0gdW5kZWZpbmVkO1xufVxuLyoqIEVuY29kZXMgYSBEYkJ1bmRsZSB0byBhIEJ1bmRsZU1ldGFkYXRhIG9iamVjdC4gKi9cbmZ1bmN0aW9uIGZyb21EYkJ1bmRsZShkYkJ1bmRsZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBkYkJ1bmRsZS5idW5kbGVJZCxcbiAgICAgICAgY3JlYXRlVGltZTogZnJvbURiVGltZXN0YW1wKGRiQnVuZGxlLmNyZWF0ZVRpbWUpLFxuICAgICAgICB2ZXJzaW9uOiBkYkJ1bmRsZS52ZXJzaW9uXG4gICAgfTtcbn1cbi8qKiBFbmNvZGVzIGEgQnVuZGxlTWV0YWRhdGEgdG8gYSBEYkJ1bmRsZS4gKi9cbmZ1bmN0aW9uIHRvRGJCdW5kbGUobWV0YWRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBidW5kbGVJZDogbWV0YWRhdGEuaWQsXG4gICAgICAgIGNyZWF0ZVRpbWU6IHRvRGJUaW1lc3RhbXAoZnJvbVZlcnNpb24obWV0YWRhdGEuY3JlYXRlVGltZSkpLFxuICAgICAgICB2ZXJzaW9uOiBtZXRhZGF0YS52ZXJzaW9uXG4gICAgfTtcbn1cbi8qKiBFbmNvZGVzIGEgRGJOYW1lZFF1ZXJ5IHRvIGEgTmFtZWRRdWVyeS4gKi9cbmZ1bmN0aW9uIGZyb21EYk5hbWVkUXVlcnkoZGJOYW1lZFF1ZXJ5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogZGJOYW1lZFF1ZXJ5Lm5hbWUsXG4gICAgICAgIHF1ZXJ5OiBmcm9tQnVuZGxlZFF1ZXJ5KGRiTmFtZWRRdWVyeS5idW5kbGVkUXVlcnkpLFxuICAgICAgICByZWFkVGltZTogZnJvbURiVGltZXN0YW1wKGRiTmFtZWRRdWVyeS5yZWFkVGltZSlcbiAgICB9O1xufVxuLyoqIEVuY29kZXMgYSBOYW1lZFF1ZXJ5IGZyb20gYSBidW5kbGUgcHJvdG8gdG8gYSBEYk5hbWVkUXVlcnkuICovXG5mdW5jdGlvbiB0b0RiTmFtZWRRdWVyeShxdWVyeSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IHF1ZXJ5Lm5hbWUsXG4gICAgICAgIHJlYWRUaW1lOiB0b0RiVGltZXN0YW1wKGZyb21WZXJzaW9uKHF1ZXJ5LnJlYWRUaW1lKSksXG4gICAgICAgIGJ1bmRsZWRRdWVyeTogcXVlcnkuYnVuZGxlZFF1ZXJ5XG4gICAgfTtcbn1cbi8qKlxuICogRW5jb2RlcyBhIGBCdW5kbGVkUXVlcnlgIGZyb20gYnVuZGxlIHByb3RvIHRvIGEgUXVlcnkgb2JqZWN0LlxuICpcbiAqIFRoaXMgcmVjb25zdHJ1Y3RzIHRoZSBvcmlnaW5hbCBxdWVyeSB1c2VkIHRvIGJ1aWxkIHRoZSBidW5kbGUgYmVpbmcgbG9hZGVkLFxuICogaW5jbHVkaW5nIGZlYXR1cmVzIGV4aXN0cyBvbmx5IGluIFNES3MgKGZvciBleGFtcGxlOiBsaW1pdC10by1sYXN0KS5cbiAqL1xuZnVuY3Rpb24gZnJvbUJ1bmRsZWRRdWVyeShidW5kbGVkUXVlcnkpIHtcbiAgICBjb25zdCBxdWVyeSA9IGNvbnZlcnRRdWVyeVRhcmdldFRvUXVlcnkoe1xuICAgICAgICBwYXJlbnQ6IGJ1bmRsZWRRdWVyeS5wYXJlbnQsXG4gICAgICAgIHN0cnVjdHVyZWRRdWVyeTogYnVuZGxlZFF1ZXJ5LnN0cnVjdHVyZWRRdWVyeVxuICAgIH0pO1xuICAgIGlmIChidW5kbGVkUXVlcnkubGltaXRUeXBlID09PSAnTEFTVCcpIHtcbiAgICAgICAgcmV0dXJuIHF1ZXJ5V2l0aExpbWl0KHF1ZXJ5LCBxdWVyeS5saW1pdCwgXCJMXCIgLyogTGltaXRUeXBlLkxhc3QgKi8pO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcnk7XG59XG4vKiogRW5jb2RlcyBhIE5hbWVkUXVlcnkgcHJvdG8gb2JqZWN0IHRvIGEgTmFtZWRRdWVyeSBtb2RlbCBvYmplY3QuICovXG5mdW5jdGlvbiBmcm9tUHJvdG9OYW1lZFF1ZXJ5KG5hbWVkUXVlcnkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lZFF1ZXJ5Lm5hbWUsXG4gICAgICAgIHF1ZXJ5OiBmcm9tQnVuZGxlZFF1ZXJ5KG5hbWVkUXVlcnkuYnVuZGxlZFF1ZXJ5KSxcbiAgICAgICAgcmVhZFRpbWU6IGZyb21WZXJzaW9uKG5hbWVkUXVlcnkucmVhZFRpbWUpXG4gICAgfTtcbn1cbi8qKiBEZWNvZGVzIGEgQnVuZGxlTWV0YWRhdGEgcHJvdG8gaW50byBhIEJ1bmRsZU1ldGFkYXRhIG9iamVjdC4gKi9cbmZ1bmN0aW9uIGZyb21CdW5kbGVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBtZXRhZGF0YS5pZCxcbiAgICAgICAgdmVyc2lvbjogbWV0YWRhdGEudmVyc2lvbixcbiAgICAgICAgY3JlYXRlVGltZTogZnJvbVZlcnNpb24obWV0YWRhdGEuY3JlYXRlVGltZSlcbiAgICB9O1xufVxuLyoqIEVuY29kZXMgYSBEYkRvY3VtZW50T3ZlcmxheSBvYmplY3QgdG8gYW4gT3ZlcmxheSBtb2RlbCBvYmplY3QuICovXG5mdW5jdGlvbiBmcm9tRGJEb2N1bWVudE92ZXJsYXkobG9jYWxTZXJpYWxpemVyLCBkYkRvY3VtZW50T3ZlcmxheSkge1xuICAgIHJldHVybiBuZXcgT3ZlcmxheShkYkRvY3VtZW50T3ZlcmxheS5sYXJnZXN0QmF0Y2hJZCwgZnJvbU11dGF0aW9uKGxvY2FsU2VyaWFsaXplci5yZW1vdGVTZXJpYWxpemVyLCBkYkRvY3VtZW50T3ZlcmxheS5vdmVybGF5TXV0YXRpb24pKTtcbn1cbi8qKiBEZWNvZGVzIGFuIE92ZXJsYXkgbW9kZWwgb2JqZWN0IGludG8gYSBEYkRvY3VtZW50T3ZlcmxheSBvYmplY3QuICovXG5mdW5jdGlvbiB0b0RiRG9jdW1lbnRPdmVybGF5KGxvY2FsU2VyaWFsaXplciwgdXNlcklkLCBvdmVybGF5KSB7XG4gICAgY29uc3QgW18sIGNvbGxlY3Rpb25QYXRoLCBkb2N1bWVudElkXSA9IHRvRGJEb2N1bWVudE92ZXJsYXlLZXkodXNlcklkLCBvdmVybGF5Lm11dGF0aW9uLmtleSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlcklkLFxuICAgICAgICBjb2xsZWN0aW9uUGF0aCxcbiAgICAgICAgZG9jdW1lbnRJZCxcbiAgICAgICAgY29sbGVjdGlvbkdyb3VwOiBvdmVybGF5Lm11dGF0aW9uLmtleS5nZXRDb2xsZWN0aW9uR3JvdXAoKSxcbiAgICAgICAgbGFyZ2VzdEJhdGNoSWQ6IG92ZXJsYXkubGFyZ2VzdEJhdGNoSWQsXG4gICAgICAgIG92ZXJsYXlNdXRhdGlvbjogdG9NdXRhdGlvbihsb2NhbFNlcmlhbGl6ZXIucmVtb3RlU2VyaWFsaXplciwgb3ZlcmxheS5tdXRhdGlvbilcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBEYkRvY3VtZW50T3ZlcmxheUtleSBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiB1c2VyIGFuZFxuICogZG9jdW1lbnQga2V5LlxuICovXG5mdW5jdGlvbiB0b0RiRG9jdW1lbnRPdmVybGF5S2V5KHVzZXJJZCwgZG9jS2V5KSB7XG4gICAgY29uc3QgZG9jSWQgPSBkb2NLZXkucGF0aC5sYXN0U2VnbWVudCgpO1xuICAgIGNvbnN0IGNvbGxlY3Rpb25QYXRoID0gZW5jb2RlUmVzb3VyY2VQYXRoKGRvY0tleS5wYXRoLnBvcExhc3QoKSk7XG4gICAgcmV0dXJuIFt1c2VySWQsIGNvbGxlY3Rpb25QYXRoLCBkb2NJZF07XG59XG5mdW5jdGlvbiB0b0RiSW5kZXhDb25maWd1cmF0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZXhJZDogaW5kZXguaW5kZXhJZCxcbiAgICAgICAgY29sbGVjdGlvbkdyb3VwOiBpbmRleC5jb2xsZWN0aW9uR3JvdXAsXG4gICAgICAgIGZpZWxkczogaW5kZXguZmllbGRzLm1hcChzID0+IFtzLmZpZWxkUGF0aC5jYW5vbmljYWxTdHJpbmcoKSwgcy5raW5kXSlcbiAgICB9O1xufVxuZnVuY3Rpb24gZnJvbURiSW5kZXhDb25maWd1cmF0aW9uKGluZGV4LCBzdGF0ZSkge1xuICAgIGNvbnN0IGRlY29kZWRTdGF0ZSA9IHN0YXRlXG4gICAgICAgID8gbmV3IEluZGV4U3RhdGUoc3RhdGUuc2VxdWVuY2VOdW1iZXIsIG5ldyBJbmRleE9mZnNldChmcm9tRGJUaW1lc3RhbXAoc3RhdGUucmVhZFRpbWUpLCBuZXcgRG9jdW1lbnRLZXkoZGVjb2RlUmVzb3VyY2VQYXRoKHN0YXRlLmRvY3VtZW50S2V5KSksIHN0YXRlLmxhcmdlc3RCYXRjaElkKSlcbiAgICAgICAgOiBJbmRleFN0YXRlLmVtcHR5KCk7XG4gICAgY29uc3QgZGVjb2RlZFNlZ21lbnRzID0gaW5kZXguZmllbGRzLm1hcCgoW2ZpZWxkUGF0aCwga2luZF0pID0+IG5ldyBJbmRleFNlZ21lbnQoRmllbGRQYXRoJDEuZnJvbVNlcnZlckZvcm1hdChmaWVsZFBhdGgpLCBraW5kKSk7XG4gICAgcmV0dXJuIG5ldyBGaWVsZEluZGV4KGluZGV4LmluZGV4SWQsIGluZGV4LmNvbGxlY3Rpb25Hcm91cCwgZGVjb2RlZFNlZ21lbnRzLCBkZWNvZGVkU3RhdGUpO1xufVxuZnVuY3Rpb24gdG9EYkluZGV4U3RhdGUoaW5kZXhJZCwgdWlkLCBzZXF1ZW5jZU51bWJlciwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZXhJZCxcbiAgICAgICAgdWlkLFxuICAgICAgICBzZXF1ZW5jZU51bWJlcixcbiAgICAgICAgcmVhZFRpbWU6IHRvRGJUaW1lc3RhbXAob2Zmc2V0LnJlYWRUaW1lKSxcbiAgICAgICAgZG9jdW1lbnRLZXk6IGVuY29kZVJlc291cmNlUGF0aChvZmZzZXQuZG9jdW1lbnRLZXkucGF0aCksXG4gICAgICAgIGxhcmdlc3RCYXRjaElkOiBvZmZzZXQubGFyZ2VzdEJhdGNoSWRcbiAgICB9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgSW5kZXhlZERiQnVuZGxlQ2FjaGUge1xuICAgIGdldEJ1bmRsZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBidW5kbGVJZCkge1xuICAgICAgICByZXR1cm4gYnVuZGxlc1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLmdldChidW5kbGVJZClcbiAgICAgICAgICAgIC5uZXh0KGJ1bmRsZSA9PiB7XG4gICAgICAgICAgICBpZiAoYnVuZGxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21EYkJ1bmRsZShidW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNhdmVCdW5kbGVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgYnVuZGxlTWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGJ1bmRsZXNTdG9yZSh0cmFuc2FjdGlvbikucHV0KHRvRGJCdW5kbGUoYnVuZGxlTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgZ2V0TmFtZWRRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnlOYW1lKSB7XG4gICAgICAgIHJldHVybiBuYW1lZFF1ZXJpZXNTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5nZXQocXVlcnlOYW1lKVxuICAgICAgICAgICAgLm5leHQocXVlcnkgPT4ge1xuICAgICAgICAgICAgaWYgKHF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21EYk5hbWVkUXVlcnkocXVlcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNhdmVOYW1lZFF1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSkge1xuICAgICAgICByZXR1cm4gbmFtZWRRdWVyaWVzU3RvcmUodHJhbnNhY3Rpb24pLnB1dCh0b0RiTmFtZWRRdWVyeShxdWVyeSkpO1xuICAgIH1cbn1cbi8qKlxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBidW5kbGVzIG9iamVjdCBzdG9yZS5cbiAqL1xuZnVuY3Rpb24gYnVuZGxlc1N0b3JlKHR4bikge1xuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiQnVuZGxlU3RvcmUpO1xufVxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIG5hbWVkUXVlcmllcyBvYmplY3Qgc3RvcmUuXG4gKi9cbmZ1bmN0aW9uIG5hbWVkUXVlcmllc1N0b3JlKHR4bikge1xuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiTmFtZWRRdWVyeVN0b3JlKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgRG9jdW1lbnRPdmVybGF5Q2FjaGUgdXNpbmcgSW5kZXhlZERiLlxuICovXG5jbGFzcyBJbmRleGVkRGJEb2N1bWVudE92ZXJsYXlDYWNoZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHNlcmlhbGl6ZXIgLSBUaGUgZG9jdW1lbnQgc2VyaWFsaXplci5cbiAgICAgKiBAcGFyYW0gdXNlcklkIC0gVGhlIHVzZXJJZCBmb3Igd2hpY2ggd2UgYXJlIGFjY2Vzc2luZyBvdmVybGF5cy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzZXJpYWxpemVyLCB1c2VySWQpIHtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcbiAgICAgICAgdGhpcy51c2VySWQgPSB1c2VySWQ7XG4gICAgfVxuICAgIHN0YXRpYyBmb3JVc2VyKHNlcmlhbGl6ZXIsIHVzZXIpIHtcbiAgICAgICAgY29uc3QgdXNlcklkID0gdXNlci51aWQgfHwgJyc7XG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhlZERiRG9jdW1lbnRPdmVybGF5Q2FjaGUoc2VyaWFsaXplciwgdXNlcklkKTtcbiAgICB9XG4gICAgZ2V0T3ZlcmxheSh0cmFuc2FjdGlvbiwga2V5KSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudE92ZXJsYXlTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5nZXQodG9EYkRvY3VtZW50T3ZlcmxheUtleSh0aGlzLnVzZXJJZCwga2V5KSlcbiAgICAgICAgICAgIC5uZXh0KGRiT3ZlcmxheSA9PiB7XG4gICAgICAgICAgICBpZiAoZGJPdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21EYkRvY3VtZW50T3ZlcmxheSh0aGlzLnNlcmlhbGl6ZXIsIGRiT3ZlcmxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldE92ZXJsYXlzKHRyYW5zYWN0aW9uLCBrZXlzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ld092ZXJsYXlNYXAoKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKGtleXMsIChrZXkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE92ZXJsYXkodHJhbnNhY3Rpb24sIGtleSkubmV4dChvdmVybGF5ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGtleSwgb3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLm5leHQoKCkgPT4gcmVzdWx0KTtcbiAgICB9XG4gICAgc2F2ZU92ZXJsYXlzKHRyYW5zYWN0aW9uLCBsYXJnZXN0QmF0Y2hJZCwgb3ZlcmxheXMpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgb3ZlcmxheXMuZm9yRWFjaCgoXywgbXV0YXRpb24pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXkgPSBuZXcgT3ZlcmxheShsYXJnZXN0QmF0Y2hJZCwgbXV0YXRpb24pO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnNhdmVPdmVybGF5KHRyYW5zYWN0aW9uLCBvdmVybGF5KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpO1xuICAgIH1cbiAgICByZW1vdmVPdmVybGF5c0ZvckJhdGNoSWQodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cywgYmF0Y2hJZCkge1xuICAgICAgICBjb25zdCBjb2xsZWN0aW9uUGF0aHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIC8vIEdldCB0aGUgc2V0IG9mIHVuaXF1ZSBjb2xsZWN0aW9uIHBhdGhzLlxuICAgICAgICBkb2N1bWVudEtleXMuZm9yRWFjaChrZXkgPT4gY29sbGVjdGlvblBhdGhzLmFkZChlbmNvZGVSZXNvdXJjZVBhdGgoa2V5LmdldENvbGxlY3Rpb25QYXRoKCkpKSk7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIGNvbGxlY3Rpb25QYXRocy5mb3JFYWNoKGNvbGxlY3Rpb25QYXRoID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UuYm91bmQoW3RoaXMudXNlcklkLCBjb2xsZWN0aW9uUGF0aCwgYmF0Y2hJZF0sIFt0aGlzLnVzZXJJZCwgY29sbGVjdGlvblBhdGgsIGJhdGNoSWQgKyAxXSwgXG4gICAgICAgICAgICAvKmxvd2VyT3Blbj0qLyBmYWxzZSwgXG4gICAgICAgICAgICAvKnVwcGVyT3Blbj0qLyB0cnVlKTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goZG9jdW1lbnRPdmVybGF5U3RvcmUodHJhbnNhY3Rpb24pLmRlbGV0ZUFsbChEYkRvY3VtZW50T3ZlcmxheUNvbGxlY3Rpb25QYXRoT3ZlcmxheUluZGV4LCByYW5nZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKTtcbiAgICB9XG4gICAgZ2V0T3ZlcmxheXNGb3JDb2xsZWN0aW9uKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uLCBzaW5jZUJhdGNoSWQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3T3ZlcmxheU1hcCgpO1xuICAgICAgICBjb25zdCBjb2xsZWN0aW9uUGF0aCA9IGVuY29kZVJlc291cmNlUGF0aChjb2xsZWN0aW9uKTtcbiAgICAgICAgLy8gV2Ugd2FudCBiYXRjaCBJRHMgbGFyZ2VyIHRoYW4gYHNpbmNlQmF0Y2hJZGAsIGFuZCBzbyB0aGUgbG93ZXIgYm91bmRcbiAgICAgICAgLy8gaXMgbm90IGluY2x1c2l2ZS5cbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbdGhpcy51c2VySWQsIGNvbGxlY3Rpb25QYXRoLCBzaW5jZUJhdGNoSWRdLCBbdGhpcy51c2VySWQsIGNvbGxlY3Rpb25QYXRoLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldLCBcbiAgICAgICAgLypsb3dlck9wZW49Ki8gdHJ1ZSk7XG4gICAgICAgIHJldHVybiBkb2N1bWVudE92ZXJsYXlTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5sb2FkQWxsKERiRG9jdW1lbnRPdmVybGF5Q29sbGVjdGlvblBhdGhPdmVybGF5SW5kZXgsIHJhbmdlKVxuICAgICAgICAgICAgLm5leHQoZGJPdmVybGF5cyA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRiT3ZlcmxheSBvZiBkYk92ZXJsYXlzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3ZlcmxheSA9IGZyb21EYkRvY3VtZW50T3ZlcmxheSh0aGlzLnNlcmlhbGl6ZXIsIGRiT3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChvdmVybGF5LmdldEtleSgpLCBvdmVybGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRPdmVybGF5c0ZvckNvbGxlY3Rpb25Hcm91cCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBzaW5jZUJhdGNoSWQsIGNvdW50KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ld092ZXJsYXlNYXAoKTtcbiAgICAgICAgbGV0IGN1cnJlbnRCYXRjaElkID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBXZSB3YW50IGJhdGNoIElEcyBsYXJnZXIgdGhhbiBgc2luY2VCYXRjaElkYCwgYW5kIHNvIHRoZSBsb3dlciBib3VuZFxuICAgICAgICAvLyBpcyBub3QgaW5jbHVzaXZlLlxuICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKFt0aGlzLnVzZXJJZCwgY29sbGVjdGlvbkdyb3VwLCBzaW5jZUJhdGNoSWRdLCBbdGhpcy51c2VySWQsIGNvbGxlY3Rpb25Hcm91cCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSwgXG4gICAgICAgIC8qbG93ZXJPcGVuPSovIHRydWUpO1xuICAgICAgICByZXR1cm4gZG9jdW1lbnRPdmVybGF5U3RvcmUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAuaXRlcmF0ZSh7XG4gICAgICAgICAgICBpbmRleDogRGJEb2N1bWVudE92ZXJsYXlDb2xsZWN0aW9uR3JvdXBPdmVybGF5SW5kZXgsXG4gICAgICAgICAgICByYW5nZVxuICAgICAgICB9LCAoXywgZGJPdmVybGF5LCBjb250cm9sKSA9PiB7XG4gICAgICAgICAgICAvLyBXZSBkbyBub3Qgd2FudCB0byByZXR1cm4gcGFydGlhbCBiYXRjaCBvdmVybGF5cywgZXZlbiBpZiB0aGUgc2l6ZVxuICAgICAgICAgICAgLy8gb2YgdGhlIHJlc3VsdCBzZXQgZXhjZWVkcyB0aGUgZ2l2ZW4gYGNvdW50YCBhcmd1bWVudC4gVGhlcmVmb3JlLCB3ZVxuICAgICAgICAgICAgLy8gY29udGludWUgdG8gYWdncmVnYXRlIHJlc3VsdHMgZXZlbiBhZnRlciB0aGUgcmVzdWx0IHNpemUgZXhjZWVkc1xuICAgICAgICAgICAgLy8gYGNvdW50YCBpZiB0aGVyZSBhcmUgbW9yZSBvdmVybGF5cyBmcm9tIHRoZSBgY3VycmVudEJhdGNoSWRgLlxuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheSA9IGZyb21EYkRvY3VtZW50T3ZlcmxheSh0aGlzLnNlcmlhbGl6ZXIsIGRiT3ZlcmxheSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnNpemUoKSA8IGNvdW50IHx8XG4gICAgICAgICAgICAgICAgb3ZlcmxheS5sYXJnZXN0QmF0Y2hJZCA9PT0gY3VycmVudEJhdGNoSWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KG92ZXJsYXkuZ2V0S2V5KCksIG92ZXJsYXkpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCYXRjaElkID0gb3ZlcmxheS5sYXJnZXN0QmF0Y2hJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gcmVzdWx0KTtcbiAgICB9XG4gICAgc2F2ZU92ZXJsYXkodHJhbnNhY3Rpb24sIG92ZXJsYXkpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50T3ZlcmxheVN0b3JlKHRyYW5zYWN0aW9uKS5wdXQodG9EYkRvY3VtZW50T3ZlcmxheSh0aGlzLnNlcmlhbGl6ZXIsIHRoaXMudXNlcklkLCBvdmVybGF5KSk7XG4gICAgfVxufVxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIGRvY3VtZW50IG92ZXJsYXkgb2JqZWN0IHN0b3JlLlxuICovXG5mdW5jdGlvbiBkb2N1bWVudE92ZXJsYXlTdG9yZSh0eG4pIHtcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYkRvY3VtZW50T3ZlcmxheVN0b3JlKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjQgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIEluZGV4ZWREYkdsb2JhbHNDYWNoZSB7XG4gICAgZ2xvYmFsc1N0b3JlKHR4bikge1xuICAgICAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYkdsb2JhbHNTdG9yZSk7XG4gICAgfVxuICAgIGdldFNlc3Npb25Ub2tlbih0eG4pIHtcbiAgICAgICAgY29uc3QgZ2xvYmFscyA9IHRoaXMuZ2xvYmFsc1N0b3JlKHR4bik7XG4gICAgICAgIHJldHVybiBnbG9iYWxzLmdldCgnc2Vzc2lvblRva2VuJykubmV4dChnbG9iYWwgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBnbG9iYWwgPT09IG51bGwgfHwgZ2xvYmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnbG9iYWwudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgICAgICA/IEJ5dGVTdHJpbmcuZnJvbVVpbnQ4QXJyYXkodmFsdWUpXG4gICAgICAgICAgICAgICAgOiBCeXRlU3RyaW5nLkVNUFRZX0JZVEVfU1RSSU5HO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0U2Vzc2lvblRva2VuKHR4biwgc2Vzc2lvblRva2VuKSB7XG4gICAgICAgIGNvbnN0IGdsb2JhbHMgPSB0aGlzLmdsb2JhbHNTdG9yZSh0eG4pO1xuICAgICAgICByZXR1cm4gZ2xvYmFscy5wdXQoe1xuICAgICAgICAgICAgbmFtZTogJ3Nlc3Npb25Ub2tlbicsXG4gICAgICAgICAgICB2YWx1ZTogc2Vzc2lvblRva2VuLnRvVWludDhBcnJheSgpXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8vIE5vdGU6IFRoaXMgY29kZSBpcyBjb3BpZWQgZnJvbSB0aGUgYmFja2VuZC4gQ29kZSB0aGF0IGlzIG5vdCB1c2VkIGJ5XG4vLyBGaXJlc3RvcmUgd2FzIHJlbW92ZWQuXG5jb25zdCBJTkRFWF9UWVBFX05VTEwgPSA1O1xuY29uc3QgSU5ERVhfVFlQRV9CT09MRUFOID0gMTA7XG5jb25zdCBJTkRFWF9UWVBFX05BTiA9IDEzO1xuY29uc3QgSU5ERVhfVFlQRV9OVU1CRVIgPSAxNTtcbmNvbnN0IElOREVYX1RZUEVfVElNRVNUQU1QID0gMjA7XG5jb25zdCBJTkRFWF9UWVBFX1NUUklORyA9IDI1O1xuY29uc3QgSU5ERVhfVFlQRV9CTE9CID0gMzA7XG5jb25zdCBJTkRFWF9UWVBFX1JFRkVSRU5DRSA9IDM3O1xuY29uc3QgSU5ERVhfVFlQRV9HRU9QT0lOVCA9IDQ1O1xuY29uc3QgSU5ERVhfVFlQRV9BUlJBWSA9IDUwO1xuY29uc3QgSU5ERVhfVFlQRV9WRUNUT1IgPSA1MztcbmNvbnN0IElOREVYX1RZUEVfTUFQID0gNTU7XG5jb25zdCBJTkRFWF9UWVBFX1JFRkVSRU5DRV9TRUdNRU5UID0gNjA7XG4vLyBBIHRlcm1pbmF0b3IgdGhhdCBpbmRpY2F0ZXMgdGhhdCBhIHRydW5jYXRhYmxlIHZhbHVlIHdhcyBub3QgdHJ1bmNhdGVkLlxuLy8gVGhpcyBtdXN0IGJlIHNtYWxsZXIgdGhhbiBhbGwgb3RoZXIgdHlwZSBsYWJlbHMuXG5jb25zdCBOT1RfVFJVTkNBVEVEID0gMjtcbi8qKiBGaXJlc3RvcmUgaW5kZXggdmFsdWUgd3JpdGVyLiAgKi9cbmNsYXNzIEZpcmVzdG9yZUluZGV4VmFsdWVXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkgeyB9XG4gICAgLy8gVGhlIHdyaXRlIG1ldGhvZHMgYmVsb3cgc2hvcnQtY2lyY3VpdCB3cml0aW5nIHRlcm1pbmF0b3JzIGZvciB2YWx1ZXNcbiAgICAvLyBjb250YWluaW5nIGEgKHRlcm1pbmF0aW5nKSB0cnVuY2F0ZWQgdmFsdWUuXG4gICAgLy9cbiAgICAvLyBBcyBhbiBleGFtcGxlLCBjb25zaWRlciB0aGUgcmVzdWx0aW5nIGVuY29kaW5nIGZvcjpcbiAgICAvL1xuICAgIC8vIFtcImJhclwiLCBbMiwgXCJmb29cIl1dIC0+IChTVFJJTkcsIFwiYmFyXCIsIFRFUk0sIEFSUkFZLCBOVU1CRVIsIDIsIFNUUklORywgXCJmb29cIiwgVEVSTSwgVEVSTSwgVEVSTSlcbiAgICAvLyBbXCJiYXJcIiwgWzIsIHRydW5jYXRlZChcImZvb1wiKV1dIC0+IChTVFJJTkcsIFwiYmFyXCIsIFRFUk0sIEFSUkFZLCBOVU1CRVIsIDIsIFNUUklORywgXCJmb29cIiwgVFJVTkMpXG4gICAgLy8gW1wiYmFyXCIsIHRydW5jYXRlZChbXCJmb29cIl0pXSAtPiAoU1RSSU5HLCBcImJhclwiLCBURVJNLCBBUlJBWS4gU1RSSU5HLCBcImZvb1wiLCBURVJNLCBUUlVOQylcbiAgICAvKiogV3JpdGVzIGFuIGluZGV4IHZhbHVlLiAgKi9cbiAgICB3cml0ZUluZGV4VmFsdWUodmFsdWUsIGVuY29kZXIpIHtcbiAgICAgICAgdGhpcy53cml0ZUluZGV4VmFsdWVBdXgodmFsdWUsIGVuY29kZXIpO1xuICAgICAgICAvLyBXcml0ZSBzZXBhcmF0b3IgdG8gc3BsaXQgaW5kZXggdmFsdWVzXG4gICAgICAgIC8vIChzZWUgZ28vZmlyZXN0b3JlLXN0b3JhZ2UtZm9ybWF0I2VuY29kaW5ncykuXG4gICAgICAgIGVuY29kZXIud3JpdGVJbmZpbml0eSgpO1xuICAgIH1cbiAgICB3cml0ZUluZGV4VmFsdWVBdXgoaW5kZXhWYWx1ZSwgZW5jb2Rlcikge1xuICAgICAgICBpZiAoJ251bGxWYWx1ZScgaW4gaW5kZXhWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfTlVMTCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ2Jvb2xlYW5WYWx1ZScgaW4gaW5kZXhWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfQk9PTEVBTik7XG4gICAgICAgICAgICBlbmNvZGVyLndyaXRlTnVtYmVyKGluZGV4VmFsdWUuYm9vbGVhblZhbHVlID8gMSA6IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCdpbnRlZ2VyVmFsdWUnIGluIGluZGV4VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX05VTUJFUik7XG4gICAgICAgICAgICBlbmNvZGVyLndyaXRlTnVtYmVyKG5vcm1hbGl6ZU51bWJlcihpbmRleFZhbHVlLmludGVnZXJWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCdkb3VibGVWYWx1ZScgaW4gaW5kZXhWYWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgbiA9IG5vcm1hbGl6ZU51bWJlcihpbmRleFZhbHVlLmRvdWJsZVZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpc05hTihuKSkge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX05BTik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgSU5ERVhfVFlQRV9OVU1CRVIpO1xuICAgICAgICAgICAgICAgIGlmIChpc05lZ2F0aXZlWmVybyhuKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyAtMC4wLCAwIGFuZCAwLjAgYXJlIGFsbCBjb25zaWRlcmVkIHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZXIud3JpdGVOdW1iZXIoMC4wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kZXIud3JpdGVOdW1iZXIobik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCd0aW1lc3RhbXBWYWx1ZScgaW4gaW5kZXhWYWx1ZSkge1xuICAgICAgICAgICAgbGV0IHRpbWVzdGFtcCA9IGluZGV4VmFsdWUudGltZXN0YW1wVmFsdWU7XG4gICAgICAgICAgICB0aGlzLndyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgSU5ERVhfVFlQRV9USU1FU1RBTVApO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aW1lc3RhbXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGltZXN0YW1wID0gbm9ybWFsaXplVGltZXN0YW1wKHRpbWVzdGFtcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmNvZGVyLndyaXRlU3RyaW5nKGAke3RpbWVzdGFtcC5zZWNvbmRzIHx8ICcnfWApO1xuICAgICAgICAgICAgZW5jb2Rlci53cml0ZU51bWJlcih0aW1lc3RhbXAubmFub3MgfHwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ3N0cmluZ1ZhbHVlJyBpbiBpbmRleFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlSW5kZXhTdHJpbmcoaW5kZXhWYWx1ZS5zdHJpbmdWYWx1ZSwgZW5jb2Rlcik7XG4gICAgICAgICAgICB0aGlzLndyaXRlVHJ1bmNhdGlvbk1hcmtlcihlbmNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgnYnl0ZXNWYWx1ZScgaW4gaW5kZXhWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfQkxPQik7XG4gICAgICAgICAgICBlbmNvZGVyLndyaXRlQnl0ZXMobm9ybWFsaXplQnl0ZVN0cmluZyhpbmRleFZhbHVlLmJ5dGVzVmFsdWUpKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVUcnVuY2F0aW9uTWFya2VyKGVuY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCdyZWZlcmVuY2VWYWx1ZScgaW4gaW5kZXhWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZUluZGV4RW50aXR5UmVmKGluZGV4VmFsdWUucmVmZXJlbmNlVmFsdWUsIGVuY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCdnZW9Qb2ludFZhbHVlJyBpbiBpbmRleFZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBnZW9Qb2ludCA9IGluZGV4VmFsdWUuZ2VvUG9pbnRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX0dFT1BPSU5UKTtcbiAgICAgICAgICAgIGVuY29kZXIud3JpdGVOdW1iZXIoZ2VvUG9pbnQubGF0aXR1ZGUgfHwgMCk7XG4gICAgICAgICAgICBlbmNvZGVyLndyaXRlTnVtYmVyKGdlb1BvaW50LmxvbmdpdHVkZSB8fCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgnbWFwVmFsdWUnIGluIGluZGV4VmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChpc01heFZhbHVlKGluZGV4VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzVmVjdG9yVmFsdWUoaW5kZXhWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlSW5kZXhWZWN0b3IoaW5kZXhWYWx1ZS5tYXBWYWx1ZSwgZW5jb2Rlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlSW5kZXhNYXAoaW5kZXhWYWx1ZS5tYXBWYWx1ZSwgZW5jb2Rlcik7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZVRydW5jYXRpb25NYXJrZXIoZW5jb2Rlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ2FycmF5VmFsdWUnIGluIGluZGV4VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVJbmRleEFycmF5KGluZGV4VmFsdWUuYXJyYXlWYWx1ZSwgZW5jb2Rlcik7XG4gICAgICAgICAgICB0aGlzLndyaXRlVHJ1bmNhdGlvbk1hcmtlcihlbmNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZhaWwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cml0ZUluZGV4U3RyaW5nKHN0cmluZ0luZGV4VmFsdWUsIGVuY29kZXIpIHtcbiAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfU1RSSU5HKTtcbiAgICAgICAgdGhpcy53cml0ZVVubGFiZWxlZEluZGV4U3RyaW5nKHN0cmluZ0luZGV4VmFsdWUsIGVuY29kZXIpO1xuICAgIH1cbiAgICB3cml0ZVVubGFiZWxlZEluZGV4U3RyaW5nKHN0cmluZ0luZGV4VmFsdWUsIGVuY29kZXIpIHtcbiAgICAgICAgZW5jb2Rlci53cml0ZVN0cmluZyhzdHJpbmdJbmRleFZhbHVlKTtcbiAgICB9XG4gICAgd3JpdGVJbmRleE1hcChtYXBJbmRleFZhbHVlLCBlbmNvZGVyKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IG1hcEluZGV4VmFsdWUuZmllbGRzIHx8IHt9O1xuICAgICAgICB0aGlzLndyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgSU5ERVhfVFlQRV9NQVApO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhtYXApKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlSW5kZXhTdHJpbmcoa2V5LCBlbmNvZGVyKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVJbmRleFZhbHVlQXV4KG1hcFtrZXldLCBlbmNvZGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cml0ZUluZGV4VmVjdG9yKG1hcEluZGV4VmFsdWUsIGVuY29kZXIpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWFwID0gbWFwSW5kZXhWYWx1ZS5maWVsZHMgfHwge307XG4gICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX1ZFQ1RPUik7XG4gICAgICAgIC8vIFZlY3RvcnMgc29ydCBmaXJzdCBieSBsZW5ndGhcbiAgICAgICAgY29uc3Qga2V5ID0gVkVDVE9SX01BUF9WRUNUT1JTX0tFWTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gKChfYiA9IChfYSA9IG1hcFtrZXldLmFycmF5VmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52YWx1ZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sZW5ndGgpIHx8IDA7XG4gICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX05VTUJFUik7XG4gICAgICAgIGVuY29kZXIud3JpdGVOdW1iZXIobm9ybWFsaXplTnVtYmVyKGxlbmd0aCkpO1xuICAgICAgICAvLyBWZWN0b3JzIHRoZW4gc29ydCBieSBwb3NpdGlvbiB2YWx1ZVxuICAgICAgICB0aGlzLndyaXRlSW5kZXhTdHJpbmcoa2V5LCBlbmNvZGVyKTtcbiAgICAgICAgdGhpcy53cml0ZUluZGV4VmFsdWVBdXgobWFwW2tleV0sIGVuY29kZXIpO1xuICAgIH1cbiAgICB3cml0ZUluZGV4QXJyYXkoYXJyYXlJbmRleFZhbHVlLCBlbmNvZGVyKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGFycmF5SW5kZXhWYWx1ZS52YWx1ZXMgfHwgW107XG4gICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX0FSUkFZKTtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHZhbHVlcykge1xuICAgICAgICAgICAgdGhpcy53cml0ZUluZGV4VmFsdWVBdXgoZWxlbWVudCwgZW5jb2Rlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVJbmRleEVudGl0eVJlZihyZWZlcmVuY2VWYWx1ZSwgZW5jb2Rlcikge1xuICAgICAgICB0aGlzLndyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgSU5ERVhfVFlQRV9SRUZFUkVOQ0UpO1xuICAgICAgICBjb25zdCBwYXRoID0gRG9jdW1lbnRLZXkuZnJvbU5hbWUocmVmZXJlbmNlVmFsdWUpLnBhdGg7XG4gICAgICAgIHBhdGguZm9yRWFjaChzZWdtZW50ID0+IHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX1JFRkVSRU5DRV9TRUdNRU5UKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVVbmxhYmVsZWRJbmRleFN0cmluZyhzZWdtZW50LCBlbmNvZGVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHdyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgdHlwZU9yZGVyKSB7XG4gICAgICAgIGVuY29kZXIud3JpdGVOdW1iZXIodHlwZU9yZGVyKTtcbiAgICB9XG4gICAgd3JpdGVUcnVuY2F0aW9uTWFya2VyKGVuY29kZXIpIHtcbiAgICAgICAgLy8gV2hpbGUgdGhlIFNESyBkb2VzIG5vdCBpbXBsZW1lbnQgdHJ1bmNhdGlvbiwgdGhlIHRydW5jYXRpb24gbWFya2VyIGlzXG4gICAgICAgIC8vIHVzZWQgdG8gdGVybWluYXRlIGFsbCB2YXJpYWJsZSBsZW5ndGggdmFsdWVzICh3aGljaCBhcmUgc3RyaW5ncywgYnl0ZXMsXG4gICAgICAgIC8vIHJlZmVyZW5jZXMsIGFycmF5cyBhbmQgbWFwcykuXG4gICAgICAgIGVuY29kZXIud3JpdGVOdW1iZXIoTk9UX1RSVU5DQVRFRCk7XG4gICAgfVxufVxuRmlyZXN0b3JlSW5kZXhWYWx1ZVdyaXRlci5JTlNUQU5DRSA9IG5ldyBGaXJlc3RvcmVJbmRleFZhbHVlV3JpdGVyKCk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgfCBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyB8IENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIHwgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogVGhlc2UgY29uc3RhbnRzIGFyZSB0YWtlbiBmcm9tIHRoZSBiYWNrZW5kLiAqL1xuY29uc3QgTUlOX1NVUlJPR0FURSA9ICdcXHVEODAwJztcbmNvbnN0IE1BWF9TVVJST0dBVEUgPSAnXFx1REJGRic7XG5jb25zdCBFU0NBUEUxID0gMHgwMDtcbmNvbnN0IE5VTExfQllURSA9IDB4ZmY7IC8vIENvbWJpbmVkIHdpdGggRVNDQVBFMVxuY29uc3QgU0VQQVJBVE9SID0gMHgwMTsgLy8gQ29tYmluZWQgd2l0aCBFU0NBUEUxXG5jb25zdCBFU0NBUEUyID0gMHhmZjtcbmNvbnN0IElORklOSVRZID0gMHhmZjsgLy8gQ29tYmluZWQgd2l0aCBFU0NBUEUyXG5jb25zdCBGRl9CWVRFID0gMHgwMDsgLy8gQ29tYmluZWQgd2l0aCBFU0NBUEUyXG5jb25zdCBMT05HX1NJWkUgPSA2NDtcbmNvbnN0IEJZVEVfU0laRSA9IDg7XG4vKipcbiAqIFRoZSBkZWZhdWx0IHNpemUgb2YgdGhlIGJ1ZmZlci4gVGhpcyBpcyBhcmJpdHJhcnksIGJ1dCBsaWtlbHkgbGFyZ2VyIHRoYW5cbiAqIG1vc3QgaW5kZXggdmFsdWVzIHNvIHRoYXQgbGVzcyBjb3BpZXMgb2YgdGhlIHVuZGVybHlpbmcgYnVmZmVyIHdpbGwgYmUgbWFkZS5cbiAqIEZvciBsYXJnZSB2YWx1ZXMsIGEgc2luZ2xlIGNvcHkgd2lsbCBtYWRlIHRvIGRvdWJsZSB0aGUgYnVmZmVyIGxlbmd0aC5cbiAqL1xuY29uc3QgREVGQVVMVF9CVUZGRVJfU0laRSA9IDEwMjQ7XG4vKiogQ29udmVydHMgYSBKYXZhU2NyaXB0IG51bWJlciB0byBhIGJ5dGUgYXJyYXkgKHVzaW5nIGJpZyBlbmRpYW4gZW5jb2RpbmcpLiAqL1xuZnVuY3Rpb24gZG91YmxlVG9Mb25nQml0cyh2YWx1ZSkge1xuICAgIGNvbnN0IGR2ID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcig4KSk7XG4gICAgZHYuc2V0RmxvYXQ2NCgwLCB2YWx1ZSwgLyogbGl0dGxlRW5kaWFuPSAqLyBmYWxzZSk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGR2LmJ1ZmZlcik7XG59XG4vKipcbiAqIENvdW50cyB0aGUgbnVtYmVyIG9mIHplcm9zIGluIGEgYnl0ZS5cbiAqXG4gKiBWaXNpYmxlIGZvciB0ZXN0aW5nLlxuICovXG5mdW5jdGlvbiBudW1iZXJPZkxlYWRpbmdaZXJvc0luQnl0ZSh4KSB7XG4gICAgaWYgKHggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgfVxuICAgIGxldCB6ZXJvcyA9IDA7XG4gICAgaWYgKHggPj4gNCA9PT0gMCkge1xuICAgICAgICAvLyBUZXN0IGlmIHRoZSBmaXJzdCBmb3VyIGJpdHMgYXJlIHplcm8uXG4gICAgICAgIHplcm9zICs9IDQ7XG4gICAgICAgIHggPSB4IDw8IDQ7XG4gICAgfVxuICAgIGlmICh4ID4+IDYgPT09IDApIHtcbiAgICAgICAgLy8gVGVzdCBpZiB0aGUgZmlyc3QgdHdvIChvciBuZXh0IHR3bykgYml0cyBhcmUgemVyby5cbiAgICAgICAgemVyb3MgKz0gMjtcbiAgICAgICAgeCA9IHggPDwgMjtcbiAgICB9XG4gICAgaWYgKHggPj4gNyA9PT0gMCkge1xuICAgICAgICAvLyBUZXN0IGlmIHRoZSByZW1haW5pbmcgYml0IGlzIHplcm8uXG4gICAgICAgIHplcm9zICs9IDE7XG4gICAgfVxuICAgIHJldHVybiB6ZXJvcztcbn1cbi8qKiBDb3VudHMgdGhlIG51bWJlciBvZiBsZWFkaW5nIHplcm9zIGluIHRoZSBnaXZlbiBieXRlIGFycmF5LiAqL1xuZnVuY3Rpb24gbnVtYmVyT2ZMZWFkaW5nWmVyb3MoYnl0ZXMpIHtcbiAgICBsZXQgbGVhZGluZ1plcm9zID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7ICsraSkge1xuICAgICAgICBjb25zdCB6ZXJvcyA9IG51bWJlck9mTGVhZGluZ1plcm9zSW5CeXRlKGJ5dGVzW2ldICYgMHhmZik7XG4gICAgICAgIGxlYWRpbmdaZXJvcyArPSB6ZXJvcztcbiAgICAgICAgaWYgKHplcm9zICE9PSA4KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVhZGluZ1plcm9zO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgcmVxdWlyZWQgdG8gc3RvcmUgXCJ2YWx1ZVwiLiBMZWFkaW5nIHplcm8gYnl0ZXNcbiAqIGFyZSBza2lwcGVkLlxuICovXG5mdW5jdGlvbiB1bnNpZ25lZE51bUxlbmd0aCh2YWx1ZSkge1xuICAgIC8vIFRoaXMgaXMganVzdCB0aGUgbnVtYmVyIG9mIGJ5dGVzIGZvciB0aGUgdW5zaWduZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIG51bWJlci5cbiAgICBjb25zdCBudW1CaXRzID0gTE9OR19TSVpFIC0gbnVtYmVyT2ZMZWFkaW5nWmVyb3ModmFsdWUpO1xuICAgIHJldHVybiBNYXRoLmNlaWwobnVtQml0cyAvIEJZVEVfU0laRSk7XG59XG4vKipcbiAqIE9yZGVyZWRDb2RlV3JpdGVyIGlzIGEgbWluaW1hbC1hbGxvY2F0aW9uIGltcGxlbWVudGF0aW9uIG9mIHRoZSB3cml0aW5nXG4gKiBiZWhhdmlvciBkZWZpbmVkIGJ5IHRoZSBiYWNrZW5kLlxuICpcbiAqIFRoZSBjb2RlIGlzIHBvcnRlZCBmcm9tIGl0cyBKYXZhIGNvdW50ZXJwYXJ0LlxuICovXG5jbGFzcyBPcmRlcmVkQ29kZVdyaXRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoREVGQVVMVF9CVUZGRVJfU0laRSk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSAwO1xuICAgIH1cbiAgICB3cml0ZUJ5dGVzQXNjZW5kaW5nKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGl0ID0gdmFsdWVbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgICBsZXQgYnl0ZSA9IGl0Lm5leHQoKTtcbiAgICAgICAgd2hpbGUgKCFieXRlLmRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlQXNjZW5kaW5nKGJ5dGUudmFsdWUpO1xuICAgICAgICAgICAgYnl0ZSA9IGl0Lm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlU2VwYXJhdG9yQXNjZW5kaW5nKCk7XG4gICAgfVxuICAgIHdyaXRlQnl0ZXNEZXNjZW5kaW5nKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGl0ID0gdmFsdWVbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgICBsZXQgYnl0ZSA9IGl0Lm5leHQoKTtcbiAgICAgICAgd2hpbGUgKCFieXRlLmRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZyhieXRlLnZhbHVlKTtcbiAgICAgICAgICAgIGJ5dGUgPSBpdC5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZVNlcGFyYXRvckRlc2NlbmRpbmcoKTtcbiAgICB9XG4gICAgLyoqIFdyaXRlcyB1dGY4IGJ5dGVzIGludG8gdGhpcyBieXRlIHNlcXVlbmNlLCBhc2NlbmRpbmcuICovXG4gICAgd3JpdGVVdGY4QXNjZW5kaW5nKHNlcXVlbmNlKSB7XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBzZXF1ZW5jZSkge1xuICAgICAgICAgICAgY29uc3QgY2hhckNvZGUgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoY2hhckNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhckNvZGUgPCAweDgwMCkge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlQXNjZW5kaW5nKCgweDBmIDw8IDYpIHwgKGNoYXJDb2RlID4+PiA2KSk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgY2hhckNvZGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPCBNSU5fU1VSUk9HQVRFIHx8IE1BWF9TVVJST0dBVEUgPCBjKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoKDB4MGYgPDwgNSkgfCAoY2hhckNvZGUgPj4+IDEyKSk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgKGNoYXJDb2RlID4+PiA2KSkpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlQXNjZW5kaW5nKDB4ODAgfCAoMHgzZiAmIGNoYXJDb2RlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlUG9pbnQgPSBjLmNvZGVQb2ludEF0KDApO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlQXNjZW5kaW5nKCgweDBmIDw8IDQpIHwgKGNvZGVQb2ludCA+Pj4gMTgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZUFzY2VuZGluZygweDgwIHwgKDB4M2YgJiAoY29kZVBvaW50ID4+PiAxMikpKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZUFzY2VuZGluZygweDgwIHwgKDB4M2YgJiAoY29kZVBvaW50ID4+PiA2KSkpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlQXNjZW5kaW5nKDB4ODAgfCAoMHgzZiAmIGNvZGVQb2ludCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGVTZXBhcmF0b3JBc2NlbmRpbmcoKTtcbiAgICB9XG4gICAgLyoqIFdyaXRlcyB1dGY4IGJ5dGVzIGludG8gdGhpcyBieXRlIHNlcXVlbmNlLCBkZXNjZW5kaW5nICovXG4gICAgd3JpdGVVdGY4RGVzY2VuZGluZyhzZXF1ZW5jZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGMgb2Ygc2VxdWVuY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXJDb2RlID0gYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMHg4MCkge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZyhjaGFyQ29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyQ29kZSA8IDB4ODAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVEZXNjZW5kaW5nKCgweDBmIDw8IDYpIHwgKGNoYXJDb2RlID4+PiA2KSk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVEZXNjZW5kaW5nKDB4ODAgfCAoMHgzZiAmIGNoYXJDb2RlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjIDwgTUlOX1NVUlJPR0FURSB8fCBNQVhfU1VSUk9HQVRFIDwgYykge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZygoMHgwZiA8PCA1KSB8IChjaGFyQ29kZSA+Pj4gMTIpKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZURlc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgKGNoYXJDb2RlID4+PiA2KSkpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZygweDgwIHwgKDB4M2YgJiBjaGFyQ29kZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZVBvaW50ID0gYy5jb2RlUG9pbnRBdCgwKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZURlc2NlbmRpbmcoKDB4MGYgPDwgNCkgfCAoY29kZVBvaW50ID4+PiAxOCkpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZygweDgwIHwgKDB4M2YgJiAoY29kZVBvaW50ID4+PiAxMikpKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZURlc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgKGNvZGVQb2ludCA+Pj4gNikpKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZURlc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgY29kZVBvaW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZVNlcGFyYXRvckRlc2NlbmRpbmcoKTtcbiAgICB9XG4gICAgd3JpdGVOdW1iZXJBc2NlbmRpbmcodmFsKSB7XG4gICAgICAgIC8vIFZhbHVlcyBhcmUgZW5jb2RlZCB3aXRoIGEgc2luZ2xlIGJ5dGUgbGVuZ3RoIHByZWZpeCwgZm9sbG93ZWQgYnkgdGhlXG4gICAgICAgIC8vIGFjdHVhbCB2YWx1ZSBpbiBiaWctZW5kaWFuIGZvcm1hdCB3aXRoIGxlYWRpbmcgMCBieXRlcyBkcm9wcGVkLlxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudG9PcmRlcmVkQml0cyh2YWwpO1xuICAgICAgICBjb25zdCBsZW4gPSB1bnNpZ25lZE51bUxlbmd0aCh2YWx1ZSk7XG4gICAgICAgIHRoaXMuZW5zdXJlQXZhaWxhYmxlKDEgKyBsZW4pO1xuICAgICAgICB0aGlzLmJ1ZmZlclt0aGlzLnBvc2l0aW9uKytdID0gbGVuICYgMHhmZjsgLy8gV3JpdGUgdGhlIGxlbmd0aFxuICAgICAgICBmb3IgKGxldCBpID0gdmFsdWUubGVuZ3RoIC0gbGVuOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb24rK10gPSB2YWx1ZVtpXSAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVOdW1iZXJEZXNjZW5kaW5nKHZhbCkge1xuICAgICAgICAvLyBWYWx1ZXMgYXJlIGVuY29kZWQgd2l0aCBhIHNpbmdsZSBieXRlIGxlbmd0aCBwcmVmaXgsIGZvbGxvd2VkIGJ5IHRoZVxuICAgICAgICAvLyBpbnZlcnRlZCB2YWx1ZSBpbiBiaWctZW5kaWFuIGZvcm1hdCB3aXRoIGxlYWRpbmcgMCBieXRlcyBkcm9wcGVkLlxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudG9PcmRlcmVkQml0cyh2YWwpO1xuICAgICAgICBjb25zdCBsZW4gPSB1bnNpZ25lZE51bUxlbmd0aCh2YWx1ZSk7XG4gICAgICAgIHRoaXMuZW5zdXJlQXZhaWxhYmxlKDEgKyBsZW4pO1xuICAgICAgICB0aGlzLmJ1ZmZlclt0aGlzLnBvc2l0aW9uKytdID0gfihsZW4gJiAweGZmKTsgLy8gV3JpdGUgdGhlIGxlbmd0aFxuICAgICAgICBmb3IgKGxldCBpID0gdmFsdWUubGVuZ3RoIC0gbGVuOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb24rK10gPSB+KHZhbHVlW2ldICYgMHhmZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIHRoZSBcImluZmluaXR5XCIgYnl0ZSBzZXF1ZW5jZSB0aGF0IHNvcnRzIGFmdGVyIGFsbCBvdGhlciBieXRlXG4gICAgICogc2VxdWVuY2VzIHdyaXR0ZW4gaW4gYXNjZW5kaW5nIG9yZGVyLlxuICAgICAqL1xuICAgIHdyaXRlSW5maW5pdHlBc2NlbmRpbmcoKSB7XG4gICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZUFzY2VuZGluZyhFU0NBUEUyKTtcbiAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlQXNjZW5kaW5nKElORklOSVRZKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIHRoZSBcImluZmluaXR5XCIgYnl0ZSBzZXF1ZW5jZSB0aGF0IHNvcnRzIGJlZm9yZSBhbGwgb3RoZXIgYnl0ZVxuICAgICAqIHNlcXVlbmNlcyB3cml0dGVuIGluIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAgICovXG4gICAgd3JpdGVJbmZpbml0eURlc2NlbmRpbmcoKSB7XG4gICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoRVNDQVBFMik7XG4gICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoSU5GSU5JVFkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGJ1ZmZlciBzdWNoIHRoYXQgaXQgaXMgdGhlIHNhbWUgYXMgd2hlbiBpdCB3YXMgbmV3bHlcbiAgICAgKiBjb25zdHJ1Y3RlZC5cbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDA7XG4gICAgfVxuICAgIHNlZWQoZW5jb2RlZEJ5dGVzKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlQXZhaWxhYmxlKGVuY29kZWRCeXRlcy5sZW5ndGgpO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zZXQoZW5jb2RlZEJ5dGVzLCB0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBlbmNvZGVkQnl0ZXMubGVuZ3RoO1xuICAgIH1cbiAgICAvKiogTWFrZXMgYSBjb3B5IG9mIHRoZSBlbmNvZGVkIGJ5dGVzIGluIHRoaXMgYnVmZmVyLiAgKi9cbiAgICBlbmNvZGVkQnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5zbGljZSgwLCB0aGlzLnBvc2l0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlcyBgdmFsYCBpbnRvIGFuIGVuY29kaW5nIHNvIHRoYXQgdGhlIG9yZGVyIG1hdGNoZXMgdGhlIElFRUUgNzU0XG4gICAgICogZmxvYXRpbmctcG9pbnQgY29tcGFyaXNvbiByZXN1bHRzIHdpdGggdGhlIGZvbGxvd2luZyBleGNlcHRpb25zOlxuICAgICAqICAgLTAuMCA8IDAuMFxuICAgICAqICAgYWxsIG5vbi1OYU4gPCBOYU5cbiAgICAgKiAgIE5hTiA9IE5hTlxuICAgICAqL1xuICAgIHRvT3JkZXJlZEJpdHModmFsKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZG91YmxlVG9Mb25nQml0cyh2YWwpO1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgZmlyc3QgYml0IGlzIHNldC4gV2UgdXNlIGEgYml0IG1hc2sgc2luY2UgdmFsdWVbMF0gaXNcbiAgICAgICAgLy8gZW5jb2RlZCBhcyBhIG51bWJlciBmcm9tIDAgdG8gMjU1LlxuICAgICAgICBjb25zdCBpc05lZ2F0aXZlID0gKHZhbHVlWzBdICYgMHg4MCkgIT09IDA7XG4gICAgICAgIC8vIFJldmVydCB0aGUgdHdvIGNvbXBsZW1lbnQgdG8gZ2V0IG5hdHVyYWwgb3JkZXJpbmdcbiAgICAgICAgdmFsdWVbMF0gXj0gaXNOZWdhdGl2ZSA/IDB4ZmYgOiAweDgwO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YWx1ZVtpXSBePSBpc05lZ2F0aXZlID8gMHhmZiA6IDB4MDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvKiogV3JpdGVzIGEgc2luZ2xlIGJ5dGUgYXNjZW5kaW5nIHRvIHRoZSBidWZmZXIuICovXG4gICAgd3JpdGVCeXRlQXNjZW5kaW5nKGIpIHtcbiAgICAgICAgY29uc3QgbWFza2VkID0gYiAmIDB4ZmY7XG4gICAgICAgIGlmIChtYXNrZWQgPT09IEVTQ0FQRTEpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZUFzY2VuZGluZyhFU0NBUEUxKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZUFzY2VuZGluZyhOVUxMX0JZVEUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hc2tlZCA9PT0gRVNDQVBFMikge1xuICAgICAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlQXNjZW5kaW5nKEVTQ0FQRTIpO1xuICAgICAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlQXNjZW5kaW5nKEZGX0JZVEUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlQXNjZW5kaW5nKG1hc2tlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFdyaXRlcyBhIHNpbmdsZSBieXRlIGRlc2NlbmRpbmcgdG8gdGhlIGJ1ZmZlci4gICovXG4gICAgd3JpdGVCeXRlRGVzY2VuZGluZyhiKSB7XG4gICAgICAgIGNvbnN0IG1hc2tlZCA9IGIgJiAweGZmO1xuICAgICAgICBpZiAobWFza2VkID09PSBFU0NBUEUxKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVEZXNjZW5kaW5nKEVTQ0FQRTEpO1xuICAgICAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlRGVzY2VuZGluZyhOVUxMX0JZVEUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hc2tlZCA9PT0gRVNDQVBFMikge1xuICAgICAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlRGVzY2VuZGluZyhFU0NBUEUyKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoRkZfQllURSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVEZXNjZW5kaW5nKGIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdyaXRlU2VwYXJhdG9yQXNjZW5kaW5nKCkge1xuICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVBc2NlbmRpbmcoRVNDQVBFMSk7XG4gICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZUFzY2VuZGluZyhTRVBBUkFUT1IpO1xuICAgIH1cbiAgICB3cml0ZVNlcGFyYXRvckRlc2NlbmRpbmcoKSB7XG4gICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoRVNDQVBFMSk7XG4gICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoU0VQQVJBVE9SKTtcbiAgICB9XG4gICAgd3JpdGVFc2NhcGVkQnl0ZUFzY2VuZGluZyhiKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlQXZhaWxhYmxlKDEpO1xuICAgICAgICB0aGlzLmJ1ZmZlclt0aGlzLnBvc2l0aW9uKytdID0gYjtcbiAgICB9XG4gICAgd3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoYikge1xuICAgICAgICB0aGlzLmVuc3VyZUF2YWlsYWJsZSgxKTtcbiAgICAgICAgdGhpcy5idWZmZXJbdGhpcy5wb3NpdGlvbisrXSA9IH5iO1xuICAgIH1cbiAgICBlbnN1cmVBdmFpbGFibGUoYnl0ZXMpIHtcbiAgICAgICAgY29uc3QgbWluQ2FwYWNpdHkgPSBieXRlcyArIHRoaXMucG9zaXRpb247XG4gICAgICAgIGlmIChtaW5DYXBhY2l0eSA8PSB0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgZG91YmxpbmcuXG4gICAgICAgIGxldCBuZXdMZW5ndGggPSB0aGlzLmJ1ZmZlci5sZW5ndGggKiAyO1xuICAgICAgICAvLyBTdGlsbCBub3QgYmlnIGVub3VnaD8gSnVzdCBhbGxvY2F0ZSB0aGUgcmlnaHQgc2l6ZS5cbiAgICAgICAgaWYgKG5ld0xlbmd0aCA8IG1pbkNhcGFjaXR5KSB7XG4gICAgICAgICAgICBuZXdMZW5ndGggPSBtaW5DYXBhY2l0eTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgdGhlIG5ldyBidWZmZXIuXG4gICAgICAgIGNvbnN0IG5ld0J1ZmZlciA9IG5ldyBVaW50OEFycmF5KG5ld0xlbmd0aCk7XG4gICAgICAgIG5ld0J1ZmZlci5zZXQodGhpcy5idWZmZXIpOyAvLyBjb3B5IG9sZCBkYXRhXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3QnVmZmVyO1xuICAgIH1cbn1cblxuY2xhc3MgQXNjZW5kaW5nSW5kZXhCeXRlRW5jb2RlciB7XG4gICAgY29uc3RydWN0b3Iob3JkZXJlZENvZGUpIHtcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZSA9IG9yZGVyZWRDb2RlO1xuICAgIH1cbiAgICB3cml0ZUJ5dGVzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMub3JkZXJlZENvZGUud3JpdGVCeXRlc0FzY2VuZGluZyh2YWx1ZSk7XG4gICAgfVxuICAgIHdyaXRlU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHRoaXMub3JkZXJlZENvZGUud3JpdGVVdGY4QXNjZW5kaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgd3JpdGVOdW1iZXIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS53cml0ZU51bWJlckFzY2VuZGluZyh2YWx1ZSk7XG4gICAgfVxuICAgIHdyaXRlSW5maW5pdHkoKSB7XG4gICAgICAgIHRoaXMub3JkZXJlZENvZGUud3JpdGVJbmZpbml0eUFzY2VuZGluZygpO1xuICAgIH1cbn1cbmNsYXNzIERlc2NlbmRpbmdJbmRleEJ5dGVFbmNvZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcmRlcmVkQ29kZSkge1xuICAgICAgICB0aGlzLm9yZGVyZWRDb2RlID0gb3JkZXJlZENvZGU7XG4gICAgfVxuICAgIHdyaXRlQnl0ZXModmFsdWUpIHtcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS53cml0ZUJ5dGVzRGVzY2VuZGluZyh2YWx1ZSk7XG4gICAgfVxuICAgIHdyaXRlU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHRoaXMub3JkZXJlZENvZGUud3JpdGVVdGY4RGVzY2VuZGluZyh2YWx1ZSk7XG4gICAgfVxuICAgIHdyaXRlTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMub3JkZXJlZENvZGUud3JpdGVOdW1iZXJEZXNjZW5kaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgd3JpdGVJbmZpbml0eSgpIHtcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS53cml0ZUluZmluaXR5RGVzY2VuZGluZygpO1xuICAgIH1cbn1cbi8qKlxuICogSW1wbGVtZW50cyBgRGlyZWN0aW9uYWxJbmRleEJ5dGVFbmNvZGVyYCB1c2luZyBgT3JkZXJlZENvZGVXcml0ZXJgIGZvciB0aGVcbiAqIGFjdHVhbCBlbmNvZGluZy5cbiAqL1xuY2xhc3MgSW5kZXhCeXRlRW5jb2RlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMub3JkZXJlZENvZGUgPSBuZXcgT3JkZXJlZENvZGVXcml0ZXIoKTtcbiAgICAgICAgdGhpcy5hc2NlbmRpbmcgPSBuZXcgQXNjZW5kaW5nSW5kZXhCeXRlRW5jb2Rlcih0aGlzLm9yZGVyZWRDb2RlKTtcbiAgICAgICAgdGhpcy5kZXNjZW5kaW5nID0gbmV3IERlc2NlbmRpbmdJbmRleEJ5dGVFbmNvZGVyKHRoaXMub3JkZXJlZENvZGUpO1xuICAgIH1cbiAgICBzZWVkKGVuY29kZWRCeXRlcykge1xuICAgICAgICB0aGlzLm9yZGVyZWRDb2RlLnNlZWQoZW5jb2RlZEJ5dGVzKTtcbiAgICB9XG4gICAgZm9yS2luZChraW5kKSB7XG4gICAgICAgIHJldHVybiBraW5kID09PSAwIC8qIEluZGV4S2luZC5BU0NFTkRJTkcgKi8gPyB0aGlzLmFzY2VuZGluZyA6IHRoaXMuZGVzY2VuZGluZztcbiAgICB9XG4gICAgZW5jb2RlZEJ5dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmRlcmVkQ29kZS5lbmNvZGVkQnl0ZXMoKTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMub3JkZXJlZENvZGUucmVzZXQoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogUmVwcmVzZW50cyBhbiBpbmRleCBlbnRyeSBzYXZlZCBieSB0aGUgU0RLIGluIHBlcnNpc3RlZCBzdG9yYWdlLiAqL1xuY2xhc3MgSW5kZXhFbnRyeSB7XG4gICAgY29uc3RydWN0b3IoaW5kZXhJZCwgZG9jdW1lbnRLZXksIGFycmF5VmFsdWUsIGRpcmVjdGlvbmFsVmFsdWUpIHtcbiAgICAgICAgdGhpcy5pbmRleElkID0gaW5kZXhJZDtcbiAgICAgICAgdGhpcy5kb2N1bWVudEtleSA9IGRvY3VtZW50S2V5O1xuICAgICAgICB0aGlzLmFycmF5VmFsdWUgPSBhcnJheVZhbHVlO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbmFsVmFsdWUgPSBkaXJlY3Rpb25hbFZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIEluZGV4RW50cnkgZW50cnkgdGhhdCBzb3J0cyBpbW1lZGlhdGVseSBhZnRlciB0aGUgY3VycmVudFxuICAgICAqIGRpcmVjdGlvbmFsIHZhbHVlLlxuICAgICAqL1xuICAgIHN1Y2Nlc3NvcigpIHtcbiAgICAgICAgY29uc3QgY3VycmVudExlbmd0aCA9IHRoaXMuZGlyZWN0aW9uYWxWYWx1ZS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG5ld0xlbmd0aCA9IGN1cnJlbnRMZW5ndGggPT09IDAgfHwgdGhpcy5kaXJlY3Rpb25hbFZhbHVlW2N1cnJlbnRMZW5ndGggLSAxXSA9PT0gMjU1XG4gICAgICAgICAgICA/IGN1cnJlbnRMZW5ndGggKyAxXG4gICAgICAgICAgICA6IGN1cnJlbnRMZW5ndGg7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NvciA9IG5ldyBVaW50OEFycmF5KG5ld0xlbmd0aCk7XG4gICAgICAgIHN1Y2Nlc3Nvci5zZXQodGhpcy5kaXJlY3Rpb25hbFZhbHVlLCAwKTtcbiAgICAgICAgaWYgKG5ld0xlbmd0aCAhPT0gY3VycmVudExlbmd0aCkge1xuICAgICAgICAgICAgc3VjY2Vzc29yLnNldChbMF0sIHRoaXMuZGlyZWN0aW9uYWxWYWx1ZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKytzdWNjZXNzb3Jbc3VjY2Vzc29yLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhFbnRyeSh0aGlzLmluZGV4SWQsIHRoaXMuZG9jdW1lbnRLZXksIHRoaXMuYXJyYXlWYWx1ZSwgc3VjY2Vzc29yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbmRleEVudHJ5Q29tcGFyYXRvcihsZWZ0LCByaWdodCkge1xuICAgIGxldCBjbXAgPSBsZWZ0LmluZGV4SWQgLSByaWdodC5pbmRleElkO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG4gICAgY21wID0gY29tcGFyZUJ5dGVBcnJheXMobGVmdC5hcnJheVZhbHVlLCByaWdodC5hcnJheVZhbHVlKTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuICAgIGNtcCA9IGNvbXBhcmVCeXRlQXJyYXlzKGxlZnQuZGlyZWN0aW9uYWxWYWx1ZSwgcmlnaHQuZGlyZWN0aW9uYWxWYWx1ZSk7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gY21wO1xuICAgIH1cbiAgICByZXR1cm4gRG9jdW1lbnRLZXkuY29tcGFyYXRvcihsZWZ0LmRvY3VtZW50S2V5LCByaWdodC5kb2N1bWVudEtleSk7XG59XG5mdW5jdGlvbiBjb21wYXJlQnl0ZUFycmF5cyhsZWZ0LCByaWdodCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdC5sZW5ndGggJiYgaSA8IHJpZ2h0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGNvbXBhcmUgPSBsZWZ0W2ldIC0gcmlnaHRbaV07XG4gICAgICAgIGlmIChjb21wYXJlICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVmdC5sZW5ndGggLSByaWdodC5sZW5ndGg7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEEgbGlnaHQgcXVlcnkgcGxhbm5lciBmb3IgRmlyZXN0b3JlLlxuICpcbiAqIFRoaXMgY2xhc3MgbWF0Y2hlcyBhIGBGaWVsZEluZGV4YCBhZ2FpbnN0IGEgRmlyZXN0b3JlIFF1ZXJ5IGBUYXJnZXRgLiBJdFxuICogZGV0ZXJtaW5lcyB3aGV0aGVyIGEgZ2l2ZW4gaW5kZXggY2FuIGJlIHVzZWQgdG8gc2VydmUgdGhlIHNwZWNpZmllZCB0YXJnZXQuXG4gKlxuICogVGhlIGZvbGxvd2luZyB0YWJsZSBzaG93Y2FzZXMgc29tZSBwb3NzaWJsZSBpbmRleCBjb25maWd1cmF0aW9uczpcbiAqXG4gKiBRdWVyeSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBJbmRleFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIHdoZXJlKCdhJywgJz09JywgJ2EnKS53aGVyZSgnYicsICc9PScsICdiJykgICAgICAgICB8IGEgQVNDLCBiIERFU0NcbiAqIHdoZXJlKCdhJywgJz09JywgJ2EnKS53aGVyZSgnYicsICc9PScsICdiJykgICAgICAgICB8IGEgQVNDXG4gKiB3aGVyZSgnYScsICc9PScsICdhJykud2hlcmUoJ2InLCAnPT0nLCAnYicpICAgICAgICAgfCBiIERFU0NcbiAqIHdoZXJlKCdhJywgJz49JywgJ2EnKS5vcmRlckJ5KCdhJykgICAgICAgICAgICAgICAgICB8IGEgQVNDXG4gKiB3aGVyZSgnYScsICc+PScsICdhJykub3JkZXJCeSgnYScsICdkZXNjJykgICAgICAgICAgfCBhIERFU0NcbiAqIHdoZXJlKCdhJywgJz49JywgJ2EnKS5vcmRlckJ5KCdhJykub3JkZXJCeSgnYicpICAgICB8IGEgQVNDLCBiIEFTQ1xuICogd2hlcmUoJ2EnLCAnPj0nLCAnYScpLm9yZGVyQnkoJ2EnKS5vcmRlckJ5KCdiJykgICAgIHwgYSBBU0NcbiAqIHdoZXJlKCdhJywgJ2FycmF5LWNvbnRhaW5zJywgJ2EnKS5vcmRlckJ5KCdiJykgICAgICB8IGEgQ09OVEFJTlMsIGIgQVNDRU5ESU5HXG4gKiB3aGVyZSgnYScsICdhcnJheS1jb250YWlucycsICdhJykub3JkZXJCeSgnYicpICAgICAgfCBhIENPTlRBSU5TXG4gKi9cbmNsYXNzIFRhcmdldEluZGV4TWF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XG4gICAgICAgIC8vIFRoZSBpbmVxdWFsaXR5IGZpbHRlcnMgb2YgdGhlIHRhcmdldCAoaWYgaXQgZXhpc3RzKS5cbiAgICAgICAgLy8gTm90ZTogVGhlIHNvcnQgb24gRmllbGRGaWx0ZXJzIGlzIG5vdCByZXF1aXJlZC4gVXNpbmcgU29ydGVkU2V0IGhlcmUganVzdCB0byB1dGlsaXplIHRoZSBjdXN0b21cbiAgICAgICAgLy8gY29tcGFyYXRvci5cbiAgICAgICAgdGhpcy5pbmVxdWFsaXR5RmlsdGVycyA9IG5ldyBTb3J0ZWRTZXQoKGxocywgcmhzKSA9PiBGaWVsZFBhdGgkMS5jb21wYXJhdG9yKGxocy5maWVsZCwgcmhzLmZpZWxkKSk7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbklkID1cbiAgICAgICAgICAgIHRhcmdldC5jb2xsZWN0aW9uR3JvdXAgIT0gbnVsbFxuICAgICAgICAgICAgICAgID8gdGFyZ2V0LmNvbGxlY3Rpb25Hcm91cFxuICAgICAgICAgICAgICAgIDogdGFyZ2V0LnBhdGgubGFzdFNlZ21lbnQoKTtcbiAgICAgICAgdGhpcy5vcmRlckJ5cyA9IHRhcmdldC5vcmRlckJ5O1xuICAgICAgICB0aGlzLmVxdWFsaXR5RmlsdGVycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiB0YXJnZXQuZmlsdGVycykge1xuICAgICAgICAgICAgY29uc3QgZmllbGRGaWx0ZXIgPSBmaWx0ZXI7XG4gICAgICAgICAgICBpZiAoZmllbGRGaWx0ZXIuaXNJbmVxdWFsaXR5KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZXF1YWxpdHlGaWx0ZXJzID0gdGhpcy5pbmVxdWFsaXR5RmlsdGVycy5hZGQoZmllbGRGaWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcXVhbGl0eUZpbHRlcnMucHVzaChmaWVsZEZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGhhc011bHRpcGxlSW5lcXVhbGl0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5lcXVhbGl0eUZpbHRlcnMuc2l6ZSA+IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgaW5kZXggY2FuIGJlIHVzZWQgdG8gc2VydmUgdGhlIFRhcmdldEluZGV4TWF0Y2hlcidzXG4gICAgICogdGFyZ2V0LlxuICAgICAqXG4gICAgICogQW4gaW5kZXggaXMgY29uc2lkZXJlZCBjYXBhYmxlIG9mIHNlcnZpbmcgdGhlIHRhcmdldCB3aGVuOlxuICAgICAqIC0gVGhlIHRhcmdldCB1c2VzIGFsbCBpbmRleCBzZWdtZW50cyBmb3IgaXRzIGZpbHRlcnMgYW5kIG9yZGVyQnkgY2xhdXNlcy5cbiAgICAgKiAgIFRoZSB0YXJnZXQgY2FuIGhhdmUgYWRkaXRpb25hbCBmaWx0ZXIgYW5kIG9yZGVyQnkgY2xhdXNlcywgYnV0IG5vdFxuICAgICAqICAgZmV3ZXIuXG4gICAgICogLSBJZiBhbiBBcnJheUNvbnRhaW5zL0FycmF5Q29udGFpbnNBbnlmaWx0ZXIgaXMgdXNlZCwgdGhlIGluZGV4IG11c3QgYWxzb1xuICAgICAqICAgaGF2ZSBhIGNvcnJlc3BvbmRpbmcgYENPTlRBSU5TYCBzZWdtZW50LlxuICAgICAqIC0gQWxsIGRpcmVjdGlvbmFsIGluZGV4IHNlZ21lbnRzIGNhbiBiZSBtYXBwZWQgdG8gdGhlIHRhcmdldCBhcyBhIHNlcmllcyBvZlxuICAgICAqICAgZXF1YWxpdHkgZmlsdGVycywgYSBzaW5nbGUgaW5lcXVhbGl0eSBmaWx0ZXIgYW5kIGEgc2VyaWVzIG9mIG9yZGVyQnlcbiAgICAgKiAgIGNsYXVzZXMuXG4gICAgICogLSBUaGUgc2VnbWVudHMgdGhhdCByZXByZXNlbnQgdGhlIGVxdWFsaXR5IGZpbHRlcnMgbWF5IGFwcGVhciBvdXQgb2Ygb3JkZXIuXG4gICAgICogLSBUaGUgb3B0aW9uYWwgc2VnbWVudCBmb3IgdGhlIGluZXF1YWxpdHkgZmlsdGVyIG11c3QgYXBwZWFyIGFmdGVyIGFsbFxuICAgICAqICAgZXF1YWxpdHkgc2VnbWVudHMuXG4gICAgICogLSBUaGUgc2VnbWVudHMgdGhhdCByZXByZXNlbnQgdGhhdCBvcmRlckJ5IGNsYXVzZSBvZiB0aGUgdGFyZ2V0IG11c3QgYXBwZWFyXG4gICAgICogICBpbiBvcmRlciBhZnRlciBhbGwgZXF1YWxpdHkgYW5kIGluZXF1YWxpdHkgc2VnbWVudHMuIFNpbmdsZSBvcmRlckJ5XG4gICAgICogICBjbGF1c2VzIGNhbm5vdCBiZSBza2lwcGVkLCBidXQgYSBjb250aW51b3VzIG9yZGVyQnkgc3VmZml4IG1heSBiZVxuICAgICAqICAgb21pdHRlZC5cbiAgICAgKi9cbiAgICBzZXJ2ZWRCeUluZGV4KGluZGV4KSB7XG4gICAgICAgIGhhcmRBc3NlcnQoaW5kZXguY29sbGVjdGlvbkdyb3VwID09PSB0aGlzLmNvbGxlY3Rpb25JZCk7XG4gICAgICAgIGlmICh0aGlzLmhhc011bHRpcGxlSW5lcXVhbGl0eSkge1xuICAgICAgICAgICAgLy8gT25seSBzaW5nbGUgaW5lcXVhbGl0eSBpcyBzdXBwb3J0ZWQgZm9yIG5vdy5cbiAgICAgICAgICAgIC8vIFRPRE8oQWRkIHN1cHBvcnQgZm9yIG11bHRpcGxlIGluZXF1YWxpdHkgcXVlcnkpOiBiLzI5ODQ0MTA0M1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGFycmF5IGVsZW1lbnQsIGZpbmQgYSBtYXRjaGluZyBmaWx0ZXIuXG4gICAgICAgIGNvbnN0IGFycmF5U2VnbWVudCA9IGZpZWxkSW5kZXhHZXRBcnJheVNlZ21lbnQoaW5kZXgpO1xuICAgICAgICBpZiAoYXJyYXlTZWdtZW50ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICF0aGlzLmhhc01hdGNoaW5nRXF1YWxpdHlGaWx0ZXIoYXJyYXlTZWdtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gZmllbGRJbmRleEdldERpcmVjdGlvbmFsU2VnbWVudHMoaW5kZXgpO1xuICAgICAgICBsZXQgZXF1YWxpdHlTZWdtZW50cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgbGV0IHNlZ21lbnRJbmRleCA9IDA7XG4gICAgICAgIGxldCBvcmRlckJ5c0luZGV4ID0gMDtcbiAgICAgICAgLy8gUHJvY2VzcyBhbGwgZXF1YWxpdGllcyBmaXJzdC4gRXF1YWxpdGllcyBjYW4gYXBwZWFyIG91dCBvZiBvcmRlci5cbiAgICAgICAgZm9yICg7IHNlZ21lbnRJbmRleCA8IHNlZ21lbnRzLmxlbmd0aDsgKytzZWdtZW50SW5kZXgpIHtcbiAgICAgICAgICAgIC8vIFdlIGF0dGVtcHQgdG8gZ3JlZWRpbHkgbWF0Y2ggYWxsIHNlZ21lbnRzIHRvIGVxdWFsaXR5IGZpbHRlcnMuIElmIGFcbiAgICAgICAgICAgIC8vIGZpbHRlciBtYXRjaGVzIGFuIGluZGV4IHNlZ21lbnQsIHdlIGNhbiBtYXJrIHRoZSBzZWdtZW50IGFzIHVzZWQuXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNNYXRjaGluZ0VxdWFsaXR5RmlsdGVyKHNlZ21lbnRzW3NlZ21lbnRJbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgZXF1YWxpdHlTZWdtZW50cyA9IGVxdWFsaXR5U2VnbWVudHMuYWRkKHNlZ21lbnRzW3NlZ21lbnRJbmRleF0uZmllbGRQYXRoLmNhbm9uaWNhbFN0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGNhbm5vdCBmaW5kIGEgbWF0Y2hpbmcgZmlsdGVyLCB3ZSBuZWVkIHRvIHZlcmlmeSB3aGV0aGVyIHRoZVxuICAgICAgICAgICAgICAgIC8vIHJlbWFpbmluZyBzZWdtZW50cyBtYXAgdG8gdGhlIHRhcmdldCdzIGluZXF1YWxpdHkgYW5kIGl0cyBvcmRlckJ5XG4gICAgICAgICAgICAgICAgLy8gY2xhdXNlcy5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgcHJvY2Vzc2VkIGFsbCBzZWdtZW50cywgYWxsIHNlZ21lbnRzIGFyZSB1c2VkIHRvIHNlcnZlXG4gICAgICAgIC8vIHRoZSBlcXVhbGl0eSBmaWx0ZXJzIGFuZCB3ZSBkbyBub3QgbmVlZCB0byBtYXAgYW55IHNlZ21lbnRzIHRvIHRoZVxuICAgICAgICAvLyB0YXJnZXQncyBpbmVxdWFsaXR5IGFuZCBvcmRlckJ5IGNsYXVzZXMuXG4gICAgICAgIGlmIChzZWdtZW50SW5kZXggPT09IHNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5lcXVhbGl0eUZpbHRlcnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIC8vIE9ubHkgYSBzaW5nbGUgaW5lcXVhbGl0eSBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLiBHZXQgdGhlIG9ubHkgZW50cnkgaW4gdGhlIHNldC5cbiAgICAgICAgICAgIGNvbnN0IGluZXF1YWxpdHlGaWx0ZXIgPSB0aGlzLmluZXF1YWxpdHlGaWx0ZXJzLmdldEl0ZXJhdG9yKCkuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gaW5lcXVhbGl0eSBmaWx0ZXIgYW5kIHRoZSBmaWVsZCB3YXMgbm90IGluIG9uZSBvZiB0aGVcbiAgICAgICAgICAgIC8vIGVxdWFsaXR5IGZpbHRlcnMgYWJvdmUsIHRoZSBuZXh0IHNlZ21lbnQgbXVzdCBtYXRjaCBib3RoIHRoZSBmaWx0ZXJcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgZmlyc3Qgb3JkZXJCeSBjbGF1c2UuXG4gICAgICAgICAgICBpZiAoIWVxdWFsaXR5U2VnbWVudHMuaGFzKGluZXF1YWxpdHlGaWx0ZXIuZmllbGQuY2Fub25pY2FsU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW3NlZ21lbnRJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoZXNGaWx0ZXIoaW5lcXVhbGl0eUZpbHRlciwgc2VnbWVudCkgfHxcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMubWF0Y2hlc09yZGVyQnkodGhpcy5vcmRlckJ5c1tvcmRlckJ5c0luZGV4KytdLCBzZWdtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytzZWdtZW50SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWxsIHJlbWFpbmluZyBzZWdtZW50cyBuZWVkIHRvIHJlcHJlc2VudCB0aGUgcHJlZml4IG9mIHRoZSB0YXJnZXQnc1xuICAgICAgICAvLyBvcmRlckJ5LlxuICAgICAgICBmb3IgKDsgc2VnbWVudEluZGV4IDwgc2VnbWVudHMubGVuZ3RoOyArK3NlZ21lbnRJbmRleCkge1xuICAgICAgICAgICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW3NlZ21lbnRJbmRleF07XG4gICAgICAgICAgICBpZiAob3JkZXJCeXNJbmRleCA+PSB0aGlzLm9yZGVyQnlzLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgICF0aGlzLm1hdGNoZXNPcmRlckJ5KHRoaXMub3JkZXJCeXNbb3JkZXJCeXNJbmRleCsrXSwgc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmdWxsIG1hdGNoZWQgZmllbGQgaW5kZXggZm9yIHRoaXMgdGFyZ2V0LiBDdXJyZW50bHkgbXVsdGlwbGVcbiAgICAgKiBpbmVxdWFsaXR5IHF1ZXJ5IGlzIG5vdCBzdXBwb3J0ZWQgc28gZnVuY3Rpb24gcmV0dXJucyBudWxsLlxuICAgICAqL1xuICAgIGJ1aWxkVGFyZ2V0SW5kZXgoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc011bHRpcGxlSW5lcXVhbGl0eSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2Ugd2FudCB0byBtYWtlIHN1cmUgb25seSBvbmUgc2VnbWVudCBjcmVhdGVkIGZvciBvbmUgZmllbGQuIEZvciBleGFtcGxlLFxuICAgICAgICAvLyBpbiBjYXNlIGxpa2UgYSA9PSAzIGFuZCBhID4gMiwgSW5kZXgge2EgQVNDRU5ESU5HfSB3aWxsIG9ubHkgYmUgY3JlYXRlZFxuICAgICAgICAvLyBvbmNlLlxuICAgICAgICBsZXQgdW5pcXVlRmllbGRzID0gbmV3IFNvcnRlZFNldChGaWVsZFBhdGgkMS5jb21wYXJhdG9yKTtcbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgdGhpcy5lcXVhbGl0eUZpbHRlcnMpIHtcbiAgICAgICAgICAgIGlmIChmaWx0ZXIuZmllbGQuaXNLZXlGaWVsZCgpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpc0FycmF5T3BlcmF0b3IgPSBmaWx0ZXIub3AgPT09IFwiYXJyYXktY29udGFpbnNcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOUyAqLyB8fFxuICAgICAgICAgICAgICAgIGZpbHRlci5vcCA9PT0gXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi87XG4gICAgICAgICAgICBpZiAoaXNBcnJheU9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChuZXcgSW5kZXhTZWdtZW50KGZpbHRlci5maWVsZCwgMiAvKiBJbmRleEtpbmQuQ09OVEFJTlMgKi8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh1bmlxdWVGaWVsZHMuaGFzKGZpbHRlci5maWVsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVuaXF1ZUZpZWxkcyA9IHVuaXF1ZUZpZWxkcy5hZGQoZmlsdGVyLmZpZWxkKTtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKG5ldyBJbmRleFNlZ21lbnQoZmlsdGVyLmZpZWxkLCAwIC8qIEluZGV4S2luZC5BU0NFTkRJTkcgKi8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiBXZSBkbyBub3QgZXhwbGljaXRseSBjaGVjayBgdGhpcy5pbmVxdWFsaXR5RmlsdGVyYCBidXQgcmF0aGVyIHJlbHlcbiAgICAgICAgLy8gb24gdGhlIHRhcmdldCBkZWZpbmluZyBhbiBhcHByb3ByaWF0ZSBcIm9yZGVyIGJ5XCIgdG8gZW5zdXJlIHRoYXQgdGhlXG4gICAgICAgIC8vIHJlcXVpcmVkIGluZGV4IHNlZ21lbnQgaXMgYWRkZWQuIFRoZSBxdWVyeSBlbmdpbmUgd291bGQgcmVqZWN0IGEgcXVlcnlcbiAgICAgICAgLy8gd2l0aCBhbiBpbmVxdWFsaXR5IGZpbHRlciB0aGF0IGxhY2tzIHRoZSByZXF1aXJlZCBvcmRlci1ieSBjbGF1c2UuXG4gICAgICAgIGZvciAoY29uc3Qgb3JkZXJCeSBvZiB0aGlzLm9yZGVyQnlzKSB7XG4gICAgICAgICAgICAvLyBTdG9wIGFkZGluZyBtb3JlIHNlZ21lbnRzIGlmIHdlIHNlZSBhIG9yZGVyLWJ5IG9uIGtleS4gVHlwaWNhbGx5IHRoaXNcbiAgICAgICAgICAgIC8vIGlzIHRoZSBkZWZhdWx0IGltcGxpY2l0IG9yZGVyLWJ5IHdoaWNoIGlzIGNvdmVyZWQgaW4gdGhlIGluZGV4X2VudHJ5XG4gICAgICAgICAgICAvLyB0YWJsZSBhcyBhIHNlcGFyYXRlIGNvbHVtbi4gSWYgaXQgaXMgbm90IHRoZSBkZWZhdWx0IG9yZGVyLWJ5LCB0aGVcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlZCBpbmRleCB3aWxsIGJlIG1pc3Npbmcgc29tZSBzZWdtZW50cyBvcHRpbWl6ZWQgZm9yIG9yZGVyLWJ5cyxcbiAgICAgICAgICAgIC8vIHdoaWNoIGlzIHByb2JhYmx5IGZpbmUuXG4gICAgICAgICAgICBpZiAob3JkZXJCeS5maWVsZC5pc0tleUZpZWxkKCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bmlxdWVGaWVsZHMuaGFzKG9yZGVyQnkuZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bmlxdWVGaWVsZHMgPSB1bmlxdWVGaWVsZHMuYWRkKG9yZGVyQnkuZmllbGQpO1xuICAgICAgICAgICAgc2VnbWVudHMucHVzaChuZXcgSW5kZXhTZWdtZW50KG9yZGVyQnkuZmllbGQsIG9yZGVyQnkuZGlyID09PSBcImFzY1wiIC8qIERpcmVjdGlvbi5BU0NFTkRJTkcgKi9cbiAgICAgICAgICAgICAgICA/IDAgLyogSW5kZXhLaW5kLkFTQ0VORElORyAqL1xuICAgICAgICAgICAgICAgIDogMSAvKiBJbmRleEtpbmQuREVTQ0VORElORyAqLykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRmllbGRJbmRleChGaWVsZEluZGV4LlVOS05PV05fSUQsIHRoaXMuY29sbGVjdGlvbklkLCBzZWdtZW50cywgSW5kZXhTdGF0ZS5lbXB0eSgpKTtcbiAgICB9XG4gICAgaGFzTWF0Y2hpbmdFcXVhbGl0eUZpbHRlcihzZWdtZW50KSB7XG4gICAgICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIHRoaXMuZXF1YWxpdHlGaWx0ZXJzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXRjaGVzRmlsdGVyKGZpbHRlciwgc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1hdGNoZXNGaWx0ZXIoZmlsdGVyLCBzZWdtZW50KSB7XG4gICAgICAgIGlmIChmaWx0ZXIgPT09IHVuZGVmaW5lZCB8fCAhZmlsdGVyLmZpZWxkLmlzRXF1YWwoc2VnbWVudC5maWVsZFBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNBcnJheU9wZXJhdG9yID0gZmlsdGVyLm9wID09PSBcImFycmF5LWNvbnRhaW5zXCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlMgKi8gfHxcbiAgICAgICAgICAgIGZpbHRlci5vcCA9PT0gXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi87XG4gICAgICAgIHJldHVybiAoc2VnbWVudC5raW5kID09PSAyIC8qIEluZGV4S2luZC5DT05UQUlOUyAqLykgPT09IGlzQXJyYXlPcGVyYXRvcjtcbiAgICB9XG4gICAgbWF0Y2hlc09yZGVyQnkob3JkZXJCeSwgc2VnbWVudCkge1xuICAgICAgICBpZiAoIW9yZGVyQnkuZmllbGQuaXNFcXVhbChzZWdtZW50LmZpZWxkUGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKChzZWdtZW50LmtpbmQgPT09IDAgLyogSW5kZXhLaW5kLkFTQ0VORElORyAqLyAmJlxuICAgICAgICAgICAgb3JkZXJCeS5kaXIgPT09IFwiYXNjXCIgLyogRGlyZWN0aW9uLkFTQ0VORElORyAqLykgfHxcbiAgICAgICAgICAgIChzZWdtZW50LmtpbmQgPT09IDEgLyogSW5kZXhLaW5kLkRFU0NFTkRJTkcgKi8gJiZcbiAgICAgICAgICAgICAgICBvcmRlckJ5LmRpciA9PT0gXCJkZXNjXCIgLyogRGlyZWN0aW9uLkRFU0NFTkRJTkcgKi8pKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFByb3ZpZGVzIHV0aWxpdHkgZnVuY3Rpb25zIHRoYXQgaGVscCB3aXRoIGJvb2xlYW4gbG9naWMgdHJhbnNmb3JtYXRpb25zIG5lZWRlZCBmb3IgaGFuZGxpbmdcbiAqIGNvbXBsZXggZmlsdGVycyB1c2VkIGluIHF1ZXJpZXMuXG4gKi9cbi8qKlxuICogVGhlIGBpbmAgZmlsdGVyIGlzIG9ubHkgYSBzeW50YWN0aWMgc3VnYXIgb3ZlciBhIGRpc2p1bmN0aW9uIG9mIGVxdWFsaXRpZXMuIEZvciBpbnN0YW5jZTogYGEgaW5cbiAqIFsxLDIsM11gIGlzIGluIGZhY3QgYGE9PTEgfHwgYT09MiB8fCBhPT0zYC4gVGhpcyBtZXRob2QgZXhwYW5kcyBhbnkgYGluYCBmaWx0ZXIgaW4gdGhlIGdpdmVuXG4gKiBpbnB1dCBpbnRvIGEgZGlzanVuY3Rpb24gb2YgZXF1YWxpdHkgZmlsdGVycyBhbmQgcmV0dXJucyB0aGUgZXhwYW5kZWQgZmlsdGVyLlxuICovXG5mdW5jdGlvbiBjb21wdXRlSW5FeHBhbnNpb24oZmlsdGVyKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBoYXJkQXNzZXJ0KGZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyIHx8IGZpbHRlciBpbnN0YW5jZW9mIENvbXBvc2l0ZUZpbHRlcik7XG4gICAgaWYgKGZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XG4gICAgICAgIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBJbkZpbHRlcikge1xuICAgICAgICAgICAgY29uc3QgZXhwYW5kZWRGaWx0ZXJzID0gKChfYiA9IChfYSA9IGZpbHRlci52YWx1ZS5hcnJheVZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmFsdWVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWFwKHZhbHVlID0+IEZpZWxkRmlsdGVyLmNyZWF0ZShmaWx0ZXIuZmllbGQsIFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLywgdmFsdWUpKSkgfHwgW107XG4gICAgICAgICAgICByZXR1cm4gQ29tcG9zaXRlRmlsdGVyLmNyZWF0ZShleHBhbmRlZEZpbHRlcnMsIFwib3JcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5PUiAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIHJlYWNoZWQgb3RoZXIga2luZHMgb2YgZmllbGQgZmlsdGVycy5cbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UgaGF2ZSBhIGNvbXBvc2l0ZSBmaWx0ZXIuXG4gICAgY29uc3QgZXhwYW5kZWRGaWx0ZXJzID0gZmlsdGVyLmZpbHRlcnMubWFwKHN1YmZpbHRlciA9PiBjb21wdXRlSW5FeHBhbnNpb24oc3ViZmlsdGVyKSk7XG4gICAgcmV0dXJuIENvbXBvc2l0ZUZpbHRlci5jcmVhdGUoZXhwYW5kZWRGaWx0ZXJzLCBmaWx0ZXIub3ApO1xufVxuLyoqXG4gKiBHaXZlbiBhIGNvbXBvc2l0ZSBmaWx0ZXIsIHJldHVybnMgdGhlIGxpc3Qgb2YgdGVybXMgaW4gaXRzIGRpc2p1bmN0aXZlIG5vcm1hbCBmb3JtLlxuICpcbiAqIDxwPkVhY2ggZWxlbWVudCBpbiB0aGUgcmV0dXJuIHZhbHVlIGlzIG9uZSB0ZXJtIG9mIHRoZSByZXN1bHRpbmcgRE5GLiBGb3IgaW5zdGFuY2U6IEZvciB0aGVcbiAqIGlucHV0OiAoQSB8fCBCKSAmJiBDLCB0aGUgRE5GIGZvcm0gaXM6IChBICYmIEMpIHx8IChCICYmIEMpLCBhbmQgdGhlIHJldHVybiB2YWx1ZSBpcyBhIGxpc3RcbiAqIHdpdGggdHdvIGVsZW1lbnRzOiBhIGNvbXBvc2l0ZSBmaWx0ZXIgdGhhdCBwZXJmb3JtcyAoQSAmJiBDKSwgYW5kIGEgY29tcG9zaXRlIGZpbHRlciB0aGF0XG4gKiBwZXJmb3JtcyAoQiAmJiBDKS5cbiAqXG4gKiBAcGFyYW0gZmlsdGVyIHRoZSBjb21wb3NpdGUgZmlsdGVyIHRvIGNhbGN1bGF0ZSBETkYgdHJhbnNmb3JtIGZvci5cbiAqIEByZXR1cm4gdGhlIHRlcm1zIGluIHRoZSBETkYgdHJhbnNmb3JtLlxuICovXG5mdW5jdGlvbiBnZXREbmZUZXJtcyhmaWx0ZXIpIHtcbiAgICBpZiAoZmlsdGVyLmdldEZpbHRlcnMoKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBjb21wdXRlRGlzdHJpYnV0ZWROb3JtYWxGb3JtKGNvbXB1dGVJbkV4cGFuc2lvbihmaWx0ZXIpKTtcbiAgICBoYXJkQXNzZXJ0KGlzRGlzanVuY3RpdmVOb3JtYWxGb3JtKHJlc3VsdCkpO1xuICAgIGlmIChpc1NpbmdsZUZpZWxkRmlsdGVyKHJlc3VsdCkgfHwgaXNGbGF0Q29uanVuY3Rpb24ocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gW3Jlc3VsdF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuZ2V0RmlsdGVycygpO1xufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gZmlsdGVyIGlzIGEgc2luZ2xlIGZpZWxkIGZpbHRlci4gZS5nLiAoYSA9PSAxMCkuICovXG5mdW5jdGlvbiBpc1NpbmdsZUZpZWxkRmlsdGVyKGZpbHRlcikge1xuICAgIHJldHVybiBmaWx0ZXIgaW5zdGFuY2VvZiBGaWVsZEZpbHRlcjtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBmaWx0ZXIgaXMgdGhlIGNvbmp1bmN0aW9uIG9mIG9uZSBvciBtb3JlIGZpZWxkIGZpbHRlcnMuIGUuZy4gKGEgPT0gMTBcbiAqICYmIGIgPT0gMjApXG4gKi9cbmZ1bmN0aW9uIGlzRmxhdENvbmp1bmN0aW9uKGZpbHRlcikge1xuICAgIHJldHVybiAoZmlsdGVyIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyICYmXG4gICAgICAgIGNvbXBvc2l0ZUZpbHRlcklzRmxhdENvbmp1bmN0aW9uKGZpbHRlcikpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBmaWx0ZXIgaXMgaW4gZGlzanVuY3RpdmUgbm9ybWFsIGZvcm0gKERORikuXG4gKlxuICogPHA+SW4gYm9vbGVhbiBsb2dpYywgYSBkaXNqdW5jdGl2ZSBub3JtYWwgZm9ybSAoRE5GKSBpcyBhIGNhbm9uaWNhbCBub3JtYWwgZm9ybSBvZiBhIGxvZ2ljYWxcbiAqIGZvcm11bGEgY29uc2lzdGluZyBvZiBhIGRpc2p1bmN0aW9uIG9mIGNvbmp1bmN0aW9uczsgaXQgY2FuIGFsc28gYmUgZGVzY3JpYmVkIGFzIGFuIE9SIG9mIEFORHMuXG4gKlxuICogPHA+Rm9yIG1vcmUgaW5mbywgdmlzaXQ6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Rpc2p1bmN0aXZlX25vcm1hbF9mb3JtXG4gKi9cbmZ1bmN0aW9uIGlzRGlzanVuY3RpdmVOb3JtYWxGb3JtKGZpbHRlcikge1xuICAgIHJldHVybiAoaXNTaW5nbGVGaWVsZEZpbHRlcihmaWx0ZXIpIHx8XG4gICAgICAgIGlzRmxhdENvbmp1bmN0aW9uKGZpbHRlcikgfHxcbiAgICAgICAgaXNEaXNqdW5jdGlvbk9mRmllbGRGaWx0ZXJzQW5kRmxhdENvbmp1bmN0aW9ucyhmaWx0ZXIpKTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBmaWx0ZXIgaXMgdGhlIGRpc2p1bmN0aW9uIG9mIG9uZSBvciBtb3JlIFwiZmxhdCBjb25qdW5jdGlvbnNcIiBhbmRcbiAqIGZpZWxkIGZpbHRlcnMuIGUuZy4gKGEgPT0gMTApIHx8IChiPT0yMCAmJiBjPT0zMClcbiAqL1xuZnVuY3Rpb24gaXNEaXNqdW5jdGlvbk9mRmllbGRGaWx0ZXJzQW5kRmxhdENvbmp1bmN0aW9ucyhmaWx0ZXIpIHtcbiAgICBpZiAoZmlsdGVyIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyKSB7XG4gICAgICAgIGlmIChjb21wb3NpdGVGaWx0ZXJJc0Rpc2p1bmN0aW9uKGZpbHRlcikpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3ViRmlsdGVyIG9mIGZpbHRlci5nZXRGaWx0ZXJzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzU2luZ2xlRmllbGRGaWx0ZXIoc3ViRmlsdGVyKSAmJiAhaXNGbGF0Q29uanVuY3Rpb24oc3ViRmlsdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29tcHV0ZURpc3RyaWJ1dGVkTm9ybWFsRm9ybShmaWx0ZXIpIHtcbiAgICBoYXJkQXNzZXJ0KGZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyIHx8IGZpbHRlciBpbnN0YW5jZW9mIENvbXBvc2l0ZUZpbHRlcik7XG4gICAgaWYgKGZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgfVxuICAgIGlmIChmaWx0ZXIuZmlsdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVEaXN0cmlidXRlZE5vcm1hbEZvcm0oZmlsdGVyLmZpbHRlcnNbMF0pO1xuICAgIH1cbiAgICAvLyBDb21wdXRlIERORiBmb3IgZWFjaCBvZiB0aGUgc3ViZmlsdGVycyBmaXJzdFxuICAgIGNvbnN0IHJlc3VsdCA9IGZpbHRlci5maWx0ZXJzLm1hcChzdWJmaWx0ZXIgPT4gY29tcHV0ZURpc3RyaWJ1dGVkTm9ybWFsRm9ybShzdWJmaWx0ZXIpKTtcbiAgICBsZXQgbmV3RmlsdGVyID0gQ29tcG9zaXRlRmlsdGVyLmNyZWF0ZShyZXN1bHQsIGZpbHRlci5vcCk7XG4gICAgbmV3RmlsdGVyID0gYXBwbHlBc3NvY2lhdGlvbihuZXdGaWx0ZXIpO1xuICAgIGlmIChpc0Rpc2p1bmN0aXZlTm9ybWFsRm9ybShuZXdGaWx0ZXIpKSB7XG4gICAgICAgIHJldHVybiBuZXdGaWx0ZXI7XG4gICAgfVxuICAgIGhhcmRBc3NlcnQobmV3RmlsdGVyIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyKTtcbiAgICBoYXJkQXNzZXJ0KGNvbXBvc2l0ZUZpbHRlcklzQ29uanVuY3Rpb24obmV3RmlsdGVyKSk7XG4gICAgaGFyZEFzc2VydChuZXdGaWx0ZXIuZmlsdGVycy5sZW5ndGggPiAxKTtcbiAgICByZXR1cm4gbmV3RmlsdGVyLmZpbHRlcnMucmVkdWNlKChydW5uaW5nUmVzdWx0LCBmaWx0ZXIpID0+IGFwcGx5RGlzdHJpYnV0aW9uKHJ1bm5pbmdSZXN1bHQsIGZpbHRlcikpO1xufVxuZnVuY3Rpb24gYXBwbHlEaXN0cmlidXRpb24obGhzLCByaHMpIHtcbiAgICBoYXJkQXNzZXJ0KGxocyBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyIHx8IGxocyBpbnN0YW5jZW9mIENvbXBvc2l0ZUZpbHRlcik7XG4gICAgaGFyZEFzc2VydChyaHMgaW5zdGFuY2VvZiBGaWVsZEZpbHRlciB8fCByaHMgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKGxocyBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XG4gICAgICAgIGlmIChyaHMgaW5zdGFuY2VvZiBGaWVsZEZpbHRlcikge1xuICAgICAgICAgICAgLy8gRmllbGRGaWx0ZXIgRmllbGRGaWx0ZXJcbiAgICAgICAgICAgIHJlc3VsdCA9IGFwcGx5RGlzdHJpYnV0aW9uRmllbGRGaWx0ZXJzKGxocywgcmhzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZpZWxkRmlsdGVyIENvbXBvc2l0ZUZpbHRlclxuICAgICAgICAgICAgcmVzdWx0ID0gYXBwbHlEaXN0cmlidXRpb25GaWVsZEFuZENvbXBvc2l0ZUZpbHRlcnMobGhzLCByaHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAocmhzIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIpIHtcbiAgICAgICAgICAgIC8vIENvbXBvc2l0ZUZpbHRlciBGaWVsZEZpbHRlclxuICAgICAgICAgICAgcmVzdWx0ID0gYXBwbHlEaXN0cmlidXRpb25GaWVsZEFuZENvbXBvc2l0ZUZpbHRlcnMocmhzLCBsaHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ29tcG9zaXRlRmlsdGVyIENvbXBvc2l0ZUZpbHRlclxuICAgICAgICAgICAgcmVzdWx0ID0gYXBwbHlEaXN0cmlidXRpb25Db21wb3NpdGVGaWx0ZXJzKGxocywgcmhzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXBwbHlBc3NvY2lhdGlvbihyZXN1bHQpO1xufVxuZnVuY3Rpb24gYXBwbHlEaXN0cmlidXRpb25GaWVsZEZpbHRlcnMobGhzLCByaHMpIHtcbiAgICAvLyBDb25qdW5jdGlvbiBkaXN0cmlidXRpb24gZm9yIHR3byBmaWVsZCBmaWx0ZXJzIGlzIHRoZSBjb25qdW5jdGlvbiBvZiB0aGVtLlxuICAgIHJldHVybiBDb21wb3NpdGVGaWx0ZXIuY3JlYXRlKFtsaHMsIHJoc10sIFwiYW5kXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuQU5EICovKTtcbn1cbmZ1bmN0aW9uIGFwcGx5RGlzdHJpYnV0aW9uQ29tcG9zaXRlRmlsdGVycyhsaHMsIHJocykge1xuICAgIGhhcmRBc3NlcnQobGhzLmZpbHRlcnMubGVuZ3RoID4gMCAmJiByaHMuZmlsdGVycy5sZW5ndGggPiAwKTtcbiAgICAvLyBUaGVyZSBhcmUgZm91ciBjYXNlczpcbiAgICAvLyAoQSAmIEIpICYgKEMgJiBEKSAtLT4gKEEgJiBCICYgQyAmIEQpXG4gICAgLy8gKEEgJiBCKSAmIChDIHwgRCkgLS0+IChBICYgQiAmIEMpIHwgKEEgJiBCICYgRClcbiAgICAvLyAoQSB8IEIpICYgKEMgJiBEKSAtLT4gKEMgJiBEICYgQSkgfCAoQyAmIEQgJiBCKVxuICAgIC8vIChBIHwgQikgJiAoQyB8IEQpIC0tPiAoQSAmIEMpIHwgKEEgJiBEKSB8IChCICYgQykgfCAoQiAmIEQpXG4gICAgLy8gQ2FzZSAxIGlzIGEgbWVyZ2UuXG4gICAgaWYgKGNvbXBvc2l0ZUZpbHRlcklzQ29uanVuY3Rpb24obGhzKSAmJiBjb21wb3NpdGVGaWx0ZXJJc0Nvbmp1bmN0aW9uKHJocykpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZUZpbHRlcldpdGhBZGRlZEZpbHRlcnMobGhzLCByaHMuZ2V0RmlsdGVycygpKTtcbiAgICB9XG4gICAgLy8gQ2FzZSAyLDMsNCBhbGwgaGF2ZSBhdCBsZWFzdCBvbmUgc2lkZSAobGhzIG9yIHJocykgdGhhdCBpcyBhIGRpc2p1bmN0aW9uLiBJbiBhbGwgdGhyZWUgY2FzZXNcbiAgICAvLyB3ZSBzaG91bGQgdGFrZSBlYWNoIGVsZW1lbnQgb2YgdGhlIGRpc2p1bmN0aW9uIGFuZCBkaXN0cmlidXRlIGl0IG92ZXIgdGhlIG90aGVyIHNpZGUsIGFuZFxuICAgIC8vIHJldHVybiB0aGUgZGlzanVuY3Rpb24gb2YgdGhlIGRpc3RyaWJ1dGlvbiByZXN1bHRzLlxuICAgIGNvbnN0IGRpc2p1bmN0aW9uU2lkZSA9IGNvbXBvc2l0ZUZpbHRlcklzRGlzanVuY3Rpb24obGhzKSA/IGxocyA6IHJocztcbiAgICBjb25zdCBvdGhlclNpZGUgPSBjb21wb3NpdGVGaWx0ZXJJc0Rpc2p1bmN0aW9uKGxocykgPyByaHMgOiBsaHM7XG4gICAgY29uc3QgcmVzdWx0cyA9IGRpc2p1bmN0aW9uU2lkZS5maWx0ZXJzLm1hcChzdWJmaWx0ZXIgPT4gYXBwbHlEaXN0cmlidXRpb24oc3ViZmlsdGVyLCBvdGhlclNpZGUpKTtcbiAgICByZXR1cm4gQ29tcG9zaXRlRmlsdGVyLmNyZWF0ZShyZXN1bHRzLCBcIm9yXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuT1IgKi8pO1xufVxuZnVuY3Rpb24gYXBwbHlEaXN0cmlidXRpb25GaWVsZEFuZENvbXBvc2l0ZUZpbHRlcnMoZmllbGRGaWx0ZXIsIGNvbXBvc2l0ZUZpbHRlcikge1xuICAgIC8vIFRoZXJlIGFyZSB0d28gY2FzZXM6XG4gICAgLy8gQSAmIChCICYgQykgLS0+IChBICYgQiAmIEMpXG4gICAgLy8gQSAmIChCIHwgQykgLS0+IChBICYgQikgfCAoQSAmIEMpXG4gICAgaWYgKGNvbXBvc2l0ZUZpbHRlcklzQ29uanVuY3Rpb24oY29tcG9zaXRlRmlsdGVyKSkge1xuICAgICAgICAvLyBDYXNlIDFcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZUZpbHRlcldpdGhBZGRlZEZpbHRlcnMoY29tcG9zaXRlRmlsdGVyLCBmaWVsZEZpbHRlci5nZXRGaWx0ZXJzKCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQ2FzZSAyXG4gICAgICAgIGNvbnN0IG5ld0ZpbHRlcnMgPSBjb21wb3NpdGVGaWx0ZXIuZmlsdGVycy5tYXAoc3ViZmlsdGVyID0+IGFwcGx5RGlzdHJpYnV0aW9uKGZpZWxkRmlsdGVyLCBzdWJmaWx0ZXIpKTtcbiAgICAgICAgcmV0dXJuIENvbXBvc2l0ZUZpbHRlci5jcmVhdGUobmV3RmlsdGVycywgXCJvclwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLk9SICovKTtcbiAgICB9XG59XG4vKipcbiAqIEFwcGxpZXMgdGhlIGFzc29jaWF0aXZpdHkgcHJvcGVydHkgdG8gdGhlIGdpdmVuIGZpbHRlciBhbmQgcmV0dXJucyB0aGUgcmVzdWx0aW5nIGZpbHRlci5cbiAqXG4gKiA8dWw+XG4gKiAgIDxsaT5BIHwgKEIgfCBDKSA9PSAoQSB8IEIpIHwgQyA9PSAoQSB8IEIgfCBDKVxuICogICA8bGk+QSAmIChCICYgQykgPT0gKEEgJiBCKSAmIEMgPT0gKEEgJiBCICYgQylcbiAqIDwvdWw+XG4gKlxuICogPHA+Rm9yIG1vcmUgaW5mbywgdmlzaXQ6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Fzc29jaWF0aXZlX3Byb3BlcnR5I1Byb3Bvc2l0aW9uYWxfbG9naWNcbiAqL1xuZnVuY3Rpb24gYXBwbHlBc3NvY2lhdGlvbihmaWx0ZXIpIHtcbiAgICBoYXJkQXNzZXJ0KGZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyIHx8IGZpbHRlciBpbnN0YW5jZW9mIENvbXBvc2l0ZUZpbHRlcik7XG4gICAgaWYgKGZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlcnMgPSBmaWx0ZXIuZ2V0RmlsdGVycygpO1xuICAgIC8vIElmIHRoZSBjb21wb3NpdGUgZmlsdGVyIG9ubHkgY29udGFpbnMgMSBmaWx0ZXIsIGFwcGx5IGFzc29jaWF0aXZpdHkgdG8gaXQuXG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBhcHBseUFzc29jaWF0aW9uKGZpbHRlcnNbMF0pO1xuICAgIH1cbiAgICAvLyBBc3NvY2lhdGl2aXR5IGFwcGxpZWQgdG8gYSBmbGF0IGNvbXBvc2l0ZSBmaWx0ZXIgcmVzdWx0cyBpcyBpdHNlbGYuXG4gICAgaWYgKGNvbXBvc2l0ZUZpbHRlcklzRmxhdChmaWx0ZXIpKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgfVxuICAgIC8vIEZpcnN0IGFwcGx5IGFzc29jaWF0aXZpdHkgdG8gYWxsIHN1YmZpbHRlcnMuIFRoaXMgd2lsbCBpbiB0dXJuIHJlY3Vyc2l2ZWx5IGFwcGx5XG4gICAgLy8gYXNzb2NpYXRpdml0eSB0byBhbGwgbmVzdGVkIGNvbXBvc2l0ZSBmaWx0ZXJzIGFuZCBmaWVsZCBmaWx0ZXJzLlxuICAgIGNvbnN0IHVwZGF0ZWRGaWx0ZXJzID0gZmlsdGVycy5tYXAoc3ViZmlsdGVyID0+IGFwcGx5QXNzb2NpYXRpb24oc3ViZmlsdGVyKSk7XG4gICAgLy8gRm9yIGNvbXBvc2l0ZSBzdWJmaWx0ZXJzIHRoYXQgcGVyZm9ybSB0aGUgc2FtZSBraW5kIG9mIGxvZ2ljYWwgb3BlcmF0aW9uIGFzIGBjb21wb3NpdGVGaWx0ZXJgXG4gICAgLy8gdGFrZSBvdXQgdGhlaXIgZmlsdGVycyBhbmQgYWRkIHRoZW0gdG8gYGNvbXBvc2l0ZUZpbHRlcmAuIEZvciBleGFtcGxlOlxuICAgIC8vIGNvbXBvc2l0ZUZpbHRlciA9IChBIHwgKEIgfCBDIHwgRCkpXG4gICAgLy8gY29tcG9zaXRlU3ViZmlsdGVyID0gKEIgfCBDIHwgRClcbiAgICAvLyBSZXN1bHQ6IChBIHwgQiB8IEMgfCBEKVxuICAgIC8vIE5vdGUgdGhhdCB0aGUgYGNvbXBvc2l0ZVN1YmZpbHRlcmAgaGFzIGJlZW4gZWxpbWluYXRlZCwgYW5kIGl0cyBmaWx0ZXJzIChCLCBDLCBEKSBoYXZlIGJlZW5cbiAgICAvLyBhZGRlZCB0byB0aGUgdG9wLWxldmVsIFwiY29tcG9zaXRlRmlsdGVyXCIuXG4gICAgY29uc3QgbmV3U3ViZmlsdGVycyA9IFtdO1xuICAgIHVwZGF0ZWRGaWx0ZXJzLmZvckVhY2goc3ViZmlsdGVyID0+IHtcbiAgICAgICAgaWYgKHN1YmZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XG4gICAgICAgICAgICBuZXdTdWJmaWx0ZXJzLnB1c2goc3ViZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdWJmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIpIHtcbiAgICAgICAgICAgIGlmIChzdWJmaWx0ZXIub3AgPT09IGZpbHRlci5vcCkge1xuICAgICAgICAgICAgICAgIC8vIGNvbXBvc2l0ZUZpbHRlcjogKEEgfCAoQiB8IEMpKVxuICAgICAgICAgICAgICAgIC8vIGNvbXBvc2l0ZVN1YmZpbHRlcjogKEIgfCBDKVxuICAgICAgICAgICAgICAgIC8vIFJlc3VsdDogKEEgfCBCIHwgQylcbiAgICAgICAgICAgICAgICBuZXdTdWJmaWx0ZXJzLnB1c2goLi4uc3ViZmlsdGVyLmZpbHRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY29tcG9zaXRlRmlsdGVyOiAoQSB8IChCICYgQykpXG4gICAgICAgICAgICAgICAgLy8gY29tcG9zaXRlU3ViZmlsdGVyOiAoQiAmIEMpXG4gICAgICAgICAgICAgICAgLy8gUmVzdWx0OiAoQSB8IChCICYgQykpXG4gICAgICAgICAgICAgICAgbmV3U3ViZmlsdGVycy5wdXNoKHN1YmZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAobmV3U3ViZmlsdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG5ld1N1YmZpbHRlcnNbMF07XG4gICAgfVxuICAgIHJldHVybiBDb21wb3NpdGVGaWx0ZXIuY3JlYXRlKG5ld1N1YmZpbHRlcnMsIGZpbHRlci5vcCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFuIGluLW1lbW9yeSBpbXBsZW1lbnRhdGlvbiBvZiBJbmRleE1hbmFnZXIuXG4gKi9cbmNsYXNzIE1lbW9yeUluZGV4TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvblBhcmVudEluZGV4ID0gbmV3IE1lbW9yeUNvbGxlY3Rpb25QYXJlbnRJbmRleCgpO1xuICAgIH1cbiAgICBhZGRUb0NvbGxlY3Rpb25QYXJlbnRJbmRleCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvblBhdGgpIHtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uUGFyZW50SW5kZXguYWRkKGNvbGxlY3Rpb25QYXRoKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGdldENvbGxlY3Rpb25QYXJlbnRzKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uSWQpIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMuY29sbGVjdGlvblBhcmVudEluZGV4LmdldEVudHJpZXMoY29sbGVjdGlvbklkKSk7XG4gICAgfVxuICAgIGFkZEZpZWxkSW5kZXgodHJhbnNhY3Rpb24sIGluZGV4KSB7XG4gICAgICAgIC8vIEZpZWxkIGluZGljZXMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBtZW1vcnkgcGVyc2lzdGVuY2UuXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBkZWxldGVGaWVsZEluZGV4KHRyYW5zYWN0aW9uLCBpbmRleCkge1xuICAgICAgICAvLyBGaWVsZCBpbmRpY2VzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbWVtb3J5IHBlcnNpc3RlbmNlLlxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZGVsZXRlQWxsRmllbGRJbmRleGVzKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIC8vIEZpZWxkIGluZGljZXMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBtZW1vcnkgcGVyc2lzdGVuY2UuXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjcmVhdGVUYXJnZXRJbmRleGVzKHRyYW5zYWN0aW9uLCB0YXJnZXQpIHtcbiAgICAgICAgLy8gRmllbGQgaW5kaWNlcyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIG1lbW9yeSBwZXJzaXN0ZW5jZS5cbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGdldERvY3VtZW50c01hdGNoaW5nVGFyZ2V0KHRyYW5zYWN0aW9uLCB0YXJnZXQpIHtcbiAgICAgICAgLy8gRmllbGQgaW5kaWNlcyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIG1lbW9yeSBwZXJzaXN0ZW5jZS5cbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH1cbiAgICBnZXRJbmRleFR5cGUodHJhbnNhY3Rpb24sIHRhcmdldCkge1xuICAgICAgICAvLyBGaWVsZCBpbmRpY2VzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbWVtb3J5IHBlcnNpc3RlbmNlLlxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoMCAvKiBJbmRleFR5cGUuTk9ORSAqLyk7XG4gICAgfVxuICAgIGdldEZpZWxkSW5kZXhlcyh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwKSB7XG4gICAgICAgIC8vIEZpZWxkIGluZGljZXMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBtZW1vcnkgcGVyc2lzdGVuY2UuXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfVxuICAgIGdldE5leHRDb2xsZWN0aW9uR3JvdXBUb1VwZGF0ZSh0cmFuc2FjdGlvbikge1xuICAgICAgICAvLyBGaWVsZCBpbmRpY2VzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbWVtb3J5IHBlcnNpc3RlbmNlLlxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgfVxuICAgIGdldE1pbk9mZnNldCh0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShJbmRleE9mZnNldC5taW4oKSk7XG4gICAgfVxuICAgIGdldE1pbk9mZnNldEZyb21Db2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCkge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoSW5kZXhPZmZzZXQubWluKCkpO1xuICAgIH1cbiAgICB1cGRhdGVDb2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCwgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEZpZWxkIGluZGljZXMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBtZW1vcnkgcGVyc2lzdGVuY2UuXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICB1cGRhdGVJbmRleEVudHJpZXModHJhbnNhY3Rpb24sIGRvY3VtZW50cykge1xuICAgICAgICAvLyBGaWVsZCBpbmRpY2VzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbWVtb3J5IHBlcnNpc3RlbmNlLlxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG59XG4vKipcbiAqIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIHRoZSBjb2xsZWN0aW9uLXBhcmVudCBpbmRleCBleHBvc2VkIGJ5IE1lbW9yeUluZGV4TWFuYWdlci5cbiAqIEFsc28gdXNlZCBmb3IgaW4tbWVtb3J5IGNhY2hpbmcgYnkgSW5kZXhlZERiSW5kZXhNYW5hZ2VyIGFuZCBpbml0aWFsIGluZGV4IHBvcHVsYXRpb25cbiAqIGluIGluZGV4ZWRkYl9zY2hlbWEudHNcbiAqL1xuY2xhc3MgTWVtb3J5Q29sbGVjdGlvblBhcmVudEluZGV4IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IHt9O1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGZhbHNlIGlmIHRoZSBlbnRyeSBhbHJlYWR5IGV4aXN0ZWQuXG4gICAgYWRkKGNvbGxlY3Rpb25QYXRoKSB7XG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb25JZCA9IGNvbGxlY3Rpb25QYXRoLmxhc3RTZWdtZW50KCk7XG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBjb2xsZWN0aW9uUGF0aC5wb3BMYXN0KCk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nUGFyZW50cyA9IHRoaXMuaW5kZXhbY29sbGVjdGlvbklkXSB8fFxuICAgICAgICAgICAgbmV3IFNvcnRlZFNldChSZXNvdXJjZVBhdGguY29tcGFyYXRvcik7XG4gICAgICAgIGNvbnN0IGFkZGVkID0gIWV4aXN0aW5nUGFyZW50cy5oYXMocGFyZW50UGF0aCk7XG4gICAgICAgIHRoaXMuaW5kZXhbY29sbGVjdGlvbklkXSA9IGV4aXN0aW5nUGFyZW50cy5hZGQocGFyZW50UGF0aCk7XG4gICAgICAgIHJldHVybiBhZGRlZDtcbiAgICB9XG4gICAgaGFzKGNvbGxlY3Rpb25QYXRoKSB7XG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb25JZCA9IGNvbGxlY3Rpb25QYXRoLmxhc3RTZWdtZW50KCk7XG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBjb2xsZWN0aW9uUGF0aC5wb3BMYXN0KCk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nUGFyZW50cyA9IHRoaXMuaW5kZXhbY29sbGVjdGlvbklkXTtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nUGFyZW50cyAmJiBleGlzdGluZ1BhcmVudHMuaGFzKHBhcmVudFBhdGgpO1xuICAgIH1cbiAgICBnZXRFbnRyaWVzKGNvbGxlY3Rpb25JZCkge1xuICAgICAgICBjb25zdCBwYXJlbnRQYXRocyA9IHRoaXMuaW5kZXhbY29sbGVjdGlvbklkXSB8fFxuICAgICAgICAgICAgbmV3IFNvcnRlZFNldChSZXNvdXJjZVBhdGguY29tcGFyYXRvcik7XG4gICAgICAgIHJldHVybiBwYXJlbnRQYXRocy50b0FycmF5KCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgTE9HX1RBRyRmID0gJ0luZGV4ZWREYkluZGV4TWFuYWdlcic7XG5jb25zdCBFTVBUWV9WQUxVRSA9IG5ldyBVaW50OEFycmF5KDApO1xuLyoqXG4gKiBBIHBlcnNpc3RlZCBpbXBsZW1lbnRhdGlvbiBvZiBJbmRleE1hbmFnZXIuXG4gKlxuICogUE9SVElORyBOT1RFOiBVbmxpa2UgaU9TIGFuZCBBbmRyb2lkLCB0aGUgV2ViIFNESyBkb2VzIG5vdCBtZW1vaXplIGluZGV4XG4gKiBkYXRhIGFzIGl0IHN1cHBvcnRzIG11bHRpLXRhYiBhY2Nlc3MuXG4gKi9cbmNsYXNzIEluZGV4ZWREYkluZGV4TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IodXNlciwgZGF0YWJhc2VJZCkge1xuICAgICAgICB0aGlzLmRhdGFiYXNlSWQgPSBkYXRhYmFzZUlkO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaW4tbWVtb3J5IGNvcHkgb2YgdGhlIGluZGV4IGVudHJpZXMgd2UndmUgYWxyZWFkeSB3cml0dGVuIHNpbmNlIHRoZSBTREtcbiAgICAgICAgICogbGF1bmNoZWQuIFVzZWQgdG8gYXZvaWQgcmUtd3JpdGluZyB0aGUgc2FtZSBlbnRyeSByZXBlYXRlZGx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzICpOT1QqIGEgY29tcGxldGUgY2FjaGUgb2Ygd2hhdCdzIGluIHBlcnNpc3RlbmNlIGFuZCBzbyBjYW4gbmV2ZXIgYmVcbiAgICAgICAgICogdXNlZCB0byBzYXRpc2Z5IHJlYWRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uUGFyZW50c0NhY2hlID0gbmV3IE1lbW9yeUNvbGxlY3Rpb25QYXJlbnRJbmRleCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFwcyBmcm9tIGEgdGFyZ2V0IHRvIGl0cyBlcXVpdmFsZW50IGxpc3Qgb2Ygc3ViLXRhcmdldHMuIEVhY2ggc3ViLXRhcmdldFxuICAgICAgICAgKiBjb250YWlucyBvbmx5IG9uZSB0ZXJtIGZyb20gdGhlIHRhcmdldCdzIGRpc2p1bmN0aXZlIG5vcm1hbCBmb3JtIChETkYpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YXJnZXRUb0RuZlN1YlRhcmdldHMgPSBuZXcgT2JqZWN0TWFwKHQgPT4gY2Fub25pZnlUYXJnZXQodCksIChsLCByKSA9PiB0YXJnZXRFcXVhbHMobCwgcikpO1xuICAgICAgICB0aGlzLnVpZCA9IHVzZXIudWlkIHx8ICcnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGVudHJ5IHRvIHRoZSBjb2xsZWN0aW9uIHBhcmVudCBpbmRleC5cbiAgICAgKlxuICAgICAqIFJlcGVhdGVkIGNhbGxzIGZvciB0aGUgc2FtZSBjb2xsZWN0aW9uUGF0aCBzaG91bGQgYmUgYXZvaWRlZCB3aXRoaW4gYVxuICAgICAqIHRyYW5zYWN0aW9uIGFzIEluZGV4ZWREYkluZGV4TWFuYWdlciBvbmx5IGNhY2hlcyB3cml0ZXMgb25jZSBhIHRyYW5zYWN0aW9uXG4gICAgICogaGFzIGJlZW4gY29tbWl0dGVkLlxuICAgICAqL1xuICAgIGFkZFRvQ29sbGVjdGlvblBhcmVudEluZGV4KHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uUGF0aCkge1xuICAgICAgICBpZiAoIXRoaXMuY29sbGVjdGlvblBhcmVudHNDYWNoZS5oYXMoY29sbGVjdGlvblBhdGgpKSB7XG4gICAgICAgICAgICBjb25zdCBjb2xsZWN0aW9uSWQgPSBjb2xsZWN0aW9uUGF0aC5sYXN0U2VnbWVudCgpO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IGNvbGxlY3Rpb25QYXRoLnBvcExhc3QoKTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmFkZE9uQ29tbWl0dGVkTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY29sbGVjdGlvbiB0byB0aGUgaW4gbWVtb3J5IGNhY2hlIG9ubHkgaWYgdGhlIHRyYW5zYWN0aW9uIHdhc1xuICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3NmdWxseSBjb21taXR0ZWQuXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsZWN0aW9uUGFyZW50c0NhY2hlLmFkZChjb2xsZWN0aW9uUGF0aCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbGxlY3Rpb25QYXJlbnQgPSB7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbklkLFxuICAgICAgICAgICAgICAgIHBhcmVudDogZW5jb2RlUmVzb3VyY2VQYXRoKHBhcmVudFBhdGgpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25QYXJlbnRzU3RvcmUodHJhbnNhY3Rpb24pLnB1dChjb2xsZWN0aW9uUGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZ2V0Q29sbGVjdGlvblBhcmVudHModHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25JZCkge1xuICAgICAgICBjb25zdCBwYXJlbnRQYXRocyA9IFtdO1xuICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKFtjb2xsZWN0aW9uSWQsICcnXSwgW2ltbWVkaWF0ZVN1Y2Nlc3Nvcihjb2xsZWN0aW9uSWQpLCAnJ10sIFxuICAgICAgICAvKmxvd2VyT3Blbj0qLyBmYWxzZSwgXG4gICAgICAgIC8qdXBwZXJPcGVuPSovIHRydWUpO1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvblBhcmVudHNTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5sb2FkQWxsKHJhbmdlKVxuICAgICAgICAgICAgLm5leHQoZW50cmllcyA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvbGxlY3Rpb25JZCBndWFyZCBzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5IChhbmQgaXNuJ3QgYXMgbG9uZ1xuICAgICAgICAgICAgICAgIC8vIGFzIHdlJ3JlIHJ1bm5pbmcgaW4gYSByZWFsIGJyb3dzZXIpLCBidXQgdGhlcmUncyBhIGJ1ZyBpblxuICAgICAgICAgICAgICAgIC8vIGluZGV4ZWRkYnNoaW0gdGhhdCBicmVha3Mgb3VyIHJhbmdlIGluIG91ciB0ZXN0cyBydW5uaW5nIGluIG5vZGU6XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2F4ZW1jbGlvbi9JbmRleGVkREJTaGltL2lzc3Vlcy8zMzRcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuY29sbGVjdGlvbklkICE9PSBjb2xsZWN0aW9uSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudFBhdGhzLnB1c2goZGVjb2RlUmVzb3VyY2VQYXRoKGVudHJ5LnBhcmVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudFBhdGhzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWRkRmllbGRJbmRleCh0cmFuc2FjdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgLy8gVE9ETyhpbmRleGluZyk6IFZlcmlmeSB0aGF0IHRoZSBhdXRvLWluY3JlbWVudGluZyBpbmRleCBJRCB3b3JrcyBpblxuICAgICAgICAvLyBTYWZhcmkgJiBGaXJlZm94LlxuICAgICAgICBjb25zdCBpbmRleGVzID0gaW5kZXhDb25maWd1cmF0aW9uU3RvcmUodHJhbnNhY3Rpb24pO1xuICAgICAgICBjb25zdCBkYkluZGV4ID0gdG9EYkluZGV4Q29uZmlndXJhdGlvbihpbmRleCk7XG4gICAgICAgIGRlbGV0ZSBkYkluZGV4LmluZGV4SWQ7IC8vIGBpbmRleElkYCBpcyBhdXRvLXBvcHVsYXRlZCBieSBJbmRleGVkRGJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaW5kZXhlcy5hZGQoZGJJbmRleCk7XG4gICAgICAgIGlmIChpbmRleC5pbmRleFN0YXRlKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZXMgPSBpbmRleFN0YXRlU3RvcmUodHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5uZXh0KGluZGV4SWQgPT4ge1xuICAgICAgICAgICAgICAgIHN0YXRlcy5wdXQodG9EYkluZGV4U3RhdGUoaW5kZXhJZCwgdGhpcy51aWQsIGluZGV4LmluZGV4U3RhdGUuc2VxdWVuY2VOdW1iZXIsIGluZGV4LmluZGV4U3RhdGUub2Zmc2V0KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlbGV0ZUZpZWxkSW5kZXgodHJhbnNhY3Rpb24sIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGluZGV4ZXMgPSBpbmRleENvbmZpZ3VyYXRpb25TdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IGluZGV4U3RhdGVTdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBpbmRleEVudHJpZXNTdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIHJldHVybiBpbmRleGVzXG4gICAgICAgICAgICAuZGVsZXRlKGluZGV4LmluZGV4SWQpXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBzdGF0ZXMuZGVsZXRlKElEQktleVJhbmdlLmJvdW5kKFtpbmRleC5pbmRleElkXSwgW2luZGV4LmluZGV4SWQgKyAxXSwgXG4gICAgICAgIC8qbG93ZXJPcGVuPSovIGZhbHNlLCBcbiAgICAgICAgLyp1cHBlck9wZW49Ki8gdHJ1ZSkpKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZW50cmllcy5kZWxldGUoSURCS2V5UmFuZ2UuYm91bmQoW2luZGV4LmluZGV4SWRdLCBbaW5kZXguaW5kZXhJZCArIDFdLCBcbiAgICAgICAgLypsb3dlck9wZW49Ki8gZmFsc2UsIFxuICAgICAgICAvKnVwcGVyT3Blbj0qLyB0cnVlKSkpO1xuICAgIH1cbiAgICBkZWxldGVBbGxGaWVsZEluZGV4ZXModHJhbnNhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgaW5kZXhlcyA9IGluZGV4Q29uZmlndXJhdGlvblN0b3JlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgY29uc3QgZW50cmllcyA9IGluZGV4RW50cmllc1N0b3JlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgY29uc3Qgc3RhdGVzID0gaW5kZXhTdGF0ZVN0b3JlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIGluZGV4ZXNcbiAgICAgICAgICAgIC5kZWxldGVBbGwoKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZW50cmllcy5kZWxldGVBbGwoKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHN0YXRlcy5kZWxldGVBbGwoKSk7XG4gICAgfVxuICAgIGNyZWF0ZVRhcmdldEluZGV4ZXModHJhbnNhY3Rpb24sIHRhcmdldCkge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2godGhpcy5nZXRTdWJUYXJnZXRzKHRhcmdldCksIChzdWJUYXJnZXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEluZGV4VHlwZSh0cmFuc2FjdGlvbiwgc3ViVGFyZ2V0KS5uZXh0KHR5cGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAwIC8qIEluZGV4VHlwZS5OT05FICovIHx8IHR5cGUgPT09IDEgLyogSW5kZXhUeXBlLlBBUlRJQUwgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0SW5kZXhNYXRjaGVyID0gbmV3IFRhcmdldEluZGV4TWF0Y2hlcihzdWJUYXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZEluZGV4ID0gdGFyZ2V0SW5kZXhNYXRjaGVyLmJ1aWxkVGFyZ2V0SW5kZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkRmllbGRJbmRleCh0cmFuc2FjdGlvbiwgZmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldERvY3VtZW50c01hdGNoaW5nVGFyZ2V0KHRyYW5zYWN0aW9uLCB0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgaW5kZXhFbnRyaWVzID0gaW5kZXhFbnRyaWVzU3RvcmUodHJhbnNhY3Rpb24pO1xuICAgICAgICBsZXQgY2FuU2VydmVUYXJnZXQgPSB0cnVlO1xuICAgICAgICBjb25zdCBpbmRleGVzID0gbmV3IE1hcCgpO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2godGhpcy5nZXRTdWJUYXJnZXRzKHRhcmdldCksIChzdWJUYXJnZXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZpZWxkSW5kZXgodHJhbnNhY3Rpb24sIHN1YlRhcmdldCkubmV4dChpbmRleCA9PiB7XG4gICAgICAgICAgICAgICAgY2FuU2VydmVUYXJnZXQgJiYgKGNhblNlcnZlVGFyZ2V0ID0gISFpbmRleCk7XG4gICAgICAgICAgICAgICAgaW5kZXhlcy5zZXQoc3ViVGFyZ2V0LCBpbmRleCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNhblNlcnZlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGV4aXN0aW5nS2V5cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKGluZGV4ZXMsIChpbmRleCwgc3ViVGFyZ2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckZiwgYFVzaW5nIGluZGV4ICR7ZmllbGRJbmRleFRvU3RyaW5nKGluZGV4KX0gdG8gZXhlY3V0ZSAke2Nhbm9uaWZ5VGFyZ2V0KHRhcmdldCl9YCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5VmFsdWVzID0gdGFyZ2V0R2V0QXJyYXlWYWx1ZXMoc3ViVGFyZ2V0LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdEluVmFsdWVzID0gdGFyZ2V0R2V0Tm90SW5WYWx1ZXMoc3ViVGFyZ2V0LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvd2VyQm91bmQgPSB0YXJnZXRHZXRMb3dlckJvdW5kKHN1YlRhcmdldCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cHBlckJvdW5kID0gdGFyZ2V0R2V0VXBwZXJCb3VuZChzdWJUYXJnZXQsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG93ZXJCb3VuZEVuY29kZWQgPSB0aGlzLmVuY29kZUJvdW5kKGluZGV4LCBzdWJUYXJnZXQsIGxvd2VyQm91bmQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cHBlckJvdW5kRW5jb2RlZCA9IHRoaXMuZW5jb2RlQm91bmQoaW5kZXgsIHN1YlRhcmdldCwgdXBwZXJCb3VuZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdEluRW5jb2RlZCA9IHRoaXMuZW5jb2RlVmFsdWVzKGluZGV4LCBzdWJUYXJnZXQsIG5vdEluVmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXhSYW5nZXMgPSB0aGlzLmdlbmVyYXRlSW5kZXhSYW5nZXMoaW5kZXguaW5kZXhJZCwgYXJyYXlWYWx1ZXMsIGxvd2VyQm91bmRFbmNvZGVkLCBsb3dlckJvdW5kLmluY2x1c2l2ZSwgdXBwZXJCb3VuZEVuY29kZWQsIHVwcGVyQm91bmQuaW5jbHVzaXZlLCBub3RJbkVuY29kZWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goaW5kZXhSYW5nZXMsIChpbmRleFJhbmdlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhFbnRyaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmxvYWRGaXJzdChpbmRleFJhbmdlLCB0YXJnZXQubGltaXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm5leHQoZW50cmllcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZG9jdW1lbnRLZXkgPSBEb2N1bWVudEtleS5mcm9tU2VnbWVudHMoZW50cnkuZG9jdW1lbnRLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nS2V5cy5oYXMoZG9jdW1lbnRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0tleXMgPSBleGlzdGluZ0tleXMuYWRkKGRvY3VtZW50S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRvY3VtZW50S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLm5leHQoKCkgPT4gcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFN1YlRhcmdldHModGFyZ2V0KSB7XG4gICAgICAgIGxldCBzdWJUYXJnZXRzID0gdGhpcy50YXJnZXRUb0RuZlN1YlRhcmdldHMuZ2V0KHRhcmdldCk7XG4gICAgICAgIGlmIChzdWJUYXJnZXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ViVGFyZ2V0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0LmZpbHRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzdWJUYXJnZXRzID0gW3RhcmdldF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBhbiBpbXBsaWNpdCBBTkQgb3BlcmF0aW9uIGJldHdlZW4gYWxsIHRoZSBmaWx0ZXJzIHN0b3JlZCBpbiB0aGUgdGFyZ2V0XG4gICAgICAgICAgICBjb25zdCBkbmYgPSBnZXREbmZUZXJtcyhDb21wb3NpdGVGaWx0ZXIuY3JlYXRlKHRhcmdldC5maWx0ZXJzLCBcImFuZFwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLkFORCAqLykpO1xuICAgICAgICAgICAgc3ViVGFyZ2V0cyA9IGRuZi5tYXAodGVybSA9PiBuZXdUYXJnZXQodGFyZ2V0LnBhdGgsIHRhcmdldC5jb2xsZWN0aW9uR3JvdXAsIHRhcmdldC5vcmRlckJ5LCB0ZXJtLmdldEZpbHRlcnMoKSwgdGFyZ2V0LmxpbWl0LCB0YXJnZXQuc3RhcnRBdCwgdGFyZ2V0LmVuZEF0KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50YXJnZXRUb0RuZlN1YlRhcmdldHMuc2V0KHRhcmdldCwgc3ViVGFyZ2V0cyk7XG4gICAgICAgIHJldHVybiBzdWJUYXJnZXRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEga2V5IHJhbmdlIHF1ZXJ5IG9uIGBEYkluZGV4RW50cnlTdG9yZWAgdGhhdCB1bmlvbnMgYWxsXG4gICAgICogYm91bmRzLlxuICAgICAqL1xuICAgIGdlbmVyYXRlSW5kZXhSYW5nZXMoaW5kZXhJZCwgYXJyYXlWYWx1ZXMsIGxvd2VyQm91bmRzLCBsb3dlckJvdW5kSW5jbHVzaXZlLCB1cHBlckJvdW5kcywgdXBwZXJCb3VuZEluY2x1c2l2ZSwgbm90SW5WYWx1ZXMpIHtcbiAgICAgICAgLy8gVGhlIG51bWJlciBvZiB0b3RhbCBpbmRleCBzY2FucyB3ZSB1bmlvbiB0b2dldGhlci4gVGhpcyBpcyBzaW1pbGFyIHRvIGFcbiAgICAgICAgLy8gZGlzdHJpYnV0ZWQgbm9ybWFsIGZvcm0sIGJ1dCBhZGFwdGVkIGZvciBhcnJheSB2YWx1ZXMuIFdlIGNyZWF0ZSBhIHNpbmdsZVxuICAgICAgICAvLyBpbmRleCByYW5nZSBwZXIgdmFsdWUgaW4gYW4gQVJSQVlfQ09OVEFJTlMgb3IgQVJSQVlfQ09OVEFJTlNfQU5ZIGZpbHRlclxuICAgICAgICAvLyBjb21iaW5lZCB3aXRoIHRoZSB2YWx1ZXMgZnJvbSB0aGUgcXVlcnkgYm91bmRzLlxuICAgICAgICBjb25zdCB0b3RhbFNjYW5zID0gKGFycmF5VmFsdWVzICE9IG51bGwgPyBhcnJheVZhbHVlcy5sZW5ndGggOiAxKSAqXG4gICAgICAgICAgICBNYXRoLm1heChsb3dlckJvdW5kcy5sZW5ndGgsIHVwcGVyQm91bmRzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHNjYW5zUGVyQXJyYXlFbGVtZW50ID0gdG90YWxTY2FucyAvIChhcnJheVZhbHVlcyAhPSBudWxsID8gYXJyYXlWYWx1ZXMubGVuZ3RoIDogMSk7XG4gICAgICAgIGNvbnN0IGluZGV4UmFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxTY2FuczsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBhcnJheVZhbHVlID0gYXJyYXlWYWx1ZXNcbiAgICAgICAgICAgICAgICA/IHRoaXMuZW5jb2RlU2luZ2xlRWxlbWVudChhcnJheVZhbHVlc1tpIC8gc2NhbnNQZXJBcnJheUVsZW1lbnRdKVxuICAgICAgICAgICAgICAgIDogRU1QVFlfVkFMVUU7XG4gICAgICAgICAgICBjb25zdCBsb3dlckJvdW5kID0gdGhpcy5nZW5lcmF0ZUxvd2VyQm91bmQoaW5kZXhJZCwgYXJyYXlWYWx1ZSwgbG93ZXJCb3VuZHNbaSAlIHNjYW5zUGVyQXJyYXlFbGVtZW50XSwgbG93ZXJCb3VuZEluY2x1c2l2ZSk7XG4gICAgICAgICAgICBjb25zdCB1cHBlckJvdW5kID0gdGhpcy5nZW5lcmF0ZVVwcGVyQm91bmQoaW5kZXhJZCwgYXJyYXlWYWx1ZSwgdXBwZXJCb3VuZHNbaSAlIHNjYW5zUGVyQXJyYXlFbGVtZW50XSwgdXBwZXJCb3VuZEluY2x1c2l2ZSk7XG4gICAgICAgICAgICBjb25zdCBub3RJbkJvdW5kID0gbm90SW5WYWx1ZXMubWFwKG5vdEluID0+IHRoaXMuZ2VuZXJhdGVMb3dlckJvdW5kKGluZGV4SWQsIGFycmF5VmFsdWUsIG5vdEluLCBcbiAgICAgICAgICAgIC8qIGluY2x1c2l2ZT0gKi8gdHJ1ZSkpO1xuICAgICAgICAgICAgaW5kZXhSYW5nZXMucHVzaCguLi50aGlzLmNyZWF0ZVJhbmdlKGxvd2VyQm91bmQsIHVwcGVyQm91bmQsIG5vdEluQm91bmQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXhSYW5nZXM7XG4gICAgfVxuICAgIC8qKiBHZW5lcmF0ZXMgdGhlIGxvd2VyIGJvdW5kIGZvciBgYXJyYXlWYWx1ZWAgYW5kIGBkaXJlY3Rpb25hbFZhbHVlYC4gKi9cbiAgICBnZW5lcmF0ZUxvd2VyQm91bmQoaW5kZXhJZCwgYXJyYXlWYWx1ZSwgZGlyZWN0aW9uYWxWYWx1ZSwgaW5jbHVzaXZlKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gbmV3IEluZGV4RW50cnkoaW5kZXhJZCwgRG9jdW1lbnRLZXkuZW1wdHkoKSwgYXJyYXlWYWx1ZSwgZGlyZWN0aW9uYWxWYWx1ZSk7XG4gICAgICAgIHJldHVybiBpbmNsdXNpdmUgPyBlbnRyeSA6IGVudHJ5LnN1Y2Nlc3NvcigpO1xuICAgIH1cbiAgICAvKiogR2VuZXJhdGVzIHRoZSB1cHBlciBib3VuZCBmb3IgYGFycmF5VmFsdWVgIGFuZCBgZGlyZWN0aW9uYWxWYWx1ZWAuICovXG4gICAgZ2VuZXJhdGVVcHBlckJvdW5kKGluZGV4SWQsIGFycmF5VmFsdWUsIGRpcmVjdGlvbmFsVmFsdWUsIGluY2x1c2l2ZSkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IG5ldyBJbmRleEVudHJ5KGluZGV4SWQsIERvY3VtZW50S2V5LmVtcHR5KCksIGFycmF5VmFsdWUsIGRpcmVjdGlvbmFsVmFsdWUpO1xuICAgICAgICByZXR1cm4gaW5jbHVzaXZlID8gZW50cnkuc3VjY2Vzc29yKCkgOiBlbnRyeTtcbiAgICB9XG4gICAgZ2V0RmllbGRJbmRleCh0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHRhcmdldEluZGV4TWF0Y2hlciA9IG5ldyBUYXJnZXRJbmRleE1hdGNoZXIodGFyZ2V0KTtcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbkdyb3VwID0gdGFyZ2V0LmNvbGxlY3Rpb25Hcm91cCAhPSBudWxsXG4gICAgICAgICAgICA/IHRhcmdldC5jb2xsZWN0aW9uR3JvdXBcbiAgICAgICAgICAgIDogdGFyZ2V0LnBhdGgubGFzdFNlZ21lbnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmllbGRJbmRleGVzKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXApLm5leHQoaW5kZXhlcyA9PiB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGluZGV4IHdpdGggdGhlIG1vc3QgbnVtYmVyIG9mIHNlZ21lbnRzLlxuICAgICAgICAgICAgbGV0IGluZGV4ID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIGluZGV4ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gdGFyZ2V0SW5kZXhNYXRjaGVyLnNlcnZlZEJ5SW5kZXgoY2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcyAmJlxuICAgICAgICAgICAgICAgICAgICAoIWluZGV4IHx8IGNhbmRpZGF0ZS5maWVsZHMubGVuZ3RoID4gaW5kZXguZmllbGRzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBjYW5kaWRhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0SW5kZXhUeXBlKHRyYW5zYWN0aW9uLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IGluZGV4VHlwZSA9IDIgLyogSW5kZXhUeXBlLkZVTEwgKi87XG4gICAgICAgIGNvbnN0IHN1YlRhcmdldHMgPSB0aGlzLmdldFN1YlRhcmdldHModGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKHN1YlRhcmdldHMsICh0YXJnZXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZpZWxkSW5kZXgodHJhbnNhY3Rpb24sIHRhcmdldCkubmV4dChpbmRleCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleFR5cGUgPSAwIC8qIEluZGV4VHlwZS5OT05FICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpbmRleFR5cGUgIT09IDAgLyogSW5kZXhUeXBlLk5PTkUgKi8gJiZcbiAgICAgICAgICAgICAgICAgICAgaW5kZXguZmllbGRzLmxlbmd0aCA8IHRhcmdldEdldFNlZ21lbnRDb3VudCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4VHlwZSA9IDEgLyogSW5kZXhUeXBlLlBBUlRJQUwgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgLy8gT1IgcXVlcmllcyBoYXZlIG1vcmUgdGhhbiBvbmUgc3ViLXRhcmdldCAob25lIHN1Yi10YXJnZXQgcGVyIERORiB0ZXJtKS4gV2UgY3VycmVudGx5IGNvbnNpZGVyXG4gICAgICAgICAgICAvLyBPUiBxdWVyaWVzIHRoYXQgaGF2ZSBhIGBsaW1pdGAgdG8gaGF2ZSBhIHBhcnRpYWwgaW5kZXguIEZvciBzdWNoIHF1ZXJpZXMgd2UgcGVyZm9ybSBzb3J0aW5nXG4gICAgICAgICAgICAvLyBhbmQgYXBwbHkgdGhlIGxpbWl0IGluIG1lbW9yeSBhcyBhIHBvc3QtcHJvY2Vzc2luZyBzdGVwLlxuICAgICAgICAgICAgaWYgKHRhcmdldEhhc0xpbWl0KHRhcmdldCkgJiZcbiAgICAgICAgICAgICAgICBzdWJUYXJnZXRzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgICAgICBpbmRleFR5cGUgPT09IDIgLyogSW5kZXhUeXBlLkZVTEwgKi8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBJbmRleFR5cGUuUEFSVElBTCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbmRleFR5cGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBieXRlIGVuY29kZWQgZm9ybSBvZiB0aGUgZGlyZWN0aW9uYWwgdmFsdWVzIGluIHRoZSBmaWVsZCBpbmRleC5cbiAgICAgKiBSZXR1cm5zIGBudWxsYCBpZiB0aGUgZG9jdW1lbnQgZG9lcyBub3QgaGF2ZSBhbGwgZmllbGRzIHNwZWNpZmllZCBpbiB0aGVcbiAgICAgKiBpbmRleC5cbiAgICAgKi9cbiAgICBlbmNvZGVEaXJlY3Rpb25hbEVsZW1lbnRzKGZpZWxkSW5kZXgsIGRvY3VtZW50KSB7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgSW5kZXhCeXRlRW5jb2RlcigpO1xuICAgICAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgZmllbGRJbmRleEdldERpcmVjdGlvbmFsU2VnbWVudHMoZmllbGRJbmRleCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZG9jdW1lbnQuZGF0YS5maWVsZChzZWdtZW50LmZpZWxkUGF0aCk7XG4gICAgICAgICAgICBpZiAoZmllbGQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uYWxFbmNvZGVyID0gZW5jb2Rlci5mb3JLaW5kKHNlZ21lbnQua2luZCk7XG4gICAgICAgICAgICBGaXJlc3RvcmVJbmRleFZhbHVlV3JpdGVyLklOU1RBTkNFLndyaXRlSW5kZXhWYWx1ZShmaWVsZCwgZGlyZWN0aW9uYWxFbmNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5jb2Rlci5lbmNvZGVkQnl0ZXMoKTtcbiAgICB9XG4gICAgLyoqIEVuY29kZXMgYSBzaW5nbGUgdmFsdWUgdG8gdGhlIGFzY2VuZGluZyBpbmRleCBmb3JtYXQuICovXG4gICAgZW5jb2RlU2luZ2xlRWxlbWVudCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IEluZGV4Qnl0ZUVuY29kZXIoKTtcbiAgICAgICAgRmlyZXN0b3JlSW5kZXhWYWx1ZVdyaXRlci5JTlNUQU5DRS53cml0ZUluZGV4VmFsdWUodmFsdWUsIGVuY29kZXIuZm9yS2luZCgwIC8qIEluZGV4S2luZC5BU0NFTkRJTkcgKi8pKTtcbiAgICAgICAgcmV0dXJuIGVuY29kZXIuZW5jb2RlZEJ5dGVzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gZW5jb2RlZCBmb3JtIG9mIHRoZSBkb2N1bWVudCBrZXkgdGhhdCBzb3J0cyBiYXNlZCBvbiB0aGUga2V5XG4gICAgICogb3JkZXJpbmcgb2YgdGhlIGZpZWxkIGluZGV4LlxuICAgICAqL1xuICAgIGVuY29kZURpcmVjdGlvbmFsS2V5KGZpZWxkSW5kZXgsIGRvY3VtZW50S2V5KSB7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgSW5kZXhCeXRlRW5jb2RlcigpO1xuICAgICAgICBGaXJlc3RvcmVJbmRleFZhbHVlV3JpdGVyLklOU1RBTkNFLndyaXRlSW5kZXhWYWx1ZShyZWZWYWx1ZSh0aGlzLmRhdGFiYXNlSWQsIGRvY3VtZW50S2V5KSwgZW5jb2Rlci5mb3JLaW5kKGZpZWxkSW5kZXhHZXRLZXlPcmRlcihmaWVsZEluZGV4KSkpO1xuICAgICAgICByZXR1cm4gZW5jb2Rlci5lbmNvZGVkQnl0ZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGUgZ2l2ZW4gZmllbGQgdmFsdWVzIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWNhdGlvbiBpbiBgdGFyZ2V0YC5cbiAgICAgKiBGb3IgSU4gcXVlcmllcywgYSBsaXN0IG9mIHBvc3NpYmxlIHZhbHVlcyBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBlbmNvZGVWYWx1ZXMoZmllbGRJbmRleCwgdGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlbmNvZGVycyA9IFtdO1xuICAgICAgICBlbmNvZGVycy5wdXNoKG5ldyBJbmRleEJ5dGVFbmNvZGVyKCkpO1xuICAgICAgICBsZXQgdmFsdWVJZHggPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgZmllbGRJbmRleEdldERpcmVjdGlvbmFsU2VnbWVudHMoZmllbGRJbmRleCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW3ZhbHVlSWR4KytdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbmNvZGVyIG9mIGVuY29kZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNJbkZpbHRlcih0YXJnZXQsIHNlZ21lbnQuZmllbGRQYXRoKSAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGVycyA9IHRoaXMuZXhwYW5kSW5kZXhWYWx1ZXMoZW5jb2RlcnMsIHNlZ21lbnQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbmFsRW5jb2RlciA9IGVuY29kZXIuZm9yS2luZChzZWdtZW50LmtpbmQpO1xuICAgICAgICAgICAgICAgICAgICBGaXJlc3RvcmVJbmRleFZhbHVlV3JpdGVyLklOU1RBTkNFLndyaXRlSW5kZXhWYWx1ZSh2YWx1ZSwgZGlyZWN0aW9uYWxFbmNvZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RW5jb2RlZEJ5dGVzKGVuY29kZXJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGUgZ2l2ZW4gYm91bmRzIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWNhdGlvbiBpbiBgdGFyZ2V0YC4gRm9yIElOXG4gICAgICogcXVlcmllcywgYSBsaXN0IG9mIHBvc3NpYmxlIHZhbHVlcyBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBlbmNvZGVCb3VuZChmaWVsZEluZGV4LCB0YXJnZXQsIGJvdW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZVZhbHVlcyhmaWVsZEluZGV4LCB0YXJnZXQsIGJvdW5kLnBvc2l0aW9uKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdGhlIGJ5dGUgcmVwcmVzZW50YXRpb24gZm9yIHRoZSBwcm92aWRlZCBlbmNvZGVycy4gKi9cbiAgICBnZXRFbmNvZGVkQnl0ZXMoZW5jb2RlcnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2RlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IGVuY29kZXJzW2ldLmVuY29kZWRCeXRlcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzZXBhcmF0ZSBlbmNvZGVyIGZvciBlYWNoIGVsZW1lbnQgb2YgYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBUaGUgbWV0aG9kIGFwcGVuZHMgZWFjaCB2YWx1ZSB0byBhbGwgZXhpc3RpbmcgZW5jb2RlcnMgKGUuZy4gZmlsdGVyKFwiYVwiLFxuICAgICAqIFwiPT1cIiwgXCJhMVwiKS5maWx0ZXIoXCJiXCIsIFwiaW5cIiwgW1wiYjFcIiwgXCJiMlwiXSkgYmVjb21lcyBbXCJhMSxiMVwiLCBcImExLGIyXCJdKS4gQVxuICAgICAqIGxpc3Qgb2YgbmV3IGVuY29kZXJzIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGV4cGFuZEluZGV4VmFsdWVzKGVuY29kZXJzLCBzZWdtZW50LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBwcmVmaXhlcyA9IFsuLi5lbmNvZGVyc107XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBhcnJheUVsZW1lbnQgb2YgdmFsdWUuYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW10pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJlZml4IG9mIHByZWZpeGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xvbmVkRW5jb2RlciA9IG5ldyBJbmRleEJ5dGVFbmNvZGVyKCk7XG4gICAgICAgICAgICAgICAgY2xvbmVkRW5jb2Rlci5zZWVkKHByZWZpeC5lbmNvZGVkQnl0ZXMoKSk7XG4gICAgICAgICAgICAgICAgRmlyZXN0b3JlSW5kZXhWYWx1ZVdyaXRlci5JTlNUQU5DRS53cml0ZUluZGV4VmFsdWUoYXJyYXlFbGVtZW50LCBjbG9uZWRFbmNvZGVyLmZvcktpbmQoc2VnbWVudC5raW5kKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGNsb25lZEVuY29kZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBpc0luRmlsdGVyKHRhcmdldCwgZmllbGRQYXRoKSB7XG4gICAgICAgIHJldHVybiAhIXRhcmdldC5maWx0ZXJzLmZpbmQoZiA9PiBmIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIgJiZcbiAgICAgICAgICAgIGYuZmllbGQuaXNFcXVhbChmaWVsZFBhdGgpICYmXG4gICAgICAgICAgICAoZi5vcCA9PT0gXCJpblwiIC8qIE9wZXJhdG9yLklOICovIHx8IGYub3AgPT09IFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovKSk7XG4gICAgfVxuICAgIGdldEZpZWxkSW5kZXhlcyh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ZXMgPSBpbmRleENvbmZpZ3VyYXRpb25TdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IGluZGV4U3RhdGVTdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIHJldHVybiAoY29sbGVjdGlvbkdyb3VwXG4gICAgICAgICAgICA/IGluZGV4ZXMubG9hZEFsbChEYkluZGV4Q29uZmlndXJhdGlvbkNvbGxlY3Rpb25Hcm91cEluZGV4LCBJREJLZXlSYW5nZS5ib3VuZChjb2xsZWN0aW9uR3JvdXAsIGNvbGxlY3Rpb25Hcm91cCkpXG4gICAgICAgICAgICA6IGluZGV4ZXMubG9hZEFsbCgpKS5uZXh0KGluZGV4Q29uZmlncyA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChpbmRleENvbmZpZ3MsIChpbmRleENvbmZpZykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZXNcbiAgICAgICAgICAgICAgICAgICAgLmdldChbaW5kZXhDb25maWcuaW5kZXhJZCwgdGhpcy51aWRdKVxuICAgICAgICAgICAgICAgICAgICAubmV4dChpbmRleFN0YXRlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJvbURiSW5kZXhDb25maWd1cmF0aW9uKGluZGV4Q29uZmlnLCBpbmRleFN0YXRlKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KS5uZXh0KCgpID0+IHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXROZXh0Q29sbGVjdGlvbkdyb3VwVG9VcGRhdGUodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmllbGRJbmRleGVzKHRyYW5zYWN0aW9uKS5uZXh0KGluZGV4ZXMgPT4ge1xuICAgICAgICAgICAgaWYgKGluZGV4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleGVzLnNvcnQoKGwsIHIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbXAgPSBsLmluZGV4U3RhdGUuc2VxdWVuY2VOdW1iZXIgLSByLmluZGV4U3RhdGUuc2VxdWVuY2VOdW1iZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNtcCAhPT0gMFxuICAgICAgICAgICAgICAgICAgICA/IGNtcFxuICAgICAgICAgICAgICAgICAgICA6IHByaW1pdGl2ZUNvbXBhcmF0b3IobC5jb2xsZWN0aW9uR3JvdXAsIHIuY29sbGVjdGlvbkdyb3VwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4ZXNbMF0uY29sbGVjdGlvbkdyb3VwO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlQ29sbGVjdGlvbkdyb3VwKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIG9mZnNldCkge1xuICAgICAgICBjb25zdCBpbmRleGVzID0gaW5kZXhDb25maWd1cmF0aW9uU3RvcmUodHJhbnNhY3Rpb24pO1xuICAgICAgICBjb25zdCBzdGF0ZXMgPSBpbmRleFN0YXRlU3RvcmUodHJhbnNhY3Rpb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXROZXh0U2VxdWVuY2VOdW1iZXIodHJhbnNhY3Rpb24pLm5leHQobmV4dFNlcXVlbmNlTnVtYmVyID0+IGluZGV4ZXNcbiAgICAgICAgICAgIC5sb2FkQWxsKERiSW5kZXhDb25maWd1cmF0aW9uQ29sbGVjdGlvbkdyb3VwSW5kZXgsIElEQktleVJhbmdlLmJvdW5kKGNvbGxlY3Rpb25Hcm91cCwgY29sbGVjdGlvbkdyb3VwKSlcbiAgICAgICAgICAgIC5uZXh0KGNvbmZpZ3MgPT4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goY29uZmlncywgKGNvbmZpZykgPT4gc3RhdGVzLnB1dCh0b0RiSW5kZXhTdGF0ZShjb25maWcuaW5kZXhJZCwgdGhpcy51aWQsIG5leHRTZXF1ZW5jZU51bWJlciwgb2Zmc2V0KSkpKSk7XG4gICAgfVxuICAgIHVwZGF0ZUluZGV4RW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRzKSB7XG4gICAgICAgIC8vIFBvcnRpbmcgTm90ZTogYGdldEZpZWxkSW5kZXhlcygpYCBvbiBXZWIgZG9lcyBub3QgY2FjaGUgaW5kZXggbG9va3VwcyBhc1xuICAgICAgICAvLyBpdCBjb3VsZCBiZSB1c2VkIGFjcm9zcyBkaWZmZXJlbnQgSW5kZXhlZERCIHRyYW5zYWN0aW9ucy4gQXMgYW55IGNhY2hlZFxuICAgICAgICAvLyBkYXRhIG1pZ2h0IGJlIGludmFsaWRhdGVkIGJ5IG90aGVyIG11bHRpLXRhYiBjbGllbnRzLCB3ZSBjYW4gb25seSB0cnVzdFxuICAgICAgICAvLyBkYXRhIHdpdGhpbiBhIHNpbmdsZSBJbmRleGVkREIgdHJhbnNhY3Rpb24uIFdlIHRoZXJlZm9yZSBhZGQgYSBjYWNoZVxuICAgICAgICAvLyBoZXJlLlxuICAgICAgICBjb25zdCBtZW1vaXplZEluZGV4ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChkb2N1bWVudHMsIChrZXksIGRvYykgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWVtb2l6ZWRDb2xsZWN0aW9uSW5kZXhlcyA9IG1lbW9pemVkSW5kZXhlcy5nZXQoa2V5LmNvbGxlY3Rpb25Hcm91cCk7XG4gICAgICAgICAgICBjb25zdCBmaWVsZEluZGV4ZXMgPSBtZW1vaXplZENvbGxlY3Rpb25JbmRleGVzXG4gICAgICAgICAgICAgICAgPyBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShtZW1vaXplZENvbGxlY3Rpb25JbmRleGVzKVxuICAgICAgICAgICAgICAgIDogdGhpcy5nZXRGaWVsZEluZGV4ZXModHJhbnNhY3Rpb24sIGtleS5jb2xsZWN0aW9uR3JvdXApO1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkSW5kZXhlcy5uZXh0KGZpZWxkSW5kZXhlcyA9PiB7XG4gICAgICAgICAgICAgICAgbWVtb2l6ZWRJbmRleGVzLnNldChrZXkuY29sbGVjdGlvbkdyb3VwLCBmaWVsZEluZGV4ZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChmaWVsZEluZGV4ZXMsIChmaWVsZEluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEV4aXN0aW5nSW5kZXhFbnRyaWVzKHRyYW5zYWN0aW9uLCBrZXksIGZpZWxkSW5kZXgpLm5leHQoZXhpc3RpbmdFbnRyaWVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0VudHJpZXMgPSB0aGlzLmNvbXB1dGVJbmRleEVudHJpZXMoZG9jLCBmaWVsZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXhpc3RpbmdFbnRyaWVzLmlzRXF1YWwobmV3RW50cmllcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2MsIGZpZWxkSW5kZXgsIGV4aXN0aW5nRW50cmllcywgbmV3RW50cmllcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZEluZGV4RW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50LCBmaWVsZEluZGV4LCBpbmRleEVudHJ5KSB7XG4gICAgICAgIGNvbnN0IGluZGV4RW50cmllcyA9IGluZGV4RW50cmllc1N0b3JlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIGluZGV4RW50cmllcy5wdXQoe1xuICAgICAgICAgICAgaW5kZXhJZDogaW5kZXhFbnRyeS5pbmRleElkLFxuICAgICAgICAgICAgdWlkOiB0aGlzLnVpZCxcbiAgICAgICAgICAgIGFycmF5VmFsdWU6IGluZGV4RW50cnkuYXJyYXlWYWx1ZSxcbiAgICAgICAgICAgIGRpcmVjdGlvbmFsVmFsdWU6IGluZGV4RW50cnkuZGlyZWN0aW9uYWxWYWx1ZSxcbiAgICAgICAgICAgIG9yZGVyZWREb2N1bWVudEtleTogdGhpcy5lbmNvZGVEaXJlY3Rpb25hbEtleShmaWVsZEluZGV4LCBkb2N1bWVudC5rZXkpLFxuICAgICAgICAgICAgZG9jdW1lbnRLZXk6IGRvY3VtZW50LmtleS5wYXRoLnRvQXJyYXkoKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVsZXRlSW5kZXhFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnQsIGZpZWxkSW5kZXgsIGluZGV4RW50cnkpIHtcbiAgICAgICAgY29uc3QgaW5kZXhFbnRyaWVzID0gaW5kZXhFbnRyaWVzU3RvcmUodHJhbnNhY3Rpb24pO1xuICAgICAgICByZXR1cm4gaW5kZXhFbnRyaWVzLmRlbGV0ZShbXG4gICAgICAgICAgICBpbmRleEVudHJ5LmluZGV4SWQsXG4gICAgICAgICAgICB0aGlzLnVpZCxcbiAgICAgICAgICAgIGluZGV4RW50cnkuYXJyYXlWYWx1ZSxcbiAgICAgICAgICAgIGluZGV4RW50cnkuZGlyZWN0aW9uYWxWYWx1ZSxcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlRGlyZWN0aW9uYWxLZXkoZmllbGRJbmRleCwgZG9jdW1lbnQua2V5KSxcbiAgICAgICAgICAgIGRvY3VtZW50LmtleS5wYXRoLnRvQXJyYXkoKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgZ2V0RXhpc3RpbmdJbmRleEVudHJpZXModHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5LCBmaWVsZEluZGV4KSB7XG4gICAgICAgIGNvbnN0IGluZGV4RW50cmllcyA9IGluZGV4RW50cmllc1N0b3JlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBuZXcgU29ydGVkU2V0KGluZGV4RW50cnlDb21wYXJhdG9yKTtcbiAgICAgICAgcmV0dXJuIGluZGV4RW50cmllc1xuICAgICAgICAgICAgLml0ZXJhdGUoe1xuICAgICAgICAgICAgaW5kZXg6IERiSW5kZXhFbnRyeURvY3VtZW50S2V5SW5kZXgsXG4gICAgICAgICAgICByYW5nZTogSURCS2V5UmFuZ2Uub25seShbXG4gICAgICAgICAgICAgICAgZmllbGRJbmRleC5pbmRleElkLFxuICAgICAgICAgICAgICAgIHRoaXMudWlkLFxuICAgICAgICAgICAgICAgIHRoaXMuZW5jb2RlRGlyZWN0aW9uYWxLZXkoZmllbGRJbmRleCwgZG9jdW1lbnRLZXkpXG4gICAgICAgICAgICBdKVxuICAgICAgICB9LCAoXywgZW50cnkpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmFkZChuZXcgSW5kZXhFbnRyeShmaWVsZEluZGV4LmluZGV4SWQsIGRvY3VtZW50S2V5LCBlbnRyeS5hcnJheVZhbHVlLCBlbnRyeS5kaXJlY3Rpb25hbFZhbHVlKSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiByZXN1bHRzKTtcbiAgICB9XG4gICAgLyoqIENyZWF0ZXMgdGhlIGluZGV4IGVudHJpZXMgZm9yIHRoZSBnaXZlbiBkb2N1bWVudC4gKi9cbiAgICBjb21wdXRlSW5kZXhFbnRyaWVzKGRvY3VtZW50LCBmaWVsZEluZGV4KSB7XG4gICAgICAgIGxldCByZXN1bHRzID0gbmV3IFNvcnRlZFNldChpbmRleEVudHJ5Q29tcGFyYXRvcik7XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbmFsVmFsdWUgPSB0aGlzLmVuY29kZURpcmVjdGlvbmFsRWxlbWVudHMoZmllbGRJbmRleCwgZG9jdW1lbnQpO1xuICAgICAgICBpZiAoZGlyZWN0aW9uYWxWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcnJheVNlZ21lbnQgPSBmaWVsZEluZGV4R2V0QXJyYXlTZWdtZW50KGZpZWxkSW5kZXgpO1xuICAgICAgICBpZiAoYXJyYXlTZWdtZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZG9jdW1lbnQuZGF0YS5maWVsZChhcnJheVNlZ21lbnQuZmllbGRQYXRoKTtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYXJyYXlWYWx1ZSBvZiB2YWx1ZS5hcnJheVZhbHVlLnZhbHVlcyB8fCBbXSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5hZGQobmV3IEluZGV4RW50cnkoZmllbGRJbmRleC5pbmRleElkLCBkb2N1bWVudC5rZXksIHRoaXMuZW5jb2RlU2luZ2xlRWxlbWVudChhcnJheVZhbHVlKSwgZGlyZWN0aW9uYWxWYWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmFkZChuZXcgSW5kZXhFbnRyeShmaWVsZEluZGV4LmluZGV4SWQsIGRvY3VtZW50LmtleSwgRU1QVFlfVkFMVUUsIGRpcmVjdGlvbmFsVmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgaW5kZXggZW50cmllcyBmb3IgdGhlIHByb3ZpZGVkIGRvY3VtZW50IGJ5IGRlbGV0aW5nIGVudHJpZXNcbiAgICAgKiB0aGF0IGFyZSBubyBsb25nZXIgcmVmZXJlbmNlZCBpbiBgbmV3RW50cmllc2AgYW5kIGFkZGluZyBhbGwgbmV3bHkgYWRkZWRcbiAgICAgKiBlbnRyaWVzLlxuICAgICAqL1xuICAgIHVwZGF0ZUVudHJpZXModHJhbnNhY3Rpb24sIGRvY3VtZW50LCBmaWVsZEluZGV4LCBleGlzdGluZ0VudHJpZXMsIG5ld0VudHJpZXMpIHtcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRmLCBcIlVwZGF0aW5nIGluZGV4IGVudHJpZXMgZm9yIGRvY3VtZW50ICclcydcIiwgZG9jdW1lbnQua2V5KTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZGlmZlNvcnRlZFNldHMoZXhpc3RpbmdFbnRyaWVzLCBuZXdFbnRyaWVzLCBpbmRleEVudHJ5Q29tcGFyYXRvciwgXG4gICAgICAgIC8qIG9uQWRkPSAqLyBlbnRyeSA9PiB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuYWRkSW5kZXhFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnQsIGZpZWxkSW5kZXgsIGVudHJ5KSk7XG4gICAgICAgIH0sIFxuICAgICAgICAvKiBvblJlbW92ZT0gKi8gZW50cnkgPT4ge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmRlbGV0ZUluZGV4RW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50LCBmaWVsZEluZGV4LCBlbnRyeSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKTtcbiAgICB9XG4gICAgZ2V0TmV4dFNlcXVlbmNlTnVtYmVyKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGxldCBuZXh0U2VxdWVuY2VOdW1iZXIgPSAxO1xuICAgICAgICBjb25zdCBzdGF0ZXMgPSBpbmRleFN0YXRlU3RvcmUodHJhbnNhY3Rpb24pO1xuICAgICAgICByZXR1cm4gc3RhdGVzXG4gICAgICAgICAgICAuaXRlcmF0ZSh7XG4gICAgICAgICAgICBpbmRleDogRGJJbmRleFN0YXRlU2VxdWVuY2VOdW1iZXJJbmRleCxcbiAgICAgICAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICAgICAgICByYW5nZTogSURCS2V5UmFuZ2UudXBwZXJCb3VuZChbdGhpcy51aWQsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXSlcbiAgICAgICAgfSwgKF8sIHN0YXRlLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmRvbmUoKTtcbiAgICAgICAgICAgIG5leHRTZXF1ZW5jZU51bWJlciA9IHN0YXRlLnNlcXVlbmNlTnVtYmVyICsgMTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IG5leHRTZXF1ZW5jZU51bWJlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgc2V0IG9mIElEQiByYW5nZXMgdGhhdCBzcGxpdHMgdGhlIGV4aXN0aW5nIHJhbmdlIGFuZCBleGNsdWRlc1xuICAgICAqIGFueSB2YWx1ZXMgdGhhdCBtYXRjaCB0aGUgYG5vdEluVmFsdWVgIGZyb20gdGhlc2UgcmFuZ2VzLiBBcyBhbiBleGFtcGxlLFxuICAgICAqICdbZm9vID4gMiAmJiBmb28gIT0gM11gIGJlY29tZXMgIGBbZm9vID4gMiAmJiA8IDMsIGZvbyA+IDNdYC5cbiAgICAgKi9cbiAgICBjcmVhdGVSYW5nZShsb3dlciwgdXBwZXIsIG5vdEluVmFsdWVzKSB7XG4gICAgICAgIC8vIFRoZSBub3RJbiB2YWx1ZXMgbmVlZCB0byBiZSBzb3J0ZWQgYW5kIHVuaXF1ZSBzbyB0aGF0IHdlIGNhbiByZXR1cm4gYVxuICAgICAgICAvLyBzb3J0ZWQgc2V0IG9mIG5vbi1vdmVybGFwcGluZyByYW5nZXMuXG4gICAgICAgIG5vdEluVmFsdWVzID0gbm90SW5WYWx1ZXNcbiAgICAgICAgICAgIC5zb3J0KChsLCByKSA9PiBpbmRleEVudHJ5Q29tcGFyYXRvcihsLCByKSlcbiAgICAgICAgICAgIC5maWx0ZXIoKGVsLCBpLCB2YWx1ZXMpID0+ICFpIHx8IGluZGV4RW50cnlDb21wYXJhdG9yKGVsLCB2YWx1ZXNbaSAtIDFdKSAhPT0gMCk7XG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IFtdO1xuICAgICAgICBib3VuZHMucHVzaChsb3dlcik7XG4gICAgICAgIGZvciAoY29uc3Qgbm90SW5WYWx1ZSBvZiBub3RJblZhbHVlcykge1xuICAgICAgICAgICAgY29uc3QgY21wVG9Mb3dlciA9IGluZGV4RW50cnlDb21wYXJhdG9yKG5vdEluVmFsdWUsIGxvd2VyKTtcbiAgICAgICAgICAgIGNvbnN0IGNtcFRvVXBwZXIgPSBpbmRleEVudHJ5Q29tcGFyYXRvcihub3RJblZhbHVlLCB1cHBlcik7XG4gICAgICAgICAgICBpZiAoY21wVG9Mb3dlciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGBub3RJblZhbHVlYCBpcyB0aGUgbG93ZXIgYm91bmQuIFdlIHRoZXJlZm9yZSBuZWVkIHRvIHJhaXNlIHRoZSBib3VuZFxuICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBuZXh0IHZhbHVlLlxuICAgICAgICAgICAgICAgIGJvdW5kc1swXSA9IGxvd2VyLnN1Y2Nlc3NvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21wVG9Mb3dlciA+IDAgJiYgY21wVG9VcHBlciA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBgbm90SW5WYWx1ZWAgaXMgaW4gdGhlIG1pZGRsZSBvZiB0aGUgcmFuZ2VcbiAgICAgICAgICAgICAgICBib3VuZHMucHVzaChub3RJblZhbHVlKTtcbiAgICAgICAgICAgICAgICBib3VuZHMucHVzaChub3RJblZhbHVlLnN1Y2Nlc3NvcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcFRvVXBwZXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gYG5vdEluVmFsdWVgIChhbmQgYWxsIGZvbGxvd2luZyB2YWx1ZXMpIGFyZSBvdXQgb2YgdGhlIHJhbmdlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYm91bmRzLnB1c2godXBwZXIpO1xuICAgICAgICBjb25zdCByYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib3VuZHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGVuY291bnRlciB0d28gYm91bmRzIHRoYXQgd2lsbCBjcmVhdGUgYW4gdW5tYXRjaGFibGUga2V5IHJhbmdlLFxuICAgICAgICAgICAgLy8gdGhlbiB3ZSByZXR1cm4gYW4gZW1wdHkgc2V0IG9mIGtleSByYW5nZXMuXG4gICAgICAgICAgICBpZiAodGhpcy5pc1JhbmdlTWF0Y2hhYmxlKGJvdW5kc1tpXSwgYm91bmRzW2kgKyAxXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb3dlckJvdW5kID0gW1xuICAgICAgICAgICAgICAgIGJvdW5kc1tpXS5pbmRleElkLFxuICAgICAgICAgICAgICAgIHRoaXMudWlkLFxuICAgICAgICAgICAgICAgIGJvdW5kc1tpXS5hcnJheVZhbHVlLFxuICAgICAgICAgICAgICAgIGJvdW5kc1tpXS5kaXJlY3Rpb25hbFZhbHVlLFxuICAgICAgICAgICAgICAgIEVNUFRZX1ZBTFVFLFxuICAgICAgICAgICAgICAgIFtdXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY29uc3QgdXBwZXJCb3VuZCA9IFtcbiAgICAgICAgICAgICAgICBib3VuZHNbaSArIDFdLmluZGV4SWQsXG4gICAgICAgICAgICAgICAgdGhpcy51aWQsXG4gICAgICAgICAgICAgICAgYm91bmRzW2kgKyAxXS5hcnJheVZhbHVlLFxuICAgICAgICAgICAgICAgIGJvdW5kc1tpICsgMV0uZGlyZWN0aW9uYWxWYWx1ZSxcbiAgICAgICAgICAgICAgICBFTVBUWV9WQUxVRSxcbiAgICAgICAgICAgICAgICBbXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKElEQktleVJhbmdlLmJvdW5kKGxvd2VyQm91bmQsIHVwcGVyQm91bmQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH1cbiAgICBpc1JhbmdlTWF0Y2hhYmxlKGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHtcbiAgICAgICAgLy8gSWYgbG93ZXIgYm91bmQgaXMgZ3JlYXRlciB0aGFuIHRoZSB1cHBlciBib3VuZCwgdGhlbiB0aGUga2V5XG4gICAgICAgIC8vIHJhbmdlIGNhbiBuZXZlciBiZSBtYXRjaGVkLlxuICAgICAgICByZXR1cm4gaW5kZXhFbnRyeUNvbXBhcmF0b3IobG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkgPiAwO1xuICAgIH1cbiAgICBnZXRNaW5PZmZzZXRGcm9tQ29sbGVjdGlvbkdyb3VwKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmllbGRJbmRleGVzKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXApLm5leHQoZ2V0TWluT2Zmc2V0RnJvbUZpZWxkSW5kZXhlcyk7XG4gICAgfVxuICAgIGdldE1pbk9mZnNldCh0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UubWFwQXJyYXkodGhpcy5nZXRTdWJUYXJnZXRzKHRhcmdldCksIChzdWJUYXJnZXQpID0+IHRoaXMuZ2V0RmllbGRJbmRleCh0cmFuc2FjdGlvbiwgc3ViVGFyZ2V0KS5uZXh0KGluZGV4ID0+IGluZGV4ID8gaW5kZXggOiBmYWlsKCkpKS5uZXh0KGdldE1pbk9mZnNldEZyb21GaWVsZEluZGV4ZXMpO1xuICAgIH1cbn1cbi8qKlxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBjb2xsZWN0aW9uUGFyZW50c1xuICogZG9jdW1lbnQgc3RvcmUuXG4gKi9cbmZ1bmN0aW9uIGNvbGxlY3Rpb25QYXJlbnRzU3RvcmUodHhuKSB7XG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJDb2xsZWN0aW9uUGFyZW50U3RvcmUpO1xufVxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIGluZGV4IGVudHJ5IG9iamVjdCBzdG9yZS5cbiAqL1xuZnVuY3Rpb24gaW5kZXhFbnRyaWVzU3RvcmUodHhuKSB7XG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJJbmRleEVudHJ5U3RvcmUpO1xufVxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIGluZGV4IGNvbmZpZ3VyYXRpb24gb2JqZWN0IHN0b3JlLlxuICovXG5mdW5jdGlvbiBpbmRleENvbmZpZ3VyYXRpb25TdG9yZSh0eG4pIHtcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYkluZGV4Q29uZmlndXJhdGlvblN0b3JlKTtcbn1cbi8qKlxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBpbmRleCBzdGF0ZSBvYmplY3Qgc3RvcmUuXG4gKi9cbmZ1bmN0aW9uIGluZGV4U3RhdGVTdG9yZSh0eG4pIHtcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYkluZGV4U3RhdGVTdG9yZSk7XG59XG5mdW5jdGlvbiBnZXRNaW5PZmZzZXRGcm9tRmllbGRJbmRleGVzKGZpZWxkSW5kZXhlcykge1xuICAgIGhhcmRBc3NlcnQoZmllbGRJbmRleGVzLmxlbmd0aCAhPT0gMCk7XG4gICAgbGV0IG1pbk9mZnNldCA9IGZpZWxkSW5kZXhlc1swXS5pbmRleFN0YXRlLm9mZnNldDtcbiAgICBsZXQgbWF4QmF0Y2hJZCA9IG1pbk9mZnNldC5sYXJnZXN0QmF0Y2hJZDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGZpZWxkSW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBuZXdPZmZzZXQgPSBmaWVsZEluZGV4ZXNbaV0uaW5kZXhTdGF0ZS5vZmZzZXQ7XG4gICAgICAgIGlmIChpbmRleE9mZnNldENvbXBhcmF0b3IobmV3T2Zmc2V0LCBtaW5PZmZzZXQpIDwgMCkge1xuICAgICAgICAgICAgbWluT2Zmc2V0ID0gbmV3T2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhCYXRjaElkIDwgbmV3T2Zmc2V0Lmxhcmdlc3RCYXRjaElkKSB7XG4gICAgICAgICAgICBtYXhCYXRjaElkID0gbmV3T2Zmc2V0Lmxhcmdlc3RCYXRjaElkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgSW5kZXhPZmZzZXQobWluT2Zmc2V0LnJlYWRUaW1lLCBtaW5PZmZzZXQuZG9jdW1lbnRLZXksIG1heEJhdGNoSWQpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBEZWxldGUgYSBtdXRhdGlvbiBiYXRjaCBhbmQgdGhlIGFzc29jaWF0ZWQgZG9jdW1lbnQgbXV0YXRpb25zLlxuICogQHJldHVybnMgQSBQZXJzaXN0ZW5jZVByb21pc2Ugb2YgdGhlIGRvY3VtZW50IG11dGF0aW9ucyB0aGF0IHdlcmUgcmVtb3ZlZC5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlTXV0YXRpb25CYXRjaCh0eG4sIHVzZXJJZCwgYmF0Y2gpIHtcbiAgICBjb25zdCBtdXRhdGlvblN0b3JlID0gdHhuLnN0b3JlKERiTXV0YXRpb25CYXRjaFN0b3JlKTtcbiAgICBjb25zdCBpbmRleFR4biA9IHR4bi5zdG9yZShEYkRvY3VtZW50TXV0YXRpb25TdG9yZSk7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLm9ubHkoYmF0Y2guYmF0Y2hJZCk7XG4gICAgbGV0IG51bURlbGV0ZWQgPSAwO1xuICAgIGNvbnN0IHJlbW92ZVByb21pc2UgPSBtdXRhdGlvblN0b3JlLml0ZXJhdGUoeyByYW5nZSB9LCAoa2V5LCB2YWx1ZSwgY29udHJvbCkgPT4ge1xuICAgICAgICBudW1EZWxldGVkKys7XG4gICAgICAgIHJldHVybiBjb250cm9sLmRlbGV0ZSgpO1xuICAgIH0pO1xuICAgIHByb21pc2VzLnB1c2gocmVtb3ZlUHJvbWlzZS5uZXh0KCgpID0+IHtcbiAgICAgICAgaGFyZEFzc2VydChudW1EZWxldGVkID09PSAxKTtcbiAgICB9KSk7XG4gICAgY29uc3QgcmVtb3ZlZERvY3VtZW50cyA9IFtdO1xuICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgYmF0Y2gubXV0YXRpb25zKSB7XG4gICAgICAgIGNvbnN0IGluZGV4S2V5ID0gbmV3RGJEb2N1bWVudE11dGF0aW9uS2V5KHVzZXJJZCwgbXV0YXRpb24ua2V5LnBhdGgsIGJhdGNoLmJhdGNoSWQpO1xuICAgICAgICBwcm9taXNlcy5wdXNoKGluZGV4VHhuLmRlbGV0ZShpbmRleEtleSkpO1xuICAgICAgICByZW1vdmVkRG9jdW1lbnRzLnB1c2gobXV0YXRpb24ua2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKS5uZXh0KCgpID0+IHJlbW92ZWREb2N1bWVudHMpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGFuIGFwcHJveGltYXRlIHNpemUgZm9yIHRoZSBnaXZlbiBkb2N1bWVudC5cbiAqL1xuZnVuY3Rpb24gZGJEb2N1bWVudFNpemUoZG9jKSB7XG4gICAgaWYgKCFkb2MpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGxldCB2YWx1ZTtcbiAgICBpZiAoZG9jLmRvY3VtZW50KSB7XG4gICAgICAgIHZhbHVlID0gZG9jLmRvY3VtZW50O1xuICAgIH1cbiAgICBlbHNlIGlmIChkb2MudW5rbm93bkRvY3VtZW50KSB7XG4gICAgICAgIHZhbHVlID0gZG9jLnVua25vd25Eb2N1bWVudDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZG9jLm5vRG9jdW1lbnQpIHtcbiAgICAgICAgdmFsdWUgPSBkb2Mubm9Eb2N1bWVudDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IGZhaWwoKTtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5sZW5ndGg7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogQSBtdXRhdGlvbiBxdWV1ZSBmb3IgYSBzcGVjaWZpYyB1c2VyLCBiYWNrZWQgYnkgSW5kZXhlZERCLiAqL1xuY2xhc3MgSW5kZXhlZERiTXV0YXRpb25RdWV1ZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogVGhlIG5vcm1hbGl6ZWQgdXNlcklkIChlLmcuIG51bGwgVUlEID0+IFwiXCIgdXNlcklkKSB1c2VkIHRvIHN0b3JlIC9cbiAgICAgKiByZXRyaWV2ZSBtdXRhdGlvbnMuXG4gICAgICovXG4gICAgdXNlcklkLCBzZXJpYWxpemVyLCBpbmRleE1hbmFnZXIsIHJlZmVyZW5jZURlbGVnYXRlKSB7XG4gICAgICAgIHRoaXMudXNlcklkID0gdXNlcklkO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xuICAgICAgICB0aGlzLmluZGV4TWFuYWdlciA9IGluZGV4TWFuYWdlcjtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZSA9IHJlZmVyZW5jZURlbGVnYXRlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FjaGVzIHRoZSBkb2N1bWVudCBrZXlzIGZvciBwZW5kaW5nIG11dGF0aW9uIGJhdGNoZXMuIElmIHRoZSBtdXRhdGlvblxuICAgICAgICAgKiBoYXMgYmVlbiByZW1vdmVkIGZyb20gSW5kZXhlZERiLCB0aGUgY2FjaGVkIHZhbHVlIG1heSBjb250aW51ZSB0b1xuICAgICAgICAgKiBiZSB1c2VkIHRvIHJldHJpZXZlIHRoZSBiYXRjaCdzIGRvY3VtZW50IGtleXMuIFRvIHJlbW92ZSBhIGNhY2hlZCB2YWx1ZVxuICAgICAgICAgKiBsb2NhbGx5LCBgcmVtb3ZlQ2FjaGVkTXV0YXRpb25LZXlzKClgIHNob3VsZCBiZSBpbnZva2VkIGVpdGhlciBkaXJlY3RseVxuICAgICAgICAgKiBvciB0aHJvdWdoIGByZW1vdmVNdXRhdGlvbkJhdGNoZXMoKWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdpdGggbXVsdGktdGFiLCB3aGVuIHRoZSBwcmltYXJ5IGNsaWVudCBhY2tub3dsZWRnZXMgb3IgcmVqZWN0cyBhIG11dGF0aW9uLFxuICAgICAgICAgKiB0aGlzIGNhY2hlIGlzIHVzZWQgYnkgc2Vjb25kYXJ5IGNsaWVudHMgdG8gaW52YWxpZGF0ZSB0aGUgbG9jYWxcbiAgICAgICAgICogdmlldyBvZiB0aGUgZG9jdW1lbnRzIHRoYXQgd2VyZSBwcmV2aW91c2x5IGFmZmVjdGVkIGJ5IHRoZSBtdXRhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIC8vIFBPUlRJTkcgTk9URTogTXVsdGktdGFiIG9ubHkuXG4gICAgICAgIHRoaXMuZG9jdW1lbnRLZXlzQnlCYXRjaElkID0ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgbXV0YXRpb24gcXVldWUgZm9yIHRoZSBnaXZlbiB1c2VyLlxuICAgICAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIgZm9yIHdoaWNoIHRvIGNyZWF0ZSBhIG11dGF0aW9uIHF1ZXVlLlxuICAgICAqIEBwYXJhbSBzZXJpYWxpemVyIC0gVGhlIHNlcmlhbGl6ZXIgdG8gdXNlIHdoZW4gcGVyc2lzdGluZyB0byBJbmRleGVkRGIuXG4gICAgICovXG4gICAgc3RhdGljIGZvclVzZXIodXNlciwgc2VyaWFsaXplciwgaW5kZXhNYW5hZ2VyLCByZWZlcmVuY2VEZWxlZ2F0ZSkge1xuICAgICAgICAvLyBUT0RPKG1jZyk6IEZpZ3VyZSBvdXQgd2hhdCBjb25zdHJhaW50cyB0aGVyZSBhcmUgb24gdXNlcklEc1xuICAgICAgICAvLyBJbiBwYXJ0aWN1bGFyLCBhcmUgdGhlcmUgYW55IHJlc2VydmVkIGNoYXJhY3RlcnM/IGFyZSBlbXB0eSBpZHMgYWxsb3dlZD9cbiAgICAgICAgLy8gRm9yIHRoZSBtb21lbnQgc3RvcmUgdGhlc2UgdG9nZXRoZXIgaW4gdGhlIHNhbWUgbXV0YXRpb25zIHRhYmxlIGFzc3VtaW5nXG4gICAgICAgIC8vIHRoYXQgZW1wdHkgdXNlcklEcyBhcmVuJ3QgYWxsb3dlZC5cbiAgICAgICAgaGFyZEFzc2VydCh1c2VyLnVpZCAhPT0gJycpO1xuICAgICAgICBjb25zdCB1c2VySWQgPSB1c2VyLmlzQXV0aGVudGljYXRlZCgpID8gdXNlci51aWQgOiAnJztcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleGVkRGJNdXRhdGlvblF1ZXVlKHVzZXJJZCwgc2VyaWFsaXplciwgaW5kZXhNYW5hZ2VyLCByZWZlcmVuY2VEZWxlZ2F0ZSk7XG4gICAgfVxuICAgIGNoZWNrRW1wdHkodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgbGV0IGVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbdGhpcy51c2VySWQsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWV0sIFt0aGlzLnVzZXJJZCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSk7XG4gICAgICAgIHJldHVybiBtdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5pdGVyYXRlKHsgaW5kZXg6IERiTXV0YXRpb25CYXRjaFVzZXJNdXRhdGlvbnNJbmRleCwgcmFuZ2UgfSwgKGtleSwgdmFsdWUsIGNvbnRyb2wpID0+IHtcbiAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGVtcHR5KTtcbiAgICB9XG4gICAgYWRkTXV0YXRpb25CYXRjaCh0cmFuc2FjdGlvbiwgbG9jYWxXcml0ZVRpbWUsIGJhc2VNdXRhdGlvbnMsIG11dGF0aW9ucykge1xuICAgICAgICBjb25zdCBkb2N1bWVudFN0b3JlID0gZG9jdW1lbnRNdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uU3RvcmUgPSBtdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIC8vIFRoZSBJbmRleGVkRGIgaW1wbGVtZW50YXRpb24gaW4gQ2hyb21lIChhbmQgRmlyZWZveCkgZG9lcyBub3QgaGFuZGxlXG4gICAgICAgIC8vIGNvbXBvdW5kIGluZGljZXMgdGhhdCBpbmNsdWRlIGF1dG8tZ2VuZXJhdGVkIGtleXMgY29ycmVjdGx5LiBUbyBlbnN1cmVcbiAgICAgICAgLy8gdGhhdCB0aGUgaW5kZXggZW50cnkgaXMgYWRkZWQgY29ycmVjdGx5IGluIGFsbCBicm93c2Vycywgd2UgcGVyZm9ybSB0d29cbiAgICAgICAgLy8gd3JpdGVzOiBUaGUgZmlyc3Qgd3JpdGUgaXMgdXNlZCB0byByZXRyaWV2ZSB0aGUgbmV4dCBhdXRvLWdlbmVyYXRlZCBCYXRjaFxuICAgICAgICAvLyBJRCwgYW5kIHRoZSBzZWNvbmQgd3JpdGUgcG9wdWxhdGVzIHRoZSBpbmRleCBhbmQgc3RvcmVzIHRoZSBhY3R1YWxcbiAgICAgICAgLy8gbXV0YXRpb24gYmF0Y2guXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NzAxOTcyXG4gICAgICAgIC8vIFdlIHdyaXRlIGFuIGVtcHR5IG9iamVjdCB0byBvYnRhaW4ga2V5XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBtdXRhdGlvblN0b3JlLmFkZCh7fSkubmV4dChiYXRjaElkID0+IHtcbiAgICAgICAgICAgIGhhcmRBc3NlcnQodHlwZW9mIGJhdGNoSWQgPT09ICdudW1iZXInKTtcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gbmV3IE11dGF0aW9uQmF0Y2goYmF0Y2hJZCwgbG9jYWxXcml0ZVRpbWUsIGJhc2VNdXRhdGlvbnMsIG11dGF0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBkYkJhdGNoID0gdG9EYk11dGF0aW9uQmF0Y2godGhpcy5zZXJpYWxpemVyLCB0aGlzLnVzZXJJZCwgYmF0Y2gpO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIGxldCBjb2xsZWN0aW9uUGFyZW50cyA9IG5ldyBTb3J0ZWRTZXQoKGwsIHIpID0+IHByaW1pdGl2ZUNvbXBhcmF0b3IobC5jYW5vbmljYWxTdHJpbmcoKSwgci5jYW5vbmljYWxTdHJpbmcoKSkpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleEtleSA9IG5ld0RiRG9jdW1lbnRNdXRhdGlvbktleSh0aGlzLnVzZXJJZCwgbXV0YXRpb24ua2V5LnBhdGgsIGJhdGNoSWQpO1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25QYXJlbnRzID0gY29sbGVjdGlvblBhcmVudHMuYWRkKG11dGF0aW9uLmtleS5wYXRoLnBvcExhc3QoKSk7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChtdXRhdGlvblN0b3JlLnB1dChkYkJhdGNoKSk7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChkb2N1bWVudFN0b3JlLnB1dChpbmRleEtleSwgRGJEb2N1bWVudE11dGF0aW9uUGxhY2Vob2xkZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbGxlY3Rpb25QYXJlbnRzLmZvckVhY2gocGFyZW50ID0+IHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuaW5kZXhNYW5hZ2VyLmFkZFRvQ29sbGVjdGlvblBhcmVudEluZGV4KHRyYW5zYWN0aW9uLCBwYXJlbnQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uYWRkT25Db21taXR0ZWRMaXN0ZW5lcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb2N1bWVudEtleXNCeUJhdGNoSWRbYmF0Y2hJZF0gPSBiYXRjaC5rZXlzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcykubmV4dCgoKSA9PiBiYXRjaCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsb29rdXBNdXRhdGlvbkJhdGNoKHRyYW5zYWN0aW9uLCBiYXRjaElkKSB7XG4gICAgICAgIHJldHVybiBtdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5nZXQoYmF0Y2hJZClcbiAgICAgICAgICAgIC5uZXh0KGRiQmF0Y2ggPT4ge1xuICAgICAgICAgICAgaWYgKGRiQmF0Y2gpIHtcbiAgICAgICAgICAgICAgICBoYXJkQXNzZXJ0KGRiQmF0Y2gudXNlcklkID09PSB0aGlzLnVzZXJJZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21EYk11dGF0aW9uQmF0Y2godGhpcy5zZXJpYWxpemVyLCBkYkJhdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZG9jdW1lbnQga2V5cyBmb3IgdGhlIG11dGF0aW9uIGJhdGNoIHdpdGggdGhlIGdpdmVuIGJhdGNoSWQuXG4gICAgICogRm9yIHByaW1hcnkgY2xpZW50cywgdGhpcyBtZXRob2QgcmV0dXJucyBgbnVsbGAgYWZ0ZXJcbiAgICAgKiBgcmVtb3ZlTXV0YXRpb25CYXRjaGVzKClgIGhhcyBiZWVuIGNhbGxlZC4gU2Vjb25kYXJ5IGNsaWVudHMgcmV0dXJuIGFcbiAgICAgKiBjYWNoZWQgcmVzdWx0IHVudGlsIGByZW1vdmVDYWNoZWRNdXRhdGlvbktleXMoKWAgaXMgaW52b2tlZC5cbiAgICAgKi9cbiAgICAvLyBQT1JUSU5HIE5PVEU6IE11bHRpLXRhYiBvbmx5LlxuICAgIGxvb2t1cE11dGF0aW9uS2V5cyh0cmFuc2FjdGlvbiwgYmF0Y2hJZCkge1xuICAgICAgICBpZiAodGhpcy5kb2N1bWVudEtleXNCeUJhdGNoSWRbYmF0Y2hJZF0pIHtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmRvY3VtZW50S2V5c0J5QmF0Y2hJZFtiYXRjaElkXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb29rdXBNdXRhdGlvbkJhdGNoKHRyYW5zYWN0aW9uLCBiYXRjaElkKS5uZXh0KGJhdGNoID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYmF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IGJhdGNoLmtleXMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2N1bWVudEtleXNCeUJhdGNoSWRbYmF0Y2hJZF0gPSBrZXlzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE5leHRNdXRhdGlvbkJhdGNoQWZ0ZXJCYXRjaElkKHRyYW5zYWN0aW9uLCBiYXRjaElkKSB7XG4gICAgICAgIGNvbnN0IG5leHRCYXRjaElkID0gYmF0Y2hJZCArIDE7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChbdGhpcy51c2VySWQsIG5leHRCYXRjaElkXSk7XG4gICAgICAgIGxldCBmb3VuZEJhdGNoID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uc1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLml0ZXJhdGUoeyBpbmRleDogRGJNdXRhdGlvbkJhdGNoVXNlck11dGF0aW9uc0luZGV4LCByYW5nZSB9LCAoa2V5LCBkYkJhdGNoLCBjb250cm9sKSA9PiB7XG4gICAgICAgICAgICBpZiAoZGJCYXRjaC51c2VySWQgPT09IHRoaXMudXNlcklkKSB7XG4gICAgICAgICAgICAgICAgaGFyZEFzc2VydChkYkJhdGNoLmJhdGNoSWQgPj0gbmV4dEJhdGNoSWQpO1xuICAgICAgICAgICAgICAgIGZvdW5kQmF0Y2ggPSBmcm9tRGJNdXRhdGlvbkJhdGNoKHRoaXMuc2VyaWFsaXplciwgZGJCYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGZvdW5kQmF0Y2gpO1xuICAgIH1cbiAgICBnZXRIaWdoZXN0VW5hY2tub3dsZWRnZWRCYXRjaElkKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UudXBwZXJCb3VuZChbXG4gICAgICAgICAgICB0aGlzLnVzZXJJZCxcbiAgICAgICAgICAgIE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICAgICAgICBdKTtcbiAgICAgICAgbGV0IGJhdGNoSWQgPSBCQVRDSElEX1VOS05PV047XG4gICAgICAgIHJldHVybiBtdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5pdGVyYXRlKHsgaW5kZXg6IERiTXV0YXRpb25CYXRjaFVzZXJNdXRhdGlvbnNJbmRleCwgcmFuZ2UsIHJldmVyc2U6IHRydWUgfSwgKGtleSwgZGJCYXRjaCwgY29udHJvbCkgPT4ge1xuICAgICAgICAgICAgYmF0Y2hJZCA9IGRiQmF0Y2guYmF0Y2hJZDtcbiAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gYmF0Y2hJZCk7XG4gICAgfVxuICAgIGdldEFsbE11dGF0aW9uQmF0Y2hlcyh0cmFuc2FjdGlvbikge1xuICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKFt0aGlzLnVzZXJJZCwgQkFUQ0hJRF9VTktOT1dOXSwgW3RoaXMudXNlcklkLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldKTtcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uc1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLmxvYWRBbGwoRGJNdXRhdGlvbkJhdGNoVXNlck11dGF0aW9uc0luZGV4LCByYW5nZSlcbiAgICAgICAgICAgIC5uZXh0KGRiQmF0Y2hlcyA9PiBkYkJhdGNoZXMubWFwKGRiQmF0Y2ggPT4gZnJvbURiTXV0YXRpb25CYXRjaCh0aGlzLnNlcmlhbGl6ZXIsIGRiQmF0Y2gpKSk7XG4gICAgfVxuICAgIGdldEFsbE11dGF0aW9uQmF0Y2hlc0FmZmVjdGluZ0RvY3VtZW50S2V5KHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleSkge1xuICAgICAgICAvLyBTY2FuIHRoZSBkb2N1bWVudC1tdXRhdGlvbiBpbmRleCBzdGFydGluZyB3aXRoIGEgcHJlZml4IHN0YXJ0aW5nIHdpdGhcbiAgICAgICAgLy8gdGhlIGdpdmVuIGRvY3VtZW50S2V5LlxuICAgICAgICBjb25zdCBpbmRleFByZWZpeCA9IG5ld0RiRG9jdW1lbnRNdXRhdGlvblByZWZpeEZvclBhdGgodGhpcy51c2VySWQsIGRvY3VtZW50S2V5LnBhdGgpO1xuICAgICAgICBjb25zdCBpbmRleFN0YXJ0ID0gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChpbmRleFByZWZpeCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50TXV0YXRpb25zU3RvcmUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAuaXRlcmF0ZSh7IHJhbmdlOiBpbmRleFN0YXJ0IH0sIChpbmRleEtleSwgXywgY29udHJvbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW3VzZXJJRCwgZW5jb2RlZFBhdGgsIGJhdGNoSWRdID0gaW5kZXhLZXk7XG4gICAgICAgICAgICAvLyBPbmx5IGNvbnNpZGVyIHJvd3MgbWF0Y2hpbmcgZXhhY3RseSB0aGUgc3BlY2lmaWMga2V5IG9mXG4gICAgICAgICAgICAvLyBpbnRlcmVzdC4gTm90ZSB0aGF0IGJlY2F1c2Ugd2Ugb3JkZXIgYnkgcGF0aCBmaXJzdCwgYW5kIHdlXG4gICAgICAgICAgICAvLyBvcmRlciB0ZXJtaW5hdG9ycyBiZWZvcmUgcGF0aCBzZXBhcmF0b3JzLCB3ZSdsbCBlbmNvdW50ZXIgYWxsXG4gICAgICAgICAgICAvLyB0aGUgaW5kZXggcm93cyBmb3IgZG9jdW1lbnRLZXkgY29udGlndW91c2x5LiBJbiBwYXJ0aWN1bGFyLCBhbGxcbiAgICAgICAgICAgIC8vIHRoZSByb3dzIGZvciBkb2N1bWVudEtleSB3aWxsIG9jY3VyIGJlZm9yZSBhbnkgcm93cyBmb3JcbiAgICAgICAgICAgIC8vIGRvY3VtZW50cyBuZXN0ZWQgaW4gYSBzdWJjb2xsZWN0aW9uIGJlbmVhdGggZG9jdW1lbnRLZXkgc28gd2VcbiAgICAgICAgICAgIC8vIGNhbiBzdG9wIGFzIHNvb24gYXMgd2UgaGl0IGFueSBzdWNoIHJvdy5cbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBkZWNvZGVSZXNvdXJjZVBhdGgoZW5jb2RlZFBhdGgpO1xuICAgICAgICAgICAgaWYgKHVzZXJJRCAhPT0gdGhpcy51c2VySWQgfHwgIWRvY3VtZW50S2V5LnBhdGguaXNFcXVhbChwYXRoKSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIExvb2sgdXAgdGhlIG11dGF0aW9uIGJhdGNoIGluIHRoZSBzdG9yZS5cbiAgICAgICAgICAgIHJldHVybiBtdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgICAgICAuZ2V0KGJhdGNoSWQpXG4gICAgICAgICAgICAgICAgLm5leHQobXV0YXRpb24gPT4ge1xuICAgICAgICAgICAgICAgIGlmICghbXV0YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZmFpbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYXJkQXNzZXJ0KG11dGF0aW9uLnVzZXJJZCA9PT0gdGhpcy51c2VySWQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChmcm9tRGJNdXRhdGlvbkJhdGNoKHRoaXMuc2VyaWFsaXplciwgbXV0YXRpb24pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gcmVzdWx0cyk7XG4gICAgfVxuICAgIGdldEFsbE11dGF0aW9uQmF0Y2hlc0FmZmVjdGluZ0RvY3VtZW50S2V5cyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKSB7XG4gICAgICAgIGxldCB1bmlxdWVCYXRjaElEcyA9IG5ldyBTb3J0ZWRTZXQocHJpbWl0aXZlQ29tcGFyYXRvcik7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIGRvY3VtZW50S2V5cy5mb3JFYWNoKGRvY3VtZW50S2V5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4U3RhcnQgPSBuZXdEYkRvY3VtZW50TXV0YXRpb25QcmVmaXhGb3JQYXRoKHRoaXMudXNlcklkLCBkb2N1bWVudEtleS5wYXRoKTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChpbmRleFN0YXJ0KTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBkb2N1bWVudE11dGF0aW9uc1N0b3JlKHRyYW5zYWN0aW9uKS5pdGVyYXRlKHsgcmFuZ2UgfSwgKGluZGV4S2V5LCBfLCBjb250cm9sKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3VzZXJJRCwgZW5jb2RlZFBhdGgsIGJhdGNoSURdID0gaW5kZXhLZXk7XG4gICAgICAgICAgICAgICAgLy8gT25seSBjb25zaWRlciByb3dzIG1hdGNoaW5nIGV4YWN0bHkgdGhlIHNwZWNpZmljIGtleSBvZlxuICAgICAgICAgICAgICAgIC8vIGludGVyZXN0LiBOb3RlIHRoYXQgYmVjYXVzZSB3ZSBvcmRlciBieSBwYXRoIGZpcnN0LCBhbmQgd2VcbiAgICAgICAgICAgICAgICAvLyBvcmRlciB0ZXJtaW5hdG9ycyBiZWZvcmUgcGF0aCBzZXBhcmF0b3JzLCB3ZSdsbCBlbmNvdW50ZXIgYWxsXG4gICAgICAgICAgICAgICAgLy8gdGhlIGluZGV4IHJvd3MgZm9yIGRvY3VtZW50S2V5IGNvbnRpZ3VvdXNseS4gSW4gcGFydGljdWxhciwgYWxsXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJvd3MgZm9yIGRvY3VtZW50S2V5IHdpbGwgb2NjdXIgYmVmb3JlIGFueSByb3dzIGZvclxuICAgICAgICAgICAgICAgIC8vIGRvY3VtZW50cyBuZXN0ZWQgaW4gYSBzdWJjb2xsZWN0aW9uIGJlbmVhdGggZG9jdW1lbnRLZXkgc28gd2VcbiAgICAgICAgICAgICAgICAvLyBjYW4gc3RvcCBhcyBzb29uIGFzIHdlIGhpdCBhbnkgc3VjaCByb3cuXG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IGRlY29kZVJlc291cmNlUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHVzZXJJRCAhPT0gdGhpcy51c2VySWQgfHwgIWRvY3VtZW50S2V5LnBhdGguaXNFcXVhbChwYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bmlxdWVCYXRjaElEcyA9IHVuaXF1ZUJhdGNoSURzLmFkZChiYXRjaElEKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcykubmV4dCgoKSA9PiB0aGlzLmxvb2t1cE11dGF0aW9uQmF0Y2hlcyh0cmFuc2FjdGlvbiwgdW5pcXVlQmF0Y2hJRHMpKTtcbiAgICB9XG4gICAgZ2V0QWxsTXV0YXRpb25CYXRjaGVzQWZmZWN0aW5nUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5KSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UGF0aCA9IHF1ZXJ5LnBhdGg7XG4gICAgICAgIGNvbnN0IGltbWVkaWF0ZUNoaWxkcmVuTGVuZ3RoID0gcXVlcnlQYXRoLmxlbmd0aCArIDE7XG4gICAgICAgIC8vIFRPRE8obWNnKTogQWN0dWFsbHkgaW1wbGVtZW50IGEgc2luZ2xlLWNvbGxlY3Rpb24gcXVlcnlcbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhpcyBpcyBhY3R1YWxseSBleGVjdXRpbmcgYW4gYW5jZXN0b3IgcXVlcnksIHRyYXZlcnNpbmcgdGhlIHdob2xlXG4gICAgICAgIC8vIHN1YnRyZWUgYmVsb3cgdGhlIGNvbGxlY3Rpb24gd2hpY2ggY2FuIGJlIGhvcnJpZmljYWxseSBpbmVmZmljaWVudCBmb3JcbiAgICAgICAgLy8gc29tZSBzdHJ1Y3R1cmVzLiBUaGUgcmlnaHQgd2F5IHRvIHNvbHZlIHRoaXMgaXMgdG8gaW1wbGVtZW50IHRoZSBmdWxsXG4gICAgICAgIC8vIHZhbHVlIGluZGV4LCBidXQgdGhhdCdzIG5vdCBpbiB0aGUgY2FyZHMgaW4gdGhlIG5lYXIgZnV0dXJlIHNvIHRoaXMgaXNcbiAgICAgICAgLy8gdGhlIGJlc3Qgd2UgY2FuIGRvIGZvciB0aGUgbW9tZW50LlxuICAgICAgICAvL1xuICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCB5ZXQgaW5kZXggdGhlIGFjdHVhbCBwcm9wZXJ0aWVzIGluIHRoZSBtdXRhdGlvbnMsIG91clxuICAgICAgICAvLyBjdXJyZW50IGFwcHJvYWNoIGlzIHRvIGp1c3QgcmV0dXJuIGFsbCBtdXRhdGlvbiBiYXRjaGVzIHRoYXQgYWZmZWN0XG4gICAgICAgIC8vIGRvY3VtZW50cyBpbiB0aGUgY29sbGVjdGlvbiBiZWluZyBxdWVyaWVkLlxuICAgICAgICBjb25zdCBpbmRleFByZWZpeCA9IG5ld0RiRG9jdW1lbnRNdXRhdGlvblByZWZpeEZvclBhdGgodGhpcy51c2VySWQsIHF1ZXJ5UGF0aCk7XG4gICAgICAgIGNvbnN0IGluZGV4U3RhcnQgPSBJREJLZXlSYW5nZS5sb3dlckJvdW5kKGluZGV4UHJlZml4KTtcbiAgICAgICAgLy8gQ29sbGVjdCB1cCB1bmlxdWUgYmF0Y2hJRHMgZW5jb3VudGVyZWQgZHVyaW5nIGEgc2NhbiBvZiB0aGUgaW5kZXguIFVzZSBhXG4gICAgICAgIC8vIFNvcnRlZFNldCB0byBhY2N1bXVsYXRlIGJhdGNoIElEcyBzbyB0aGV5IGNhbiBiZSB0cmF2ZXJzZWQgaW4gb3JkZXIgaW4gYVxuICAgICAgICAvLyBzY2FuIG9mIHRoZSBtYWluIHRhYmxlLlxuICAgICAgICBsZXQgdW5pcXVlQmF0Y2hJRHMgPSBuZXcgU29ydGVkU2V0KHByaW1pdGl2ZUNvbXBhcmF0b3IpO1xuICAgICAgICByZXR1cm4gZG9jdW1lbnRNdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5pdGVyYXRlKHsgcmFuZ2U6IGluZGV4U3RhcnQgfSwgKGluZGV4S2V5LCBfLCBjb250cm9sKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbdXNlcklELCBlbmNvZGVkUGF0aCwgYmF0Y2hJRF0gPSBpbmRleEtleTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBkZWNvZGVSZXNvdXJjZVBhdGgoZW5jb2RlZFBhdGgpO1xuICAgICAgICAgICAgaWYgKHVzZXJJRCAhPT0gdGhpcy51c2VySWQgfHwgIXF1ZXJ5UGF0aC5pc1ByZWZpeE9mKHBhdGgpKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbC5kb25lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUm93cyB3aXRoIGRvY3VtZW50IGtleXMgbW9yZSB0aGFuIG9uZSBzZWdtZW50IGxvbmdlciB0aGFuIHRoZVxuICAgICAgICAgICAgLy8gcXVlcnkgcGF0aCBjYW4ndCBiZSBtYXRjaGVzLiBGb3IgZXhhbXBsZSwgYSBxdWVyeSBvbiAncm9vbXMnXG4gICAgICAgICAgICAvLyBjYW4ndCBtYXRjaCB0aGUgZG9jdW1lbnQgL3Jvb21zL2FiYy9tZXNzYWdlcy94eXguXG4gICAgICAgICAgICAvLyBUT0RPKG1jZyk6IHdlJ2xsIG5lZWQgYSBkaWZmZXJlbnQgc2Nhbm5lciB3aGVuIHdlIGltcGxlbWVudFxuICAgICAgICAgICAgLy8gYW5jZXN0b3IgcXVlcmllcy5cbiAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCAhPT0gaW1tZWRpYXRlQ2hpbGRyZW5MZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bmlxdWVCYXRjaElEcyA9IHVuaXF1ZUJhdGNoSURzLmFkZChiYXRjaElEKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHRoaXMubG9va3VwTXV0YXRpb25CYXRjaGVzKHRyYW5zYWN0aW9uLCB1bmlxdWVCYXRjaElEcykpO1xuICAgIH1cbiAgICBsb29rdXBNdXRhdGlvbkJhdGNoZXModHJhbnNhY3Rpb24sIGJhdGNoSURzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgLy8gVE9ETyhyb2Nrd29vZCk6IEltcGxlbWVudCB0aGlzIHVzaW5nIGl0ZXJhdGUuXG4gICAgICAgIGJhdGNoSURzLmZvckVhY2goYmF0Y2hJZCA9PiB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKG11dGF0aW9uc1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgIC5nZXQoYmF0Y2hJZClcbiAgICAgICAgICAgICAgICAubmV4dChtdXRhdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGZhaWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGFyZEFzc2VydChtdXRhdGlvbi51c2VySWQgPT09IHRoaXMudXNlcklkKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZnJvbURiTXV0YXRpb25CYXRjaCh0aGlzLnNlcmlhbGl6ZXIsIG11dGF0aW9uKSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpLm5leHQoKCkgPT4gcmVzdWx0cyk7XG4gICAgfVxuICAgIHJlbW92ZU11dGF0aW9uQmF0Y2godHJhbnNhY3Rpb24sIGJhdGNoKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVNdXRhdGlvbkJhdGNoKHRyYW5zYWN0aW9uLnNpbXBsZURiVHJhbnNhY3Rpb24sIHRoaXMudXNlcklkLCBiYXRjaCkubmV4dChyZW1vdmVkRG9jdW1lbnRzID0+IHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmFkZE9uQ29tbWl0dGVkTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2FjaGVkTXV0YXRpb25LZXlzKGJhdGNoLmJhdGNoSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2gocmVtb3ZlZERvY3VtZW50cywgKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmVyZW5jZURlbGVnYXRlLm1hcmtQb3RlbnRpYWxseU9ycGhhbmVkKHRyYW5zYWN0aW9uLCBrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGNhY2hlZCBrZXlzIGZvciBhIG11dGF0aW9uIGJhdGNoLiBUaGlzIG1ldGhvZCBzaG91bGQgYmVcbiAgICAgKiBjYWxsZWQgYnkgc2Vjb25kYXJ5IGNsaWVudHMgYWZ0ZXIgdGhleSBwcm9jZXNzIG11dGF0aW9uIHVwZGF0ZXMuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgZG9lcyBub3QgaGF2ZSB0byBiZSBjYWxsZWQgZnJvbSBwcmltYXJ5IGNsaWVudHMgYXNcbiAgICAgKiB0aGUgY29ycmVzcG9uZGluZyBjYWNoZSBlbnRyaWVzIGFyZSBjbGVhcmVkIHdoZW4gYW4gYWNrbm93bGVkZ2VkIG9yXG4gICAgICogcmVqZWN0ZWQgYmF0Y2ggaXMgcmVtb3ZlZCBmcm9tIHRoZSBtdXRhdGlvbiBxdWV1ZS5cbiAgICAgKi9cbiAgICAvLyBQT1JUSU5HIE5PVEU6IE11bHRpLXRhYiBvbmx5XG4gICAgcmVtb3ZlQ2FjaGVkTXV0YXRpb25LZXlzKGJhdGNoSWQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuZG9jdW1lbnRLZXlzQnlCYXRjaElkW2JhdGNoSWRdO1xuICAgIH1cbiAgICBwZXJmb3JtQ29uc2lzdGVuY3lDaGVjayh0eG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tFbXB0eSh0eG4pLm5leHQoZW1wdHkgPT4ge1xuICAgICAgICAgICAgaWYgKCFlbXB0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVmVyaWZ5IHRoYXQgdGhlcmUgYXJlIG5vIGVudHJpZXMgaW4gdGhlIGRvY3VtZW50TXV0YXRpb25zIGluZGV4IGlmXG4gICAgICAgICAgICAvLyB0aGUgcXVldWUgaXMgZW1wdHkuXG4gICAgICAgICAgICBjb25zdCBzdGFydFJhbmdlID0gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChuZXdEYkRvY3VtZW50TXV0YXRpb25QcmVmaXhGb3JVc2VyKHRoaXMudXNlcklkKSk7XG4gICAgICAgICAgICBjb25zdCBkYW5nbGluZ011dGF0aW9uUmVmZXJlbmNlcyA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50TXV0YXRpb25zU3RvcmUodHhuKVxuICAgICAgICAgICAgICAgIC5pdGVyYXRlKHsgcmFuZ2U6IHN0YXJ0UmFuZ2UgfSwgKGtleSwgXywgY29udHJvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJJRCA9IGtleVswXTtcbiAgICAgICAgICAgICAgICBpZiAodXNlcklEICE9PSB0aGlzLnVzZXJJZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IGRlY29kZVJlc291cmNlUGF0aChrZXlbMV0pO1xuICAgICAgICAgICAgICAgICAgICBkYW5nbGluZ011dGF0aW9uUmVmZXJlbmNlcy5wdXNoKHBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQoZGFuZ2xpbmdNdXRhdGlvblJlZmVyZW5jZXMubGVuZ3RoID09PSAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29udGFpbnNLZXkodHhuLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uUXVldWVDb250YWluc0tleSh0eG4sIHRoaXMudXNlcklkLCBrZXkpO1xuICAgIH1cbiAgICAvLyBQT1JUSU5HIE5PVEU6IE11bHRpLXRhYiBvbmx5IChzdGF0ZSBpcyBoZWxkIGluIG1lbW9yeSBpbiBvdGhlciBjbGllbnRzKS5cbiAgICAvKiogUmV0dXJucyB0aGUgbXV0YXRpb24gcXVldWUncyBtZXRhZGF0YSBmcm9tIEluZGV4ZWREYi4gKi9cbiAgICBnZXRNdXRhdGlvblF1ZXVlTWV0YWRhdGEodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uUXVldWVzU3RvcmUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAuZ2V0KHRoaXMudXNlcklkKVxuICAgICAgICAgICAgLm5leHQoKG1ldGFkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKG1ldGFkYXRhIHx8IHtcbiAgICAgICAgICAgICAgICB1c2VySWQ6IHRoaXMudXNlcklkLFxuICAgICAgICAgICAgICAgIGxhc3RBY2tub3dsZWRnZWRCYXRjaElkOiBCQVRDSElEX1VOS05PV04sXG4gICAgICAgICAgICAgICAgbGFzdFN0cmVhbVRva2VuOiAnJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbXV0YXRpb24gcXVldWUgZm9yIHRoZSBnaXZlbiB1c2VyIGNvbnRhaW5zIGEgcGVuZGluZ1xuICogICAgICAgICBtdXRhdGlvbiBmb3IgdGhlIGdpdmVuIGtleS5cbiAqL1xuZnVuY3Rpb24gbXV0YXRpb25RdWV1ZUNvbnRhaW5zS2V5KHR4biwgdXNlcklkLCBrZXkpIHtcbiAgICBjb25zdCBpbmRleEtleSA9IG5ld0RiRG9jdW1lbnRNdXRhdGlvblByZWZpeEZvclBhdGgodXNlcklkLCBrZXkucGF0aCk7XG4gICAgY29uc3QgZW5jb2RlZFBhdGggPSBpbmRleEtleVsxXTtcbiAgICBjb25zdCBzdGFydFJhbmdlID0gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChpbmRleEtleSk7XG4gICAgbGV0IGNvbnRhaW5zS2V5ID0gZmFsc2U7XG4gICAgcmV0dXJuIGRvY3VtZW50TXV0YXRpb25zU3RvcmUodHhuKVxuICAgICAgICAuaXRlcmF0ZSh7IHJhbmdlOiBzdGFydFJhbmdlLCBrZXlzT25seTogdHJ1ZSB9LCAoa2V5LCB2YWx1ZSwgY29udHJvbCkgPT4ge1xuICAgICAgICBjb25zdCBbdXNlcklELCBrZXlQYXRoLCAvKmJhdGNoSUQqLyBfXSA9IGtleTtcbiAgICAgICAgaWYgKHVzZXJJRCA9PT0gdXNlcklkICYmIGtleVBhdGggPT09IGVuY29kZWRQYXRoKSB7XG4gICAgICAgICAgICBjb250YWluc0tleSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbC5kb25lKCk7XG4gICAgfSlcbiAgICAgICAgLm5leHQoKCkgPT4gY29udGFpbnNLZXkpO1xufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiBhbnkgbXV0YXRpb24gcXVldWUgY29udGFpbnMgdGhlIGdpdmVuIGRvY3VtZW50LiAqL1xuZnVuY3Rpb24gbXV0YXRpb25RdWV1ZXNDb250YWluS2V5KHR4biwgZG9jS2V5KSB7XG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgcmV0dXJuIG11dGF0aW9uUXVldWVzU3RvcmUodHhuKVxuICAgICAgICAuaXRlcmF0ZVNlcmlhbCh1c2VySWQgPT4ge1xuICAgICAgICByZXR1cm4gbXV0YXRpb25RdWV1ZUNvbnRhaW5zS2V5KHR4biwgdXNlcklkLCBkb2NLZXkpLm5leHQoY29udGFpbnNLZXkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5zS2V5KSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCFjb250YWluc0tleSk7XG4gICAgICAgIH0pO1xuICAgIH0pXG4gICAgICAgIC5uZXh0KCgpID0+IGZvdW5kKTtcbn1cbi8qKlxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBtdXRhdGlvbnMgb2JqZWN0IHN0b3JlLlxuICovXG5mdW5jdGlvbiBtdXRhdGlvbnNTdG9yZSh0eG4pIHtcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYk11dGF0aW9uQmF0Y2hTdG9yZSk7XG59XG4vKipcbiAqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZvciB0aGUgbXV0YXRpb25RdWV1ZXMgb2JqZWN0IHN0b3JlLlxuICovXG5mdW5jdGlvbiBkb2N1bWVudE11dGF0aW9uc1N0b3JlKHR4bikge1xuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiRG9jdW1lbnRNdXRhdGlvblN0b3JlKTtcbn1cbi8qKlxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBtdXRhdGlvblF1ZXVlcyBvYmplY3Qgc3RvcmUuXG4gKi9cbmZ1bmN0aW9uIG11dGF0aW9uUXVldWVzU3RvcmUodHhuKSB7XG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJNdXRhdGlvblF1ZXVlU3RvcmUpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqIE9mZnNldCB0byBlbnN1cmUgbm9uLW92ZXJsYXBwaW5nIHRhcmdldCBpZHMuICovXG5jb25zdCBPRkZTRVQgPSAyO1xuLyoqXG4gKiBHZW5lcmF0ZXMgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nIHRhcmdldCBJRHMgZm9yIHNlbmRpbmcgdGFyZ2V0cyB0byB0aGVcbiAqIHdhdGNoIHN0cmVhbS5cbiAqXG4gKiBUaGUgY2xpZW50IGNvbnN0cnVjdHMgdHdvIGdlbmVyYXRvcnMsIG9uZSBmb3IgdGhlIHRhcmdldCBjYWNoZSwgYW5kIG9uZSBmb3JcbiAqIGZvciB0aGUgc3luYyBlbmdpbmUgKHRvIGdlbmVyYXRlIGxpbWJvIGRvY3VtZW50cyB0YXJnZXRzKS4gVGhlc2VcbiAqIGdlbmVyYXRvcnMgcHJvZHVjZSBub24tb3ZlcmxhcHBpbmcgSURzIChieSB1c2luZyBldmVuIGFuZCBvZGQgSURzXG4gKiByZXNwZWN0aXZlbHkpLlxuICpcbiAqIEJ5IHNlcGFyYXRpbmcgdGhlIHRhcmdldCBJRCBzcGFjZSwgdGhlIHF1ZXJ5IGNhY2hlIGNhbiBnZW5lcmF0ZSB0YXJnZXQgSURzXG4gKiB0aGF0IHBlcnNpc3QgYWNyb3NzIGNsaWVudCByZXN0YXJ0cywgd2hpbGUgc3luYyBlbmdpbmUgY2FuIGluZGVwZW5kZW50bHlcbiAqIGdlbmVyYXRlIGluLW1lbW9yeSB0YXJnZXQgSURzIHRoYXQgYXJlIHRyYW5zaWVudCBhbmQgY2FuIGJlIHJldXNlZCBhZnRlciBhXG4gKiByZXN0YXJ0LlxuICovXG5jbGFzcyBUYXJnZXRJZEdlbmVyYXRvciB7XG4gICAgY29uc3RydWN0b3IobGFzdElkKSB7XG4gICAgICAgIHRoaXMubGFzdElkID0gbGFzdElkO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICB0aGlzLmxhc3RJZCArPSBPRkZTRVQ7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RJZDtcbiAgICB9XG4gICAgc3RhdGljIGZvclRhcmdldENhY2hlKCkge1xuICAgICAgICAvLyBUaGUgdGFyZ2V0IGNhY2hlIGdlbmVyYXRvciBtdXN0IHJldHVybiAnMicgaW4gaXRzIGZpcnN0IGNhbGwgdG8gYG5leHQoKWBcbiAgICAgICAgLy8gYXMgdGhlcmUgaXMgbm8gZGlmZmVyZW50aWF0aW9uIGluIHRoZSBwcm90b2NvbCBsYXllciBiZXR3ZWVuIGFuIHVuc2V0XG4gICAgICAgIC8vIG51bWJlciBhbmQgdGhlIG51bWJlciAnMCcuIElmIHdlIHdlcmUgdG8gc2VudCBhIHRhcmdldCB3aXRoIHRhcmdldCBJRFxuICAgICAgICAvLyAnMCcsIHRoZSBiYWNrZW5kIHdvdWxkIGNvbnNpZGVyIGl0IHVuc2V0IGFuZCByZXBsYWNlIGl0IHdpdGggaXRzIG93biBJRC5cbiAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXRJZEdlbmVyYXRvcigyIC0gT0ZGU0VUKTtcbiAgICB9XG4gICAgc3RhdGljIGZvclN5bmNFbmdpbmUoKSB7XG4gICAgICAgIC8vIFN5bmMgZW5naW5lIGFzc2lnbnMgdGFyZ2V0IElEcyBmb3IgbGltYm8gZG9jdW1lbnQgZGV0ZWN0aW9uLlxuICAgICAgICByZXR1cm4gbmV3IFRhcmdldElkR2VuZXJhdG9yKDEgLSBPRkZTRVQpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIEluZGV4ZWREYlRhcmdldENhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihyZWZlcmVuY2VEZWxlZ2F0ZSwgc2VyaWFsaXplcikge1xuICAgICAgICB0aGlzLnJlZmVyZW5jZURlbGVnYXRlID0gcmVmZXJlbmNlRGVsZWdhdGU7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XG4gICAgfVxuICAgIC8vIFBPUlRJTkcgTk9URTogV2UgZG9uJ3QgY2FjaGUgZ2xvYmFsIG1ldGFkYXRhIGZvciB0aGUgdGFyZ2V0IGNhY2hlLCBzaW5jZVxuICAgIC8vIHNvbWUgb2YgaXQgKGluIHBhcnRpY3VsYXIgYGhpZ2hlc3RUYXJnZXRJZGApIGNhbiBiZSBtb2RpZmllZCBieSBzZWNvbmRhcnlcbiAgICAvLyB0YWJzLiBXZSBjb3VsZCBwZXJoYXBzIGJlIG1vcmUgZ3JhbnVsYXIgKGFuZCBlLmcuIHN0aWxsIGNhY2hlXG4gICAgLy8gYGxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb25gIGluIG1lbW9yeSkgYnV0IGZvciBzaW1wbGljaXR5IHdlIGN1cnJlbnRseSBnb1xuICAgIC8vIHRvIEluZGV4ZWREYiB3aGVuZXZlciB3ZSBuZWVkIHRvIHJlYWQgbWV0YWRhdGEuIFdlIGNhbiByZXZpc2l0IGlmIGl0IHR1cm5zXG4gICAgLy8gb3V0IHRvIGhhdmUgYSBtZWFuaW5nZnVsIHBlcmZvcm1hbmNlIGltcGFjdC5cbiAgICBhbGxvY2F0ZVRhcmdldElkKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldHJpZXZlTWV0YWRhdGEodHJhbnNhY3Rpb24pLm5leHQobWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0SWRHZW5lcmF0b3IgPSBuZXcgVGFyZ2V0SWRHZW5lcmF0b3IobWV0YWRhdGEuaGlnaGVzdFRhcmdldElkKTtcbiAgICAgICAgICAgIG1ldGFkYXRhLmhpZ2hlc3RUYXJnZXRJZCA9IHRhcmdldElkR2VuZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNhdmVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgbWV0YWRhdGEpLm5leHQoKCkgPT4gbWV0YWRhdGEuaGlnaGVzdFRhcmdldElkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldExhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV0cmlldmVNZXRhZGF0YSh0cmFuc2FjdGlvbikubmV4dChtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gU25hcHNob3RWZXJzaW9uLmZyb21UaW1lc3RhbXAobmV3IFRpbWVzdGFtcChtZXRhZGF0YS5sYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uLnNlY29uZHMsIG1ldGFkYXRhLmxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24ubmFub3NlY29uZHMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEhpZ2hlc3RTZXF1ZW5jZU51bWJlcih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXRyaWV2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uKS5uZXh0KHRhcmdldEdsb2JhbCA9PiB0YXJnZXRHbG9iYWwuaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyKTtcbiAgICB9XG4gICAgc2V0VGFyZ2V0c01ldGFkYXRhKHRyYW5zYWN0aW9uLCBoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIsIGxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV0cmlldmVNZXRhZGF0YSh0cmFuc2FjdGlvbikubmV4dChtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICBtZXRhZGF0YS5oaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIgPSBoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXI7XG4gICAgICAgICAgICBpZiAobGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbikge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhLmxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24gPVxuICAgICAgICAgICAgICAgICAgICBsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uLnRvVGltZXN0YW1wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyID4gbWV0YWRhdGEuaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEuaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyID0gaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBtZXRhZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhZGRUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhdmVUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhKS5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldHJpZXZlTWV0YWRhdGEodHJhbnNhY3Rpb24pLm5leHQobWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhLnRhcmdldENvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVNZXRhZGF0YUZyb21UYXJnZXREYXRhKHRhcmdldERhdGEsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zYXZlTWV0YWRhdGEodHJhbnNhY3Rpb24sIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlVGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0RGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zYXZlVGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0RGF0YSk7XG4gICAgfVxuICAgIHJlbW92ZVRhcmdldERhdGEodHJhbnNhY3Rpb24sIHRhcmdldERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlTWF0Y2hpbmdLZXlzRm9yVGFyZ2V0SWQodHJhbnNhY3Rpb24sIHRhcmdldERhdGEudGFyZ2V0SWQpXG4gICAgICAgICAgICAubmV4dCgoKSA9PiB0YXJnZXRzU3RvcmUodHJhbnNhY3Rpb24pLmRlbGV0ZSh0YXJnZXREYXRhLnRhcmdldElkKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHRoaXMucmV0cmlldmVNZXRhZGF0YSh0cmFuc2FjdGlvbikpXG4gICAgICAgICAgICAubmV4dChtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICBoYXJkQXNzZXJ0KG1ldGFkYXRhLnRhcmdldENvdW50ID4gMCk7XG4gICAgICAgICAgICBtZXRhZGF0YS50YXJnZXRDb3VudCAtPSAxO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBtZXRhZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcm9wcyBhbnkgdGFyZ2V0cyB3aXRoIHNlcXVlbmNlIG51bWJlciBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHVwcGVyIGJvdW5kLCBleGNlcHRpbmcgdGhvc2VcbiAgICAgKiBwcmVzZW50IGluIGBhY3RpdmVUYXJnZXRJZHNgLiBEb2N1bWVudCBhc3NvY2lhdGlvbnMgZm9yIHRoZSByZW1vdmVkIHRhcmdldHMgYXJlIGFsc28gcmVtb3ZlZC5cbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdGFyZ2V0cyByZW1vdmVkLlxuICAgICAqL1xuICAgIHJlbW92ZVRhcmdldHModHhuLCB1cHBlckJvdW5kLCBhY3RpdmVUYXJnZXRJZHMpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRhcmdldHNTdG9yZSh0eG4pXG4gICAgICAgICAgICAuaXRlcmF0ZSgoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0RGF0YSA9IGZyb21EYlRhcmdldCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0RGF0YS5zZXF1ZW5jZU51bWJlciA8PSB1cHBlckJvdW5kICYmXG4gICAgICAgICAgICAgICAgYWN0aXZlVGFyZ2V0SWRzLmdldCh0YXJnZXREYXRhLnRhcmdldElkKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnJlbW92ZVRhcmdldERhdGEodHhuLCB0YXJnZXREYXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcykpXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBjb3VudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgcHJvdmlkZWQgZnVuY3Rpb24gd2l0aCBlYWNoIGBUYXJnZXREYXRhYCB0aGF0IHdlIGhhdmUgY2FjaGVkLlxuICAgICAqL1xuICAgIGZvckVhY2hUYXJnZXQodHhuLCBmKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRzU3RvcmUodHhuKS5pdGVyYXRlKChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXREYXRhID0gZnJvbURiVGFyZ2V0KHZhbHVlKTtcbiAgICAgICAgICAgIGYodGFyZ2V0RGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXRyaWV2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUYXJnZXRTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5nZXQoRGJUYXJnZXRHbG9iYWxLZXkpXG4gICAgICAgICAgICAubmV4dChtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICBoYXJkQXNzZXJ0KG1ldGFkYXRhICE9PSBudWxsKTtcbiAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNhdmVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgbWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRhcmdldFN0b3JlKHRyYW5zYWN0aW9uKS5wdXQoRGJUYXJnZXRHbG9iYWxLZXksIG1ldGFkYXRhKTtcbiAgICB9XG4gICAgc2F2ZVRhcmdldERhdGEodHJhbnNhY3Rpb24sIHRhcmdldERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldHNTdG9yZSh0cmFuc2FjdGlvbikucHV0KHRvRGJUYXJnZXQodGhpcy5zZXJpYWxpemVyLCB0YXJnZXREYXRhKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluLXBsYWNlIHVwZGF0ZXMgdGhlIHByb3ZpZGVkIG1ldGFkYXRhIHRvIGFjY291bnQgZm9yIHZhbHVlcyBpbiB0aGUgZ2l2ZW5cbiAgICAgKiBUYXJnZXREYXRhLiBTYXZpbmcgaXMgZG9uZSBzZXBhcmF0ZWx5LiBSZXR1cm5zIHRydWUgaWYgdGhlcmUgd2VyZSBhbnlcbiAgICAgKiBjaGFuZ2VzIHRvIHRoZSBtZXRhZGF0YS5cbiAgICAgKi9cbiAgICB1cGRhdGVNZXRhZGF0YUZyb21UYXJnZXREYXRhKHRhcmdldERhdGEsIG1ldGFkYXRhKSB7XG4gICAgICAgIGxldCB1cGRhdGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0YXJnZXREYXRhLnRhcmdldElkID4gbWV0YWRhdGEuaGlnaGVzdFRhcmdldElkKSB7XG4gICAgICAgICAgICBtZXRhZGF0YS5oaWdoZXN0VGFyZ2V0SWQgPSB0YXJnZXREYXRhLnRhcmdldElkO1xuICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldERhdGEuc2VxdWVuY2VOdW1iZXIgPiBtZXRhZGF0YS5oaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhLmhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlciA9IHRhcmdldERhdGEuc2VxdWVuY2VOdW1iZXI7XG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICB9XG4gICAgZ2V0VGFyZ2V0Q291bnQodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV0cmlldmVNZXRhZGF0YSh0cmFuc2FjdGlvbikubmV4dChtZXRhZGF0YSA9PiBtZXRhZGF0YS50YXJnZXRDb3VudCk7XG4gICAgfVxuICAgIGdldFRhcmdldERhdGEodHJhbnNhY3Rpb24sIHRhcmdldCkge1xuICAgICAgICAvLyBJdGVyYXRpbmcgYnkgdGhlIGNhbm9uaWNhbElkIG1heSB5aWVsZCBtb3JlIHRoYW4gb25lIHJlc3VsdCBiZWNhdXNlXG4gICAgICAgIC8vIGNhbm9uaWNhbElkIHZhbHVlcyBhcmUgbm90IHJlcXVpcmVkIHRvIGJlIHVuaXF1ZSBwZXIgdGFyZ2V0LiBUaGlzIHF1ZXJ5XG4gICAgICAgIC8vIGRlcGVuZHMgb24gdGhlIHF1ZXJ5VGFyZ2V0cyBpbmRleCB0byBiZSBlZmZpY2llbnQuXG4gICAgICAgIGNvbnN0IGNhbm9uaWNhbElkID0gY2Fub25pZnlUYXJnZXQodGFyZ2V0KTtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbY2Fub25pY2FsSWQsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWV0sIFtjYW5vbmljYWxJZCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGFyZ2V0c1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLml0ZXJhdGUoeyByYW5nZSwgaW5kZXg6IERiVGFyZ2V0UXVlcnlUYXJnZXRzSW5kZXhOYW1lIH0sIChrZXksIHZhbHVlLCBjb250cm9sKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmb3VuZCA9IGZyb21EYlRhcmdldCh2YWx1ZSk7XG4gICAgICAgICAgICAvLyBBZnRlciBmaW5kaW5nIGEgcG90ZW50aWFsIG1hdGNoLCBjaGVjayB0aGF0IHRoZSB0YXJnZXQgaXNcbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IGVxdWFsIHRvIHRoZSByZXF1ZXN0ZWQgdGFyZ2V0LlxuICAgICAgICAgICAgaWYgKHRhcmdldEVxdWFscyh0YXJnZXQsIGZvdW5kLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmb3VuZDtcbiAgICAgICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHJlc3VsdCk7XG4gICAgfVxuICAgIGFkZE1hdGNoaW5nS2V5cyh0eG4sIGtleXMsIHRhcmdldElkKSB7XG4gICAgICAgIC8vIFBPUlRJTkcgTk9URTogVGhlIHJldmVyc2UgaW5kZXggKGRvY3VtZW50c1RhcmdldHMpIGlzIG1haW50YWluZWQgYnlcbiAgICAgICAgLy8gSW5kZXhlZERiLlxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBjb25zdCBzdG9yZSA9IGRvY3VtZW50VGFyZ2V0U3RvcmUodHhuKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gZW5jb2RlUmVzb3VyY2VQYXRoKGtleS5wYXRoKTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goc3RvcmUucHV0KHsgdGFyZ2V0SWQsIHBhdGggfSkpO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnJlZmVyZW5jZURlbGVnYXRlLmFkZFJlZmVyZW5jZSh0eG4sIHRhcmdldElkLCBrZXkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcyk7XG4gICAgfVxuICAgIHJlbW92ZU1hdGNoaW5nS2V5cyh0eG4sIGtleXMsIHRhcmdldElkKSB7XG4gICAgICAgIC8vIFBPUlRJTkcgTk9URTogVGhlIHJldmVyc2UgaW5kZXggKGRvY3VtZW50c1RhcmdldHMpIGlzIG1haW50YWluZWQgYnlcbiAgICAgICAgLy8gSW5kZXhlZERiLlxuICAgICAgICBjb25zdCBzdG9yZSA9IGRvY3VtZW50VGFyZ2V0U3RvcmUodHhuKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKGtleXMsIChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBlbmNvZGVSZXNvdXJjZVBhdGgoa2V5LnBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKFtcbiAgICAgICAgICAgICAgICBzdG9yZS5kZWxldGUoW3RhcmdldElkLCBwYXRoXSksXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZS5yZW1vdmVSZWZlcmVuY2UodHhuLCB0YXJnZXRJZCwga2V5KVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVNYXRjaGluZ0tleXNGb3JUYXJnZXRJZCh0eG4sIHRhcmdldElkKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gZG9jdW1lbnRUYXJnZXRTdG9yZSh0eG4pO1xuICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKFt0YXJnZXRJZF0sIFt0YXJnZXRJZCArIDFdLCBcbiAgICAgICAgLypsb3dlck9wZW49Ki8gZmFsc2UsIFxuICAgICAgICAvKnVwcGVyT3Blbj0qLyB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHN0b3JlLmRlbGV0ZShyYW5nZSk7XG4gICAgfVxuICAgIGdldE1hdGNoaW5nS2V5c0ZvclRhcmdldElkKHR4biwgdGFyZ2V0SWQpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbdGFyZ2V0SWRdLCBbdGFyZ2V0SWQgKyAxXSwgXG4gICAgICAgIC8qbG93ZXJPcGVuPSovIGZhbHNlLCBcbiAgICAgICAgLyp1cHBlck9wZW49Ki8gdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gZG9jdW1lbnRUYXJnZXRTdG9yZSh0eG4pO1xuICAgICAgICBsZXQgcmVzdWx0ID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgcmV0dXJuIHN0b3JlXG4gICAgICAgICAgICAuaXRlcmF0ZSh7IHJhbmdlLCBrZXlzT25seTogdHJ1ZSB9LCAoa2V5LCBfLCBjb250cm9sKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gZGVjb2RlUmVzb3VyY2VQYXRoKGtleVsxXSk7XG4gICAgICAgICAgICBjb25zdCBkb2NLZXkgPSBuZXcgRG9jdW1lbnRLZXkocGF0aCk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGRvY0tleSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiByZXN1bHQpO1xuICAgIH1cbiAgICBjb250YWluc0tleSh0eG4sIGtleSkge1xuICAgICAgICBjb25zdCBwYXRoID0gZW5jb2RlUmVzb3VyY2VQYXRoKGtleS5wYXRoKTtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbcGF0aF0sIFtpbW1lZGlhdGVTdWNjZXNzb3IocGF0aCldLCBcbiAgICAgICAgLypsb3dlck9wZW49Ki8gZmFsc2UsIFxuICAgICAgICAvKnVwcGVyT3Blbj0qLyB0cnVlKTtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50VGFyZ2V0U3RvcmUodHhuKVxuICAgICAgICAgICAgLml0ZXJhdGUoe1xuICAgICAgICAgICAgaW5kZXg6IERiVGFyZ2V0RG9jdW1lbnREb2N1bWVudFRhcmdldHNJbmRleCxcbiAgICAgICAgICAgIGtleXNPbmx5OiB0cnVlLFxuICAgICAgICAgICAgcmFuZ2VcbiAgICAgICAgfSwgKFt0YXJnZXRJZCwgcGF0aF0sIF8sIGNvbnRyb2wpID0+IHtcbiAgICAgICAgICAgIC8vIEhhdmluZyBhIHNlbnRpbmVsIHJvdyBmb3IgYSBkb2N1bWVudCBkb2VzIG5vdCBjb3VudCBhcyBjb250YWluaW5nIHRoYXQgZG9jdW1lbnQ7XG4gICAgICAgICAgICAvLyBGb3IgdGhlIHRhcmdldCBjYWNoZSwgY29udGFpbmluZyB0aGUgZG9jdW1lbnQgbWVhbnMgdGhlIGRvY3VtZW50IGlzIHBhcnQgb2Ygc29tZVxuICAgICAgICAgICAgLy8gdGFyZ2V0LlxuICAgICAgICAgICAgaWYgKHRhcmdldElkICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGNvdW50ID4gMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvb2tzIHVwIGEgVGFyZ2V0RGF0YSBlbnRyeSBieSB0YXJnZXQgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0SWQgLSBUaGUgdGFyZ2V0IElEIG9mIHRoZSBUYXJnZXREYXRhIGVudHJ5IHRvIGxvb2sgdXAuXG4gICAgICogQHJldHVybnMgVGhlIGNhY2hlZCBUYXJnZXREYXRhIGVudHJ5LCBvciBudWxsIGlmIHRoZSBjYWNoZSBoYXMgbm8gZW50cnkgZm9yXG4gICAgICogdGhlIHRhcmdldC5cbiAgICAgKi9cbiAgICAvLyBQT1JUSU5HIE5PVEU6IE11bHRpLXRhYiBvbmx5LlxuICAgIGdldFRhcmdldERhdGFGb3JUYXJnZXQodHJhbnNhY3Rpb24sIHRhcmdldElkKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRzU3RvcmUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAuZ2V0KHRhcmdldElkKVxuICAgICAgICAgICAgLm5leHQoZm91bmQgPT4ge1xuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21EYlRhcmdldChmb3VuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIHF1ZXJpZXMgb2JqZWN0IHN0b3JlLlxuICovXG5mdW5jdGlvbiB0YXJnZXRzU3RvcmUodHhuKSB7XG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJUYXJnZXRTdG9yZSk7XG59XG4vKipcbiAqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZvciB0aGUgdGFyZ2V0IGdsb2JhbHMgb2JqZWN0IHN0b3JlLlxuICovXG5mdW5jdGlvbiBnbG9iYWxUYXJnZXRTdG9yZSh0eG4pIHtcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYlRhcmdldEdsb2JhbFN0b3JlKTtcbn1cbi8qKlxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBkb2N1bWVudCB0YXJnZXQgb2JqZWN0IHN0b3JlLlxuICovXG5mdW5jdGlvbiBkb2N1bWVudFRhcmdldFN0b3JlKHR4bikge1xuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiVGFyZ2V0RG9jdW1lbnRTdG9yZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBHQ19ESURfTk9UX1JVTiA9IHtcbiAgICBkaWRSdW46IGZhbHNlLFxuICAgIHNlcXVlbmNlTnVtYmVyc0NvbGxlY3RlZDogMCxcbiAgICB0YXJnZXRzUmVtb3ZlZDogMCxcbiAgICBkb2N1bWVudHNSZW1vdmVkOiAwXG59O1xuY29uc3QgTFJVX0NPTExFQ1RJT05fRElTQUJMRUQgPSAtMTtcbmNvbnN0IExSVV9ERUZBVUxUX0NBQ0hFX1NJWkVfQllURVMgPSA0MCAqIDEwMjQgKiAxMDI0O1xuY2xhc3MgTHJ1UGFyYW1zIHtcbiAgICBzdGF0aWMgd2l0aENhY2hlU2l6ZShjYWNoZVNpemUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMcnVQYXJhbXMoY2FjaGVTaXplLCBMcnVQYXJhbXMuREVGQVVMVF9DT0xMRUNUSU9OX1BFUkNFTlRJTEUsIExydVBhcmFtcy5ERUZBVUxUX01BWF9TRVFVRU5DRV9OVU1CRVJTX1RPX0NPTExFQ1QpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBXaGVuIHdlIGF0dGVtcHQgdG8gY29sbGVjdCwgd2Ugd2lsbCBvbmx5IGRvIHNvIGlmIHRoZSBjYWNoZSBzaXplIGlzIGdyZWF0ZXIgdGhhbiB0aGlzXG4gICAgLy8gdGhyZXNob2xkLiBQYXNzaW5nIGBDT0xMRUNUSU9OX0RJU0FCTEVEYCBoZXJlIHdpbGwgY2F1c2UgY29sbGVjdGlvbiB0byBhbHdheXMgYmUgc2tpcHBlZC5cbiAgICBjYWNoZVNpemVDb2xsZWN0aW9uVGhyZXNob2xkLCBcbiAgICAvLyBUaGUgcGVyY2VudGFnZSBvZiBzZXF1ZW5jZSBudW1iZXJzIHRoYXQgd2Ugd2lsbCBhdHRlbXB0IHRvIGNvbGxlY3RcbiAgICBwZXJjZW50aWxlVG9Db2xsZWN0LCBcbiAgICAvLyBBIGNhcCBvbiB0aGUgdG90YWwgbnVtYmVyIG9mIHNlcXVlbmNlIG51bWJlcnMgdGhhdCB3aWxsIGJlIGNvbGxlY3RlZC4gVGhpcyBwcmV2ZW50c1xuICAgIC8vIHVzIGZyb20gY29sbGVjdGluZyBhIGh1Z2UgbnVtYmVyIG9mIHNlcXVlbmNlIG51bWJlcnMgaWYgdGhlIGNhY2hlIGhhcyBncm93biB2ZXJ5IGxhcmdlLlxuICAgIG1heGltdW1TZXF1ZW5jZU51bWJlcnNUb0NvbGxlY3QpIHtcbiAgICAgICAgdGhpcy5jYWNoZVNpemVDb2xsZWN0aW9uVGhyZXNob2xkID0gY2FjaGVTaXplQ29sbGVjdGlvblRocmVzaG9sZDtcbiAgICAgICAgdGhpcy5wZXJjZW50aWxlVG9Db2xsZWN0ID0gcGVyY2VudGlsZVRvQ29sbGVjdDtcbiAgICAgICAgdGhpcy5tYXhpbXVtU2VxdWVuY2VOdW1iZXJzVG9Db2xsZWN0ID0gbWF4aW11bVNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdDtcbiAgICB9XG59XG5McnVQYXJhbXMuREVGQVVMVF9DT0xMRUNUSU9OX1BFUkNFTlRJTEUgPSAxMDtcbkxydVBhcmFtcy5ERUZBVUxUX01BWF9TRVFVRU5DRV9OVU1CRVJTX1RPX0NPTExFQ1QgPSAxMDAwO1xuTHJ1UGFyYW1zLkRFRkFVTFQgPSBuZXcgTHJ1UGFyYW1zKExSVV9ERUZBVUxUX0NBQ0hFX1NJWkVfQllURVMsIExydVBhcmFtcy5ERUZBVUxUX0NPTExFQ1RJT05fUEVSQ0VOVElMRSwgTHJ1UGFyYW1zLkRFRkFVTFRfTUFYX1NFUVVFTkNFX05VTUJFUlNfVE9fQ09MTEVDVCk7XG5McnVQYXJhbXMuRElTQUJMRUQgPSBuZXcgTHJ1UGFyYW1zKExSVV9DT0xMRUNUSU9OX0RJU0FCTEVELCAwLCAwKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IExPR19UQUckZSA9ICdMcnVHYXJiYWdlQ29sbGVjdG9yJztcbmNvbnN0IExSVV9NSU5JTVVNX0NBQ0hFX1NJWkVfQllURVMgPSAxICogMTAyNCAqIDEwMjQ7XG4vKiogSG93IGxvbmcgd2Ugd2FpdCB0byB0cnkgcnVubmluZyBMUlUgR0MgYWZ0ZXIgU0RLIGluaXRpYWxpemF0aW9uLiAqL1xuY29uc3QgSU5JVElBTF9HQ19ERUxBWV9NUyA9IDEgKiA2MCAqIDEwMDA7XG4vKiogTWluaW11bSBhbW91bnQgb2YgdGltZSBiZXR3ZWVuIEdDIGNoZWNrcywgYWZ0ZXIgdGhlIGZpcnN0IG9uZS4gKi9cbmNvbnN0IFJFR1VMQVJfR0NfREVMQVlfTVMgPSA1ICogNjAgKiAxMDAwO1xuZnVuY3Rpb24gYnVmZmVyRW50cnlDb21wYXJhdG9yKFthU2VxdWVuY2UsIGFJbmRleF0sIFtiU2VxdWVuY2UsIGJJbmRleF0pIHtcbiAgICBjb25zdCBzZXFDbXAgPSBwcmltaXRpdmVDb21wYXJhdG9yKGFTZXF1ZW5jZSwgYlNlcXVlbmNlKTtcbiAgICBpZiAoc2VxQ21wID09PSAwKSB7XG4gICAgICAgIC8vIFRoaXMgb3JkZXIgZG9lc24ndCBtYXR0ZXIsIGJ1dCB3ZSBjYW4gYmlhcyBhZ2FpbnN0IGNodXJuIGJ5IHNvcnRpbmdcbiAgICAgICAgLy8gZW50cmllcyBjcmVhdGVkIGVhcmxpZXIgYXMgbGVzcyB0aGFuIG5ld2VyIGVudHJpZXMuXG4gICAgICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGFJbmRleCwgYkluZGV4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzZXFDbXA7XG4gICAgfVxufVxuLyoqXG4gKiBVc2VkIHRvIGNhbGN1bGF0ZSB0aGUgbnRoIHNlcXVlbmNlIG51bWJlci4gS2VlcHMgYSByb2xsaW5nIGJ1ZmZlciBvZiB0aGVcbiAqIGxvd2VzdCBuIHZhbHVlcyBwYXNzZWQgdG8gYGFkZEVsZW1lbnRgLCBhbmQgZmluYWxseSByZXBvcnRzIHRoZSBsYXJnZXN0IG9mXG4gKiB0aGVtIGluIGBtYXhWYWx1ZWAuXG4gKi9cbmNsYXNzIFJvbGxpbmdTZXF1ZW5jZU51bWJlckJ1ZmZlciB7XG4gICAgY29uc3RydWN0b3IobWF4RWxlbWVudHMpIHtcbiAgICAgICAgdGhpcy5tYXhFbGVtZW50cyA9IG1heEVsZW1lbnRzO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBTb3J0ZWRTZXQoYnVmZmVyRW50cnlDb21wYXJhdG9yKTtcbiAgICAgICAgdGhpcy5wcmV2aW91c0luZGV4ID0gMDtcbiAgICB9XG4gICAgbmV4dEluZGV4KCkge1xuICAgICAgICByZXR1cm4gKyt0aGlzLnByZXZpb3VzSW5kZXg7XG4gICAgfVxuICAgIGFkZEVsZW1lbnQoc2VxdWVuY2VOdW1iZXIpIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSBbc2VxdWVuY2VOdW1iZXIsIHRoaXMubmV4dEluZGV4KCldO1xuICAgICAgICBpZiAodGhpcy5idWZmZXIuc2l6ZSA8IHRoaXMubWF4RWxlbWVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuYWRkKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGhpZ2hlc3RWYWx1ZSA9IHRoaXMuYnVmZmVyLmxhc3QoKTtcbiAgICAgICAgICAgIGlmIChidWZmZXJFbnRyeUNvbXBhcmF0b3IoZW50cnksIGhpZ2hlc3RWYWx1ZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5kZWxldGUoaGlnaGVzdFZhbHVlKS5hZGQoZW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBtYXhWYWx1ZSgpIHtcbiAgICAgICAgLy8gR3VhcmFudGVlZCB0byBiZSBub24tZW1wdHkuIElmIHdlIGRlY2lkZSB3ZSBhcmUgbm90IGNvbGxlY3RpbmcgYW55XG4gICAgICAgIC8vIHNlcXVlbmNlIG51bWJlcnMsIG50aFNlcXVlbmNlTnVtYmVyIGJlbG93IHNob3J0LWNpcmN1aXRzLiBJZiB3ZSBoYXZlXG4gICAgICAgIC8vIGRlY2lkZWQgdGhhdCB3ZSBhcmUgY29sbGVjdGluZyBuIHNlcXVlbmNlIG51bWJlcnMsIGl0J3MgYmVjYXVzZSBuIGlzIHNvbWVcbiAgICAgICAgLy8gcGVyY2VudGFnZSBvZiB0aGUgZXhpc3Rpbmcgc2VxdWVuY2UgbnVtYmVycy4gVGhhdCBtZWFucyB3ZSBzaG91bGQgbmV2ZXJcbiAgICAgICAgLy8gYmUgaW4gYSBzaXR1YXRpb24gd2hlcmUgd2UgYXJlIGNvbGxlY3Rpbmcgc2VxdWVuY2UgbnVtYmVycyBidXQgZG9uJ3RcbiAgICAgICAgLy8gYWN0dWFsbHkgaGF2ZSBhbnkuXG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5sYXN0KClbMF07XG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgc2NoZWR1bGluZyBvZiBMUlUgZ2FyYmFnZSBjb2xsZWN0aW9uLiBJdCBoYW5kbGVzIGNoZWNraW5nXG4gKiB3aGV0aGVyIG9yIG5vdCBHQyBpcyBlbmFibGVkLCBhcyB3ZWxsIGFzIHdoaWNoIGRlbGF5IHRvIHVzZSBiZWZvcmUgdGhlIG5leHQgcnVuLlxuICovXG5jbGFzcyBMcnVTY2hlZHVsZXIge1xuICAgIGNvbnN0cnVjdG9yKGdhcmJhZ2VDb2xsZWN0b3IsIGFzeW5jUXVldWUsIGxvY2FsU3RvcmUpIHtcbiAgICAgICAgdGhpcy5nYXJiYWdlQ29sbGVjdG9yID0gZ2FyYmFnZUNvbGxlY3RvcjtcbiAgICAgICAgdGhpcy5hc3luY1F1ZXVlID0gYXN5bmNRdWV1ZTtcbiAgICAgICAgdGhpcy5sb2NhbFN0b3JlID0gbG9jYWxTdG9yZTtcbiAgICAgICAgdGhpcy5nY1Rhc2sgPSBudWxsO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2FyYmFnZUNvbGxlY3Rvci5wYXJhbXMuY2FjaGVTaXplQ29sbGVjdGlvblRocmVzaG9sZCAhPT1cbiAgICAgICAgICAgIExSVV9DT0xMRUNUSU9OX0RJU0FCTEVEKSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlR0MoSU5JVElBTF9HQ19ERUxBWV9NUyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2NUYXNrKSB7XG4gICAgICAgICAgICB0aGlzLmdjVGFzay5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMuZ2NUYXNrID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgc3RhcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2NUYXNrICE9PSBudWxsO1xuICAgIH1cbiAgICBzY2hlZHVsZUdDKGRlbGF5KSB7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckZSwgYEdhcmJhZ2UgY29sbGVjdGlvbiBzY2hlZHVsZWQgaW4gJHtkZWxheX1tc2ApO1xuICAgICAgICB0aGlzLmdjVGFzayA9IHRoaXMuYXN5bmNRdWV1ZS5lbnF1ZXVlQWZ0ZXJEZWxheShcImxydV9nYXJiYWdlX2NvbGxlY3Rpb25cIiAvKiBUaW1lcklkLkxydUdhcmJhZ2VDb2xsZWN0aW9uICovLCBkZWxheSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5nY1Rhc2sgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmxvY2FsU3RvcmUuY29sbGVjdEdhcmJhZ2UodGhpcy5nYXJiYWdlQ29sbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihlKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGUsICdJZ25vcmluZyBJbmRleGVkREIgZXJyb3IgZHVyaW5nIGdhcmJhZ2UgY29sbGVjdGlvbjogJywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBpZ25vcmVJZlByaW1hcnlMZWFzZUxvc3MoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zY2hlZHVsZUdDKFJFR1VMQVJfR0NfREVMQVlfTVMpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIEltcGxlbWVudHMgdGhlIHN0ZXBzIGZvciBMUlUgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICovXG5jbGFzcyBMcnVHYXJiYWdlQ29sbGVjdG9ySW1wbCB7XG4gICAgY29uc3RydWN0b3IoZGVsZWdhdGUsIHBhcmFtcykge1xuICAgICAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIH1cbiAgICBjYWxjdWxhdGVUYXJnZXRDb3VudCh0eG4sIHBlcmNlbnRpbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUuZ2V0U2VxdWVuY2VOdW1iZXJDb3VudCh0eG4pLm5leHQodGFyZ2V0Q291bnQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKHBlcmNlbnRpbGUgLyAxMDAuMCkgKiB0YXJnZXRDb3VudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBudGhTZXF1ZW5jZU51bWJlcih0eG4sIG4pIHtcbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgUm9sbGluZ1NlcXVlbmNlTnVtYmVyQnVmZmVyKG4pO1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZVxuICAgICAgICAgICAgLmZvckVhY2hUYXJnZXQodHhuLCB0YXJnZXQgPT4gYnVmZmVyLmFkZEVsZW1lbnQodGFyZ2V0LnNlcXVlbmNlTnVtYmVyKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLmZvckVhY2hPcnBoYW5lZERvY3VtZW50U2VxdWVuY2VOdW1iZXIodHhuLCBzZXF1ZW5jZU51bWJlciA9PiBidWZmZXIuYWRkRWxlbWVudChzZXF1ZW5jZU51bWJlcikpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gYnVmZmVyLm1heFZhbHVlKTtcbiAgICB9XG4gICAgcmVtb3ZlVGFyZ2V0cyh0eG4sIHVwcGVyQm91bmQsIGFjdGl2ZVRhcmdldElkcykge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5yZW1vdmVUYXJnZXRzKHR4biwgdXBwZXJCb3VuZCwgYWN0aXZlVGFyZ2V0SWRzKTtcbiAgICB9XG4gICAgcmVtb3ZlT3JwaGFuZWREb2N1bWVudHModHhuLCB1cHBlckJvdW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLnJlbW92ZU9ycGhhbmVkRG9jdW1lbnRzKHR4biwgdXBwZXJCb3VuZCk7XG4gICAgfVxuICAgIGNvbGxlY3QodHhuLCBhY3RpdmVUYXJnZXRJZHMpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLmNhY2hlU2l6ZUNvbGxlY3Rpb25UaHJlc2hvbGQgPT09IExSVV9DT0xMRUNUSU9OX0RJU0FCTEVEKSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZygnTHJ1R2FyYmFnZUNvbGxlY3RvcicsICdHYXJiYWdlIGNvbGxlY3Rpb24gc2tpcHBlZDsgZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShHQ19ESURfTk9UX1JVTik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2FjaGVTaXplKHR4bikubmV4dChjYWNoZVNpemUgPT4ge1xuICAgICAgICAgICAgaWYgKGNhY2hlU2l6ZSA8IHRoaXMucGFyYW1zLmNhY2hlU2l6ZUNvbGxlY3Rpb25UaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnTHJ1R2FyYmFnZUNvbGxlY3RvcicsIGBHYXJiYWdlIGNvbGxlY3Rpb24gc2tpcHBlZDsgQ2FjaGUgc2l6ZSAke2NhY2hlU2l6ZX0gYCArXG4gICAgICAgICAgICAgICAgICAgIGBpcyBsb3dlciB0aGFuIHRocmVzaG9sZCAke3RoaXMucGFyYW1zLmNhY2hlU2l6ZUNvbGxlY3Rpb25UaHJlc2hvbGR9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEdDX0RJRF9OT1RfUlVOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucnVuR2FyYmFnZUNvbGxlY3Rpb24odHhuLCBhY3RpdmVUYXJnZXRJZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0Q2FjaGVTaXplKHR4bikge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5nZXRDYWNoZVNpemUodHhuKTtcbiAgICB9XG4gICAgcnVuR2FyYmFnZUNvbGxlY3Rpb24odHhuLCBhY3RpdmVUYXJnZXRJZHMpIHtcbiAgICAgICAgbGV0IHVwcGVyQm91bmRTZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgbGV0IHNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdCwgdGFyZ2V0c1JlbW92ZWQ7XG4gICAgICAgIC8vIFRpbWVzdGFtcHMgZm9yIHZhcmlvdXMgcGllY2VzIG9mIHRoZSBwcm9jZXNzXG4gICAgICAgIGxldCBjb3VudGVkVGFyZ2V0c1RzLCBmb3VuZFVwcGVyQm91bmRUcywgcmVtb3ZlZFRhcmdldHNUcywgcmVtb3ZlZERvY3VtZW50c1RzO1xuICAgICAgICBjb25zdCBzdGFydFRzID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlVGFyZ2V0Q291bnQodHhuLCB0aGlzLnBhcmFtcy5wZXJjZW50aWxlVG9Db2xsZWN0KVxuICAgICAgICAgICAgLm5leHQoc2VxdWVuY2VOdW1iZXJzID0+IHtcbiAgICAgICAgICAgIC8vIENhcCBhdCB0aGUgY29uZmlndXJlZCBtYXhcbiAgICAgICAgICAgIGlmIChzZXF1ZW5jZU51bWJlcnMgPiB0aGlzLnBhcmFtcy5tYXhpbXVtU2VxdWVuY2VOdW1iZXJzVG9Db2xsZWN0KSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ0xydUdhcmJhZ2VDb2xsZWN0b3InLCAnQ2FwcGluZyBzZXF1ZW5jZSBudW1iZXJzIHRvIGNvbGxlY3QgZG93biAnICtcbiAgICAgICAgICAgICAgICAgICAgYHRvIHRoZSBtYXhpbXVtIG9mICR7dGhpcy5wYXJhbXMubWF4aW11bVNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdH0gYCArXG4gICAgICAgICAgICAgICAgICAgIGBmcm9tICR7c2VxdWVuY2VOdW1iZXJzfWApO1xuICAgICAgICAgICAgICAgIHNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyYW1zLm1heGltdW1TZXF1ZW5jZU51bWJlcnNUb0NvbGxlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZU51bWJlcnNUb0NvbGxlY3QgPSBzZXF1ZW5jZU51bWJlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudGVkVGFyZ2V0c1RzID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm50aFNlcXVlbmNlTnVtYmVyKHR4biwgc2VxdWVuY2VOdW1iZXJzVG9Db2xsZWN0KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KHVwcGVyQm91bmQgPT4ge1xuICAgICAgICAgICAgdXBwZXJCb3VuZFNlcXVlbmNlTnVtYmVyID0gdXBwZXJCb3VuZDtcbiAgICAgICAgICAgIGZvdW5kVXBwZXJCb3VuZFRzID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZVRhcmdldHModHhuLCB1cHBlckJvdW5kU2VxdWVuY2VOdW1iZXIsIGFjdGl2ZVRhcmdldElkcyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dChudW1UYXJnZXRzUmVtb3ZlZCA9PiB7XG4gICAgICAgICAgICB0YXJnZXRzUmVtb3ZlZCA9IG51bVRhcmdldHNSZW1vdmVkO1xuICAgICAgICAgICAgcmVtb3ZlZFRhcmdldHNUcyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVPcnBoYW5lZERvY3VtZW50cyh0eG4sIHVwcGVyQm91bmRTZXF1ZW5jZU51bWJlcik7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dChkb2N1bWVudHNSZW1vdmVkID0+IHtcbiAgICAgICAgICAgIHJlbW92ZWREb2N1bWVudHNUcyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBpZiAoZ2V0TG9nTGV2ZWwoKSA8PSBMb2dMZXZlbC5ERUJVRykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2MgPSAnTFJVIEdhcmJhZ2UgQ29sbGVjdGlvblxcbicgK1xuICAgICAgICAgICAgICAgICAgICBgXFx0Q291bnRlZCB0YXJnZXRzIGluICR7Y291bnRlZFRhcmdldHNUcyAtIHN0YXJ0VHN9bXNcXG5gICtcbiAgICAgICAgICAgICAgICAgICAgYFxcdERldGVybWluZWQgbGVhc3QgcmVjZW50bHkgdXNlZCAke3NlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdH0gaW4gYCArXG4gICAgICAgICAgICAgICAgICAgIGAke2ZvdW5kVXBwZXJCb3VuZFRzIC0gY291bnRlZFRhcmdldHNUc31tc1xcbmAgK1xuICAgICAgICAgICAgICAgICAgICBgXFx0UmVtb3ZlZCAke3RhcmdldHNSZW1vdmVkfSB0YXJnZXRzIGluIGAgK1xuICAgICAgICAgICAgICAgICAgICBgJHtyZW1vdmVkVGFyZ2V0c1RzIC0gZm91bmRVcHBlckJvdW5kVHN9bXNcXG5gICtcbiAgICAgICAgICAgICAgICAgICAgYFxcdFJlbW92ZWQgJHtkb2N1bWVudHNSZW1vdmVkfSBkb2N1bWVudHMgaW4gYCArXG4gICAgICAgICAgICAgICAgICAgIGAke3JlbW92ZWREb2N1bWVudHNUcyAtIHJlbW92ZWRUYXJnZXRzVHN9bXNcXG5gICtcbiAgICAgICAgICAgICAgICAgICAgYFRvdGFsIER1cmF0aW9uOiAke3JlbW92ZWREb2N1bWVudHNUcyAtIHN0YXJ0VHN9bXNgO1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdMcnVHYXJiYWdlQ29sbGVjdG9yJywgZGVzYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgICAgIGRpZFJ1bjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZU51bWJlcnNDb2xsZWN0ZWQ6IHNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdCxcbiAgICAgICAgICAgICAgICB0YXJnZXRzUmVtb3ZlZCxcbiAgICAgICAgICAgICAgICBkb2N1bWVudHNSZW1vdmVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbmV3THJ1R2FyYmFnZUNvbGxlY3RvcihkZWxlZ2F0ZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBMcnVHYXJiYWdlQ29sbGVjdG9ySW1wbChkZWxlZ2F0ZSwgcGFyYW1zKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKiBQcm92aWRlcyBMUlUgZnVuY3Rpb25hbGl0eSBmb3IgSW5kZXhlZERCIHBlcnNpc3RlbmNlLiAqL1xuY2xhc3MgSW5kZXhlZERiTHJ1RGVsZWdhdGVJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihkYiwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuZGIgPSBkYjtcbiAgICAgICAgdGhpcy5nYXJiYWdlQ29sbGVjdG9yID0gbmV3THJ1R2FyYmFnZUNvbGxlY3Rvcih0aGlzLCBwYXJhbXMpO1xuICAgIH1cbiAgICBnZXRTZXF1ZW5jZU51bWJlckNvdW50KHR4bikge1xuICAgICAgICBjb25zdCBkb2NDb3VudFByb21pc2UgPSB0aGlzLm9ycGhhbmVkRG9jdW1lbnRDb3VudCh0eG4pO1xuICAgICAgICBjb25zdCB0YXJnZXRDb3VudFByb21pc2UgPSB0aGlzLmRiLmdldFRhcmdldENhY2hlKCkuZ2V0VGFyZ2V0Q291bnQodHhuKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldENvdW50UHJvbWlzZS5uZXh0KHRhcmdldENvdW50ID0+IGRvY0NvdW50UHJvbWlzZS5uZXh0KGRvY0NvdW50ID0+IHRhcmdldENvdW50ICsgZG9jQ291bnQpKTtcbiAgICB9XG4gICAgb3JwaGFuZWREb2N1bWVudENvdW50KHR4bikge1xuICAgICAgICBsZXQgb3JwaGFuZWRDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzLmZvckVhY2hPcnBoYW5lZERvY3VtZW50U2VxdWVuY2VOdW1iZXIodHhuLCBfID0+IHtcbiAgICAgICAgICAgIG9ycGhhbmVkQ291bnQrKztcbiAgICAgICAgfSkubmV4dCgoKSA9PiBvcnBoYW5lZENvdW50KTtcbiAgICB9XG4gICAgZm9yRWFjaFRhcmdldCh0eG4sIGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGIuZ2V0VGFyZ2V0Q2FjaGUoKS5mb3JFYWNoVGFyZ2V0KHR4biwgZik7XG4gICAgfVxuICAgIGZvckVhY2hPcnBoYW5lZERvY3VtZW50U2VxdWVuY2VOdW1iZXIodHhuLCBmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvckVhY2hPcnBoYW5lZERvY3VtZW50KHR4biwgKGRvY0tleSwgc2VxdWVuY2VOdW1iZXIpID0+IGYoc2VxdWVuY2VOdW1iZXIpKTtcbiAgICB9XG4gICAgYWRkUmVmZXJlbmNlKHR4biwgdGFyZ2V0SWQsIGtleSkge1xuICAgICAgICByZXR1cm4gd3JpdGVTZW50aW5lbEtleSh0eG4sIGtleSk7XG4gICAgfVxuICAgIHJlbW92ZVJlZmVyZW5jZSh0eG4sIHRhcmdldElkLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlU2VudGluZWxLZXkodHhuLCBrZXkpO1xuICAgIH1cbiAgICByZW1vdmVUYXJnZXRzKHR4biwgdXBwZXJCb3VuZCwgYWN0aXZlVGFyZ2V0SWRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRiLmdldFRhcmdldENhY2hlKCkucmVtb3ZlVGFyZ2V0cyh0eG4sIHVwcGVyQm91bmQsIGFjdGl2ZVRhcmdldElkcyk7XG4gICAgfVxuICAgIG1hcmtQb3RlbnRpYWxseU9ycGhhbmVkKHR4biwga2V5KSB7XG4gICAgICAgIHJldHVybiB3cml0ZVNlbnRpbmVsS2V5KHR4biwga2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGFueXRoaW5nIHdvdWxkIHByZXZlbnQgdGhpcyBkb2N1bWVudCBmcm9tIGJlaW5nIGdhcmJhZ2VcbiAgICAgKiBjb2xsZWN0ZWQsIGdpdmVuIHRoYXQgdGhlIGRvY3VtZW50IGluIHF1ZXN0aW9uIGlzIG5vdCBwcmVzZW50IGluIGFueVxuICAgICAqIHRhcmdldHMgYW5kIGhhcyBhIHNlcXVlbmNlIG51bWJlciBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHVwcGVyIGJvdW5kIGZvclxuICAgICAqIHRoZSBjb2xsZWN0aW9uIHJ1bi5cbiAgICAgKi9cbiAgICBpc1Bpbm5lZCh0eG4sIGRvY0tleSkge1xuICAgICAgICByZXR1cm4gbXV0YXRpb25RdWV1ZXNDb250YWluS2V5KHR4biwgZG9jS2V5KTtcbiAgICB9XG4gICAgcmVtb3ZlT3JwaGFuZWREb2N1bWVudHModHhuLCB1cHBlckJvdW5kKSB7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50Q2FjaGUgPSB0aGlzLmRiLmdldFJlbW90ZURvY3VtZW50Q2FjaGUoKTtcbiAgICAgICAgY29uc3QgY2hhbmdlQnVmZmVyID0gZG9jdW1lbnRDYWNoZS5uZXdDaGFuZ2VCdWZmZXIoKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgbGV0IGRvY3VtZW50Q291bnQgPSAwO1xuICAgICAgICBjb25zdCBpdGVyYXRpb24gPSB0aGlzLmZvckVhY2hPcnBoYW5lZERvY3VtZW50KHR4biwgKGRvY0tleSwgc2VxdWVuY2VOdW1iZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChzZXF1ZW5jZU51bWJlciA8PSB1cHBlckJvdW5kKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuaXNQaW5uZWQodHhuLCBkb2NLZXkpLm5leHQoaXNQaW5uZWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUGlubmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdXIgc2l6ZSBhY2NvdW50aW5nIHJlcXVpcmVzIHVzIHRvIHJlYWQgYWxsIGRvY3VtZW50cyBiZWZvcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92aW5nIHRoZW0uXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhbmdlQnVmZmVyLmdldEVudHJ5KHR4biwgZG9jS2V5KS5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VCdWZmZXIucmVtb3ZlRW50cnkoZG9jS2V5LCBTbmFwc2hvdFZlcnNpb24ubWluKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudFRhcmdldFN0b3JlKHR4bikuZGVsZXRlKHNlbnRpbmVsS2V5JDEoZG9jS2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gocCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaXRlcmF0aW9uXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcykpXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBjaGFuZ2VCdWZmZXIuYXBwbHkodHhuKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGRvY3VtZW50Q291bnQpO1xuICAgIH1cbiAgICByZW1vdmVUYXJnZXQodHhuLCB0YXJnZXREYXRhKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWQgPSB0YXJnZXREYXRhLndpdGhTZXF1ZW5jZU51bWJlcih0eG4uY3VycmVudFNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGIuZ2V0VGFyZ2V0Q2FjaGUoKS51cGRhdGVUYXJnZXREYXRhKHR4biwgdXBkYXRlZCk7XG4gICAgfVxuICAgIHVwZGF0ZUxpbWJvRG9jdW1lbnQodHhuLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlU2VudGluZWxLZXkodHhuLCBrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIHByb3ZpZGVkIGZ1bmN0aW9uIGZvciBlYWNoIGRvY3VtZW50IGluIHRoZSBjYWNoZSB0aGF0IGlzICdvcnBoYW5lZCcuIE9ycGhhbmVkXG4gICAgICogbWVhbnMgbm90IGEgcGFydCBvZiBhbnkgdGFyZ2V0LCBzbyB0aGUgb25seSBlbnRyeSBpbiB0aGUgdGFyZ2V0LWRvY3VtZW50IGluZGV4IGZvclxuICAgICAqIHRoYXQgZG9jdW1lbnQgd2lsbCBiZSB0aGUgc2VudGluZWwgcm93ICh0YXJnZXRJZCAwKSwgd2hpY2ggd2lsbCBhbHNvIGhhdmUgdGhlIHNlcXVlbmNlXG4gICAgICogbnVtYmVyIGZvciB0aGUgbGFzdCB0aW1lIHRoZSBkb2N1bWVudCB3YXMgYWNjZXNzZWQuXG4gICAgICovXG4gICAgZm9yRWFjaE9ycGhhbmVkRG9jdW1lbnQodHhuLCBmKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gZG9jdW1lbnRUYXJnZXRTdG9yZSh0eG4pO1xuICAgICAgICBsZXQgbmV4dFRvUmVwb3J0ID0gTGlzdGVuU2VxdWVuY2UuSU5WQUxJRDtcbiAgICAgICAgbGV0IG5leHRQYXRoO1xuICAgICAgICByZXR1cm4gc3RvcmVcbiAgICAgICAgICAgIC5pdGVyYXRlKHtcbiAgICAgICAgICAgIGluZGV4OiBEYlRhcmdldERvY3VtZW50RG9jdW1lbnRUYXJnZXRzSW5kZXhcbiAgICAgICAgfSwgKFt0YXJnZXRJZCwgZG9jS2V5XSwgeyBwYXRoLCBzZXF1ZW5jZU51bWJlciB9KSA9PiB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0SWQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBuZXh0VG9SZXBvcnQgaXMgdmFsaWQsIHJlcG9ydCBpdCwgdGhpcyBpcyBhIG5ldyBrZXkgc28gdGhlXG4gICAgICAgICAgICAgICAgLy8gbGFzdCBvbmUgbXVzdCBub3QgYmUgYSBtZW1iZXIgb2YgYW55IHRhcmdldHMuXG4gICAgICAgICAgICAgICAgaWYgKG5leHRUb1JlcG9ydCAhPT0gTGlzdGVuU2VxdWVuY2UuSU5WQUxJRCkge1xuICAgICAgICAgICAgICAgICAgICBmKG5ldyBEb2N1bWVudEtleShkZWNvZGVSZXNvdXJjZVBhdGgobmV4dFBhdGgpKSwgbmV4dFRvUmVwb3J0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gc2V0IG5leHRUb1JlcG9ydCB0byBiZSB0aGlzIHNlcXVlbmNlIG51bWJlci4gSXQncyB0aGUgbmV4dCBvbmUgd2VcbiAgICAgICAgICAgICAgICAvLyBtaWdodCByZXBvcnQsIGlmIHdlIGRvbid0IGZpbmQgYW55IHRhcmdldHMgZm9yIHRoaXMgZG9jdW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoZSBzZXF1ZW5jZSBudW1iZXIgbXVzdCBiZSBkZWZpbmVkIHdoZW4gdGhlIHRhcmdldElkXG4gICAgICAgICAgICAgICAgLy8gaXMgMC5cbiAgICAgICAgICAgICAgICBuZXh0VG9SZXBvcnQgPSBzZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgICAgICAgICBuZXh0UGF0aCA9IHBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzZXQgbmV4dFRvUmVwb3J0IHRvIGJlIGludmFsaWQsIHdlIGtub3cgd2UgZG9uJ3QgbmVlZCB0byByZXBvcnRcbiAgICAgICAgICAgICAgICAvLyB0aGlzIG9uZSBzaW5jZSB3ZSBmb3VuZCBhIHRhcmdldCBmb3IgaXQuXG4gICAgICAgICAgICAgICAgbmV4dFRvUmVwb3J0ID0gTGlzdGVuU2VxdWVuY2UuSU5WQUxJRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgIC8vIFNpbmNlIHdlIHJlcG9ydCBzZXF1ZW5jZSBudW1iZXJzIGFmdGVyIGdldHRpbmcgdG8gdGhlIG5leHQga2V5LCB3ZVxuICAgICAgICAgICAgLy8gbmVlZCB0byBjaGVjayBpZiB0aGUgbGFzdCBrZXkgd2UgaXRlcmF0ZWQgb3ZlciB3YXMgYW4gb3JwaGFuZWRcbiAgICAgICAgICAgIC8vIGRvY3VtZW50IGFuZCByZXBvcnQgaXQuXG4gICAgICAgICAgICBpZiAobmV4dFRvUmVwb3J0ICE9PSBMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEKSB7XG4gICAgICAgICAgICAgICAgZihuZXcgRG9jdW1lbnRLZXkoZGVjb2RlUmVzb3VyY2VQYXRoKG5leHRQYXRoKSksIG5leHRUb1JlcG9ydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDYWNoZVNpemUodHhuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRiLmdldFJlbW90ZURvY3VtZW50Q2FjaGUoKS5nZXRTaXplKHR4bik7XG4gICAgfVxufVxuZnVuY3Rpb24gc2VudGluZWxLZXkkMShrZXkpIHtcbiAgICByZXR1cm4gWzAsIGVuY29kZVJlc291cmNlUGF0aChrZXkucGF0aCldO1xufVxuLyoqXG4gKiBAcmV0dXJucyBBIHZhbHVlIHN1aXRhYmxlIGZvciB3cml0aW5nIGEgc2VudGluZWwgcm93IGluIHRoZSB0YXJnZXQtZG9jdW1lbnRcbiAqIHN0b3JlLlxuICovXG5mdW5jdGlvbiBzZW50aW5lbFJvdyhrZXksIHNlcXVlbmNlTnVtYmVyKSB7XG4gICAgcmV0dXJuIHsgdGFyZ2V0SWQ6IDAsIHBhdGg6IGVuY29kZVJlc291cmNlUGF0aChrZXkucGF0aCksIHNlcXVlbmNlTnVtYmVyIH07XG59XG5mdW5jdGlvbiB3cml0ZVNlbnRpbmVsS2V5KHR4biwga2V5KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50VGFyZ2V0U3RvcmUodHhuKS5wdXQoc2VudGluZWxSb3coa2V5LCB0eG4uY3VycmVudFNlcXVlbmNlTnVtYmVyKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFuIGluLW1lbW9yeSBidWZmZXIgb2YgZW50cmllcyB0byBiZSB3cml0dGVuIHRvIGEgUmVtb3RlRG9jdW1lbnRDYWNoZS5cbiAqIEl0IGNhbiBiZSB1c2VkIHRvIGJhdGNoIHVwIGEgc2V0IG9mIGNoYW5nZXMgdG8gYmUgd3JpdHRlbiB0byB0aGUgY2FjaGUsIGJ1dFxuICogYWRkaXRpb25hbGx5IHN1cHBvcnRzIHJlYWRpbmcgZW50cmllcyBiYWNrIHdpdGggdGhlIGBnZXRFbnRyeSgpYCBtZXRob2QsXG4gKiBmYWxsaW5nIGJhY2sgdG8gdGhlIHVuZGVybHlpbmcgUmVtb3RlRG9jdW1lbnRDYWNoZSBpZiBubyBlbnRyeSBpc1xuICogYnVmZmVyZWQuXG4gKlxuICogRW50cmllcyBhZGRlZCB0byB0aGUgY2FjaGUgKm11c3QqIGJlIHJlYWQgZmlyc3QuIFRoaXMgaXMgdG8gZmFjaWxpdGF0ZVxuICogY2FsY3VsYXRpbmcgdGhlIHNpemUgZGVsdGEgb2YgdGhlIHBlbmRpbmcgY2hhbmdlcy5cbiAqXG4gKiBQT1JUSU5HIE5PVEU6IFRoaXMgY2xhc3Mgd2FzIGltcGxlbWVudGVkIHRoZW4gcmVtb3ZlZCBmcm9tIG90aGVyIHBsYXRmb3Jtcy5cbiAqIElmIGJ5dGUtY291bnRpbmcgZW5kcyB1cCBiZWluZyBuZWVkZWQgb24gdGhlIG90aGVyIHBsYXRmb3JtcywgY29uc2lkZXJcbiAqIHBvcnRpbmcgdGhpcyBjbGFzcyBhcyBwYXJ0IG9mIHRoYXQgaW1wbGVtZW50YXRpb24gd29yay5cbiAqL1xuY2xhc3MgUmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBBIG1hcHBpbmcgb2YgZG9jdW1lbnQga2V5IHRvIHRoZSBuZXcgY2FjaGUgZW50cnkgdGhhdCBzaG91bGQgYmUgd3JpdHRlbi5cbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gbmV3IE9iamVjdE1hcChrZXkgPT4ga2V5LnRvU3RyaW5nKCksIChsLCByKSA9PiBsLmlzRXF1YWwocikpO1xuICAgICAgICB0aGlzLmNoYW5nZXNBcHBsaWVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1ZmZlcnMgYSBgUmVtb3RlRG9jdW1lbnRDYWNoZS5hZGRFbnRyeSgpYCBjYWxsLlxuICAgICAqXG4gICAgICogWW91IGNhbiBvbmx5IG1vZGlmeSBkb2N1bWVudHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiByZXRyaWV2ZWQgdmlhXG4gICAgICogYGdldEVudHJ5KCkvZ2V0RW50cmllcygpYCAoZW5mb3JjZWQgdmlhIEluZGV4ZWREYnMgYGFwcGx5KClgKS5cbiAgICAgKi9cbiAgICBhZGRFbnRyeShkb2N1bWVudCkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdEFwcGxpZWQoKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLnNldChkb2N1bWVudC5rZXksIGRvY3VtZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVmZmVycyBhIGBSZW1vdGVEb2N1bWVudENhY2hlLnJlbW92ZUVudHJ5KClgIGNhbGwuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIG9ubHkgcmVtb3ZlIGRvY3VtZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIHJldHJpZXZlZCB2aWFcbiAgICAgKiBgZ2V0RW50cnkoKS9nZXRFbnRyaWVzKClgIChlbmZvcmNlZCB2aWEgSW5kZXhlZERicyBgYXBwbHkoKWApLlxuICAgICAqL1xuICAgIHJlbW92ZUVudHJ5KGtleSwgcmVhZFRpbWUpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RBcHBsaWVkKCk7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5zZXQoa2V5LCBNdXRhYmxlRG9jdW1lbnQubmV3SW52YWxpZERvY3VtZW50KGtleSkuc2V0UmVhZFRpbWUocmVhZFRpbWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9va3MgdXAgYW4gZW50cnkgaW4gdGhlIGNhY2hlLiBUaGUgYnVmZmVyZWQgY2hhbmdlcyB3aWxsIGZpcnN0IGJlIGNoZWNrZWQsXG4gICAgICogYW5kIGlmIG5vIGJ1ZmZlcmVkIGNoYW5nZSBhcHBsaWVzLCB0aGlzIHdpbGwgZm9yd2FyZCB0b1xuICAgICAqIGBSZW1vdGVEb2N1bWVudENhY2hlLmdldEVudHJ5KClgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVGhlIHRyYW5zYWN0aW9uIGluIHdoaWNoIHRvIHBlcmZvcm0gYW55IHBlcnNpc3RlbmNlXG4gICAgICogICAgIG9wZXJhdGlvbnMuXG4gICAgICogQHBhcmFtIGRvY3VtZW50S2V5IC0gVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gbG9vayB1cC5cbiAgICAgKiBAcmV0dXJucyBUaGUgY2FjaGVkIGRvY3VtZW50IG9yIGFuIGludmFsaWQgZG9jdW1lbnQgaWYgd2UgaGF2ZSBub3RoaW5nXG4gICAgICogY2FjaGVkLlxuICAgICAqL1xuICAgIGdldEVudHJ5KHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleSkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdEFwcGxpZWQoKTtcbiAgICAgICAgY29uc3QgYnVmZmVyZWRFbnRyeSA9IHRoaXMuY2hhbmdlcy5nZXQoZG9jdW1lbnRLZXkpO1xuICAgICAgICBpZiAoYnVmZmVyZWRFbnRyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoYnVmZmVyZWRFbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRGcm9tQ2FjaGUodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb29rcyB1cCBzZXZlcmFsIGVudHJpZXMgaW4gdGhlIGNhY2hlLCBmb3J3YXJkaW5nIHRvXG4gICAgICogYFJlbW90ZURvY3VtZW50Q2FjaGUuZ2V0RW50cnkoKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gLSBUaGUgdHJhbnNhY3Rpb24gaW4gd2hpY2ggdG8gcGVyZm9ybSBhbnkgcGVyc2lzdGVuY2VcbiAgICAgKiAgICAgb3BlcmF0aW9ucy5cbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRLZXlzIC0gVGhlIGtleXMgb2YgdGhlIGVudHJpZXMgdG8gbG9vayB1cC5cbiAgICAgKiBAcmV0dXJucyBBIG1hcCBvZiBjYWNoZWQgZG9jdW1lbnRzLCBpbmRleGVkIGJ5IGtleS4gSWYgYW4gZW50cnkgY2Fubm90IGJlXG4gICAgICogICAgIGZvdW5kLCB0aGUgY29ycmVzcG9uZGluZyBrZXkgd2lsbCBiZSBtYXBwZWQgdG8gYW4gaW52YWxpZCBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBnZXRFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsRnJvbUNhY2hlKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGJ1ZmZlcmVkIGNoYW5nZXMgdG8gdGhlIHVuZGVybHlpbmcgUmVtb3RlRG9jdW1lbnRDYWNoZSwgdXNpbmdcbiAgICAgKiB0aGUgcHJvdmlkZWQgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgYXBwbHkodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RBcHBsaWVkKCk7XG4gICAgICAgIHRoaXMuY2hhbmdlc0FwcGxpZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseUNoYW5nZXModHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgICAvKiogSGVscGVyIHRvIGFzc2VydCB0aGlzLmNoYW5nZXMgaXMgbm90IG51bGwgICovXG4gICAgYXNzZXJ0Tm90QXBwbGllZCgpIHtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFRoZSBSZW1vdGVEb2N1bWVudENhY2hlIGZvciBJbmRleGVkRGIuIFRvIGNvbnN0cnVjdCwgaW52b2tlXG4gKiBgbmV3SW5kZXhlZERiUmVtb3RlRG9jdW1lbnRDYWNoZSgpYC5cbiAqL1xuY2xhc3MgSW5kZXhlZERiUmVtb3RlRG9jdW1lbnRDYWNoZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHNlcmlhbGl6ZXIpIHtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcbiAgICB9XG4gICAgc2V0SW5kZXhNYW5hZ2VyKGluZGV4TWFuYWdlcikge1xuICAgICAgICB0aGlzLmluZGV4TWFuYWdlciA9IGluZGV4TWFuYWdlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgc3VwcGxpZWQgZW50cmllcyB0byB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBBbGwgY2FsbHMgb2YgYGFkZEVudHJ5YCBhcmUgcmVxdWlyZWQgdG8gZ28gdGhyb3VnaCB0aGUgUmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXJcbiAgICAgKiByZXR1cm5lZCBieSBgbmV3Q2hhbmdlQnVmZmVyKClgIHRvIGVuc3VyZSBwcm9wZXIgYWNjb3VudGluZyBvZiBtZXRhZGF0YS5cbiAgICAgKi9cbiAgICBhZGRFbnRyeSh0cmFuc2FjdGlvbiwga2V5LCBkb2MpIHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRTdG9yZSA9IHJlbW90ZURvY3VtZW50c1N0b3JlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50U3RvcmUucHV0KGRvYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBkb2N1bWVudCBmcm9tIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEFsbCBjYWxscyBvZiBgcmVtb3ZlRW50cnlgICBhcmUgcmVxdWlyZWQgdG8gZ28gdGhyb3VnaCB0aGUgUmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXJcbiAgICAgKiByZXR1cm5lZCBieSBgbmV3Q2hhbmdlQnVmZmVyKClgIHRvIGVuc3VyZSBwcm9wZXIgYWNjb3VudGluZyBvZiBtZXRhZGF0YS5cbiAgICAgKi9cbiAgICByZW1vdmVFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXksIHJlYWRUaW1lKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gcmVtb3RlRG9jdW1lbnRzU3RvcmUodHJhbnNhY3Rpb24pO1xuICAgICAgICByZXR1cm4gc3RvcmUuZGVsZXRlKGRiUmVhZFRpbWVLZXkoZG9jdW1lbnRLZXksIHJlYWRUaW1lKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGN1cnJlbnQgY2FjaGUgc2l6ZS5cbiAgICAgKlxuICAgICAqIENhbGxlcnMgdG8gYGFkZEVudHJ5KClgIGFuZCBgcmVtb3ZlRW50cnkoKWAgKm11c3QqIGNhbGwgdGhpcyBhZnRlcndhcmRzIHRvIHVwZGF0ZSB0aGVcbiAgICAgKiBjYWNoZSdzIG1ldGFkYXRhLlxuICAgICAqL1xuICAgIHVwZGF0ZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBzaXplRGVsdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWV0YWRhdGEodHJhbnNhY3Rpb24pLm5leHQobWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgbWV0YWRhdGEuYnl0ZVNpemUgKz0gc2l6ZURlbHRhO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TWV0YWRhdGEodHJhbnNhY3Rpb24sIG1ldGFkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEVudHJ5KHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleSkge1xuICAgICAgICBsZXQgZG9jID0gTXV0YWJsZURvY3VtZW50Lm5ld0ludmFsaWREb2N1bWVudChkb2N1bWVudEtleSk7XG4gICAgICAgIHJldHVybiByZW1vdGVEb2N1bWVudHNTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5pdGVyYXRlKHtcbiAgICAgICAgICAgIGluZGV4OiBEYlJlbW90ZURvY3VtZW50RG9jdW1lbnRLZXlJbmRleCxcbiAgICAgICAgICAgIHJhbmdlOiBJREJLZXlSYW5nZS5vbmx5KGRiS2V5KGRvY3VtZW50S2V5KSlcbiAgICAgICAgfSwgKF8sIGRiUmVtb3RlRG9jKSA9PiB7XG4gICAgICAgICAgICBkb2MgPSB0aGlzLm1heWJlRGVjb2RlRG9jdW1lbnQoZG9jdW1lbnRLZXksIGRiUmVtb3RlRG9jKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGRvYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvb2tzIHVwIGFuIGVudHJ5IGluIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkb2N1bWVudEtleSAtIFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGxvb2sgdXAuXG4gICAgICogQHJldHVybnMgVGhlIGNhY2hlZCBkb2N1bWVudCBlbnRyeSBhbmQgaXRzIHNpemUuXG4gICAgICovXG4gICAgZ2V0U2l6ZWRFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHNpemU6IDAsXG4gICAgICAgICAgICBkb2N1bWVudDogTXV0YWJsZURvY3VtZW50Lm5ld0ludmFsaWREb2N1bWVudChkb2N1bWVudEtleSlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlbW90ZURvY3VtZW50c1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLml0ZXJhdGUoe1xuICAgICAgICAgICAgaW5kZXg6IERiUmVtb3RlRG9jdW1lbnREb2N1bWVudEtleUluZGV4LFxuICAgICAgICAgICAgcmFuZ2U6IElEQktleVJhbmdlLm9ubHkoZGJLZXkoZG9jdW1lbnRLZXkpKVxuICAgICAgICB9LCAoXywgZGJSZW1vdGVEb2MpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudDogdGhpcy5tYXliZURlY29kZURvY3VtZW50KGRvY3VtZW50S2V5LCBkYlJlbW90ZURvYyksXG4gICAgICAgICAgICAgICAgc2l6ZTogZGJEb2N1bWVudFNpemUoZGJSZW1vdGVEb2MpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gcmVzdWx0KTtcbiAgICB9XG4gICAgZ2V0RW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKSB7XG4gICAgICAgIGxldCByZXN1bHRzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZvckVhY2hEYkVudHJ5KHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMsIChrZXksIGRiUmVtb3RlRG9jKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkb2MgPSB0aGlzLm1heWJlRGVjb2RlRG9jdW1lbnQoa2V5LCBkYlJlbW90ZURvYyk7XG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5pbnNlcnQoa2V5LCBkb2MpO1xuICAgICAgICB9KS5uZXh0KCgpID0+IHJlc3VsdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb29rcyB1cCBzZXZlcmFsIGVudHJpZXMgaW4gdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50S2V5cyAtIFRoZSBzZXQgb2Yga2V5cyBlbnRyaWVzIHRvIGxvb2sgdXAuXG4gICAgICogQHJldHVybnMgQSBtYXAgb2YgZG9jdW1lbnRzIGluZGV4ZWQgYnkga2V5IGFuZCBhIG1hcCBvZiBzaXplcyBpbmRleGVkIGJ5XG4gICAgICogICAgIGtleSAoemVybyBpZiB0aGUgZG9jdW1lbnQgZG9lcyBub3QgZXhpc3QpLlxuICAgICAqL1xuICAgIGdldFNpemVkRW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKSB7XG4gICAgICAgIGxldCByZXN1bHRzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XG4gICAgICAgIGxldCBzaXplTWFwID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9yRWFjaERiRW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cywgKGtleSwgZGJSZW1vdGVEb2MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IHRoaXMubWF5YmVEZWNvZGVEb2N1bWVudChrZXksIGRiUmVtb3RlRG9jKTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmluc2VydChrZXksIGRvYyk7XG4gICAgICAgICAgICBzaXplTWFwID0gc2l6ZU1hcC5pbnNlcnQoa2V5LCBkYkRvY3VtZW50U2l6ZShkYlJlbW90ZURvYykpO1xuICAgICAgICB9KS5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IGRvY3VtZW50czogcmVzdWx0cywgc2l6ZU1hcCB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZm9yRWFjaERiRW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGRvY3VtZW50S2V5cy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzb3J0ZWRLZXlzID0gbmV3IFNvcnRlZFNldChkYktleUNvbXBhcmF0b3IpO1xuICAgICAgICBkb2N1bWVudEtleXMuZm9yRWFjaChlID0+IChzb3J0ZWRLZXlzID0gc29ydGVkS2V5cy5hZGQoZSkpKTtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChkYktleShzb3J0ZWRLZXlzLmZpcnN0KCkpLCBkYktleShzb3J0ZWRLZXlzLmxhc3QoKSkpO1xuICAgICAgICBjb25zdCBrZXlJdGVyID0gc29ydGVkS2V5cy5nZXRJdGVyYXRvcigpO1xuICAgICAgICBsZXQgbmV4dEtleSA9IGtleUl0ZXIuZ2V0TmV4dCgpO1xuICAgICAgICByZXR1cm4gcmVtb3RlRG9jdW1lbnRzU3RvcmUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAuaXRlcmF0ZSh7IGluZGV4OiBEYlJlbW90ZURvY3VtZW50RG9jdW1lbnRLZXlJbmRleCwgcmFuZ2UgfSwgKF8sIGRiUmVtb3RlRG9jLCBjb250cm9sKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwb3RlbnRpYWxLZXkgPSBEb2N1bWVudEtleS5mcm9tU2VnbWVudHMoW1xuICAgICAgICAgICAgICAgIC4uLmRiUmVtb3RlRG9jLnByZWZpeFBhdGgsXG4gICAgICAgICAgICAgICAgZGJSZW1vdGVEb2MuY29sbGVjdGlvbkdyb3VwLFxuICAgICAgICAgICAgICAgIGRiUmVtb3RlRG9jLmRvY3VtZW50SWRcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgLy8gR28gdGhyb3VnaCBrZXlzIG5vdCBmb3VuZCBpbiBjYWNoZS5cbiAgICAgICAgICAgIHdoaWxlIChuZXh0S2V5ICYmIGRiS2V5Q29tcGFyYXRvcihuZXh0S2V5LCBwb3RlbnRpYWxLZXkpIDwgMCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5leHRLZXksIG51bGwpO1xuICAgICAgICAgICAgICAgIG5leHRLZXkgPSBrZXlJdGVyLmdldE5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0S2V5ICYmIG5leHRLZXkuaXNFcXVhbChwb3RlbnRpYWxLZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gS2V5IGZvdW5kIGluIGNhY2hlLlxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5leHRLZXksIGRiUmVtb3RlRG9jKTtcbiAgICAgICAgICAgICAgICBuZXh0S2V5ID0ga2V5SXRlci5oYXNOZXh0KCkgPyBrZXlJdGVyLmdldE5leHQoKSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTa2lwIHRvIHRoZSBuZXh0IGtleSAoaWYgdGhlcmUgaXMgb25lKS5cbiAgICAgICAgICAgIGlmIChuZXh0S2V5KSB7XG4gICAgICAgICAgICAgICAgY29udHJvbC5za2lwKGRiS2V5KG5leHRLZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgLy8gVGhlIHJlc3Qgb2YgdGhlIGtleXMgYXJlIG5vdCBpbiB0aGUgY2FjaGUuIE9uZSBjYXNlIHdoZXJlIGBpdGVyYXRlYFxuICAgICAgICAgICAgLy8gYWJvdmUgd29uJ3QgZ28gdGhyb3VnaCB0aGVtIGlzIHdoZW4gdGhlIGNhY2hlIGlzIGVtcHR5LlxuICAgICAgICAgICAgd2hpbGUgKG5leHRLZXkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXh0S2V5LCBudWxsKTtcbiAgICAgICAgICAgICAgICBuZXh0S2V5ID0ga2V5SXRlci5oYXNOZXh0KCkgPyBrZXlJdGVyLmdldE5leHQoKSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXREb2N1bWVudHNNYXRjaGluZ1F1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSwgb2Zmc2V0LCBtdXRhdGVkRG9jcywgY29udGV4dCkge1xuICAgICAgICBjb25zdCBjb2xsZWN0aW9uID0gcXVlcnkucGF0aDtcbiAgICAgICAgY29uc3Qgc3RhcnRLZXkgPSBbXG4gICAgICAgICAgICBjb2xsZWN0aW9uLnBvcExhc3QoKS50b0FycmF5KCksXG4gICAgICAgICAgICBjb2xsZWN0aW9uLmxhc3RTZWdtZW50KCksXG4gICAgICAgICAgICB0b0RiVGltZXN0YW1wS2V5KG9mZnNldC5yZWFkVGltZSksXG4gICAgICAgICAgICBvZmZzZXQuZG9jdW1lbnRLZXkucGF0aC5pc0VtcHR5KClcbiAgICAgICAgICAgICAgICA/ICcnXG4gICAgICAgICAgICAgICAgOiBvZmZzZXQuZG9jdW1lbnRLZXkucGF0aC5sYXN0U2VnbWVudCgpXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGVuZEtleSA9IFtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24ucG9wTGFzdCgpLnRvQXJyYXkoKSxcbiAgICAgICAgICAgIGNvbGxlY3Rpb24ubGFzdFNlZ21lbnQoKSxcbiAgICAgICAgICAgIFtOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJdLFxuICAgICAgICAgICAgJydcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIHJlbW90ZURvY3VtZW50c1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLmxvYWRBbGwoSURCS2V5UmFuZ2UuYm91bmQoc3RhcnRLZXksIGVuZEtleSwgdHJ1ZSkpXG4gICAgICAgICAgICAubmV4dChkYlJlbW90ZURvY3MgPT4ge1xuICAgICAgICAgICAgY29udGV4dCA9PT0gbnVsbCB8fCBjb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZXh0LmluY3JlbWVudERvY3VtZW50UmVhZENvdW50KGRiUmVtb3RlRG9jcy5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdHMgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGJSZW1vdGVEb2Mgb2YgZGJSZW1vdGVEb2NzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSB0aGlzLm1heWJlRGVjb2RlRG9jdW1lbnQoRG9jdW1lbnRLZXkuZnJvbVNlZ21lbnRzKGRiUmVtb3RlRG9jLnByZWZpeFBhdGguY29uY2F0KGRiUmVtb3RlRG9jLmNvbGxlY3Rpb25Hcm91cCwgZGJSZW1vdGVEb2MuZG9jdW1lbnRJZCkpLCBkYlJlbW90ZURvYyk7XG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmlzRm91bmREb2N1bWVudCgpICYmXG4gICAgICAgICAgICAgICAgICAgIChxdWVyeU1hdGNoZXMocXVlcnksIGRvY3VtZW50KSB8fCBtdXRhdGVkRG9jcy5oYXMoZG9jdW1lbnQua2V5KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWl0aGVyIHRoZSBkb2N1bWVudCBtYXRjaGVzIHRoZSBnaXZlbiBxdWVyeSwgb3IgaXQgaXMgbXV0YXRlZC5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuaW5zZXJ0KGRvY3VtZW50LmtleSwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0QWxsRnJvbUNvbGxlY3Rpb25Hcm91cCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBvZmZzZXQsIGxpbWl0KSB7XG4gICAgICAgIGxldCByZXN1bHRzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0S2V5ID0gZGJDb2xsZWN0aW9uR3JvdXBLZXkoY29sbGVjdGlvbkdyb3VwLCBvZmZzZXQpO1xuICAgICAgICBjb25zdCBlbmRLZXkgPSBkYkNvbGxlY3Rpb25Hcm91cEtleShjb2xsZWN0aW9uR3JvdXAsIEluZGV4T2Zmc2V0Lm1heCgpKTtcbiAgICAgICAgcmV0dXJuIHJlbW90ZURvY3VtZW50c1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLml0ZXJhdGUoe1xuICAgICAgICAgICAgaW5kZXg6IERiUmVtb3RlRG9jdW1lbnRDb2xsZWN0aW9uR3JvdXBJbmRleCxcbiAgICAgICAgICAgIHJhbmdlOiBJREJLZXlSYW5nZS5ib3VuZChzdGFydEtleSwgZW5kS2V5LCB0cnVlKVxuICAgICAgICB9LCAoXywgZGJSZW1vdGVEb2MsIGNvbnRyb2wpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gdGhpcy5tYXliZURlY29kZURvY3VtZW50KERvY3VtZW50S2V5LmZyb21TZWdtZW50cyhkYlJlbW90ZURvYy5wcmVmaXhQYXRoLmNvbmNhdChkYlJlbW90ZURvYy5jb2xsZWN0aW9uR3JvdXAsIGRiUmVtb3RlRG9jLmRvY3VtZW50SWQpKSwgZGJSZW1vdGVEb2MpO1xuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuaW5zZXJ0KGRvY3VtZW50LmtleSwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdHMuc2l6ZSA9PT0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHJlc3VsdHMpO1xuICAgIH1cbiAgICBuZXdDaGFuZ2VCdWZmZXIob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEluZGV4ZWREYlJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyKHRoaXMsICEhb3B0aW9ucyAmJiBvcHRpb25zLnRyYWNrUmVtb3ZhbHMpO1xuICAgIH1cbiAgICBnZXRTaXplKHR4bikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNZXRhZGF0YSh0eG4pLm5leHQobWV0YWRhdGEgPT4gbWV0YWRhdGEuYnl0ZVNpemUpO1xuICAgIH1cbiAgICBnZXRNZXRhZGF0YSh0eG4pIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50R2xvYmFsU3RvcmUodHhuKVxuICAgICAgICAgICAgLmdldChEYlJlbW90ZURvY3VtZW50R2xvYmFsS2V5KVxuICAgICAgICAgICAgLm5leHQobWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgaGFyZEFzc2VydCghIW1ldGFkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldE1ldGFkYXRhKHR4biwgbWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50R2xvYmFsU3RvcmUodHhuKS5wdXQoRGJSZW1vdGVEb2N1bWVudEdsb2JhbEtleSwgbWV0YWRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGBkYlJlbW90ZURvY2AgYW5kIHJldHVybnMgdGhlIGRvY3VtZW50IChvciBhbiBpbnZhbGlkIGRvY3VtZW50IGlmXG4gICAgICogdGhlIGRvY3VtZW50IGNvcnJlc3BvbmRzIHRvIHRoZSBmb3JtYXQgdXNlZCBmb3Igc2VudGluZWwgZGVsZXRlcykuXG4gICAgICovXG4gICAgbWF5YmVEZWNvZGVEb2N1bWVudChkb2N1bWVudEtleSwgZGJSZW1vdGVEb2MpIHtcbiAgICAgICAgaWYgKGRiUmVtb3RlRG9jKSB7XG4gICAgICAgICAgICBjb25zdCBkb2MgPSBmcm9tRGJSZW1vdGVEb2N1bWVudCh0aGlzLnNlcmlhbGl6ZXIsIGRiUmVtb3RlRG9jKTtcbiAgICAgICAgICAgIC8vIFdoZXRoZXIgdGhlIGRvY3VtZW50IGlzIGEgc2VudGluZWwgcmVtb3ZhbCBhbmQgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbiB0aGVcbiAgICAgICAgICAgIC8vIGBnZXROZXdEb2N1bWVudENoYW5nZXMoKWBcbiAgICAgICAgICAgIGNvbnN0IGlzU2VudGluZWxSZW1vdmFsID0gZG9jLmlzTm9Eb2N1bWVudCgpICYmIGRvYy52ZXJzaW9uLmlzRXF1YWwoU25hcHNob3RWZXJzaW9uLm1pbigpKTtcbiAgICAgICAgICAgIGlmICghaXNTZW50aW5lbFJlbW92YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNdXRhYmxlRG9jdW1lbnQubmV3SW52YWxpZERvY3VtZW50KGRvY3VtZW50S2V5KTtcbiAgICB9XG59XG4vKiogQ3JlYXRlcyBhIG5ldyBJbmRleGVkRGJSZW1vdGVEb2N1bWVudENhY2hlLiAqL1xuZnVuY3Rpb24gbmV3SW5kZXhlZERiUmVtb3RlRG9jdW1lbnRDYWNoZShzZXJpYWxpemVyKSB7XG4gICAgcmV0dXJuIG5ldyBJbmRleGVkRGJSZW1vdGVEb2N1bWVudENhY2hlSW1wbChzZXJpYWxpemVyKTtcbn1cbi8qKlxuICogSGFuZGxlcyB0aGUgZGV0YWlscyBvZiBhZGRpbmcgYW5kIHVwZGF0aW5nIGRvY3VtZW50cyBpbiB0aGUgSW5kZXhlZERiUmVtb3RlRG9jdW1lbnRDYWNoZS5cbiAqXG4gKiBVbmxpa2UgdGhlIE1lbW9yeVJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyLCB0aGUgSW5kZXhlZERiIGltcGxlbWVudGF0aW9uIGNvbXB1dGVzIHRoZSBzaXplXG4gKiBkZWx0YSBmb3IgYWxsIHN1Ym1pdHRlZCBjaGFuZ2VzLiBUaGlzIGF2b2lkcyBoYXZpbmcgdG8gcmUtcmVhZCBhbGwgZG9jdW1lbnRzIGZyb20gSW5kZXhlZERiXG4gKiB3aGVuIHdlIGFwcGx5IHRoZSBjaGFuZ2VzLlxuICovXG5jbGFzcyBJbmRleGVkRGJSZW1vdGVEb2N1bWVudENoYW5nZUJ1ZmZlciBleHRlbmRzIFJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRDYWNoZSAtIFRoZSBJbmRleGVkRGJSZW1vdGVEb2N1bWVudENhY2hlIHRvIGFwcGx5IHRoZSBjaGFuZ2VzIHRvLlxuICAgICAqIEBwYXJhbSB0cmFja1JlbW92YWxzIC0gV2hldGhlciB0byBjcmVhdGUgc2VudGluZWwgZGVsZXRlcyB0aGF0IGNhbiBiZSB0cmFja2VkIGJ5XG4gICAgICogYGdldE5ld0RvY3VtZW50Q2hhbmdlcygpYC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudENhY2hlLCB0cmFja1JlbW92YWxzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRDYWNoZSA9IGRvY3VtZW50Q2FjaGU7XG4gICAgICAgIHRoaXMudHJhY2tSZW1vdmFscyA9IHRyYWNrUmVtb3ZhbHM7XG4gICAgICAgIC8vIEEgbWFwIG9mIGRvY3VtZW50IHNpemVzIGFuZCByZWFkIHRpbWVzIHByaW9yIHRvIGFwcGx5aW5nIHRoZSBjaGFuZ2VzIGluXG4gICAgICAgIC8vIHRoaXMgYnVmZmVyLlxuICAgICAgICB0aGlzLmRvY3VtZW50U3RhdGVzID0gbmV3IE9iamVjdE1hcChrZXkgPT4ga2V5LnRvU3RyaW5nKCksIChsLCByKSA9PiBsLmlzRXF1YWwocikpO1xuICAgIH1cbiAgICBhcHBseUNoYW5nZXModHJhbnNhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgbGV0IHNpemVEZWx0YSA9IDA7XG4gICAgICAgIGxldCBjb2xsZWN0aW9uUGFyZW50cyA9IG5ldyBTb3J0ZWRTZXQoKGwsIHIpID0+IHByaW1pdGl2ZUNvbXBhcmF0b3IobC5jYW5vbmljYWxTdHJpbmcoKSwgci5jYW5vbmljYWxTdHJpbmcoKSkpO1xuICAgICAgICB0aGlzLmNoYW5nZXMuZm9yRWFjaCgoa2V5LCBkb2N1bWVudENoYW5nZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNEb2MgPSB0aGlzLmRvY3VtZW50U3RhdGVzLmdldChrZXkpO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmRvY3VtZW50Q2FjaGUucmVtb3ZlRW50cnkodHJhbnNhY3Rpb24sIGtleSwgcHJldmlvdXNEb2MucmVhZFRpbWUpKTtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudENoYW5nZS5pc1ZhbGlkRG9jdW1lbnQoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvYyA9IHRvRGJSZW1vdGVEb2N1bWVudCh0aGlzLmRvY3VtZW50Q2FjaGUuc2VyaWFsaXplciwgZG9jdW1lbnRDaGFuZ2UpO1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25QYXJlbnRzID0gY29sbGVjdGlvblBhcmVudHMuYWRkKGtleS5wYXRoLnBvcExhc3QoKSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGRiRG9jdW1lbnRTaXplKGRvYyk7XG4gICAgICAgICAgICAgICAgc2l6ZURlbHRhICs9IHNpemUgLSBwcmV2aW91c0RvYy5zaXplO1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5kb2N1bWVudENhY2hlLmFkZEVudHJ5KHRyYW5zYWN0aW9uLCBrZXksIGRvYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2l6ZURlbHRhIC09IHByZXZpb3VzRG9jLnNpemU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tSZW1vdmFscykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBvcmRlciB0byB0cmFjayByZW1vdmFscywgd2Ugc3RvcmUgYSBcInNlbnRpbmVsIGRlbGV0ZVwiIGluIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdGVEb2N1bWVudENhY2hlLiBUaGlzIGVudHJ5IGlzIHJlcHJlc2VudGVkIGJ5IGEgTm9Eb2N1bWVudFxuICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIGEgdmVyc2lvbiBvZiAwIGFuZCBpZ25vcmVkIGJ5IGBtYXliZURlY29kZURvY3VtZW50KClgIGJ1dFxuICAgICAgICAgICAgICAgICAgICAvLyBwcmVzZXJ2ZWQgaW4gYGdldE5ld0RvY3VtZW50Q2hhbmdlcygpYC5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsZXRlZERvYyA9IHRvRGJSZW1vdGVEb2N1bWVudCh0aGlzLmRvY3VtZW50Q2FjaGUuc2VyaWFsaXplciwgZG9jdW1lbnRDaGFuZ2UuY29udmVydFRvTm9Eb2N1bWVudChTbmFwc2hvdFZlcnNpb24ubWluKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmRvY3VtZW50Q2FjaGUuYWRkRW50cnkodHJhbnNhY3Rpb24sIGtleSwgZGVsZXRlZERvYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbGxlY3Rpb25QYXJlbnRzLmZvckVhY2gocGFyZW50ID0+IHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5kb2N1bWVudENhY2hlLmluZGV4TWFuYWdlci5hZGRUb0NvbGxlY3Rpb25QYXJlbnRJbmRleCh0cmFuc2FjdGlvbiwgcGFyZW50KSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuZG9jdW1lbnRDYWNoZS51cGRhdGVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgc2l6ZURlbHRhKSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcyk7XG4gICAgfVxuICAgIGdldEZyb21DYWNoZSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpIHtcbiAgICAgICAgLy8gUmVjb3JkIHRoZSBzaXplIG9mIGV2ZXJ5dGhpbmcgd2UgbG9hZCBmcm9tIHRoZSBjYWNoZSBzbyB3ZSBjYW4gY29tcHV0ZSBhIGRlbHRhIGxhdGVyLlxuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudENhY2hlXG4gICAgICAgICAgICAuZ2V0U2l6ZWRFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpXG4gICAgICAgICAgICAubmV4dChnZXRSZXN1bHQgPT4ge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudFN0YXRlcy5zZXQoZG9jdW1lbnRLZXksIHtcbiAgICAgICAgICAgICAgICBzaXplOiBnZXRSZXN1bHQuc2l6ZSxcbiAgICAgICAgICAgICAgICByZWFkVGltZTogZ2V0UmVzdWx0LmRvY3VtZW50LnJlYWRUaW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBnZXRSZXN1bHQuZG9jdW1lbnQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRBbGxGcm9tQ2FjaGUodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cykge1xuICAgICAgICAvLyBSZWNvcmQgdGhlIHNpemUgb2YgZXZlcnl0aGluZyB3ZSBsb2FkIGZyb20gdGhlIGNhY2hlIHNvIHdlIGNhbiBjb21wdXRlXG4gICAgICAgIC8vIGEgZGVsdGEgbGF0ZXIuXG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50Q2FjaGVcbiAgICAgICAgICAgIC5nZXRTaXplZEVudHJpZXModHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cylcbiAgICAgICAgICAgIC5uZXh0KCh7IGRvY3VtZW50cywgc2l6ZU1hcCB9KSA9PiB7XG4gICAgICAgICAgICAvLyBOb3RlOiBgZ2V0QWxsRnJvbUNhY2hlYCByZXR1cm5zIHR3byBtYXBzIGluc3RlYWQgb2YgYSBzaW5nbGUgbWFwIGZyb21cbiAgICAgICAgICAgIC8vIGtleXMgdG8gYERvY3VtZW50U2l6ZUVudHJ5YHMuIFRoaXMgaXMgdG8gYWxsb3cgcmV0dXJuaW5nIHRoZVxuICAgICAgICAgICAgLy8gYE11dGFibGVEb2N1bWVudE1hcGAgZGlyZWN0bHksIHdpdGhvdXQgYSBjb252ZXJzaW9uLlxuICAgICAgICAgICAgc2l6ZU1hcC5mb3JFYWNoKChkb2N1bWVudEtleSwgc2l6ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRTdGF0ZXMuc2V0KGRvY3VtZW50S2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICAgICAgICAgIHJlYWRUaW1lOiBkb2N1bWVudHMuZ2V0KGRvY3VtZW50S2V5KS5yZWFkVGltZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnRzO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBkb2N1bWVudEdsb2JhbFN0b3JlKHR4bikge1xuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiUmVtb3RlRG9jdW1lbnRHbG9iYWxTdG9yZSk7XG59XG4vKipcbiAqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZvciB0aGUgcmVtb3RlRG9jdW1lbnRzIG9iamVjdCBzdG9yZS5cbiAqL1xuZnVuY3Rpb24gcmVtb3RlRG9jdW1lbnRzU3RvcmUodHhuKSB7XG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJSZW1vdGVEb2N1bWVudFN0b3JlKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIGtleSB0aGF0IGNhbiBiZSB1c2VkIGZvciBkb2N1bWVudCBsb29rdXBzIG9uIHRoZVxuICogYERiUmVtb3RlRG9jdW1lbnREb2N1bWVudEtleUluZGV4YCBpbmRleC5cbiAqL1xuZnVuY3Rpb24gZGJLZXkoZG9jdW1lbnRLZXkpIHtcbiAgICBjb25zdCBwYXRoID0gZG9jdW1lbnRLZXkucGF0aC50b0FycmF5KCk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgLyogcHJlZml4IHBhdGggKi8gcGF0aC5zbGljZSgwLCBwYXRoLmxlbmd0aCAtIDIpLFxuICAgICAgICAvKiBjb2xsZWN0aW9uIGlkICovIHBhdGhbcGF0aC5sZW5ndGggLSAyXSxcbiAgICAgICAgLyogZG9jdW1lbnQgaWQgKi8gcGF0aFtwYXRoLmxlbmd0aCAtIDFdXG4gICAgXTtcbn1cbi8qKlxuICogUmV0dXJucyBhIGtleSB0aGF0IGNhbiBiZSB1c2VkIGZvciBkb2N1bWVudCBsb29rdXBzIHZpYSB0aGUgcHJpbWFyeSBrZXkgb2ZcbiAqIHRoZSBEYlJlbW90ZURvY3VtZW50IG9iamVjdCBzdG9yZS5cbiAqL1xuZnVuY3Rpb24gZGJSZWFkVGltZUtleShkb2N1bWVudEtleSwgcmVhZFRpbWUpIHtcbiAgICBjb25zdCBwYXRoID0gZG9jdW1lbnRLZXkucGF0aC50b0FycmF5KCk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgLyogcHJlZml4IHBhdGggKi8gcGF0aC5zbGljZSgwLCBwYXRoLmxlbmd0aCAtIDIpLFxuICAgICAgICAvKiBjb2xsZWN0aW9uIGlkICovIHBhdGhbcGF0aC5sZW5ndGggLSAyXSxcbiAgICAgICAgdG9EYlRpbWVzdGFtcEtleShyZWFkVGltZSksXG4gICAgICAgIC8qIGRvY3VtZW50IGlkICovIHBhdGhbcGF0aC5sZW5ndGggLSAxXVxuICAgIF07XG59XG4vKipcbiAqIFJldHVybnMgYSBrZXkgdGhhdCBjYW4gYmUgdXNlZCBmb3IgZG9jdW1lbnQgbG9va3VwcyBvbiB0aGVcbiAqIGBEYlJlbW90ZURvY3VtZW50RG9jdW1lbnRDb2xsZWN0aW9uR3JvdXBJbmRleGAgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGRiQ29sbGVjdGlvbkdyb3VwS2V5KGNvbGxlY3Rpb25Hcm91cCwgb2Zmc2V0KSB7XG4gICAgY29uc3QgcGF0aCA9IG9mZnNldC5kb2N1bWVudEtleS5wYXRoLnRvQXJyYXkoKTtcbiAgICByZXR1cm4gW1xuICAgICAgICAvKiBjb2xsZWN0aW9uIGlkICovIGNvbGxlY3Rpb25Hcm91cCxcbiAgICAgICAgdG9EYlRpbWVzdGFtcEtleShvZmZzZXQucmVhZFRpbWUpLFxuICAgICAgICAvKiBwcmVmaXggcGF0aCAqLyBwYXRoLnNsaWNlKDAsIHBhdGgubGVuZ3RoIC0gMiksXG4gICAgICAgIC8qIGRvY3VtZW50IGlkICovIHBhdGgubGVuZ3RoID4gMCA/IHBhdGhbcGF0aC5sZW5ndGggLSAxXSA6ICcnXG4gICAgXTtcbn1cbi8qKlxuICogQ29tcGFyYXRvciB0aGF0IGNvbXBhcmVzIGRvY3VtZW50IGtleXMgYWNjb3JkaW5nIHRvIHRoZSBwcmltYXJ5IGtleSBzb3J0aW5nXG4gKiB1c2VkIGJ5IHRoZSBgRGJSZW1vdGVEb2N1bWVudERvY3VtZW50YCBzdG9yZSAoYnkgcHJlZml4IHBhdGgsIGNvbGxlY3Rpb24gaWRcbiAqIGFuZCB0aGVuIGRvY3VtZW50IElEKS5cbiAqXG4gKiBWaXNpYmxlIGZvciB0ZXN0aW5nLlxuICovXG5mdW5jdGlvbiBkYktleUNvbXBhcmF0b3IobCwgcikge1xuICAgIGNvbnN0IGxlZnQgPSBsLnBhdGgudG9BcnJheSgpO1xuICAgIGNvbnN0IHJpZ2h0ID0gci5wYXRoLnRvQXJyYXkoKTtcbiAgICAvLyBUaGUgb3JkZXJpbmcgaXMgYmFzZWQgb24gaHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL2JsaW5rLysvZmU1YzIxZmVmOTRkYWU3MWMxYzMzNDQ3NzViOGQ4YTdmN2U2ZDllYy9Tb3VyY2UvbW9kdWxlcy9pbmRleGVkZGIvSURCS2V5LmNwcCM3NFxuICAgIGxldCBjbXAgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdC5sZW5ndGggLSAyICYmIGkgPCByaWdodC5sZW5ndGggLSAyOyArK2kpIHtcbiAgICAgICAgY21wID0gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0W2ldLCByaWdodFtpXSk7XG4gICAgICAgIGlmIChjbXApIHtcbiAgICAgICAgICAgIHJldHVybiBjbXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY21wID0gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0Lmxlbmd0aCwgcmlnaHQubGVuZ3RoKTtcbiAgICBpZiAoY21wKSB7XG4gICAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuICAgIGNtcCA9IHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdFtsZWZ0Lmxlbmd0aCAtIDJdLCByaWdodFtyaWdodC5sZW5ndGggLSAyXSk7XG4gICAgaWYgKGNtcCkge1xuICAgICAgICByZXR1cm4gY21wO1xuICAgIH1cbiAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0W2xlZnQubGVuZ3RoIC0gMV0sIHJpZ2h0W3JpZ2h0Lmxlbmd0aCAtIDFdKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogU2NoZW1hIFZlcnNpb24gZm9yIHRoZSBXZWIgY2xpZW50OlxuICogMS4gIEluaXRpYWwgdmVyc2lvbiBpbmNsdWRpbmcgTXV0YXRpb24gUXVldWUsIFF1ZXJ5IENhY2hlLCBhbmQgUmVtb3RlXG4gKiAgICAgRG9jdW1lbnQgQ2FjaGVcbiAqIDIuICBVc2VkIHRvIGVuc3VyZSBhIHRhcmdldEdsb2JhbCBvYmplY3QgZXhpc3RzIGFuZCBhZGQgdGFyZ2V0Q291bnQgdG8gaXQuIE5vXG4gKiAgICAgbG9uZ2VyIHJlcXVpcmVkIGJlY2F1c2UgbWlncmF0aW9uIDMgdW5jb25kaXRpb25hbGx5IGNsZWFycyBpdC5cbiAqIDMuICBEcm9wcGVkIGFuZCByZS1jcmVhdGVkIFF1ZXJ5IENhY2hlIHRvIGRlYWwgd2l0aCBjYWNoZSBjb3JydXB0aW9uIHJlbGF0ZWRcbiAqICAgICB0byBsaW1ibyByZXNvbHV0aW9uLiBBZGRyZXNzZXNcbiAqICAgICBodHRwczovL2dpdGh1Yi5jb20vZmlyZWJhc2UvZmlyZWJhc2UtaW9zLXNkay9pc3N1ZXMvMTU0OFxuICogNC4gIE11bHRpLVRhYiBTdXBwb3J0LlxuICogNS4gIFJlbW92YWwgb2YgaGVsZCB3cml0ZSBhY2tzLlxuICogNi4gIENyZWF0ZSBkb2N1bWVudCBnbG9iYWwgZm9yIHRyYWNraW5nIGRvY3VtZW50IGNhY2hlIHNpemUuXG4gKiA3LiAgRW5zdXJlIGV2ZXJ5IGNhY2hlZCBkb2N1bWVudCBoYXMgYSBzZW50aW5lbCByb3cgd2l0aCBhIHNlcXVlbmNlIG51bWJlci5cbiAqIDguICBBZGQgY29sbGVjdGlvbi1wYXJlbnQgaW5kZXggZm9yIENvbGxlY3Rpb24gR3JvdXAgcXVlcmllcy5cbiAqIDkuICBDaGFuZ2UgUmVtb3RlRG9jdW1lbnRDaGFuZ2VzIHN0b3JlIHRvIGJlIGtleWVkIGJ5IHJlYWRUaW1lIHJhdGhlciB0aGFuXG4gKiAgICAgYW4gYXV0by1pbmNyZW1lbnRpbmcgSUQuIFRoaXMgaXMgcmVxdWlyZWQgZm9yIEluZGV4LUZyZWUgcXVlcmllcy5cbiAqIDEwLiBSZXdyaXRlIHRoZSBjYW5vbmljYWwgSURzIHRvIHRoZSBleHBsaWNpdCBQcm90b2J1Zi1iYXNlZCBmb3JtYXQuXG4gKiAxMS4gQWRkIGJ1bmRsZXMgYW5kIG5hbWVkX3F1ZXJpZXMgZm9yIGJ1bmRsZSBzdXBwb3J0LlxuICogMTIuIEFkZCBkb2N1bWVudCBvdmVybGF5cy5cbiAqIDEzLiBSZXdyaXRlIHRoZSBrZXlzIG9mIHRoZSByZW1vdGUgZG9jdW1lbnQgY2FjaGUgdG8gYWxsb3cgZm9yIGVmZmljaWVudFxuICogICAgIGRvY3VtZW50IGxvb2t1cCB2aWEgYGdldEFsbCgpYC5cbiAqIDE0LiBBZGQgb3ZlcmxheXMuXG4gKiAxNS4gQWRkIGluZGV4aW5nIHN1cHBvcnQuXG4gKiAxNi4gUGFyc2UgdGltZXN0YW1wIHN0cmluZ3MgYmVmb3JlIGNyZWF0aW5nIGluZGV4IGVudHJpZXMuXG4gKi9cbmNvbnN0IFNDSEVNQV9WRVJTSU9OID0gMTc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgYSBsb2NhbCB2aWV3IChvdmVybGF5KSBvZiBhIGRvY3VtZW50LCBhbmQgdGhlIGZpZWxkcyB0aGF0IGFyZVxuICogbG9jYWxseSBtdXRhdGVkLlxuICovXG5jbGFzcyBPdmVybGF5ZWREb2N1bWVudCB7XG4gICAgY29uc3RydWN0b3Iob3ZlcmxheWVkRG9jdW1lbnQsIFxuICAgIC8qKlxuICAgICAqIFRoZSBmaWVsZHMgdGhhdCBhcmUgbG9jYWxseSBtdXRhdGVkIGJ5IHBhdGNoIG11dGF0aW9ucy5cbiAgICAgKlxuICAgICAqIElmIHRoZSBvdmVybGF5ZWRcdGRvY3VtZW50IGlzIGZyb20gc2V0IG9yIGRlbGV0ZSBtdXRhdGlvbnMsIHRoaXMgaXMgYG51bGxgLlxuICAgICAqIElmIHRoZXJlIGlzIG5vIG92ZXJsYXkgKG11dGF0aW9uKSBmb3IgdGhlIGRvY3VtZW50LCB0aGlzIGlzIGFuIGVtcHR5IGBGaWVsZE1hc2tgLlxuICAgICAqL1xuICAgIG11dGF0ZWRGaWVsZHMpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5ZWREb2N1bWVudCA9IG92ZXJsYXllZERvY3VtZW50O1xuICAgICAgICB0aGlzLm11dGF0ZWRGaWVsZHMgPSBtdXRhdGVkRmllbGRzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSByZWFkb25seSB2aWV3IG9mIHRoZSBsb2NhbCBzdGF0ZSBvZiBhbGwgZG9jdW1lbnRzIHdlJ3JlIHRyYWNraW5nIChpLmUuIHdlXG4gKiBoYXZlIGEgY2FjaGVkIHZlcnNpb24gaW4gcmVtb3RlRG9jdW1lbnRDYWNoZSBvciBsb2NhbCBtdXRhdGlvbnMgZm9yIHRoZVxuICogZG9jdW1lbnQpLiBUaGUgdmlldyBpcyBjb21wdXRlZCBieSBhcHBseWluZyB0aGUgbXV0YXRpb25zIGluIHRoZVxuICogTXV0YXRpb25RdWV1ZSB0byB0aGUgUmVtb3RlRG9jdW1lbnRDYWNoZS5cbiAqL1xuY2xhc3MgTG9jYWxEb2N1bWVudHNWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihyZW1vdGVEb2N1bWVudENhY2hlLCBtdXRhdGlvblF1ZXVlLCBkb2N1bWVudE92ZXJsYXlDYWNoZSwgaW5kZXhNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMucmVtb3RlRG9jdW1lbnRDYWNoZSA9IHJlbW90ZURvY3VtZW50Q2FjaGU7XG4gICAgICAgIHRoaXMubXV0YXRpb25RdWV1ZSA9IG11dGF0aW9uUXVldWU7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRPdmVybGF5Q2FjaGUgPSBkb2N1bWVudE92ZXJsYXlDYWNoZTtcbiAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIgPSBpbmRleE1hbmFnZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbG9jYWwgdmlldyBvZiB0aGUgZG9jdW1lbnQgaWRlbnRpZmllZCBieSBga2V5YC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIExvY2FsIHZpZXcgb2YgdGhlIGRvY3VtZW50IG9yIG51bGwgaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgY2FjaGVkXG4gICAgICogc3RhdGUgZm9yIGl0LlxuICAgICAqL1xuICAgIGdldERvY3VtZW50KHRyYW5zYWN0aW9uLCBrZXkpIHtcbiAgICAgICAgbGV0IG92ZXJsYXkgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudE92ZXJsYXlDYWNoZVxuICAgICAgICAgICAgLmdldE92ZXJsYXkodHJhbnNhY3Rpb24sIGtleSlcbiAgICAgICAgICAgIC5uZXh0KHZhbHVlID0+IHtcbiAgICAgICAgICAgIG92ZXJsYXkgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGUuZ2V0RW50cnkodHJhbnNhY3Rpb24sIGtleSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dChkb2N1bWVudCA9PiB7XG4gICAgICAgICAgICBpZiAob3ZlcmxheSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhvdmVybGF5Lm11dGF0aW9uLCBkb2N1bWVudCwgRmllbGRNYXNrLmVtcHR5KCksIFRpbWVzdGFtcC5ub3coKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsb2NhbCB2aWV3IG9mIHRoZSBkb2N1bWVudHMgaWRlbnRpZmllZCBieSBga2V5c2AuXG4gICAgICpcbiAgICAgKiBJZiB3ZSBkb24ndCBoYXZlIGNhY2hlZCBzdGF0ZSBmb3IgYSBkb2N1bWVudCBpbiBga2V5c2AsIGEgTm9Eb2N1bWVudCB3aWxsXG4gICAgICogYmUgc3RvcmVkIGZvciB0aGF0IGtleSBpbiB0aGUgcmVzdWx0aW5nIHNldC5cbiAgICAgKi9cbiAgICBnZXREb2N1bWVudHModHJhbnNhY3Rpb24sIGtleXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3RlRG9jdW1lbnRDYWNoZVxuICAgICAgICAgICAgLmdldEVudHJpZXModHJhbnNhY3Rpb24sIGtleXMpXG4gICAgICAgICAgICAubmV4dChkb2NzID0+IHRoaXMuZ2V0TG9jYWxWaWV3T2ZEb2N1bWVudHModHJhbnNhY3Rpb24sIGRvY3MsIGRvY3VtZW50S2V5U2V0KCkpLm5leHQoKCkgPT4gZG9jcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW1pbGFyIHRvIGBnZXREb2N1bWVudHNgLCBidXQgY3JlYXRlcyB0aGUgbG9jYWwgdmlldyBmcm9tIHRoZSBnaXZlblxuICAgICAqIGBiYXNlRG9jc2Agd2l0aG91dCByZXRyaWV2aW5nIGRvY3VtZW50cyBmcm9tIHRoZSBsb2NhbCBzdG9yZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbiAtIFRoZSB0cmFuc2FjdGlvbiB0aGlzIG9wZXJhdGlvbiBpcyBzY29wZWQgdG8uXG4gICAgICogQHBhcmFtIGRvY3MgLSBUaGUgZG9jdW1lbnRzIHRvIGFwcGx5IGxvY2FsIG11dGF0aW9ucyB0byBnZXQgdGhlIGxvY2FsIHZpZXdzLlxuICAgICAqIEBwYXJhbSBleGlzdGVuY2VTdGF0ZUNoYW5nZWQgLSBUaGUgc2V0IG9mIGRvY3VtZW50IGtleXMgd2hvc2UgZXhpc3RlbmNlIHN0YXRlXG4gICAgICogICBpcyBjaGFuZ2VkLiBUaGlzIGlzIHVzZWZ1bCB0byBkZXRlcm1pbmUgaWYgc29tZSBkb2N1bWVudHMgb3ZlcmxheSBuZWVkc1xuICAgICAqICAgdG8gYmUgcmVjYWxjdWxhdGVkLlxuICAgICAqL1xuICAgIGdldExvY2FsVmlld09mRG9jdW1lbnRzKHRyYW5zYWN0aW9uLCBkb2NzLCBleGlzdGVuY2VTdGF0ZUNoYW5nZWQgPSBkb2N1bWVudEtleVNldCgpKSB7XG4gICAgICAgIGNvbnN0IG92ZXJsYXlzID0gbmV3T3ZlcmxheU1hcCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wb3B1bGF0ZU92ZXJsYXlzKHRyYW5zYWN0aW9uLCBvdmVybGF5cywgZG9jcykubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlVmlld3ModHJhbnNhY3Rpb24sIGRvY3MsIG92ZXJsYXlzLCBleGlzdGVuY2VTdGF0ZUNoYW5nZWQpLm5leHQoY29tcHV0ZVZpZXdzUmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gZG9jdW1lbnRNYXAoKTtcbiAgICAgICAgICAgICAgICBjb21wdXRlVmlld3NSZXN1bHQuZm9yRWFjaCgoZG9jdW1lbnRLZXksIG92ZXJsYXllZERvY3VtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5pbnNlcnQoZG9jdW1lbnRLZXksIG92ZXJsYXllZERvY3VtZW50Lm92ZXJsYXllZERvY3VtZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBvdmVybGF5ZWQgZG9jdW1lbnRzIGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnQgbWFwLCB3aGljaCB3aWxsIGluY2x1ZGVcbiAgICAgKiB0aGUgbG9jYWwgdmlldyBvZiB0aG9zZSBkb2N1bWVudHMgYW5kIGEgYEZpZWxkTWFza2AgaW5kaWNhdGluZyB3aGljaCBmaWVsZHNcbiAgICAgKiBhcmUgbXV0YXRlZCBsb2NhbGx5LCBgbnVsbGAgaWYgb3ZlcmxheSBpcyBhIFNldCBvciBEZWxldGUgbXV0YXRpb24uXG4gICAgICovXG4gICAgZ2V0T3ZlcmxheWVkRG9jdW1lbnRzKHRyYW5zYWN0aW9uLCBkb2NzKSB7XG4gICAgICAgIGNvbnN0IG92ZXJsYXlzID0gbmV3T3ZlcmxheU1hcCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wb3B1bGF0ZU92ZXJsYXlzKHRyYW5zYWN0aW9uLCBvdmVybGF5cywgZG9jcykubmV4dCgoKSA9PiB0aGlzLmNvbXB1dGVWaWV3cyh0cmFuc2FjdGlvbiwgZG9jcywgb3ZlcmxheXMsIGRvY3VtZW50S2V5U2V0KCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgb3ZlcmxheXMgZm9yIHtAY29kZSBkb2NzfSBhbmQgYWRkcyB0aGVtIHRvIHByb3ZpZGVkIG92ZXJsYXkgbWFwXG4gICAgICogaWYgdGhlIG1hcCBkb2VzIG5vdCBhbHJlYWR5IGNvbnRhaW4gYW4gZW50cnkgZm9yIHRoZSBnaXZlbiBkb2N1bWVudCBrZXkuXG4gICAgICovXG4gICAgcG9wdWxhdGVPdmVybGF5cyh0cmFuc2FjdGlvbiwgb3ZlcmxheXMsIGRvY3MpIHtcbiAgICAgICAgY29uc3QgbWlzc2luZ092ZXJsYXlzID0gW107XG4gICAgICAgIGRvY3MuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKCFvdmVybGF5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIG1pc3NpbmdPdmVybGF5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudE92ZXJsYXlDYWNoZVxuICAgICAgICAgICAgLmdldE92ZXJsYXlzKHRyYW5zYWN0aW9uLCBtaXNzaW5nT3ZlcmxheXMpXG4gICAgICAgICAgICAubmV4dChyZXN1bHQgPT4ge1xuICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goKGtleSwgdmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgb3ZlcmxheXMuc2V0KGtleSwgdmFsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGxvY2FsIHZpZXcgZm9yIHRoZSBnaXZlbiBkb2N1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZG9jcyAtIFRoZSBkb2N1bWVudHMgdG8gY29tcHV0ZSB2aWV3cyBmb3IuIEl0IGFsc28gaGFzIHRoZSBiYXNlXG4gICAgICogICB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudHMuXG4gICAgICogQHBhcmFtIG92ZXJsYXlzIC0gVGhlIG92ZXJsYXlzIHRoYXQgbmVlZCB0byBiZSBhcHBsaWVkIHRvIHRoZSBnaXZlbiBiYXNlXG4gICAgICogICB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudHMuXG4gICAgICogQHBhcmFtIGV4aXN0ZW5jZVN0YXRlQ2hhbmdlZCAtIEEgc2V0IG9mIGRvY3VtZW50cyB3aG9zZSBleGlzdGVuY2Ugc3RhdGVzXG4gICAgICogICBtaWdodCBoYXZlIGNoYW5nZWQuIFRoaXMgaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgd2UgbmVlZCB0byByZS1jYWxjdWxhdGVcbiAgICAgKiAgIG92ZXJsYXlzIGZyb20gbXV0YXRpb24gcXVldWVzLlxuICAgICAqIEByZXR1cm4gQSBtYXAgcmVwcmVzZW50cyB0aGUgbG9jYWwgZG9jdW1lbnRzIHZpZXcuXG4gICAgICovXG4gICAgY29tcHV0ZVZpZXdzKHRyYW5zYWN0aW9uLCBkb2NzLCBvdmVybGF5cywgZXhpc3RlbmNlU3RhdGVDaGFuZ2VkKSB7XG4gICAgICAgIGxldCByZWNhbGN1bGF0ZURvY3VtZW50cyA9IG11dGFibGVEb2N1bWVudE1hcCgpO1xuICAgICAgICBjb25zdCBtdXRhdGVkRmllbGRzID0gbmV3RG9jdW1lbnRLZXlNYXAoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IG5ld092ZXJsYXllZERvY3VtZW50TWFwKCk7XG4gICAgICAgIGRvY3MuZm9yRWFjaCgoXywgZG9jKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvdmVybGF5ID0gb3ZlcmxheXMuZ2V0KGRvYy5rZXkpO1xuICAgICAgICAgICAgLy8gUmVjYWxjdWxhdGUgYW4gb3ZlcmxheSBpZiB0aGUgZG9jdW1lbnQncyBleGlzdGVuY2Ugc3RhdGUgY2hhbmdlZCBkdWUgdG9cbiAgICAgICAgICAgIC8vIGEgcmVtb3RlIGV2ZW50ICphbmQqIHRoZSBvdmVybGF5IGlzIGEgUGF0Y2hNdXRhdGlvbi4gVGhpcyBpcyBiZWNhdXNlXG4gICAgICAgICAgICAvLyBkb2N1bWVudCBleGlzdGVuY2Ugc3RhdGUgY2FuIGNoYW5nZSBpZiBzb21lIHBhdGNoIG11dGF0aW9uJ3NcbiAgICAgICAgICAgIC8vIHByZWNvbmRpdGlvbnMgYXJlIG1ldC5cbiAgICAgICAgICAgIC8vIE5PVEU6IHdlIHJlY2FsY3VsYXRlIHdoZW4gYG92ZXJsYXlgIGlzIHVuZGVmaW5lZCBhcyB3ZWxsLCBiZWNhdXNlIHRoZXJlXG4gICAgICAgICAgICAvLyBtaWdodCBiZSBhIHBhdGNoIG11dGF0aW9uIHdob3NlIHByZWNvbmRpdGlvbiBkb2VzIG5vdCBtYXRjaCBiZWZvcmUgdGhlXG4gICAgICAgICAgICAvLyBjaGFuZ2UgKGhlbmNlIG92ZXJsYXkgaXMgdW5kZWZpbmVkKSwgYnV0IHdvdWxkIG5vdyBtYXRjaC5cbiAgICAgICAgICAgIGlmIChleGlzdGVuY2VTdGF0ZUNoYW5nZWQuaGFzKGRvYy5rZXkpICYmXG4gICAgICAgICAgICAgICAgKG92ZXJsYXkgPT09IHVuZGVmaW5lZCB8fCBvdmVybGF5Lm11dGF0aW9uIGluc3RhbmNlb2YgUGF0Y2hNdXRhdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZWNhbGN1bGF0ZURvY3VtZW50cyA9IHJlY2FsY3VsYXRlRG9jdW1lbnRzLmluc2VydChkb2Mua2V5LCBkb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3ZlcmxheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbXV0YXRlZEZpZWxkcy5zZXQoZG9jLmtleSwgb3ZlcmxheS5tdXRhdGlvbi5nZXRGaWVsZE1hc2soKSk7XG4gICAgICAgICAgICAgICAgbXV0YXRpb25BcHBseVRvTG9jYWxWaWV3KG92ZXJsYXkubXV0YXRpb24sIGRvYywgb3ZlcmxheS5tdXRhdGlvbi5nZXRGaWVsZE1hc2soKSwgVGltZXN0YW1wLm5vdygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5vIG92ZXJsYXkgZXhpc3RzXG4gICAgICAgICAgICAgICAgLy8gVXNpbmcgRU1QVFkgdG8gaW5kaWNhdGUgdGhlcmUgaXMgbm8gb3ZlcmxheSBmb3IgdGhlIGRvY3VtZW50LlxuICAgICAgICAgICAgICAgIG11dGF0ZWRGaWVsZHMuc2V0KGRvYy5rZXksIEZpZWxkTWFzay5lbXB0eSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY2FsY3VsYXRlQW5kU2F2ZU92ZXJsYXlzKHRyYW5zYWN0aW9uLCByZWNhbGN1bGF0ZURvY3VtZW50cykubmV4dChyZWNhbGN1bGF0ZWRGaWVsZHMgPT4ge1xuICAgICAgICAgICAgcmVjYWxjdWxhdGVkRmllbGRzLmZvckVhY2goKGRvY3VtZW50S2V5LCBtYXNrKSA9PiBtdXRhdGVkRmllbGRzLnNldChkb2N1bWVudEtleSwgbWFzaykpO1xuICAgICAgICAgICAgZG9jcy5mb3JFYWNoKChkb2N1bWVudEtleSwgZG9jdW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHMuc2V0KGRvY3VtZW50S2V5LCBuZXcgT3ZlcmxheWVkRG9jdW1lbnQoZG9jdW1lbnQsIChfYSA9IG11dGF0ZWRGaWVsZHMuZ2V0KGRvY3VtZW50S2V5KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlY2FsY3VsYXRlQW5kU2F2ZU92ZXJsYXlzKHRyYW5zYWN0aW9uLCBkb2NzKSB7XG4gICAgICAgIGNvbnN0IG1hc2tzID0gbmV3RG9jdW1lbnRLZXlNYXAoKTtcbiAgICAgICAgLy8gQSByZXZlcnNlIGxvb2t1cCBtYXAgZnJvbSBiYXRjaCBpZCB0byB0aGUgZG9jdW1lbnRzIHdpdGhpbiB0aGF0IGJhdGNoLlxuICAgICAgICBsZXQgZG9jdW1lbnRzQnlCYXRjaElkID0gbmV3IFNvcnRlZE1hcCgoa2V5MSwga2V5MikgPT4ga2V5MSAtIGtleTIpO1xuICAgICAgICBsZXQgcHJvY2Vzc2VkID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubXV0YXRpb25RdWV1ZVxuICAgICAgICAgICAgLmdldEFsbE11dGF0aW9uQmF0Y2hlc0FmZmVjdGluZ0RvY3VtZW50S2V5cyh0cmFuc2FjdGlvbiwgZG9jcylcbiAgICAgICAgICAgIC5uZXh0KGJhdGNoZXMgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBiYXRjaCBvZiBiYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgYmF0Y2gua2V5cygpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFzZURvYyA9IGRvY3MuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXNlRG9jID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hc2sgPSBtYXNrcy5nZXQoa2V5KSB8fCBGaWVsZE1hc2suZW1wdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgbWFzayA9IGJhdGNoLmFwcGx5VG9Mb2NhbFZpZXcoYmFzZURvYywgbWFzayk7XG4gICAgICAgICAgICAgICAgICAgIG1hc2tzLnNldChrZXksIG1hc2spO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdTZXQgPSAoZG9jdW1lbnRzQnlCYXRjaElkLmdldChiYXRjaC5iYXRjaElkKSB8fCBkb2N1bWVudEtleVNldCgpKS5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRzQnlCYXRjaElkID0gZG9jdW1lbnRzQnlCYXRjaElkLmluc2VydChiYXRjaC5iYXRjaElkLCBuZXdTZXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgaW4gZGVzY2VuZGluZyBvcmRlciBvZiBiYXRjaCBJRHMsIGFuZCBza2lwIGRvY3VtZW50cyB0aGF0IGFyZVxuICAgICAgICAgICAgLy8gYWxyZWFkeSBzYXZlZC5cbiAgICAgICAgICAgIGNvbnN0IGl0ZXIgPSBkb2N1bWVudHNCeUJhdGNoSWQuZ2V0UmV2ZXJzZUl0ZXJhdG9yKCk7XG4gICAgICAgICAgICB3aGlsZSAoaXRlci5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IGl0ZXIuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoSWQgPSBlbnRyeS5rZXk7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IGVudHJ5LnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlzID0gbmV3TXV0YXRpb25NYXAoKTtcbiAgICAgICAgICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9jZXNzZWQuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlNdXRhdGlvbiA9IGNhbGN1bGF0ZU92ZXJsYXlNdXRhdGlvbihkb2NzLmdldChrZXkpLCBtYXNrcy5nZXQoa2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxheU11dGF0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheXMuc2V0KGtleSwgb3ZlcmxheU11dGF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZCA9IHByb2Nlc3NlZC5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5kb2N1bWVudE92ZXJsYXlDYWNoZS5zYXZlT3ZlcmxheXModHJhbnNhY3Rpb24sIGJhdGNoSWQsIG92ZXJsYXlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbWFza3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZXMgb3ZlcmxheXMgYnkgcmVhZGluZyB0aGUgZG9jdW1lbnRzIGZyb20gcmVtb3RlIGRvY3VtZW50IGNhY2hlXG4gICAgICogZmlyc3QsIGFuZCBzYXZlcyB0aGVtIGFmdGVyIHRoZXkgYXJlIGNhbGN1bGF0ZWQuXG4gICAgICovXG4gICAgcmVjYWxjdWxhdGVBbmRTYXZlT3ZlcmxheXNGb3JEb2N1bWVudEtleXModHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdGVEb2N1bWVudENhY2hlXG4gICAgICAgICAgICAuZ2V0RW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKVxuICAgICAgICAgICAgLm5leHQoZG9jcyA9PiB0aGlzLnJlY2FsY3VsYXRlQW5kU2F2ZU92ZXJsYXlzKHRyYW5zYWN0aW9uLCBkb2NzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgcXVlcnkgYWdhaW5zdCB0aGUgbG9jYWwgdmlldyBvZiBhbGwgZG9jdW1lbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVGhlIHBlcnNpc3RlbmNlIHRyYW5zYWN0aW9uLlxuICAgICAqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeSB0byBtYXRjaCBkb2N1bWVudHMgYWdhaW5zdC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IC0gUmVhZCB0aW1lIGFuZCBrZXkgdG8gc3RhcnQgc2Nhbm5pbmcgYnkgKGV4Y2x1c2l2ZSkuXG4gICAgICogQHBhcmFtIGNvbnRleHQgLSBBIG9wdGlvbmFsIHRyYWNrZXIgdG8ga2VlcCBhIHJlY29yZCBvZiBpbXBvcnRhbnQgZGV0YWlsc1xuICAgICAqICAgZHVyaW5nIGRhdGFiYXNlIGxvY2FsIHF1ZXJ5IGV4ZWN1dGlvbi5cbiAgICAgKi9cbiAgICBnZXREb2N1bWVudHNNYXRjaGluZ1F1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSwgb2Zmc2V0LCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChpc0RvY3VtZW50UXVlcnkkMShxdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERvY3VtZW50c01hdGNoaW5nRG9jdW1lbnRRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnkucGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDb2xsZWN0aW9uR3JvdXBRdWVyeShxdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERvY3VtZW50c01hdGNoaW5nQ29sbGVjdGlvbkdyb3VwUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBvZmZzZXQsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RG9jdW1lbnRzTWF0Y2hpbmdDb2xsZWN0aW9uUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBvZmZzZXQsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgY29sbGVjdGlvbiBncm91cCwgcmV0dXJucyB0aGUgbmV4dCBkb2N1bWVudHMgdGhhdCBmb2xsb3cgdGhlIHByb3ZpZGVkIG9mZnNldCwgYWxvbmdcbiAgICAgKiB3aXRoIGFuIHVwZGF0ZWQgYmF0Y2ggSUQuXG4gICAgICpcbiAgICAgKiA8cD5UaGUgZG9jdW1lbnRzIHJldHVybmVkIGJ5IHRoaXMgbWV0aG9kIGFyZSBvcmRlcmVkIGJ5IHJlbW90ZSB2ZXJzaW9uIGZyb20gdGhlIHByb3ZpZGVkXG4gICAgICogb2Zmc2V0LiBJZiB0aGVyZSBhcmUgbm8gbW9yZSByZW1vdGUgZG9jdW1lbnRzIGFmdGVyIHRoZSBwcm92aWRlZCBvZmZzZXQsIGRvY3VtZW50cyB3aXRoXG4gICAgICogbXV0YXRpb25zIGluIG9yZGVyIG9mIGJhdGNoIGlkIGZyb20gdGhlIG9mZnNldCBhcmUgcmV0dXJuZWQuIFNpbmNlIGFsbCBkb2N1bWVudHMgaW4gYSBiYXRjaCBhcmVcbiAgICAgKiByZXR1cm5lZCB0b2dldGhlciwgdGhlIHRvdGFsIG51bWJlciBvZiBkb2N1bWVudHMgcmV0dXJuZWQgY2FuIGV4Y2VlZCB7QGNvZGUgY291bnR9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25Hcm91cCBUaGUgY29sbGVjdGlvbiBncm91cCBmb3IgdGhlIGRvY3VtZW50cy5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IFRoZSBvZmZzZXQgdG8gaW5kZXggaW50by5cbiAgICAgKiBAcGFyYW0gY291bnQgVGhlIG51bWJlciBvZiBkb2N1bWVudHMgdG8gcmV0dXJuXG4gICAgICogQHJldHVybiBBIExvY2FsV3JpdGVSZXN1bHQgd2l0aCB0aGUgZG9jdW1lbnRzIHRoYXQgZm9sbG93IHRoZSBwcm92aWRlZCBvZmZzZXQgYW5kIHRoZSBsYXN0IHByb2Nlc3NlZCBiYXRjaCBpZC5cbiAgICAgKi9cbiAgICBnZXROZXh0RG9jdW1lbnRzKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIG9mZnNldCwgY291bnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3RlRG9jdW1lbnRDYWNoZVxuICAgICAgICAgICAgLmdldEFsbEZyb21Db2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCwgb2Zmc2V0LCBjb3VudClcbiAgICAgICAgICAgIC5uZXh0KChvcmlnaW5hbERvY3MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlzUHJvbWlzZSA9IGNvdW50IC0gb3JpZ2luYWxEb2NzLnNpemUgPiAwXG4gICAgICAgICAgICAgICAgPyB0aGlzLmRvY3VtZW50T3ZlcmxheUNhY2hlLmdldE92ZXJsYXlzRm9yQ29sbGVjdGlvbkdyb3VwKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIG9mZnNldC5sYXJnZXN0QmF0Y2hJZCwgY291bnQgLSBvcmlnaW5hbERvY3Muc2l6ZSlcbiAgICAgICAgICAgICAgICA6IFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKG5ld092ZXJsYXlNYXAoKSk7XG4gICAgICAgICAgICAvLyBUaGUgY2FsbHNpdGUgd2lsbCB1c2UgdGhlIGxhcmdlc3QgYmF0Y2ggSUQgdG9nZXRoZXIgd2l0aCB0aGUgbGF0ZXN0IHJlYWQgdGltZSB0byBjcmVhdGVcbiAgICAgICAgICAgIC8vIGEgbmV3IGluZGV4IG9mZnNldC4gU2luY2Ugd2Ugb25seSBwcm9jZXNzIGJhdGNoIElEcyBpZiBhbGwgcmVtb3RlIGRvY3VtZW50cyBoYXZlIGJlZW4gcmVhZCxcbiAgICAgICAgICAgIC8vIG5vIG92ZXJsYXkgd2lsbCBpbmNyZWFzZSB0aGUgb3ZlcmFsbCByZWFkIHRpbWUuIFRoaXMgaXMgd2h5IHdlIG9ubHkgbmVlZCB0byBzcGVjaWFsIGNhc2VcbiAgICAgICAgICAgIC8vIHRoZSBiYXRjaCBpZC5cbiAgICAgICAgICAgIGxldCBsYXJnZXN0QmF0Y2hJZCA9IElOSVRJQUxfTEFSR0VTVF9CQVRDSF9JRDtcbiAgICAgICAgICAgIGxldCBtb2RpZmllZERvY3MgPSBvcmlnaW5hbERvY3M7XG4gICAgICAgICAgICByZXR1cm4gb3ZlcmxheXNQcm9taXNlLm5leHQob3ZlcmxheXMgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChvdmVybGF5cywgKGtleSwgb3ZlcmxheSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFyZ2VzdEJhdGNoSWQgPCBvdmVybGF5Lmxhcmdlc3RCYXRjaElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXJnZXN0QmF0Y2hJZCA9IG92ZXJsYXkubGFyZ2VzdEJhdGNoSWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsRG9jcy5nZXQoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3RlRG9jdW1lbnRDYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldEVudHJ5KHRyYW5zYWN0aW9uLCBrZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAubmV4dChkb2MgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWREb2NzID0gbW9kaWZpZWREb2NzLmluc2VydChrZXksIGRvYyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IHRoaXMucG9wdWxhdGVPdmVybGF5cyh0cmFuc2FjdGlvbiwgb3ZlcmxheXMsIG9yaWdpbmFsRG9jcykpXG4gICAgICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IHRoaXMuY29tcHV0ZVZpZXdzKHRyYW5zYWN0aW9uLCBtb2RpZmllZERvY3MsIG92ZXJsYXlzLCBkb2N1bWVudEtleVNldCgpKSlcbiAgICAgICAgICAgICAgICAgICAgLm5leHQobG9jYWxEb2NzID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIGJhdGNoSWQ6IGxhcmdlc3RCYXRjaElkLFxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzOiBjb252ZXJ0T3ZlcmxheWVkRG9jdW1lbnRNYXBUb0RvY3VtZW50TWFwKGxvY2FsRG9jcylcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldERvY3VtZW50c01hdGNoaW5nRG9jdW1lbnRRdWVyeSh0cmFuc2FjdGlvbiwgZG9jUGF0aCkge1xuICAgICAgICAvLyBKdXN0IGRvIGEgc2ltcGxlIGRvY3VtZW50IGxvb2t1cC5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RG9jdW1lbnQodHJhbnNhY3Rpb24sIG5ldyBEb2N1bWVudEtleShkb2NQYXRoKSkubmV4dChkb2N1bWVudCA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gZG9jdW1lbnRNYXAoKTtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5pc0ZvdW5kRG9jdW1lbnQoKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5pbnNlcnQoZG9jdW1lbnQua2V5LCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0RG9jdW1lbnRzTWF0Y2hpbmdDb2xsZWN0aW9uR3JvdXBRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnksIG9mZnNldCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBjb2xsZWN0aW9uSWQgPSBxdWVyeS5jb2xsZWN0aW9uR3JvdXA7XG4gICAgICAgIGxldCByZXN1bHRzID0gZG9jdW1lbnRNYXAoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhNYW5hZ2VyXG4gICAgICAgICAgICAuZ2V0Q29sbGVjdGlvblBhcmVudHModHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25JZClcbiAgICAgICAgICAgIC5uZXh0KHBhcmVudHMgPT4ge1xuICAgICAgICAgICAgLy8gUGVyZm9ybSBhIGNvbGxlY3Rpb24gcXVlcnkgYWdhaW5zdCBlYWNoIHBhcmVudCB0aGF0IGNvbnRhaW5zIHRoZVxuICAgICAgICAgICAgLy8gY29sbGVjdGlvbklkIGFuZCBhZ2dyZWdhdGUgdGhlIHJlc3VsdHMuXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2gocGFyZW50cywgKHBhcmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxlY3Rpb25RdWVyeSA9IGFzQ29sbGVjdGlvblF1ZXJ5QXRQYXRoKHF1ZXJ5LCBwYXJlbnQuY2hpbGQoY29sbGVjdGlvbklkKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RG9jdW1lbnRzTWF0Y2hpbmdDb2xsZWN0aW9uUXVlcnkodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25RdWVyeSwgb2Zmc2V0LCBjb250ZXh0KS5uZXh0KHIgPT4ge1xuICAgICAgICAgICAgICAgICAgICByLmZvckVhY2goKGtleSwgZG9jKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5pbnNlcnQoa2V5LCBkb2MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLm5leHQoKCkgPT4gcmVzdWx0cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXREb2N1bWVudHNNYXRjaGluZ0NvbGxlY3Rpb25RdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnksIG9mZnNldCwgY29udGV4dCkge1xuICAgICAgICAvLyBRdWVyeSB0aGUgcmVtb3RlIGRvY3VtZW50cyBhbmQgb3ZlcmxheSBtdXRhdGlvbnMuXG4gICAgICAgIGxldCBvdmVybGF5cztcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRPdmVybGF5Q2FjaGVcbiAgICAgICAgICAgIC5nZXRPdmVybGF5c0ZvckNvbGxlY3Rpb24odHJhbnNhY3Rpb24sIHF1ZXJ5LnBhdGgsIG9mZnNldC5sYXJnZXN0QmF0Y2hJZClcbiAgICAgICAgICAgIC5uZXh0KHJlc3VsdCA9PiB7XG4gICAgICAgICAgICBvdmVybGF5cyA9IHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGUuZ2V0RG9jdW1lbnRzTWF0Y2hpbmdRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnksIG9mZnNldCwgb3ZlcmxheXMsIGNvbnRleHQpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQocmVtb3RlRG9jdW1lbnRzID0+IHtcbiAgICAgICAgICAgIC8vIEFzIGRvY3VtZW50cyBtaWdodCBtYXRjaCB0aGUgcXVlcnkgYmVjYXVzZSBvZiB0aGVpciBvdmVybGF5IHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIGluY2x1ZGUgZG9jdW1lbnRzIGZvciBhbGwgb3ZlcmxheXMgaW4gdGhlIGluaXRpYWwgZG9jdW1lbnQgc2V0LlxuICAgICAgICAgICAgb3ZlcmxheXMuZm9yRWFjaCgoXywgb3ZlcmxheSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IG92ZXJsYXkuZ2V0S2V5KCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW90ZURvY3VtZW50cy5nZXQoa2V5KSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVEb2N1bWVudHMgPSByZW1vdGVEb2N1bWVudHMuaW5zZXJ0KGtleSwgTXV0YWJsZURvY3VtZW50Lm5ld0ludmFsaWREb2N1bWVudChrZXkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBvdmVybGF5cyBhbmQgbWF0Y2ggYWdhaW5zdCB0aGUgcXVlcnkuXG4gICAgICAgICAgICBsZXQgcmVzdWx0cyA9IGRvY3VtZW50TWFwKCk7XG4gICAgICAgICAgICByZW1vdGVEb2N1bWVudHMuZm9yRWFjaCgoa2V5LCBkb2N1bWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXkgPSBvdmVybGF5cy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhvdmVybGF5Lm11dGF0aW9uLCBkb2N1bWVudCwgRmllbGRNYXNrLmVtcHR5KCksIFRpbWVzdGFtcC5ub3coKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZpbmFsbHksIGluc2VydCB0aGUgZG9jdW1lbnRzIHRoYXQgc3RpbGwgbWF0Y2ggdGhlIHF1ZXJ5XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXJ5TWF0Y2hlcyhxdWVyeSwgZG9jdW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmluc2VydChrZXksIGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBNZW1vcnlCdW5kbGVDYWNoZSB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWFsaXplcikge1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xuICAgICAgICB0aGlzLmJ1bmRsZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubmFtZWRRdWVyaWVzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBnZXRCdW5kbGVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgYnVuZGxlSWQpIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMuYnVuZGxlcy5nZXQoYnVuZGxlSWQpKTtcbiAgICB9XG4gICAgc2F2ZUJ1bmRsZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBidW5kbGVNZXRhZGF0YSkge1xuICAgICAgICB0aGlzLmJ1bmRsZXMuc2V0KGJ1bmRsZU1ldGFkYXRhLmlkLCBmcm9tQnVuZGxlTWV0YWRhdGEoYnVuZGxlTWV0YWRhdGEpKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGdldE5hbWVkUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5TmFtZSkge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5uYW1lZFF1ZXJpZXMuZ2V0KHF1ZXJ5TmFtZSkpO1xuICAgIH1cbiAgICBzYXZlTmFtZWRRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnkpIHtcbiAgICAgICAgdGhpcy5uYW1lZFF1ZXJpZXMuc2V0KHF1ZXJ5Lm5hbWUsIGZyb21Qcm90b05hbWVkUXVlcnkocXVlcnkpKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBbiBpbi1tZW1vcnkgaW1wbGVtZW50YXRpb24gb2YgRG9jdW1lbnRPdmVybGF5Q2FjaGUuXG4gKi9cbmNsYXNzIE1lbW9yeURvY3VtZW50T3ZlcmxheUNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gQSBtYXAgc29ydGVkIGJ5IERvY3VtZW50S2V5LCB3aG9zZSB2YWx1ZSBpcyBhIHBhaXIgb2YgdGhlIGxhcmdlc3QgYmF0Y2ggaWRcbiAgICAgICAgLy8gZm9yIHRoZSBvdmVybGF5IGFuZCB0aGUgb3ZlcmxheSBpdHNlbGYuXG4gICAgICAgIHRoaXMub3ZlcmxheXMgPSBuZXcgU29ydGVkTWFwKERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xuICAgICAgICB0aGlzLm92ZXJsYXlCeUJhdGNoSWQgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGdldE92ZXJsYXkodHJhbnNhY3Rpb24sIGtleSkge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5vdmVybGF5cy5nZXQoa2V5KSk7XG4gICAgfVxuICAgIGdldE92ZXJsYXlzKHRyYW5zYWN0aW9uLCBrZXlzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ld092ZXJsYXlNYXAoKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKGtleXMsIChrZXkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE92ZXJsYXkodHJhbnNhY3Rpb24sIGtleSkubmV4dChvdmVybGF5ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGtleSwgb3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLm5leHQoKCkgPT4gcmVzdWx0KTtcbiAgICB9XG4gICAgc2F2ZU92ZXJsYXlzKHRyYW5zYWN0aW9uLCBsYXJnZXN0QmF0Y2hJZCwgb3ZlcmxheXMpIHtcbiAgICAgICAgb3ZlcmxheXMuZm9yRWFjaCgoXywgbXV0YXRpb24pID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2F2ZU92ZXJsYXkodHJhbnNhY3Rpb24sIGxhcmdlc3RCYXRjaElkLCBtdXRhdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgcmVtb3ZlT3ZlcmxheXNGb3JCYXRjaElkKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMsIGJhdGNoSWQpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IHRoaXMub3ZlcmxheUJ5QmF0Y2hJZC5nZXQoYmF0Y2hJZCk7XG4gICAgICAgIGlmIChrZXlzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gKHRoaXMub3ZlcmxheXMgPSB0aGlzLm92ZXJsYXlzLnJlbW92ZShrZXkpKSk7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlCeUJhdGNoSWQuZGVsZXRlKGJhdGNoSWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBnZXRPdmVybGF5c0ZvckNvbGxlY3Rpb24odHJhbnNhY3Rpb24sIGNvbGxlY3Rpb24sIHNpbmNlQmF0Y2hJZCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXdPdmVybGF5TWFwKCk7XG4gICAgICAgIGNvbnN0IGltbWVkaWF0ZUNoaWxkcmVuUGF0aExlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoICsgMTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gbmV3IERvY3VtZW50S2V5KGNvbGxlY3Rpb24uY2hpbGQoJycpKTtcbiAgICAgICAgY29uc3QgaXRlciA9IHRoaXMub3ZlcmxheXMuZ2V0SXRlcmF0b3JGcm9tKHByZWZpeCk7XG4gICAgICAgIHdoaWxlIChpdGVyLmhhc05leHQoKSkge1xuICAgICAgICAgICAgY29uc3QgZW50cnkgPSBpdGVyLmdldE5leHQoKTtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXkgPSBlbnRyeS52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IG92ZXJsYXkuZ2V0S2V5KCk7XG4gICAgICAgICAgICBpZiAoIWNvbGxlY3Rpb24uaXNQcmVmaXhPZihrZXkucGF0aCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvY3VtZW50cyBmcm9tIHN1Yi1jb2xsZWN0aW9uc1xuICAgICAgICAgICAgaWYgKGtleS5wYXRoLmxlbmd0aCAhPT0gaW1tZWRpYXRlQ2hpbGRyZW5QYXRoTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3ZlcmxheS5sYXJnZXN0QmF0Y2hJZCA+IHNpbmNlQmF0Y2hJZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQob3ZlcmxheS5nZXRLZXkoKSwgb3ZlcmxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfVxuICAgIGdldE92ZXJsYXlzRm9yQ29sbGVjdGlvbkdyb3VwKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIHNpbmNlQmF0Y2hJZCwgY291bnQpIHtcbiAgICAgICAgbGV0IGJhdGNoSWRUb092ZXJsYXlzID0gbmV3IFNvcnRlZE1hcCgoa2V5MSwga2V5MikgPT4ga2V5MSAtIGtleTIpO1xuICAgICAgICBjb25zdCBpdGVyID0gdGhpcy5vdmVybGF5cy5nZXRJdGVyYXRvcigpO1xuICAgICAgICB3aGlsZSAoaXRlci5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gaXRlci5nZXROZXh0KCk7XG4gICAgICAgICAgICBjb25zdCBvdmVybGF5ID0gZW50cnkudmFsdWU7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBvdmVybGF5LmdldEtleSgpO1xuICAgICAgICAgICAgaWYgKGtleS5nZXRDb2xsZWN0aW9uR3JvdXAoKSAhPT0gY29sbGVjdGlvbkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3ZlcmxheS5sYXJnZXN0QmF0Y2hJZCA+IHNpbmNlQmF0Y2hJZCkge1xuICAgICAgICAgICAgICAgIGxldCBvdmVybGF5c0ZvckJhdGNoSWQgPSBiYXRjaElkVG9PdmVybGF5cy5nZXQob3ZlcmxheS5sYXJnZXN0QmF0Y2hJZCk7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXlzRm9yQmF0Y2hJZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBvdmVybGF5c0ZvckJhdGNoSWQgPSBuZXdPdmVybGF5TWFwKCk7XG4gICAgICAgICAgICAgICAgICAgIGJhdGNoSWRUb092ZXJsYXlzID0gYmF0Y2hJZFRvT3ZlcmxheXMuaW5zZXJ0KG92ZXJsYXkubGFyZ2VzdEJhdGNoSWQsIG92ZXJsYXlzRm9yQmF0Y2hJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG92ZXJsYXlzRm9yQmF0Y2hJZC5zZXQob3ZlcmxheS5nZXRLZXkoKSwgb3ZlcmxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3T3ZlcmxheU1hcCgpO1xuICAgICAgICBjb25zdCBiYXRjaEl0ZXIgPSBiYXRjaElkVG9PdmVybGF5cy5nZXRJdGVyYXRvcigpO1xuICAgICAgICB3aGlsZSAoYmF0Y2hJdGVyLmhhc05leHQoKSkge1xuICAgICAgICAgICAgY29uc3QgZW50cnkgPSBiYXRjaEl0ZXIuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheXMgPSBlbnRyeS52YWx1ZTtcbiAgICAgICAgICAgIG92ZXJsYXlzLmZvckVhY2goKGtleSwgb3ZlcmxheSkgPT4gcmVzdWx0LnNldChrZXksIG92ZXJsYXkpKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc2l6ZSgpID49IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfVxuICAgIHNhdmVPdmVybGF5KHRyYW5zYWN0aW9uLCBsYXJnZXN0QmF0Y2hJZCwgbXV0YXRpb24pIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBhc3NvY2lhdGlvbiBvZiB0aGUgb3ZlcmxheSB0byBpdHMgYmF0Y2ggaWQuXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5vdmVybGF5cy5nZXQobXV0YXRpb24ua2V5KTtcbiAgICAgICAgaWYgKGV4aXN0aW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTZXQgPSB0aGlzLm92ZXJsYXlCeUJhdGNoSWRcbiAgICAgICAgICAgICAgICAuZ2V0KGV4aXN0aW5nLmxhcmdlc3RCYXRjaElkKVxuICAgICAgICAgICAgICAgIC5kZWxldGUobXV0YXRpb24ua2V5KTtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheUJ5QmF0Y2hJZC5zZXQoZXhpc3RpbmcubGFyZ2VzdEJhdGNoSWQsIG5ld1NldCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdmVybGF5cyA9IHRoaXMub3ZlcmxheXMuaW5zZXJ0KG11dGF0aW9uLmtleSwgbmV3IE92ZXJsYXkobGFyZ2VzdEJhdGNoSWQsIG11dGF0aW9uKSk7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgYXNzb2NpYXRpb24gb2YgdGhpcyBvdmVybGF5IHRvIHRoZSBnaXZlbiBsYXJnZXN0QmF0Y2hJZC5cbiAgICAgICAgbGV0IGJhdGNoID0gdGhpcy5vdmVybGF5QnlCYXRjaElkLmdldChsYXJnZXN0QmF0Y2hJZCk7XG4gICAgICAgIGlmIChiYXRjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBiYXRjaCA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlCeUJhdGNoSWQuc2V0KGxhcmdlc3RCYXRjaElkLCBiYXRjaCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdmVybGF5QnlCYXRjaElkLnNldChsYXJnZXN0QmF0Y2hJZCwgYmF0Y2guYWRkKG11dGF0aW9uLmtleSkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjQgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIE1lbW9yeUdsb2JhbHNDYWNoZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvblRva2VuID0gQnl0ZVN0cmluZy5FTVBUWV9CWVRFX1NUUklORztcbiAgICB9XG4gICAgZ2V0U2Vzc2lvblRva2VuKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLnNlc3Npb25Ub2tlbik7XG4gICAgfVxuICAgIHNldFNlc3Npb25Ub2tlbih0cmFuc2FjdGlvbiwgc2Vzc2lvblRva2VuKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvblRva2VuID0gc2Vzc2lvblRva2VuO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiByZWZlcmVuY2VzIHRvIGEgZG9jdW1lbnQgZnJvbSBzb21lIGtpbmQgb2YgbnVtYmVyZWQgZW50aXR5XG4gKiAoZWl0aGVyIGEgdGFyZ2V0IElEIG9yIGJhdGNoIElEKS4gQXMgcmVmZXJlbmNlcyBhcmUgYWRkZWQgdG8gb3IgcmVtb3ZlZCBmcm9tXG4gKiB0aGUgc2V0IGNvcnJlc3BvbmRpbmcgZXZlbnRzIGFyZSBlbWl0dGVkIHRvIGEgcmVnaXN0ZXJlZCBnYXJiYWdlIGNvbGxlY3Rvci5cbiAqXG4gKiBFYWNoIHJlZmVyZW5jZSBpcyByZXByZXNlbnRlZCBieSBhIERvY3VtZW50UmVmZXJlbmNlIG9iamVjdC4gRWFjaCBvZiB0aGVtXG4gKiBjb250YWlucyBlbm91Z2ggaW5mb3JtYXRpb24gdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhlIHJlZmVyZW5jZS4gVGhleSBhcmUgYWxsXG4gKiBzdG9yZWQgcHJpbWFyaWx5IGluIGEgc2V0IHNvcnRlZCBieSBrZXkuIEEgZG9jdW1lbnQgaXMgY29uc2lkZXJlZCBnYXJiYWdlIGlmXG4gKiB0aGVyZSdzIG5vIHJlZmVyZW5jZXMgaW4gdGhhdCBzZXQgKHRoaXMgY2FuIGJlIGVmZmljaWVudGx5IGNoZWNrZWQgdGhhbmtzIHRvXG4gKiBzb3J0aW5nIGJ5IGtleSkuXG4gKlxuICogUmVmZXJlbmNlU2V0IGFsc28ga2VlcHMgYSBzZWNvbmRhcnkgc2V0IHRoYXQgY29udGFpbnMgcmVmZXJlbmNlcyBzb3J0ZWQgYnlcbiAqIElEcy4gVGhpcyBvbmUgaXMgdXNlZCB0byBlZmZpY2llbnRseSBpbXBsZW1lbnQgcmVtb3ZhbCBvZiBhbGwgcmVmZXJlbmNlcyBieVxuICogc29tZSB0YXJnZXQgSUQuXG4gKi9cbmNsYXNzIFJlZmVyZW5jZVNldCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIEEgc2V0IG9mIG91dHN0YW5kaW5nIHJlZmVyZW5jZXMgdG8gYSBkb2N1bWVudCBzb3J0ZWQgYnkga2V5LlxuICAgICAgICB0aGlzLnJlZnNCeUtleSA9IG5ldyBTb3J0ZWRTZXQoRG9jUmVmZXJlbmNlLmNvbXBhcmVCeUtleSk7XG4gICAgICAgIC8vIEEgc2V0IG9mIG91dHN0YW5kaW5nIHJlZmVyZW5jZXMgdG8gYSBkb2N1bWVudCBzb3J0ZWQgYnkgdGFyZ2V0IGlkLlxuICAgICAgICB0aGlzLnJlZnNCeVRhcmdldCA9IG5ldyBTb3J0ZWRTZXQoRG9jUmVmZXJlbmNlLmNvbXBhcmVCeVRhcmdldElkKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmVmZXJlbmNlIHNldCBjb250YWlucyBubyByZWZlcmVuY2VzLiAqL1xuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZnNCeUtleS5pc0VtcHR5KCk7XG4gICAgfVxuICAgIC8qKiBBZGRzIGEgcmVmZXJlbmNlIHRvIHRoZSBnaXZlbiBkb2N1bWVudCBrZXkgZm9yIHRoZSBnaXZlbiBJRC4gKi9cbiAgICBhZGRSZWZlcmVuY2Uoa2V5LCBpZCkge1xuICAgICAgICBjb25zdCByZWYgPSBuZXcgRG9jUmVmZXJlbmNlKGtleSwgaWQpO1xuICAgICAgICB0aGlzLnJlZnNCeUtleSA9IHRoaXMucmVmc0J5S2V5LmFkZChyZWYpO1xuICAgICAgICB0aGlzLnJlZnNCeVRhcmdldCA9IHRoaXMucmVmc0J5VGFyZ2V0LmFkZChyZWYpO1xuICAgIH1cbiAgICAvKiogQWRkIHJlZmVyZW5jZXMgdG8gdGhlIGdpdmVuIGRvY3VtZW50IGtleXMgZm9yIHRoZSBnaXZlbiBJRC4gKi9cbiAgICBhZGRSZWZlcmVuY2VzKGtleXMsIGlkKSB7XG4gICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gdGhpcy5hZGRSZWZlcmVuY2Uoa2V5LCBpZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgcmVmZXJlbmNlIHRvIHRoZSBnaXZlbiBkb2N1bWVudCBrZXkgZm9yIHRoZSBnaXZlblxuICAgICAqIElELlxuICAgICAqL1xuICAgIHJlbW92ZVJlZmVyZW5jZShrZXksIGlkKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlUmVmKG5ldyBEb2NSZWZlcmVuY2Uoa2V5LCBpZCkpO1xuICAgIH1cbiAgICByZW1vdmVSZWZlcmVuY2VzKGtleXMsIGlkKSB7XG4gICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gdGhpcy5yZW1vdmVSZWZlcmVuY2Uoa2V5LCBpZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIHJlZmVyZW5jZXMgd2l0aCBhIGdpdmVuIElELiBDYWxscyByZW1vdmVSZWYoKSBmb3IgZWFjaCBrZXlcbiAgICAgKiByZW1vdmVkLlxuICAgICAqL1xuICAgIHJlbW92ZVJlZmVyZW5jZXNGb3JJZChpZCkge1xuICAgICAgICBjb25zdCBlbXB0eUtleSA9IG5ldyBEb2N1bWVudEtleShuZXcgUmVzb3VyY2VQYXRoKFtdKSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0UmVmID0gbmV3IERvY1JlZmVyZW5jZShlbXB0eUtleSwgaWQpO1xuICAgICAgICBjb25zdCBlbmRSZWYgPSBuZXcgRG9jUmVmZXJlbmNlKGVtcHR5S2V5LCBpZCArIDEpO1xuICAgICAgICBjb25zdCBrZXlzID0gW107XG4gICAgICAgIHRoaXMucmVmc0J5VGFyZ2V0LmZvckVhY2hJblJhbmdlKFtzdGFydFJlZiwgZW5kUmVmXSwgcmVmID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUmVmKHJlZik7XG4gICAgICAgICAgICBrZXlzLnB1c2gocmVmLmtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9XG4gICAgcmVtb3ZlQWxsUmVmZXJlbmNlcygpIHtcbiAgICAgICAgdGhpcy5yZWZzQnlLZXkuZm9yRWFjaChyZWYgPT4gdGhpcy5yZW1vdmVSZWYocmVmKSk7XG4gICAgfVxuICAgIHJlbW92ZVJlZihyZWYpIHtcbiAgICAgICAgdGhpcy5yZWZzQnlLZXkgPSB0aGlzLnJlZnNCeUtleS5kZWxldGUocmVmKTtcbiAgICAgICAgdGhpcy5yZWZzQnlUYXJnZXQgPSB0aGlzLnJlZnNCeVRhcmdldC5kZWxldGUocmVmKTtcbiAgICB9XG4gICAgcmVmZXJlbmNlc0ZvcklkKGlkKSB7XG4gICAgICAgIGNvbnN0IGVtcHR5S2V5ID0gbmV3IERvY3VtZW50S2V5KG5ldyBSZXNvdXJjZVBhdGgoW10pKTtcbiAgICAgICAgY29uc3Qgc3RhcnRSZWYgPSBuZXcgRG9jUmVmZXJlbmNlKGVtcHR5S2V5LCBpZCk7XG4gICAgICAgIGNvbnN0IGVuZFJlZiA9IG5ldyBEb2NSZWZlcmVuY2UoZW1wdHlLZXksIGlkICsgMSk7XG4gICAgICAgIGxldCBrZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgdGhpcy5yZWZzQnlUYXJnZXQuZm9yRWFjaEluUmFuZ2UoW3N0YXJ0UmVmLCBlbmRSZWZdLCByZWYgPT4ge1xuICAgICAgICAgICAga2V5cyA9IGtleXMuYWRkKHJlZi5rZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuICAgIGNvbnRhaW5zS2V5KGtleSkge1xuICAgICAgICBjb25zdCByZWYgPSBuZXcgRG9jUmVmZXJlbmNlKGtleSwgMCk7XG4gICAgICAgIGNvbnN0IGZpcnN0UmVmID0gdGhpcy5yZWZzQnlLZXkuZmlyc3RBZnRlck9yRXF1YWwocmVmKTtcbiAgICAgICAgcmV0dXJuIGZpcnN0UmVmICE9PSBudWxsICYmIGtleS5pc0VxdWFsKGZpcnN0UmVmLmtleSk7XG4gICAgfVxufVxuY2xhc3MgRG9jUmVmZXJlbmNlIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIHRhcmdldE9yQmF0Y2hJZCkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy50YXJnZXRPckJhdGNoSWQgPSB0YXJnZXRPckJhdGNoSWQ7XG4gICAgfVxuICAgIC8qKiBDb21wYXJlIGJ5IGtleSB0aGVuIGJ5IElEICovXG4gICAgc3RhdGljIGNvbXBhcmVCeUtleShsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gKERvY3VtZW50S2V5LmNvbXBhcmF0b3IobGVmdC5rZXksIHJpZ2h0LmtleSkgfHxcbiAgICAgICAgICAgIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdC50YXJnZXRPckJhdGNoSWQsIHJpZ2h0LnRhcmdldE9yQmF0Y2hJZCkpO1xuICAgIH1cbiAgICAvKiogQ29tcGFyZSBieSBJRCB0aGVuIGJ5IGtleSAqL1xuICAgIHN0YXRpYyBjb21wYXJlQnlUYXJnZXRJZChsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gKHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdC50YXJnZXRPckJhdGNoSWQsIHJpZ2h0LnRhcmdldE9yQmF0Y2hJZCkgfHxcbiAgICAgICAgICAgIERvY3VtZW50S2V5LmNvbXBhcmF0b3IobGVmdC5rZXksIHJpZ2h0LmtleSkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIE1lbW9yeU11dGF0aW9uUXVldWUge1xuICAgIGNvbnN0cnVjdG9yKGluZGV4TWFuYWdlciwgcmVmZXJlbmNlRGVsZWdhdGUpIHtcbiAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIgPSBpbmRleE1hbmFnZXI7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlRGVsZWdhdGUgPSByZWZlcmVuY2VEZWxlZ2F0ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzZXQgb2YgYWxsIG11dGF0aW9ucyB0aGF0IGhhdmUgYmVlbiBzZW50IGJ1dCBub3QgeWV0IGJlZW4gYXBwbGllZCB0b1xuICAgICAgICAgKiB0aGUgYmFja2VuZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubXV0YXRpb25RdWV1ZSA9IFtdO1xuICAgICAgICAvKiogTmV4dCB2YWx1ZSB0byB1c2Ugd2hlbiBhc3NpZ25pbmcgc2VxdWVudGlhbCBJRHMgdG8gZWFjaCBtdXRhdGlvbiBiYXRjaC4gKi9cbiAgICAgICAgdGhpcy5uZXh0QmF0Y2hJZCA9IDE7XG4gICAgICAgIC8qKiBBbiBvcmRlcmVkIG1hcHBpbmcgYmV0d2VlbiBkb2N1bWVudHMgYW5kIHRoZSBtdXRhdGlvbnMgYmF0Y2ggSURzLiAqL1xuICAgICAgICB0aGlzLmJhdGNoZXNCeURvY3VtZW50S2V5ID0gbmV3IFNvcnRlZFNldChEb2NSZWZlcmVuY2UuY29tcGFyZUJ5S2V5KTtcbiAgICB9XG4gICAgY2hlY2tFbXB0eSh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5tdXRhdGlvblF1ZXVlLmxlbmd0aCA9PT0gMCk7XG4gICAgfVxuICAgIGFkZE11dGF0aW9uQmF0Y2godHJhbnNhY3Rpb24sIGxvY2FsV3JpdGVUaW1lLCBiYXNlTXV0YXRpb25zLCBtdXRhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYmF0Y2hJZCA9IHRoaXMubmV4dEJhdGNoSWQ7XG4gICAgICAgIHRoaXMubmV4dEJhdGNoSWQrKztcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25RdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uUXVldWVbdGhpcy5tdXRhdGlvblF1ZXVlLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhdGNoID0gbmV3IE11dGF0aW9uQmF0Y2goYmF0Y2hJZCwgbG9jYWxXcml0ZVRpbWUsIGJhc2VNdXRhdGlvbnMsIG11dGF0aW9ucyk7XG4gICAgICAgIHRoaXMubXV0YXRpb25RdWV1ZS5wdXNoKGJhdGNoKTtcbiAgICAgICAgLy8gVHJhY2sgcmVmZXJlbmNlcyBieSBkb2N1bWVudCBrZXkgYW5kIGluZGV4IGNvbGxlY3Rpb24gcGFyZW50cy5cbiAgICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXkgPSB0aGlzLmJhdGNoZXNCeURvY3VtZW50S2V5LmFkZChuZXcgRG9jUmVmZXJlbmNlKG11dGF0aW9uLmtleSwgYmF0Y2hJZCkpO1xuICAgICAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIuYWRkVG9Db2xsZWN0aW9uUGFyZW50SW5kZXgodHJhbnNhY3Rpb24sIG11dGF0aW9uLmtleS5wYXRoLnBvcExhc3QoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKGJhdGNoKTtcbiAgICB9XG4gICAgbG9va3VwTXV0YXRpb25CYXRjaCh0cmFuc2FjdGlvbiwgYmF0Y2hJZCkge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5maW5kTXV0YXRpb25CYXRjaChiYXRjaElkKSk7XG4gICAgfVxuICAgIGdldE5leHRNdXRhdGlvbkJhdGNoQWZ0ZXJCYXRjaElkKHRyYW5zYWN0aW9uLCBiYXRjaElkKSB7XG4gICAgICAgIGNvbnN0IG5leHRCYXRjaElkID0gYmF0Y2hJZCArIDE7XG4gICAgICAgIC8vIFRoZSByZXF1ZXN0ZWQgYmF0Y2hJZCBtYXkgc3RpbGwgYmUgb3V0IG9mIHJhbmdlIHNvIG5vcm1hbGl6ZSBpdCB0byB0aGVcbiAgICAgICAgLy8gc3RhcnQgb2YgdGhlIHF1ZXVlLlxuICAgICAgICBjb25zdCByYXdJbmRleCA9IHRoaXMuaW5kZXhPZkJhdGNoSWQobmV4dEJhdGNoSWQpO1xuICAgICAgICBjb25zdCBpbmRleCA9IHJhd0luZGV4IDwgMCA/IDAgOiByYXdJbmRleDtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMubXV0YXRpb25RdWV1ZS5sZW5ndGggPiBpbmRleCA/IHRoaXMubXV0YXRpb25RdWV1ZVtpbmRleF0gOiBudWxsKTtcbiAgICB9XG4gICAgZ2V0SGlnaGVzdFVuYWNrbm93bGVkZ2VkQmF0Y2hJZCgpIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMubXV0YXRpb25RdWV1ZS5sZW5ndGggPT09IDAgPyBCQVRDSElEX1VOS05PV04gOiB0aGlzLm5leHRCYXRjaElkIC0gMSk7XG4gICAgfVxuICAgIGdldEFsbE11dGF0aW9uQmF0Y2hlcyh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5tdXRhdGlvblF1ZXVlLnNsaWNlKCkpO1xuICAgIH1cbiAgICBnZXRBbGxNdXRhdGlvbkJhdGNoZXNBZmZlY3RpbmdEb2N1bWVudEtleSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBuZXcgRG9jUmVmZXJlbmNlKGRvY3VtZW50S2V5LCAwKTtcbiAgICAgICAgY29uc3QgZW5kID0gbmV3IERvY1JlZmVyZW5jZShkb2N1bWVudEtleSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXkuZm9yRWFjaEluUmFuZ2UoW3N0YXJ0LCBlbmRdLCByZWYgPT4ge1xuICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSB0aGlzLmZpbmRNdXRhdGlvbkJhdGNoKHJlZi50YXJnZXRPckJhdGNoSWQpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYmF0Y2gpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfVxuICAgIGdldEFsbE11dGF0aW9uQmF0Y2hlc0FmZmVjdGluZ0RvY3VtZW50S2V5cyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKSB7XG4gICAgICAgIGxldCB1bmlxdWVCYXRjaElEcyA9IG5ldyBTb3J0ZWRTZXQocHJpbWl0aXZlQ29tcGFyYXRvcik7XG4gICAgICAgIGRvY3VtZW50S2V5cy5mb3JFYWNoKGRvY3VtZW50S2V5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gbmV3IERvY1JlZmVyZW5jZShkb2N1bWVudEtleSwgMCk7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBuZXcgRG9jUmVmZXJlbmNlKGRvY3VtZW50S2V5LCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICAgICAgdGhpcy5iYXRjaGVzQnlEb2N1bWVudEtleS5mb3JFYWNoSW5SYW5nZShbc3RhcnQsIGVuZF0sIHJlZiA9PiB7XG4gICAgICAgICAgICAgICAgdW5pcXVlQmF0Y2hJRHMgPSB1bmlxdWVCYXRjaElEcy5hZGQocmVmLnRhcmdldE9yQmF0Y2hJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmZpbmRNdXRhdGlvbkJhdGNoZXModW5pcXVlQmF0Y2hJRHMpKTtcbiAgICB9XG4gICAgZ2V0QWxsTXV0YXRpb25CYXRjaGVzQWZmZWN0aW5nUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5KSB7XG4gICAgICAgIC8vIFVzZSB0aGUgcXVlcnkgcGF0aCBhcyBhIHByZWZpeCBmb3IgdGVzdGluZyBpZiBhIGRvY3VtZW50IG1hdGNoZXMgdGhlXG4gICAgICAgIC8vIHF1ZXJ5LlxuICAgICAgICBjb25zdCBwcmVmaXggPSBxdWVyeS5wYXRoO1xuICAgICAgICBjb25zdCBpbW1lZGlhdGVDaGlsZHJlblBhdGhMZW5ndGggPSBwcmVmaXgubGVuZ3RoICsgMTtcbiAgICAgICAgLy8gQ29uc3RydWN0IGEgZG9jdW1lbnQgcmVmZXJlbmNlIGZvciBhY3R1YWxseSBzY2FubmluZyB0aGUgaW5kZXguIFVubGlrZVxuICAgICAgICAvLyB0aGUgcHJlZml4IHRoZSBkb2N1bWVudCBrZXkgaW4gdGhpcyByZWZlcmVuY2UgbXVzdCBoYXZlIGFuIGV2ZW4gbnVtYmVyIG9mXG4gICAgICAgIC8vIHNlZ21lbnRzLiBUaGUgZW1wdHkgc2VnbWVudCBjYW4gYmUgdXNlZCBhIHN1ZmZpeCBvZiB0aGUgcXVlcnkgcGF0aFxuICAgICAgICAvLyBiZWNhdXNlIGl0IHByZWNlZGVzIGFsbCBvdGhlciBzZWdtZW50cyBpbiBhbiBvcmRlcmVkIHRyYXZlcnNhbC5cbiAgICAgICAgbGV0IHN0YXJ0UGF0aCA9IHByZWZpeDtcbiAgICAgICAgaWYgKCFEb2N1bWVudEtleS5pc0RvY3VtZW50S2V5KHN0YXJ0UGF0aCkpIHtcbiAgICAgICAgICAgIHN0YXJ0UGF0aCA9IHN0YXJ0UGF0aC5jaGlsZCgnJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBuZXcgRG9jUmVmZXJlbmNlKG5ldyBEb2N1bWVudEtleShzdGFydFBhdGgpLCAwKTtcbiAgICAgICAgLy8gRmluZCB1bmlxdWUgYmF0Y2hJRHMgcmVmZXJlbmNlZCBieSBhbGwgZG9jdW1lbnRzIHBvdGVudGlhbGx5IG1hdGNoaW5nIHRoZVxuICAgICAgICAvLyBxdWVyeS5cbiAgICAgICAgbGV0IHVuaXF1ZUJhdGNoSURzID0gbmV3IFNvcnRlZFNldChwcmltaXRpdmVDb21wYXJhdG9yKTtcbiAgICAgICAgdGhpcy5iYXRjaGVzQnlEb2N1bWVudEtleS5mb3JFYWNoV2hpbGUocmVmID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJvd0tleVBhdGggPSByZWYua2V5LnBhdGg7XG4gICAgICAgICAgICBpZiAoIXByZWZpeC5pc1ByZWZpeE9mKHJvd0tleVBhdGgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUm93cyB3aXRoIGRvY3VtZW50IGtleXMgbW9yZSB0aGFuIG9uZSBzZWdtZW50IGxvbmdlciB0aGFuIHRoZSBxdWVyeVxuICAgICAgICAgICAgICAgIC8vIHBhdGggY2FuJ3QgYmUgbWF0Y2hlcy4gRm9yIGV4YW1wbGUsIGEgcXVlcnkgb24gJ3Jvb21zJyBjYW4ndCBtYXRjaFxuICAgICAgICAgICAgICAgIC8vIHRoZSBkb2N1bWVudCAvcm9vbXMvYWJjL21lc3NhZ2VzL3h5eC5cbiAgICAgICAgICAgICAgICAvLyBUT0RPKG1jZyk6IHdlJ2xsIG5lZWQgYSBkaWZmZXJlbnQgc2Nhbm5lciB3aGVuIHdlIGltcGxlbWVudFxuICAgICAgICAgICAgICAgIC8vIGFuY2VzdG9yIHF1ZXJpZXMuXG4gICAgICAgICAgICAgICAgaWYgKHJvd0tleVBhdGgubGVuZ3RoID09PSBpbW1lZGlhdGVDaGlsZHJlblBhdGhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlQmF0Y2hJRHMgPSB1bmlxdWVCYXRjaElEcy5hZGQocmVmLnRhcmdldE9yQmF0Y2hJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBzdGFydCk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmZpbmRNdXRhdGlvbkJhdGNoZXModW5pcXVlQmF0Y2hJRHMpKTtcbiAgICB9XG4gICAgZmluZE11dGF0aW9uQmF0Y2hlcyhiYXRjaElEcykge1xuICAgICAgICAvLyBDb25zdHJ1Y3QgYW4gYXJyYXkgb2YgbWF0Y2hpbmcgYmF0Y2hlcywgc29ydGVkIGJ5IGJhdGNoSUQgdG8gZW5zdXJlIHRoYXRcbiAgICAgICAgLy8gbXVsdGlwbGUgbXV0YXRpb25zIGFmZmVjdGluZyB0aGUgc2FtZSBkb2N1bWVudCBrZXkgYXJlIGFwcGxpZWQgaW4gb3JkZXIuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBiYXRjaElEcy5mb3JFYWNoKGJhdGNoSWQgPT4ge1xuICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSB0aGlzLmZpbmRNdXRhdGlvbkJhdGNoKGJhdGNoSWQpO1xuICAgICAgICAgICAgaWYgKGJhdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYmF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVtb3ZlTXV0YXRpb25CYXRjaCh0cmFuc2FjdGlvbiwgYmF0Y2gpIHtcbiAgICAgICAgLy8gRmluZCB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IGJhdGNoIGZvciByZW1vdmFsLlxuICAgICAgICBjb25zdCBiYXRjaEluZGV4ID0gdGhpcy5pbmRleE9mRXhpc3RpbmdCYXRjaElkKGJhdGNoLmJhdGNoSWQsICdyZW1vdmVkJyk7XG4gICAgICAgIGhhcmRBc3NlcnQoYmF0Y2hJbmRleCA9PT0gMCk7XG4gICAgICAgIHRoaXMubXV0YXRpb25RdWV1ZS5zaGlmdCgpO1xuICAgICAgICBsZXQgcmVmZXJlbmNlcyA9IHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChiYXRjaC5tdXRhdGlvbnMsIChtdXRhdGlvbikgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVmID0gbmV3IERvY1JlZmVyZW5jZShtdXRhdGlvbi5rZXksIGJhdGNoLmJhdGNoSWQpO1xuICAgICAgICAgICAgcmVmZXJlbmNlcyA9IHJlZmVyZW5jZXMuZGVsZXRlKHJlZik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZS5tYXJrUG90ZW50aWFsbHlPcnBoYW5lZCh0cmFuc2FjdGlvbiwgbXV0YXRpb24ua2V5KTtcbiAgICAgICAgfSkubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJhdGNoZXNCeURvY3VtZW50S2V5ID0gcmVmZXJlbmNlcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZUNhY2hlZE11dGF0aW9uS2V5cyhiYXRjaElkKSB7XG4gICAgICAgIC8vIE5vLW9wIHNpbmNlIHRoZSBtZW1vcnkgbXV0YXRpb24gcXVldWUgZG9lcyBub3QgbWFpbnRhaW4gYSBzZXBhcmF0ZSBjYWNoZS5cbiAgICB9XG4gICAgY29udGFpbnNLZXkodHhuLCBrZXkpIHtcbiAgICAgICAgY29uc3QgcmVmID0gbmV3IERvY1JlZmVyZW5jZShrZXksIDApO1xuICAgICAgICBjb25zdCBmaXJzdFJlZiA9IHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXkuZmlyc3RBZnRlck9yRXF1YWwocmVmKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKGtleS5pc0VxdWFsKGZpcnN0UmVmICYmIGZpcnN0UmVmLmtleSkpO1xuICAgIH1cbiAgICBwZXJmb3JtQ29uc2lzdGVuY3lDaGVjayh0eG4pIHtcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25RdWV1ZS5sZW5ndGggPT09IDApIDtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gYmF0Y2hJZCBpbiB0aGUgbXV0YXRpb24gcXVldWUgYW5kIGFzc2VydHMgdGhhdFxuICAgICAqIHRoZSByZXN1bHRpbmcgaW5kZXggaXMgd2l0aGluIHRoZSBib3VuZHMgb2YgdGhlIHF1ZXVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJhdGNoSWQgLSBUaGUgYmF0Y2hJZCB0byBzZWFyY2ggZm9yXG4gICAgICogQHBhcmFtIGFjdGlvbiAtIEEgZGVzY3JpcHRpb24gb2Ygd2hhdCB0aGUgY2FsbGVyIGlzIGRvaW5nLCBwaHJhc2VkIGluIHBhc3NpdmVcbiAgICAgKiBmb3JtIChlLmcuIFwiYWNrbm93bGVkZ2VkXCIgaW4gYSByb3V0aW5lIHRoYXQgYWNrbm93bGVkZ2VzIGJhdGNoZXMpLlxuICAgICAqL1xuICAgIGluZGV4T2ZFeGlzdGluZ0JhdGNoSWQoYmF0Y2hJZCwgYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleE9mQmF0Y2hJZChiYXRjaElkKTtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIGJhdGNoSWQgaW4gdGhlIG11dGF0aW9uIHF1ZXVlLiBUaGlzIG9wZXJhdGlvblxuICAgICAqIGlzIE8oMSkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgY29tcHV0ZWQgaW5kZXggb2YgdGhlIGJhdGNoIHdpdGggdGhlIGdpdmVuIGJhdGNoSWQsIGJhc2VkIG9uXG4gICAgICogdGhlIHN0YXRlIG9mIHRoZSBxdWV1ZS4gTm90ZSB0aGlzIGluZGV4IGNhbiBiZSBuZWdhdGl2ZSBpZiB0aGUgcmVxdWVzdGVkXG4gICAgICogYmF0Y2hJZCBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcXVldWUgb3IgcGFzdCB0aGUgZW5kIG9mIHRoZVxuICAgICAqIHF1ZXVlIGlmIHRoZSBiYXRjaElkIGlzIGxhcmdlciB0aGFuIHRoZSBsYXN0IGFkZGVkIGJhdGNoLlxuICAgICAqL1xuICAgIGluZGV4T2ZCYXRjaElkKGJhdGNoSWQpIHtcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25RdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIEFzIGFuIGluZGV4IHRoaXMgaXMgcGFzdCB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXhhbWluZSB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlIHRvIGZpZ3VyZSBvdXQgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGVcbiAgICAgICAgLy8gYmF0Y2hJZCBhbmQgaW5kZXhlcyBpbiB0aGUgYXJyYXkuIE5vdGUgdGhhdCBzaW5jZSB0aGUgcXVldWUgaXMgb3JkZXJlZFxuICAgICAgICAvLyBieSBiYXRjaElkLCBpZiB0aGUgZmlyc3QgYmF0Y2ggaGFzIGEgbGFyZ2VyIGJhdGNoSWQgdGhlbiB0aGUgcmVxdWVzdGVkXG4gICAgICAgIC8vIGJhdGNoSWQgZG9lc24ndCBleGlzdCBpbiB0aGUgcXVldWUuXG4gICAgICAgIGNvbnN0IGZpcnN0QmF0Y2hJZCA9IHRoaXMubXV0YXRpb25RdWV1ZVswXS5iYXRjaElkO1xuICAgICAgICByZXR1cm4gYmF0Y2hJZCAtIGZpcnN0QmF0Y2hJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSB2ZXJzaW9uIG9mIGxvb2t1cE11dGF0aW9uQmF0Y2ggdGhhdCBkb2Vzbid0IHJldHVybiBhIHByb21pc2UsIHRoaXMgbWFrZXNcbiAgICAgKiBvdGhlciBmdW5jdGlvbnMgdGhhdCB1c2VzIHRoaXMgY29kZSBlYXNpZXIgdG8gcmVhZCBhbmQgbW9yZSBlZmZpY2llbnQuXG4gICAgICovXG4gICAgZmluZE11dGF0aW9uQmF0Y2goYmF0Y2hJZCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuaW5kZXhPZkJhdGNoSWQoYmF0Y2hJZCk7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5tdXRhdGlvblF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmF0Y2ggPSB0aGlzLm11dGF0aW9uUXVldWVbaW5kZXhdO1xuICAgICAgICByZXR1cm4gYmF0Y2g7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gZG9jdW1lbnRFbnRyeU1hcCgpIHtcbiAgICByZXR1cm4gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcbn1cbi8qKlxuICogVGhlIG1lbW9yeS1vbmx5IFJlbW90ZURvY3VtZW50Q2FjaGUgZm9yIEluZGV4ZWREYi4gVG8gY29uc3RydWN0LCBpbnZva2VcbiAqIGBuZXdNZW1vcnlSZW1vdGVEb2N1bWVudENhY2hlKClgLlxuICovXG5jbGFzcyBNZW1vcnlSZW1vdGVEb2N1bWVudENhY2hlSW1wbCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHNpemVyIC0gVXNlZCB0byBhc3Nlc3MgdGhlIHNpemUgb2YgYSBkb2N1bWVudC4gRm9yIGVhZ2VyIEdDLCB0aGlzIGlzXG4gICAgICogZXhwZWN0ZWQgdG8ganVzdCByZXR1cm4gMCB0byBhdm9pZCB1bm5lY2Vzc2FyaWx5IGRvaW5nIHRoZSB3b3JrIG9mXG4gICAgICogY2FsY3VsYXRpbmcgdGhlIHNpemUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2l6ZXIpIHtcbiAgICAgICAgdGhpcy5zaXplciA9IHNpemVyO1xuICAgICAgICAvKiogVW5kZXJseWluZyBjYWNoZSBvZiBkb2N1bWVudHMgYW5kIHRoZWlyIHJlYWQgdGltZXMuICovXG4gICAgICAgIHRoaXMuZG9jcyA9IGRvY3VtZW50RW50cnlNYXAoKTtcbiAgICAgICAgLyoqIFNpemUgb2YgYWxsIGNhY2hlZCBkb2N1bWVudHMuICovXG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuICAgIHNldEluZGV4TWFuYWdlcihpbmRleE1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIgPSBpbmRleE1hbmFnZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIHN1cHBsaWVkIGVudHJ5IHRvIHRoZSBjYWNoZSBhbmQgdXBkYXRlcyB0aGUgY2FjaGUgc2l6ZSBhcyBhcHByb3ByaWF0ZS5cbiAgICAgKlxuICAgICAqIEFsbCBjYWxscyBvZiBgYWRkRW50cnlgICBhcmUgcmVxdWlyZWQgdG8gZ28gdGhyb3VnaCB0aGUgUmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXJcbiAgICAgKiByZXR1cm5lZCBieSBgbmV3Q2hhbmdlQnVmZmVyKClgLlxuICAgICAqL1xuICAgIGFkZEVudHJ5KHRyYW5zYWN0aW9uLCBkb2MpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZG9jLmtleTtcbiAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmRvY3MuZ2V0KGtleSk7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzU2l6ZSA9IGVudHJ5ID8gZW50cnkuc2l6ZSA6IDA7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTaXplID0gdGhpcy5zaXplcihkb2MpO1xuICAgICAgICB0aGlzLmRvY3MgPSB0aGlzLmRvY3MuaW5zZXJ0KGtleSwge1xuICAgICAgICAgICAgZG9jdW1lbnQ6IGRvYy5tdXRhYmxlQ29weSgpLFxuICAgICAgICAgICAgc2l6ZTogY3VycmVudFNpemVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2l6ZSArPSBjdXJyZW50U2l6ZSAtIHByZXZpb3VzU2l6ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhNYW5hZ2VyLmFkZFRvQ29sbGVjdGlvblBhcmVudEluZGV4KHRyYW5zYWN0aW9uLCBrZXkucGF0aC5wb3BMYXN0KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgZW50cnkgZnJvbSB0aGUgY2FjaGUgYW5kIHVwZGF0ZXMgdGhlIGNhY2hlIHNpemUgYXMgYXBwcm9wcmlhdGUuXG4gICAgICpcbiAgICAgKiBBbGwgY2FsbHMgb2YgYHJlbW92ZUVudHJ5YCBhcmUgcmVxdWlyZWQgdG8gZ28gdGhyb3VnaCB0aGUgUmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXJcbiAgICAgKiByZXR1cm5lZCBieSBgbmV3Q2hhbmdlQnVmZmVyKClgLlxuICAgICAqL1xuICAgIHJlbW92ZUVudHJ5KGRvY3VtZW50S2V5KSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5kb2NzLmdldChkb2N1bWVudEtleSk7XG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgdGhpcy5kb2NzID0gdGhpcy5kb2NzLnJlbW92ZShkb2N1bWVudEtleSk7XG4gICAgICAgICAgICB0aGlzLnNpemUgLT0gZW50cnkuc2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmRvY3MuZ2V0KGRvY3VtZW50S2V5KTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKGVudHJ5XG4gICAgICAgICAgICA/IGVudHJ5LmRvY3VtZW50Lm11dGFibGVDb3B5KClcbiAgICAgICAgICAgIDogTXV0YWJsZURvY3VtZW50Lm5ld0ludmFsaWREb2N1bWVudChkb2N1bWVudEtleSkpO1xuICAgIH1cbiAgICBnZXRFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpIHtcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcbiAgICAgICAgZG9jdW1lbnRLZXlzLmZvckVhY2goZG9jdW1lbnRLZXkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmRvY3MuZ2V0KGRvY3VtZW50S2V5KTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmluc2VydChkb2N1bWVudEtleSwgZW50cnlcbiAgICAgICAgICAgICAgICA/IGVudHJ5LmRvY3VtZW50Lm11dGFibGVDb3B5KClcbiAgICAgICAgICAgICAgICA6IE11dGFibGVEb2N1bWVudC5uZXdJbnZhbGlkRG9jdW1lbnQoZG9jdW1lbnRLZXkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShyZXN1bHRzKTtcbiAgICB9XG4gICAgZ2V0RG9jdW1lbnRzTWF0Y2hpbmdRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnksIG9mZnNldCwgbXV0YXRlZERvY3MpIHtcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcbiAgICAgICAgLy8gRG9jdW1lbnRzIGFyZSBvcmRlcmVkIGJ5IGtleSwgc28gd2UgY2FuIHVzZSBhIHByZWZpeCBzY2FuIHRvIG5hcnJvdyBkb3duXG4gICAgICAgIC8vIHRoZSBkb2N1bWVudHMgd2UgbmVlZCB0byBtYXRjaCB0aGUgcXVlcnkgYWdhaW5zdC5cbiAgICAgICAgY29uc3QgY29sbGVjdGlvblBhdGggPSBxdWVyeS5wYXRoO1xuICAgICAgICBjb25zdCBwcmVmaXggPSBuZXcgRG9jdW1lbnRLZXkoY29sbGVjdGlvblBhdGguY2hpbGQoJycpKTtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLmRvY3MuZ2V0SXRlcmF0b3JGcm9tKHByZWZpeCk7XG4gICAgICAgIHdoaWxlIChpdGVyYXRvci5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZTogeyBkb2N1bWVudCB9IH0gPSBpdGVyYXRvci5nZXROZXh0KCk7XG4gICAgICAgICAgICBpZiAoIWNvbGxlY3Rpb25QYXRoLmlzUHJlZml4T2Yoa2V5LnBhdGgpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5LnBhdGgubGVuZ3RoID4gY29sbGVjdGlvblBhdGgubGVuZ3RoICsgMSkge1xuICAgICAgICAgICAgICAgIC8vIEV4Y2x1ZGUgZW50cmllcyBmcm9tIHN1YmNvbGxlY3Rpb25zLlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4T2Zmc2V0Q29tcGFyYXRvcihuZXdJbmRleE9mZnNldEZyb21Eb2N1bWVudChkb2N1bWVudCksIG9mZnNldCkgPD0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBkb2N1bWVudCBzb3J0cyBiZWZvcmUgdGhlIG9mZnNldC5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbXV0YXRlZERvY3MuaGFzKGRvY3VtZW50LmtleSkgJiYgIXF1ZXJ5TWF0Y2hlcyhxdWVyeSwgZG9jdW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGRvY3VtZW50IGNhbm5vdCBwb3NzaWJseSBtYXRjaCB0aGUgcXVlcnkuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5pbnNlcnQoZG9jdW1lbnQua2V5LCBkb2N1bWVudC5tdXRhYmxlQ29weSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XG4gICAgfVxuICAgIGdldEFsbEZyb21Db2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCwgb2Zmc2V0LCBsaW1pdCkge1xuICAgICAgICAvLyBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgZnJvbSB0aGUgSW5kZXhCYWNrZmlsbGVyIGlmIHBlcnNpc3RlbmNlXG4gICAgICAgIC8vIGlzIGVuYWJsZWQuXG4gICAgICAgIGZhaWwoKTtcbiAgICB9XG4gICAgZm9yRWFjaERvY3VtZW50S2V5KHRyYW5zYWN0aW9uLCBmKSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaCh0aGlzLmRvY3MsIChrZXkpID0+IGYoa2V5KSk7XG4gICAgfVxuICAgIG5ld0NoYW5nZUJ1ZmZlcihvcHRpb25zKSB7XG4gICAgICAgIC8vIGB0cmFja1JlbW92YWxzYCBpcyBpZ25vcmVzIHNpbmNlIHRoZSBNZW1vcnlSZW1vdGVEb2N1bWVudENhY2hlIGtlZXBzXG4gICAgICAgIC8vIGEgc2VwYXJhdGUgY2hhbmdlbG9nIGFuZCBkb2VzIG5vdCBuZWVkIHNwZWNpYWwgaGFuZGxpbmcgZm9yIHJlbW92YWxzLlxuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeVJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyKHRoaXMpO1xuICAgIH1cbiAgICBnZXRTaXplKHR4bikge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5zaXplKTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWVtb3J5LW9ubHkgUmVtb3RlRG9jdW1lbnRDYWNoZS5cbiAqXG4gKiBAcGFyYW0gc2l6ZXIgLSBVc2VkIHRvIGFzc2VzcyB0aGUgc2l6ZSBvZiBhIGRvY3VtZW50LiBGb3IgZWFnZXIgR0MsIHRoaXMgaXNcbiAqIGV4cGVjdGVkIHRvIGp1c3QgcmV0dXJuIDAgdG8gYXZvaWQgdW5uZWNlc3NhcmlseSBkb2luZyB0aGUgd29yayBvZlxuICogY2FsY3VsYXRpbmcgdGhlIHNpemUuXG4gKi9cbmZ1bmN0aW9uIG5ld01lbW9yeVJlbW90ZURvY3VtZW50Q2FjaGUoc2l6ZXIpIHtcbiAgICByZXR1cm4gbmV3IE1lbW9yeVJlbW90ZURvY3VtZW50Q2FjaGVJbXBsKHNpemVyKTtcbn1cbi8qKlxuICogSGFuZGxlcyB0aGUgZGV0YWlscyBvZiBhZGRpbmcgYW5kIHVwZGF0aW5nIGRvY3VtZW50cyBpbiB0aGUgTWVtb3J5UmVtb3RlRG9jdW1lbnRDYWNoZS5cbiAqL1xuY2xhc3MgTWVtb3J5UmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXIgZXh0ZW5kcyBSZW1vdGVEb2N1bWVudENoYW5nZUJ1ZmZlciB7XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnRDYWNoZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmRvY3VtZW50Q2FjaGUgPSBkb2N1bWVudENhY2hlO1xuICAgIH1cbiAgICBhcHBseUNoYW5nZXModHJhbnNhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLmZvckVhY2goKGtleSwgZG9jKSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9jLmlzVmFsaWREb2N1bWVudCgpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmRvY3VtZW50Q2FjaGUuYWRkRW50cnkodHJhbnNhY3Rpb24sIGRvYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb2N1bWVudENhY2hlLnJlbW92ZUVudHJ5KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpO1xuICAgIH1cbiAgICBnZXRGcm9tQ2FjaGUodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50Q2FjaGUuZ2V0RW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KTtcbiAgICB9XG4gICAgZ2V0QWxsRnJvbUNhY2hlKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRDYWNoZS5nZXRFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIE1lbW9yeVRhcmdldENhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihwZXJzaXN0ZW5jZSkge1xuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlID0gcGVyc2lzdGVuY2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXBzIGEgdGFyZ2V0IHRvIHRoZSBkYXRhIGFib3V0IHRoYXQgdGFyZ2V0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhcmdldHMgPSBuZXcgT2JqZWN0TWFwKHQgPT4gY2Fub25pZnlUYXJnZXQodCksIHRhcmdldEVxdWFscyk7XG4gICAgICAgIC8qKiBUaGUgbGFzdCByZWNlaXZlZCBzbmFwc2hvdCB2ZXJzaW9uLiAqL1xuICAgICAgICB0aGlzLmxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24gPSBTbmFwc2hvdFZlcnNpb24ubWluKCk7XG4gICAgICAgIC8qKiBUaGUgaGlnaGVzdCBudW1iZXJlZCB0YXJnZXQgSUQgZW5jb3VudGVyZWQuICovXG4gICAgICAgIHRoaXMuaGlnaGVzdFRhcmdldElkID0gMDtcbiAgICAgICAgLyoqIFRoZSBoaWdoZXN0IHNlcXVlbmNlIG51bWJlciBlbmNvdW50ZXJlZC4gKi9cbiAgICAgICAgdGhpcy5oaWdoZXN0U2VxdWVuY2VOdW1iZXIgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBvcmRlcmVkIGJpZGlyZWN0aW9uYWwgbWFwcGluZyBiZXR3ZWVuIGRvY3VtZW50cyBhbmQgdGhlIHJlbW90ZSB0YXJnZXRcbiAgICAgICAgICogSURzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWZlcmVuY2VzID0gbmV3IFJlZmVyZW5jZVNldCgpO1xuICAgICAgICB0aGlzLnRhcmdldENvdW50ID0gMDtcbiAgICAgICAgdGhpcy50YXJnZXRJZEdlbmVyYXRvciA9IFRhcmdldElkR2VuZXJhdG9yLmZvclRhcmdldENhY2hlKCk7XG4gICAgfVxuICAgIGZvckVhY2hUYXJnZXQodHhuLCBmKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0cy5mb3JFYWNoKChfLCB0YXJnZXREYXRhKSA9PiBmKHRhcmdldERhdGEpKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGdldExhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMubGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbik7XG4gICAgfVxuICAgIGdldEhpZ2hlc3RTZXF1ZW5jZU51bWJlcih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5oaWdoZXN0U2VxdWVuY2VOdW1iZXIpO1xuICAgIH1cbiAgICBhbGxvY2F0ZVRhcmdldElkKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuaGlnaGVzdFRhcmdldElkID0gdGhpcy50YXJnZXRJZEdlbmVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmhpZ2hlc3RUYXJnZXRJZCk7XG4gICAgfVxuICAgIHNldFRhcmdldHNNZXRhZGF0YSh0cmFuc2FjdGlvbiwgaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyLCBsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKSB7XG4gICAgICAgIGlmIChsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24gPSBsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIgPiB0aGlzLmhpZ2hlc3RTZXF1ZW5jZU51bWJlcikge1xuICAgICAgICAgICAgdGhpcy5oaWdoZXN0U2VxdWVuY2VOdW1iZXIgPSBoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHNhdmVUYXJnZXREYXRhKHRhcmdldERhdGEpIHtcbiAgICAgICAgdGhpcy50YXJnZXRzLnNldCh0YXJnZXREYXRhLnRhcmdldCwgdGFyZ2V0RGF0YSk7XG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gdGFyZ2V0RGF0YS50YXJnZXRJZDtcbiAgICAgICAgaWYgKHRhcmdldElkID4gdGhpcy5oaWdoZXN0VGFyZ2V0SWQpIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0SWRHZW5lcmF0b3IgPSBuZXcgVGFyZ2V0SWRHZW5lcmF0b3IodGFyZ2V0SWQpO1xuICAgICAgICAgICAgdGhpcy5oaWdoZXN0VGFyZ2V0SWQgPSB0YXJnZXRJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0RGF0YS5zZXF1ZW5jZU51bWJlciA+IHRoaXMuaGlnaGVzdFNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgICAgICB0aGlzLmhpZ2hlc3RTZXF1ZW5jZU51bWJlciA9IHRhcmdldERhdGEuc2VxdWVuY2VOdW1iZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkVGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0RGF0YSkge1xuICAgICAgICB0aGlzLnNhdmVUYXJnZXREYXRhKHRhcmdldERhdGEpO1xuICAgICAgICB0aGlzLnRhcmdldENvdW50ICs9IDE7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICB1cGRhdGVUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhKSB7XG4gICAgICAgIHRoaXMuc2F2ZVRhcmdldERhdGEodGFyZ2V0RGF0YSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICByZW1vdmVUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0cy5kZWxldGUodGFyZ2V0RGF0YS50YXJnZXQpO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMucmVtb3ZlUmVmZXJlbmNlc0ZvcklkKHRhcmdldERhdGEudGFyZ2V0SWQpO1xuICAgICAgICB0aGlzLnRhcmdldENvdW50IC09IDE7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICByZW1vdmVUYXJnZXRzKHRyYW5zYWN0aW9uLCB1cHBlckJvdW5kLCBhY3RpdmVUYXJnZXRJZHMpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgY29uc3QgcmVtb3ZhbHMgPSBbXTtcbiAgICAgICAgdGhpcy50YXJnZXRzLmZvckVhY2goKGtleSwgdGFyZ2V0RGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRhcmdldERhdGEuc2VxdWVuY2VOdW1iZXIgPD0gdXBwZXJCb3VuZCAmJlxuICAgICAgICAgICAgICAgIGFjdGl2ZVRhcmdldElkcy5nZXQodGFyZ2V0RGF0YS50YXJnZXRJZCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldHMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgcmVtb3ZhbHMucHVzaCh0aGlzLnJlbW92ZU1hdGNoaW5nS2V5c0ZvclRhcmdldElkKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhLnRhcmdldElkKSk7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihyZW1vdmFscykubmV4dCgoKSA9PiBjb3VudCk7XG4gICAgfVxuICAgIGdldFRhcmdldENvdW50KHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLnRhcmdldENvdW50KTtcbiAgICB9XG4gICAgZ2V0VGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHRhcmdldERhdGEgPSB0aGlzLnRhcmdldHMuZ2V0KHRhcmdldCkgfHwgbnVsbDtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRhcmdldERhdGEpO1xuICAgIH1cbiAgICBhZGRNYXRjaGluZ0tleXModHhuLCBrZXlzLCB0YXJnZXRJZCkge1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMuYWRkUmVmZXJlbmNlcyhrZXlzLCB0YXJnZXRJZCk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICByZW1vdmVNYXRjaGluZ0tleXModHhuLCBrZXlzLCB0YXJnZXRJZCkge1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMucmVtb3ZlUmVmZXJlbmNlcyhrZXlzLCB0YXJnZXRJZCk7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZURlbGVnYXRlID0gdGhpcy5wZXJzaXN0ZW5jZS5yZWZlcmVuY2VEZWxlZ2F0ZTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgaWYgKHJlZmVyZW5jZURlbGVnYXRlKSB7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHJlZmVyZW5jZURlbGVnYXRlLm1hcmtQb3RlbnRpYWxseU9ycGhhbmVkKHR4biwga2V5KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpO1xuICAgIH1cbiAgICByZW1vdmVNYXRjaGluZ0tleXNGb3JUYXJnZXRJZCh0eG4sIHRhcmdldElkKSB7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlcy5yZW1vdmVSZWZlcmVuY2VzRm9ySWQodGFyZ2V0SWQpO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZ2V0TWF0Y2hpbmdLZXlzRm9yVGFyZ2V0SWQodHhuLCB0YXJnZXRJZCkge1xuICAgICAgICBjb25zdCBtYXRjaGluZ0tleXMgPSB0aGlzLnJlZmVyZW5jZXMucmVmZXJlbmNlc0ZvcklkKHRhcmdldElkKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKG1hdGNoaW5nS2V5cyk7XG4gICAgfVxuICAgIGNvbnRhaW5zS2V5KHR4biwga2V5KSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLnJlZmVyZW5jZXMuY29udGFpbnNLZXkoa2V5KSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgTE9HX1RBRyRkID0gJ01lbW9yeVBlcnNpc3RlbmNlJztcbi8qKlxuICogQSBtZW1vcnktYmFja2VkIGluc3RhbmNlIG9mIFBlcnNpc3RlbmNlLiBEYXRhIGlzIHN0b3JlZCBvbmx5IGluIFJBTSBhbmRcbiAqIG5vdCBwZXJzaXN0ZWQgYWNyb3NzIHNlc3Npb25zLlxuICovXG5jbGFzcyBNZW1vcnlQZXJzaXN0ZW5jZSB7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIGFjY2VwdHMgYSBmYWN0b3J5IGZvciBjcmVhdGluZyBhIHJlZmVyZW5jZSBkZWxlZ2F0ZS4gVGhpc1xuICAgICAqIGFsbG93cyBib3RoIHRoZSBkZWxlZ2F0ZSBhbmQgdGhpcyBpbnN0YW5jZSB0byBoYXZlIHN0cm9uZyByZWZlcmVuY2VzIHRvXG4gICAgICogZWFjaCBvdGhlciB3aXRob3V0IGhhdmluZyBudWxsYWJsZSBmaWVsZHMgdGhhdCB3b3VsZCB0aGVuIG5lZWQgdG8gYmVcbiAgICAgKiBjaGVja2VkIG9yIGFzc2VydGVkIG9uIGV2ZXJ5IGFjY2Vzcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZWZlcmVuY2VEZWxlZ2F0ZUZhY3RvcnksIHNlcmlhbGl6ZXIpIHtcbiAgICAgICAgdGhpcy5tdXRhdGlvblF1ZXVlcyA9IHt9O1xuICAgICAgICB0aGlzLm92ZXJsYXlzID0ge307XG4gICAgICAgIHRoaXMubGlzdGVuU2VxdWVuY2UgPSBuZXcgTGlzdGVuU2VxdWVuY2UoMCk7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZ2xvYmFsc0NhY2hlID0gbmV3IE1lbW9yeUdsb2JhbHNDYWNoZSgpO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZURlbGVnYXRlID0gcmVmZXJlbmNlRGVsZWdhdGVGYWN0b3J5KHRoaXMpO1xuICAgICAgICB0aGlzLnRhcmdldENhY2hlID0gbmV3IE1lbW9yeVRhcmdldENhY2hlKHRoaXMpO1xuICAgICAgICBjb25zdCBzaXplciA9IChkb2MpID0+IHRoaXMucmVmZXJlbmNlRGVsZWdhdGUuZG9jdW1lbnRTaXplKGRvYyk7XG4gICAgICAgIHRoaXMuaW5kZXhNYW5hZ2VyID0gbmV3IE1lbW9yeUluZGV4TWFuYWdlcigpO1xuICAgICAgICB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGUgPSBuZXdNZW1vcnlSZW1vdGVEb2N1bWVudENhY2hlKHNpemVyKTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gbmV3IExvY2FsU2VyaWFsaXplcihzZXJpYWxpemVyKTtcbiAgICAgICAgdGhpcy5idW5kbGVDYWNoZSA9IG5ldyBNZW1vcnlCdW5kbGVDYWNoZSh0aGlzLnNlcmlhbGl6ZXIpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBzaHV0ZG93bigpIHtcbiAgICAgICAgLy8gTm8gZHVyYWJsZSBzdGF0ZSB0byBlbnN1cmUgaXMgY2xvc2VkIG9uIHNodXRkb3duLlxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGFydGVkO1xuICAgIH1cbiAgICBzZXREYXRhYmFzZURlbGV0ZWRMaXN0ZW5lcigpIHtcbiAgICAgICAgLy8gTm8gb3AuXG4gICAgfVxuICAgIHNldE5ldHdvcmtFbmFibGVkKCkge1xuICAgICAgICAvLyBObyBvcC5cbiAgICB9XG4gICAgZ2V0SW5kZXhNYW5hZ2VyKHVzZXIpIHtcbiAgICAgICAgLy8gV2UgZG8gbm90IGN1cnJlbnRseSBzdXBwb3J0IGluZGljZXMgZm9yIG1lbW9yeSBwZXJzaXN0ZW5jZSwgc28gd2UgY2FuXG4gICAgICAgIC8vIHJldHVybiB0aGUgc2FtZSBzaGFyZWQgaW5zdGFuY2Ugb2YgdGhlIG1lbW9yeSBpbmRleCBtYW5hZ2VyLlxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleE1hbmFnZXI7XG4gICAgfVxuICAgIGdldERvY3VtZW50T3ZlcmxheUNhY2hlKHVzZXIpIHtcbiAgICAgICAgbGV0IG92ZXJsYXkgPSB0aGlzLm92ZXJsYXlzW3VzZXIudG9LZXkoKV07XG4gICAgICAgIGlmICghb3ZlcmxheSkge1xuICAgICAgICAgICAgb3ZlcmxheSA9IG5ldyBNZW1vcnlEb2N1bWVudE92ZXJsYXlDYWNoZSgpO1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5c1t1c2VyLnRvS2V5KCldID0gb3ZlcmxheTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3ZlcmxheTtcbiAgICB9XG4gICAgZ2V0TXV0YXRpb25RdWV1ZSh1c2VyLCBpbmRleE1hbmFnZXIpIHtcbiAgICAgICAgbGV0IHF1ZXVlID0gdGhpcy5tdXRhdGlvblF1ZXVlc1t1c2VyLnRvS2V5KCldO1xuICAgICAgICBpZiAoIXF1ZXVlKSB7XG4gICAgICAgICAgICBxdWV1ZSA9IG5ldyBNZW1vcnlNdXRhdGlvblF1ZXVlKGluZGV4TWFuYWdlciwgdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZSk7XG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uUXVldWVzW3VzZXIudG9LZXkoKV0gPSBxdWV1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXVldWU7XG4gICAgfVxuICAgIGdldEdsb2JhbHNDYWNoZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2xvYmFsc0NhY2hlO1xuICAgIH1cbiAgICBnZXRUYXJnZXRDYWNoZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0Q2FjaGU7XG4gICAgfVxuICAgIGdldFJlbW90ZURvY3VtZW50Q2FjaGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGU7XG4gICAgfVxuICAgIGdldEJ1bmRsZUNhY2hlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idW5kbGVDYWNoZTtcbiAgICB9XG4gICAgcnVuVHJhbnNhY3Rpb24oYWN0aW9uLCBtb2RlLCB0cmFuc2FjdGlvbk9wZXJhdGlvbikge1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGQsICdTdGFydGluZyB0cmFuc2FjdGlvbjonLCBhY3Rpb24pO1xuICAgICAgICBjb25zdCB0eG4gPSBuZXcgTWVtb3J5VHJhbnNhY3Rpb24odGhpcy5saXN0ZW5TZXF1ZW5jZS5uZXh0KCkpO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZURlbGVnYXRlLm9uVHJhbnNhY3Rpb25TdGFydGVkKCk7XG4gICAgICAgIHJldHVybiB0cmFuc2FjdGlvbk9wZXJhdGlvbih0eG4pXG4gICAgICAgICAgICAubmV4dChyZXN1bHQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmZXJlbmNlRGVsZWdhdGVcbiAgICAgICAgICAgICAgICAub25UcmFuc2FjdGlvbkNvbW1pdHRlZCh0eG4pXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gcmVzdWx0KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50b1Byb21pc2UoKVxuICAgICAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIHR4bi5yYWlzZU9uQ29tbWl0dGVkRXZlbnQoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtdXRhdGlvblF1ZXVlc0NvbnRhaW5LZXkodHJhbnNhY3Rpb24sIGtleSkge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLm9yKE9iamVjdC52YWx1ZXModGhpcy5tdXRhdGlvblF1ZXVlcykubWFwKHF1ZXVlID0+ICgpID0+IHF1ZXVlLmNvbnRhaW5zS2V5KHRyYW5zYWN0aW9uLCBrZXkpKSk7XG4gICAgfVxufVxuLyoqXG4gKiBNZW1vcnkgcGVyc2lzdGVuY2UgaXMgbm90IGFjdHVhbGx5IHRyYW5zYWN0aW9uYWwsIGJ1dCBmdXR1cmUgaW1wbGVtZW50YXRpb25zXG4gKiBtYXkgaGF2ZSB0cmFuc2FjdGlvbi1zY29wZWQgc3RhdGUuXG4gKi9cbmNsYXNzIE1lbW9yeVRyYW5zYWN0aW9uIGV4dGVuZHMgUGVyc2lzdGVuY2VUcmFuc2FjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoY3VycmVudFNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY3VycmVudFNlcXVlbmNlTnVtYmVyID0gY3VycmVudFNlcXVlbmNlTnVtYmVyO1xuICAgIH1cbn1cbmNsYXNzIE1lbW9yeUVhZ2VyRGVsZWdhdGUge1xuICAgIGNvbnN0cnVjdG9yKHBlcnNpc3RlbmNlKSB7XG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2UgPSBwZXJzaXN0ZW5jZTtcbiAgICAgICAgLyoqIFRyYWNrcyBhbGwgZG9jdW1lbnRzIHRoYXQgYXJlIGFjdGl2ZSBpbiBRdWVyeSB2aWV3cy4gKi9cbiAgICAgICAgdGhpcy5sb2NhbFZpZXdSZWZlcmVuY2VzID0gbmV3IFJlZmVyZW5jZVNldCgpO1xuICAgICAgICAvKiogVGhlIGxpc3Qgb2YgZG9jdW1lbnRzIHRoYXQgYXJlIHBvdGVudGlhbGx5IEdDZWQgYWZ0ZXIgZWFjaCB0cmFuc2FjdGlvbi4gKi9cbiAgICAgICAgdGhpcy5fb3JwaGFuZWREb2N1bWVudHMgPSBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgZmFjdG9yeShwZXJzaXN0ZW5jZSkge1xuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeUVhZ2VyRGVsZWdhdGUocGVyc2lzdGVuY2UpO1xuICAgIH1cbiAgICBnZXQgb3JwaGFuZWREb2N1bWVudHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fb3JwaGFuZWREb2N1bWVudHMpIHtcbiAgICAgICAgICAgIHRocm93IGZhaWwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcnBoYW5lZERvY3VtZW50cztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRSZWZlcmVuY2UodHhuLCB0YXJnZXRJZCwga2V5KSB7XG4gICAgICAgIHRoaXMubG9jYWxWaWV3UmVmZXJlbmNlcy5hZGRSZWZlcmVuY2Uoa2V5LCB0YXJnZXRJZCk7XG4gICAgICAgIHRoaXMub3JwaGFuZWREb2N1bWVudHMuZGVsZXRlKGtleS50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHJlbW92ZVJlZmVyZW5jZSh0eG4sIHRhcmdldElkLCBrZXkpIHtcbiAgICAgICAgdGhpcy5sb2NhbFZpZXdSZWZlcmVuY2VzLnJlbW92ZVJlZmVyZW5jZShrZXksIHRhcmdldElkKTtcbiAgICAgICAgdGhpcy5vcnBoYW5lZERvY3VtZW50cy5hZGQoa2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgbWFya1BvdGVudGlhbGx5T3JwaGFuZWQodHhuLCBrZXkpIHtcbiAgICAgICAgdGhpcy5vcnBoYW5lZERvY3VtZW50cy5hZGQoa2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgcmVtb3ZlVGFyZ2V0KHR4biwgdGFyZ2V0RGF0YSkge1xuICAgICAgICBjb25zdCBvcnBoYW5lZCA9IHRoaXMubG9jYWxWaWV3UmVmZXJlbmNlcy5yZW1vdmVSZWZlcmVuY2VzRm9ySWQodGFyZ2V0RGF0YS50YXJnZXRJZCk7XG4gICAgICAgIG9ycGhhbmVkLmZvckVhY2goa2V5ID0+IHRoaXMub3JwaGFuZWREb2N1bWVudHMuYWRkKGtleS50b1N0cmluZygpKSk7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy5wZXJzaXN0ZW5jZS5nZXRUYXJnZXRDYWNoZSgpO1xuICAgICAgICByZXR1cm4gY2FjaGVcbiAgICAgICAgICAgIC5nZXRNYXRjaGluZ0tleXNGb3JUYXJnZXRJZCh0eG4sIHRhcmdldERhdGEudGFyZ2V0SWQpXG4gICAgICAgICAgICAubmV4dChrZXlzID0+IHtcbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gdGhpcy5vcnBoYW5lZERvY3VtZW50cy5hZGQoa2V5LnRvU3RyaW5nKCkpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGNhY2hlLnJlbW92ZVRhcmdldERhdGEodHhuLCB0YXJnZXREYXRhKSk7XG4gICAgfVxuICAgIG9uVHJhbnNhY3Rpb25TdGFydGVkKCkge1xuICAgICAgICB0aGlzLl9vcnBoYW5lZERvY3VtZW50cyA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgb25UcmFuc2FjdGlvbkNvbW1pdHRlZCh0eG4pIHtcbiAgICAgICAgLy8gUmVtb3ZlIG5ld2x5IG9ycGhhbmVkIGRvY3VtZW50cy5cbiAgICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLnBlcnNpc3RlbmNlLmdldFJlbW90ZURvY3VtZW50Q2FjaGUoKTtcbiAgICAgICAgY29uc3QgY2hhbmdlQnVmZmVyID0gY2FjaGUubmV3Q2hhbmdlQnVmZmVyKCk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaCh0aGlzLm9ycGhhbmVkRG9jdW1lbnRzLCAocGF0aCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gRG9jdW1lbnRLZXkuZnJvbVBhdGgocGF0aCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1JlZmVyZW5jZWQodHhuLCBrZXkpLm5leHQoaXNSZWZlcmVuY2VkID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUmVmZXJlbmNlZCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VCdWZmZXIucmVtb3ZlRW50cnkoa2V5LCBTbmFwc2hvdFZlcnNpb24ubWluKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX29ycGhhbmVkRG9jdW1lbnRzID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VCdWZmZXIuYXBwbHkodHhuKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZUxpbWJvRG9jdW1lbnQodHhuLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNSZWZlcmVuY2VkKHR4biwga2V5KS5uZXh0KGlzUmVmZXJlbmNlZCA9PiB7XG4gICAgICAgICAgICBpZiAoaXNSZWZlcmVuY2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcnBoYW5lZERvY3VtZW50cy5kZWxldGUoa2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcnBoYW5lZERvY3VtZW50cy5hZGQoa2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZG9jdW1lbnRTaXplKGRvYykge1xuICAgICAgICAvLyBGb3IgZWFnZXIgR0MsIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhlIGRvY3VtZW50IHNpemUsIHRoZXJlIGFyZSBubyBzaXplIHRocmVzaG9sZHMuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpc1JlZmVyZW5jZWQodHhuLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5vcihbXG4gICAgICAgICAgICAoKSA9PiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmxvY2FsVmlld1JlZmVyZW5jZXMuY29udGFpbnNLZXkoa2V5KSksXG4gICAgICAgICAgICAoKSA9PiB0aGlzLnBlcnNpc3RlbmNlLmdldFRhcmdldENhY2hlKCkuY29udGFpbnNLZXkodHhuLCBrZXkpLFxuICAgICAgICAgICAgKCkgPT4gdGhpcy5wZXJzaXN0ZW5jZS5tdXRhdGlvblF1ZXVlc0NvbnRhaW5LZXkodHhuLCBrZXkpXG4gICAgICAgIF0pO1xuICAgIH1cbn1cbmNsYXNzIE1lbW9yeUxydURlbGVnYXRlIHtcbiAgICBjb25zdHJ1Y3RvcihwZXJzaXN0ZW5jZSwgbHJ1UGFyYW1zKSB7XG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2UgPSBwZXJzaXN0ZW5jZTtcbiAgICAgICAgdGhpcy5vcnBoYW5lZFNlcXVlbmNlTnVtYmVycyA9IG5ldyBPYmplY3RNYXAoayA9PiBlbmNvZGVSZXNvdXJjZVBhdGgoay5wYXRoKSwgKGwsIHIpID0+IGwuaXNFcXVhbChyKSk7XG4gICAgICAgIHRoaXMuZ2FyYmFnZUNvbGxlY3RvciA9IG5ld0xydUdhcmJhZ2VDb2xsZWN0b3IodGhpcywgbHJ1UGFyYW1zKTtcbiAgICB9XG4gICAgc3RhdGljIGZhY3RvcnkocGVyc2lzdGVuY2UsIGxydVBhcmFtcykge1xuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeUxydURlbGVnYXRlKHBlcnNpc3RlbmNlLCBscnVQYXJhbXMpO1xuICAgIH1cbiAgICAvLyBOby1vcHMsIHByZXNlbnQgc28gbWVtb3J5IHBlcnNpc3RlbmNlIGRvZXNuJ3QgaGF2ZSB0byBjYXJlIHdoaWNoIGRlbGVnYXRlXG4gICAgLy8gaXQgaGFzLlxuICAgIG9uVHJhbnNhY3Rpb25TdGFydGVkKCkgeyB9XG4gICAgb25UcmFuc2FjdGlvbkNvbW1pdHRlZCh0eG4pIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGZvckVhY2hUYXJnZXQodHhuLCBmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbmNlLmdldFRhcmdldENhY2hlKCkuZm9yRWFjaFRhcmdldCh0eG4sIGYpO1xuICAgIH1cbiAgICBnZXRTZXF1ZW5jZU51bWJlckNvdW50KHR4bikge1xuICAgICAgICBjb25zdCBkb2NDb3VudFByb21pc2UgPSB0aGlzLm9ycGhhbmVkRG9jdW1lbnRDb3VudCh0eG4pO1xuICAgICAgICBjb25zdCB0YXJnZXRDb3VudFByb21pc2UgPSB0aGlzLnBlcnNpc3RlbmNlXG4gICAgICAgICAgICAuZ2V0VGFyZ2V0Q2FjaGUoKVxuICAgICAgICAgICAgLmdldFRhcmdldENvdW50KHR4bik7XG4gICAgICAgIHJldHVybiB0YXJnZXRDb3VudFByb21pc2UubmV4dCh0YXJnZXRDb3VudCA9PiBkb2NDb3VudFByb21pc2UubmV4dChkb2NDb3VudCA9PiB0YXJnZXRDb3VudCArIGRvY0NvdW50KSk7XG4gICAgfVxuICAgIG9ycGhhbmVkRG9jdW1lbnRDb3VudCh0eG4pIHtcbiAgICAgICAgbGV0IG9ycGhhbmVkQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JFYWNoT3JwaGFuZWREb2N1bWVudFNlcXVlbmNlTnVtYmVyKHR4biwgXyA9PiB7XG4gICAgICAgICAgICBvcnBoYW5lZENvdW50Kys7XG4gICAgICAgIH0pLm5leHQoKCkgPT4gb3JwaGFuZWRDb3VudCk7XG4gICAgfVxuICAgIGZvckVhY2hPcnBoYW5lZERvY3VtZW50U2VxdWVuY2VOdW1iZXIodHhuLCBmKSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaCh0aGlzLm9ycGhhbmVkU2VxdWVuY2VOdW1iZXJzLCAoa2V5LCBzZXF1ZW5jZU51bWJlcikgPT4ge1xuICAgICAgICAgICAgLy8gUGFzcyBpbiB0aGUgZXhhY3Qgc2VxdWVuY2UgbnVtYmVyIGFzIHRoZSB1cHBlciBib3VuZCBzbyB3ZSBrbm93IGl0IHdvbid0IGJlIHBpbm5lZCBieVxuICAgICAgICAgICAgLy8gYmVpbmcgdG9vIHJlY2VudC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzUGlubmVkKHR4biwga2V5LCBzZXF1ZW5jZU51bWJlcikubmV4dChpc1Bpbm5lZCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1Bpbm5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZihzZXF1ZW5jZU51bWJlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZVRhcmdldHModHhuLCB1cHBlckJvdW5kLCBhY3RpdmVUYXJnZXRJZHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2VcbiAgICAgICAgICAgIC5nZXRUYXJnZXRDYWNoZSgpXG4gICAgICAgICAgICAucmVtb3ZlVGFyZ2V0cyh0eG4sIHVwcGVyQm91bmQsIGFjdGl2ZVRhcmdldElkcyk7XG4gICAgfVxuICAgIHJlbW92ZU9ycGhhbmVkRG9jdW1lbnRzKHR4biwgdXBwZXJCb3VuZCkge1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMucGVyc2lzdGVuY2UuZ2V0UmVtb3RlRG9jdW1lbnRDYWNoZSgpO1xuICAgICAgICBjb25zdCBjaGFuZ2VCdWZmZXIgPSBjYWNoZS5uZXdDaGFuZ2VCdWZmZXIoKTtcbiAgICAgICAgY29uc3QgcCA9IGNhY2hlLmZvckVhY2hEb2N1bWVudEtleSh0eG4sIGtleSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1Bpbm5lZCh0eG4sIGtleSwgdXBwZXJCb3VuZCkubmV4dChpc1Bpbm5lZCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1Bpbm5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VCdWZmZXIucmVtb3ZlRW50cnkoa2V5LCBTbmFwc2hvdFZlcnNpb24ubWluKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHAubmV4dCgoKSA9PiBjaGFuZ2VCdWZmZXIuYXBwbHkodHhuKSkubmV4dCgoKSA9PiBjb3VudCk7XG4gICAgfVxuICAgIG1hcmtQb3RlbnRpYWxseU9ycGhhbmVkKHR4biwga2V5KSB7XG4gICAgICAgIHRoaXMub3JwaGFuZWRTZXF1ZW5jZU51bWJlcnMuc2V0KGtleSwgdHhuLmN1cnJlbnRTZXF1ZW5jZU51bWJlcik7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICByZW1vdmVUYXJnZXQodHhuLCB0YXJnZXREYXRhKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWQgPSB0YXJnZXREYXRhLndpdGhTZXF1ZW5jZU51bWJlcih0eG4uY3VycmVudFNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2UuZ2V0VGFyZ2V0Q2FjaGUoKS51cGRhdGVUYXJnZXREYXRhKHR4biwgdXBkYXRlZCk7XG4gICAgfVxuICAgIGFkZFJlZmVyZW5jZSh0eG4sIHRhcmdldElkLCBrZXkpIHtcbiAgICAgICAgdGhpcy5vcnBoYW5lZFNlcXVlbmNlTnVtYmVycy5zZXQoa2V5LCB0eG4uY3VycmVudFNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHJlbW92ZVJlZmVyZW5jZSh0eG4sIHRhcmdldElkLCBrZXkpIHtcbiAgICAgICAgdGhpcy5vcnBoYW5lZFNlcXVlbmNlTnVtYmVycy5zZXQoa2V5LCB0eG4uY3VycmVudFNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHVwZGF0ZUxpbWJvRG9jdW1lbnQodHhuLCBrZXkpIHtcbiAgICAgICAgdGhpcy5vcnBoYW5lZFNlcXVlbmNlTnVtYmVycy5zZXQoa2V5LCB0eG4uY3VycmVudFNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGRvY3VtZW50U2l6ZShkb2N1bWVudCkge1xuICAgICAgICBsZXQgZG9jdW1lbnRTaXplID0gZG9jdW1lbnQua2V5LnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgICAgICBpZiAoZG9jdW1lbnQuaXNGb3VuZERvY3VtZW50KCkpIHtcbiAgICAgICAgICAgIGRvY3VtZW50U2l6ZSArPSBlc3RpbWF0ZUJ5dGVTaXplKGRvY3VtZW50LmRhdGEudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb2N1bWVudFNpemU7XG4gICAgfVxuICAgIGlzUGlubmVkKHR4biwga2V5LCB1cHBlckJvdW5kKSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uub3IoW1xuICAgICAgICAgICAgKCkgPT4gdGhpcy5wZXJzaXN0ZW5jZS5tdXRhdGlvblF1ZXVlc0NvbnRhaW5LZXkodHhuLCBrZXkpLFxuICAgICAgICAgICAgKCkgPT4gdGhpcy5wZXJzaXN0ZW5jZS5nZXRUYXJnZXRDYWNoZSgpLmNvbnRhaW5zS2V5KHR4biwga2V5KSxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcnBoYW5lZEF0ID0gdGhpcy5vcnBoYW5lZFNlcXVlbmNlTnVtYmVycy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUob3JwaGFuZWRBdCAhPT0gdW5kZWZpbmVkICYmIG9ycGhhbmVkQXQgPiB1cHBlckJvdW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGdldENhY2hlU2l6ZSh0eG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2UuZ2V0UmVtb3RlRG9jdW1lbnRDYWNoZSgpLmdldFNpemUodHhuKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogUGVyZm9ybXMgZGF0YWJhc2UgY3JlYXRpb24gYW5kIHNjaGVtYSB1cGdyYWRlcy4gKi9cbmNsYXNzIFNjaGVtYUNvbnZlcnRlciB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWFsaXplcikge1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBkYXRhYmFzZSBjcmVhdGlvbiBhbmQgc2NoZW1hIHVwZ3JhZGVzLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGluIHByb2R1Y3Rpb24sIHRoaXMgbWV0aG9kIGlzIG9ubHkgZXZlciB1c2VkIHRvIHVwZ3JhZGUgdGhlIHNjaGVtYVxuICAgICAqIHRvIFNDSEVNQV9WRVJTSU9OLiBEaWZmZXJlbnQgdmFsdWVzIG9mIHRvVmVyc2lvbiBhcmUgb25seSB1c2VkIGZvciB0ZXN0aW5nXG4gICAgICogYW5kIGxvY2FsIGZlYXR1cmUgZGV2ZWxvcG1lbnQuXG4gICAgICovXG4gICAgY3JlYXRlT3JVcGdyYWRlKGRiLCB0eG4sIGZyb21WZXJzaW9uLCB0b1ZlcnNpb24pIHtcbiAgICAgICAgY29uc3Qgc2ltcGxlRGJUcmFuc2FjdGlvbiA9IG5ldyBTaW1wbGVEYlRyYW5zYWN0aW9uKCdjcmVhdGVPclVwZ3JhZGUnLCB0eG4pO1xuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAxICYmIHRvVmVyc2lvbiA+PSAxKSB7XG4gICAgICAgICAgICBjcmVhdGVQcmltYXJ5Q2xpZW50U3RvcmUoZGIpO1xuICAgICAgICAgICAgY3JlYXRlTXV0YXRpb25RdWV1ZShkYik7XG4gICAgICAgICAgICBjcmVhdGVRdWVyeUNhY2hlKGRiKTtcbiAgICAgICAgICAgIGNyZWF0ZUxlZ2FjeVJlbW90ZURvY3VtZW50Q2FjaGUoZGIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1pZ3JhdGlvbiAyIHRvIHBvcHVsYXRlIHRoZSB0YXJnZXRHbG9iYWwgb2JqZWN0IG5vIGxvbmdlciBuZWVkZWQgc2luY2VcbiAgICAgICAgLy8gbWlncmF0aW9uIDMgdW5jb25kaXRpb25hbGx5IGNsZWFycyBpdC5cbiAgICAgICAgbGV0IHAgPSBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAzICYmIHRvVmVyc2lvbiA+PSAzKSB7XG4gICAgICAgICAgICAvLyBCcmFuZCBuZXcgY2xpZW50cyBkb24ndCBuZWVkIHRvIGRyb3AgYW5kIHJlY3JlYXRlLS1vbmx5IGNsaWVudHMgdGhhdFxuICAgICAgICAgICAgLy8gcG90ZW50aWFsbHkgaGF2ZSBjb3JydXB0IGRhdGEuXG4gICAgICAgICAgICBpZiAoZnJvbVZlcnNpb24gIT09IDApIHtcbiAgICAgICAgICAgICAgICBkcm9wUXVlcnlDYWNoZShkYik7XG4gICAgICAgICAgICAgICAgY3JlYXRlUXVlcnlDYWNoZShkYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHdyaXRlRW1wdHlUYXJnZXRHbG9iYWxFbnRyeShzaW1wbGVEYlRyYW5zYWN0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgNCAmJiB0b1ZlcnNpb24gPj0gNCkge1xuICAgICAgICAgICAgaWYgKGZyb21WZXJzaW9uICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gU2NoZW1hIHZlcnNpb24gMyB1c2VzIGF1dG8tZ2VuZXJhdGVkIGtleXMgdG8gZ2VuZXJhdGUgZ2xvYmFsbHkgdW5pcXVlXG4gICAgICAgICAgICAgICAgLy8gbXV0YXRpb24gYmF0Y2ggSURzICh0aGlzIHdhcyBwcmV2aW91c2x5IGVuc3VyZWQgaW50ZXJuYWxseSBieSB0aGVcbiAgICAgICAgICAgICAgICAvLyBjbGllbnQpLiBUbyBtaWdyYXRlIHRvIHRoZSBuZXcgc2NoZW1hLCB3ZSBoYXZlIHRvIHJlYWQgYWxsIG11dGF0aW9uc1xuICAgICAgICAgICAgICAgIC8vIGFuZCB3cml0ZSB0aGVtIGJhY2sgb3V0LiBXZSBwcmVzZXJ2ZSB0aGUgZXhpc3RpbmcgYmF0Y2ggSURzIHRvIGd1YXJhbnRlZVxuICAgICAgICAgICAgICAgIC8vIGNvbnNpc3RlbmN5IHdpdGggb3RoZXIgb2JqZWN0IHN0b3Jlcy4gQW55IGZ1cnRoZXIgbXV0YXRpb24gYmF0Y2ggSURzIHdpbGxcbiAgICAgICAgICAgICAgICAvLyBiZSBhdXRvLWdlbmVyYXRlZC5cbiAgICAgICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHVwZ3JhZGVNdXRhdGlvbkJhdGNoU2NoZW1hQW5kTWlncmF0ZURhdGEoZGIsIHNpbXBsZURiVHJhbnNhY3Rpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUNsaWVudE1ldGFkYXRhU3RvcmUoZGIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgNSAmJiB0b1ZlcnNpb24gPj0gNSkge1xuICAgICAgICAgICAgcCA9IHAubmV4dCgoKSA9PiB0aGlzLnJlbW92ZUFja25vd2xlZGdlZE11dGF0aW9ucyhzaW1wbGVEYlRyYW5zYWN0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgNiAmJiB0b1ZlcnNpb24gPj0gNikge1xuICAgICAgICAgICAgcCA9IHAubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3JlYXRlRG9jdW1lbnRHbG9iYWxTdG9yZShkYik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkRG9jdW1lbnRHbG9iYWwoc2ltcGxlRGJUcmFuc2FjdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCA3ICYmIHRvVmVyc2lvbiA+PSA3KSB7XG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHRoaXMuZW5zdXJlU2VxdWVuY2VOdW1iZXJzKHNpbXBsZURiVHJhbnNhY3Rpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCA4ICYmIHRvVmVyc2lvbiA+PSA4KSB7XG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHRoaXMuY3JlYXRlQ29sbGVjdGlvblBhcmVudEluZGV4KGRiLCBzaW1wbGVEYlRyYW5zYWN0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgOSAmJiB0b1ZlcnNpb24gPj0gOSkge1xuICAgICAgICAgICAgcCA9IHAubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gTXVsdGktVGFiIHVzZWQgdG8gbWFuYWdlIGl0cyBvd24gY2hhbmdlbG9nLCBidXQgdGhpcyBoYXMgYmVlbiBtb3ZlZFxuICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBEYlJlbW90ZURvY3VtZW50IG9iamVjdCBzdG9yZSBpdHNlbGYuIFNpbmNlIHRoZSBwcmV2aW91cyBjaGFuZ2VcbiAgICAgICAgICAgICAgICAvLyBsb2cgb25seSBjb250YWluZWQgdHJhbnNpZW50IGRhdGEsIHdlIGNhbiBkcm9wIGl0cyBvYmplY3Qgc3RvcmUuXG4gICAgICAgICAgICAgICAgZHJvcFJlbW90ZURvY3VtZW50Q2hhbmdlc1N0b3JlKGRiKTtcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBTY2hlbWEgdmVyc2lvbiA5IHVzZWQgdG8gY3JlYXRlIGEgcmVhZCB0aW1lIGluZGV4IGZvciB0aGVcbiAgICAgICAgICAgICAgICAvLyBSZW1vdGVEb2N1bWVudENhY2hlLiBUaGlzIGlzIG5vdyBkb25lIHdpdGggc2NoZW1hIHZlcnNpb24gMTMuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAxMCAmJiB0b1ZlcnNpb24gPj0gMTApIHtcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4gdGhpcy5yZXdyaXRlQ2Fub25pY2FsSWRzKHNpbXBsZURiVHJhbnNhY3Rpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAxMSAmJiB0b1ZlcnNpb24gPj0gMTEpIHtcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUJ1bmRsZXNTdG9yZShkYik7XG4gICAgICAgICAgICAgICAgY3JlYXRlTmFtZWRRdWVyaWVzU3RvcmUoZGIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgMTIgJiYgdG9WZXJzaW9uID49IDEyKSB7XG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBjcmVhdGVEb2N1bWVudE92ZXJsYXlTdG9yZShkYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAxMyAmJiB0b1ZlcnNpb24gPj0gMTMpIHtcbiAgICAgICAgICAgIHAgPSBwXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gY3JlYXRlUmVtb3RlRG9jdW1lbnRDYWNoZShkYikpXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gdGhpcy5yZXdyaXRlUmVtb3RlRG9jdW1lbnRDYWNoZShkYiwgc2ltcGxlRGJUcmFuc2FjdGlvbikpXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gZGIuZGVsZXRlT2JqZWN0U3RvcmUoRGJSZW1vdGVEb2N1bWVudFN0b3JlJDEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAxNCAmJiB0b1ZlcnNpb24gPj0gMTQpIHtcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4gdGhpcy5ydW5PdmVybGF5TWlncmF0aW9uKGRiLCBzaW1wbGVEYlRyYW5zYWN0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgMTUgJiYgdG9WZXJzaW9uID49IDE1KSB7XG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IGNyZWF0ZUZpZWxkSW5kZXgoZGIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAxNiAmJiB0b1ZlcnNpb24gPj0gMTYpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBvYmplY3Qgc3RvcmVzIHRvIHJlbW92ZSBwb3NzaWJseSBjb3JydXB0ZWQgaW5kZXggZW50cmllc1xuICAgICAgICAgICAgcCA9IHBcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXhTdGF0ZVN0b3JlID0gdHhuLm9iamVjdFN0b3JlKERiSW5kZXhTdGF0ZVN0b3JlKTtcbiAgICAgICAgICAgICAgICBpbmRleFN0YXRlU3RvcmUuY2xlYXIoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4RW50cnlTdG9yZSA9IHR4bi5vYmplY3RTdG9yZShEYkluZGV4RW50cnlTdG9yZSk7XG4gICAgICAgICAgICAgICAgaW5kZXhFbnRyeVN0b3JlLmNsZWFyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAxNyAmJiB0b1ZlcnNpb24gPj0gMTcpIHtcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUdsb2JhbHNTdG9yZShkYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgYWRkRG9jdW1lbnRHbG9iYWwodHhuKSB7XG4gICAgICAgIGxldCBieXRlU2l6ZSA9IDA7XG4gICAgICAgIHJldHVybiB0eG5cbiAgICAgICAgICAgIC5zdG9yZShEYlJlbW90ZURvY3VtZW50U3RvcmUkMSlcbiAgICAgICAgICAgIC5pdGVyYXRlKChfLCBkb2MpID0+IHtcbiAgICAgICAgICAgIGJ5dGVTaXplICs9IGRiRG9jdW1lbnRTaXplKGRvYyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHsgYnl0ZVNpemUgfTtcbiAgICAgICAgICAgIHJldHVybiB0eG5cbiAgICAgICAgICAgICAgICAuc3RvcmUoRGJSZW1vdGVEb2N1bWVudEdsb2JhbFN0b3JlKVxuICAgICAgICAgICAgICAgIC5wdXQoRGJSZW1vdGVEb2N1bWVudEdsb2JhbEtleSwgbWV0YWRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlQWNrbm93bGVkZ2VkTXV0YXRpb25zKHR4bikge1xuICAgICAgICBjb25zdCBxdWV1ZXNTdG9yZSA9IHR4bi5zdG9yZShEYk11dGF0aW9uUXVldWVTdG9yZSk7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uc1N0b3JlID0gdHhuLnN0b3JlKERiTXV0YXRpb25CYXRjaFN0b3JlKTtcbiAgICAgICAgcmV0dXJuIHF1ZXVlc1N0b3JlLmxvYWRBbGwoKS5uZXh0KHF1ZXVlcyA9PiB7XG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2gocXVldWVzLCAocXVldWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKFtxdWV1ZS51c2VySWQsIEJBVENISURfVU5LTk9XTl0sIFtxdWV1ZS51c2VySWQsIHF1ZXVlLmxhc3RBY2tub3dsZWRnZWRCYXRjaElkXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG11dGF0aW9uc1N0b3JlXG4gICAgICAgICAgICAgICAgICAgIC5sb2FkQWxsKERiTXV0YXRpb25CYXRjaFVzZXJNdXRhdGlvbnNJbmRleCwgcmFuZ2UpXG4gICAgICAgICAgICAgICAgICAgIC5uZXh0KGRiQmF0Y2hlcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChkYkJhdGNoZXMsIChkYkJhdGNoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXJkQXNzZXJ0KGRiQmF0Y2gudXNlcklkID09PSBxdWV1ZS51c2VySWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSBmcm9tRGJNdXRhdGlvbkJhdGNoKHRoaXMuc2VyaWFsaXplciwgZGJCYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlTXV0YXRpb25CYXRjaCh0eG4sIHF1ZXVlLnVzZXJJZCwgYmF0Y2gpLm5leHQoKCkgPT4geyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhhdCBldmVyeSBkb2N1bWVudCBpbiB0aGUgcmVtb3RlIGRvY3VtZW50IGNhY2hlIGhhcyBhIGNvcnJlc3BvbmRpbmcgc2VudGluZWwgcm93XG4gICAgICogd2l0aCBhIHNlcXVlbmNlIG51bWJlci4gTWlzc2luZyByb3dzIGFyZSBnaXZlbiB0aGUgbW9zdCByZWNlbnRseSB1c2VkIHNlcXVlbmNlIG51bWJlci5cbiAgICAgKi9cbiAgICBlbnN1cmVTZXF1ZW5jZU51bWJlcnModHhuKSB7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50VGFyZ2V0U3RvcmUgPSB0eG4uc3RvcmUoRGJUYXJnZXREb2N1bWVudFN0b3JlKTtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRzU3RvcmUgPSB0eG4uc3RvcmUoRGJSZW1vdGVEb2N1bWVudFN0b3JlJDEpO1xuICAgICAgICBjb25zdCBnbG9iYWxUYXJnZXRTdG9yZSA9IHR4bi5zdG9yZShEYlRhcmdldEdsb2JhbFN0b3JlKTtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRhcmdldFN0b3JlLmdldChEYlRhcmdldEdsb2JhbEtleSkubmV4dChtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3cml0ZVNlbnRpbmVsS2V5ID0gKHBhdGgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnRUYXJnZXRTdG9yZS5wdXQoe1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRJZDogMCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogZW5jb2RlUmVzb3VyY2VQYXRoKHBhdGgpLFxuICAgICAgICAgICAgICAgICAgICBzZXF1ZW5jZU51bWJlcjogbWV0YWRhdGEuaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudHNTdG9yZVxuICAgICAgICAgICAgICAgIC5pdGVyYXRlKChrZXksIGRvYykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBuZXcgUmVzb3VyY2VQYXRoKGtleSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9jU2VudGluZWxLZXkgPSBzZW50aW5lbEtleShwYXRoKTtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGRvY3VtZW50VGFyZ2V0U3RvcmUuZ2V0KGRvY1NlbnRpbmVsS2V5KS5uZXh0KG1heWJlU2VudGluZWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1heWJlU2VudGluZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZVNlbnRpbmVsS2V5KHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVDb2xsZWN0aW9uUGFyZW50SW5kZXgoZGIsIHR4bikge1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGluZGV4LlxuICAgICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShEYkNvbGxlY3Rpb25QYXJlbnRTdG9yZSwge1xuICAgICAgICAgICAga2V5UGF0aDogRGJDb2xsZWN0aW9uUGFyZW50S2V5UGF0aFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY29sbGVjdGlvblBhcmVudHNTdG9yZSA9IHR4bi5zdG9yZShEYkNvbGxlY3Rpb25QYXJlbnRTdG9yZSk7XG4gICAgICAgIC8vIEhlbHBlciB0byBhZGQgYW4gaW5kZXggZW50cnkgaWZmIHdlIGhhdmVuJ3QgYWxyZWFkeSB3cml0dGVuIGl0LlxuICAgICAgICBjb25zdCBjYWNoZSA9IG5ldyBNZW1vcnlDb2xsZWN0aW9uUGFyZW50SW5kZXgoKTtcbiAgICAgICAgY29uc3QgYWRkRW50cnkgPSAoY29sbGVjdGlvblBhdGgpID0+IHtcbiAgICAgICAgICAgIGlmIChjYWNoZS5hZGQoY29sbGVjdGlvblBhdGgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvbklkID0gY29sbGVjdGlvblBhdGgubGFzdFNlZ21lbnQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRQYXRoID0gY29sbGVjdGlvblBhdGgucG9wTGFzdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uUGFyZW50c1N0b3JlLnB1dCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBlbmNvZGVSZXNvdXJjZVBhdGgocGFyZW50UGF0aClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gSW5kZXggZXhpc3RpbmcgcmVtb3RlIGRvY3VtZW50cy5cbiAgICAgICAgcmV0dXJuIHR4blxuICAgICAgICAgICAgLnN0b3JlKERiUmVtb3RlRG9jdW1lbnRTdG9yZSQxKVxuICAgICAgICAgICAgLml0ZXJhdGUoeyBrZXlzT25seTogdHJ1ZSB9LCAocGF0aFNlZ21lbnRzLCBfKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gbmV3IFJlc291cmNlUGF0aChwYXRoU2VnbWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEVudHJ5KHBhdGgucG9wTGFzdCgpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgIC8vIEluZGV4IGV4aXN0aW5nIG11dGF0aW9ucy5cbiAgICAgICAgICAgIHJldHVybiB0eG5cbiAgICAgICAgICAgICAgICAuc3RvcmUoRGJEb2N1bWVudE11dGF0aW9uU3RvcmUpXG4gICAgICAgICAgICAgICAgLml0ZXJhdGUoeyBrZXlzT25seTogdHJ1ZSB9LCAoW3VzZXJJRCwgZW5jb2RlZFBhdGgsIGJhdGNoSWRdLCBfKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IGRlY29kZVJlc291cmNlUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZEVudHJ5KHBhdGgucG9wTGFzdCgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV3cml0ZUNhbm9uaWNhbElkcyh0eG4pIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0U3RvcmUgPSB0eG4uc3RvcmUoRGJUYXJnZXRTdG9yZSk7XG4gICAgICAgIHJldHVybiB0YXJnZXRTdG9yZS5pdGVyYXRlKChrZXksIG9yaWdpbmFsRGJUYXJnZXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsVGFyZ2V0RGF0YSA9IGZyb21EYlRhcmdldChvcmlnaW5hbERiVGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWREYlRhcmdldCA9IHRvRGJUYXJnZXQodGhpcy5zZXJpYWxpemVyLCBvcmlnaW5hbFRhcmdldERhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldFN0b3JlLnB1dCh1cGRhdGVkRGJUYXJnZXQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV3cml0ZVJlbW90ZURvY3VtZW50Q2FjaGUoZGIsIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGxlZ2FjeVJlbW90ZURvY3VtZW50U3RvcmUgPSB0cmFuc2FjdGlvbi5zdG9yZShEYlJlbW90ZURvY3VtZW50U3RvcmUkMSk7XG4gICAgICAgIGNvbnN0IHdyaXRlcyA9IFtdO1xuICAgICAgICByZXR1cm4gbGVnYWN5UmVtb3RlRG9jdW1lbnRTdG9yZVxuICAgICAgICAgICAgLml0ZXJhdGUoKF8sIGxlZ2FjeURvY3VtZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZW1vdGVEb2N1bWVudFN0b3JlID0gdHJhbnNhY3Rpb24uc3RvcmUoRGJSZW1vdGVEb2N1bWVudFN0b3JlKTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBleHRyYWN0S2V5KGxlZ2FjeURvY3VtZW50KS5wYXRoLnRvQXJyYXkoKTtcbiAgICAgICAgICAgIGNvbnN0IGRiUmVtb3RlRG9jdW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgcHJlZml4UGF0aDogcGF0aC5zbGljZSgwLCBwYXRoLmxlbmd0aCAtIDIpLFxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25Hcm91cDogcGF0aFtwYXRoLmxlbmd0aCAtIDJdLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50SWQ6IHBhdGhbcGF0aC5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICByZWFkVGltZTogbGVnYWN5RG9jdW1lbnQucmVhZFRpbWUgfHwgWzAsIDBdLFxuICAgICAgICAgICAgICAgIHVua25vd25Eb2N1bWVudDogbGVnYWN5RG9jdW1lbnQudW5rbm93bkRvY3VtZW50LFxuICAgICAgICAgICAgICAgIG5vRG9jdW1lbnQ6IGxlZ2FjeURvY3VtZW50Lm5vRG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQ6IGxlZ2FjeURvY3VtZW50LmRvY3VtZW50LFxuICAgICAgICAgICAgICAgIGhhc0NvbW1pdHRlZE11dGF0aW9uczogISFsZWdhY3lEb2N1bWVudC5oYXNDb21taXR0ZWRNdXRhdGlvbnNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3cml0ZXMucHVzaChyZW1vdGVEb2N1bWVudFN0b3JlLnB1dChkYlJlbW90ZURvY3VtZW50KSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcih3cml0ZXMpKTtcbiAgICB9XG4gICAgcnVuT3ZlcmxheU1pZ3JhdGlvbihkYiwgdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgbXV0YXRpb25zU3RvcmUgPSB0cmFuc2FjdGlvbi5zdG9yZShEYk11dGF0aW9uQmF0Y2hTdG9yZSk7XG4gICAgICAgIGNvbnN0IHJlbW90ZURvY3VtZW50Q2FjaGUgPSBuZXdJbmRleGVkRGJSZW1vdGVEb2N1bWVudENhY2hlKHRoaXMuc2VyaWFsaXplcik7XG4gICAgICAgIGNvbnN0IG1lbW9yeVBlcnNpc3RlbmNlID0gbmV3IE1lbW9yeVBlcnNpc3RlbmNlKE1lbW9yeUVhZ2VyRGVsZWdhdGUuZmFjdG9yeSwgdGhpcy5zZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIpO1xuICAgICAgICByZXR1cm4gbXV0YXRpb25zU3RvcmUubG9hZEFsbCgpLm5leHQoZGJCYXRjaGVzID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJUb0RvY3VtZW50U2V0ID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZGJCYXRjaGVzLmZvckVhY2goZGJCYXRjaCA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGxldCBkb2N1bWVudFNldCA9IChfYSA9IHVzZXJUb0RvY3VtZW50U2V0LmdldChkYkJhdGNoLnVzZXJJZCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSBmcm9tRGJNdXRhdGlvbkJhdGNoKHRoaXMuc2VyaWFsaXplciwgZGJCYXRjaCk7XG4gICAgICAgICAgICAgICAgYmF0Y2gua2V5cygpLmZvckVhY2goa2V5ID0+IChkb2N1bWVudFNldCA9IGRvY3VtZW50U2V0LmFkZChrZXkpKSk7XG4gICAgICAgICAgICAgICAgdXNlclRvRG9jdW1lbnRTZXQuc2V0KGRiQmF0Y2gudXNlcklkLCBkb2N1bWVudFNldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaCh1c2VyVG9Eb2N1bWVudFNldCwgKGFsbERvY3VtZW50S2V5c0ZvclVzZXIsIHVzZXJJZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXIgPSBuZXcgVXNlcih1c2VySWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50T3ZlcmxheUNhY2hlID0gSW5kZXhlZERiRG9jdW1lbnRPdmVybGF5Q2FjaGUuZm9yVXNlcih0aGlzLnNlcmlhbGl6ZXIsIHVzZXIpO1xuICAgICAgICAgICAgICAgIC8vIE5PVEU6IFRoZSBpbmRleCBtYW5hZ2VyIGFuZCB0aGUgcmVmZXJlbmNlIGRlbGVnYXRlIGFyZVxuICAgICAgICAgICAgICAgIC8vIGlycmVsZXZhbnQgZm9yIHRoZSBwdXJwb3NlIG9mIHJlY2FsY3VsYXRpbmcgYW5kIHNhdmluZ1xuICAgICAgICAgICAgICAgIC8vIG92ZXJsYXlzLiBXZSBjYW4gdGhlcmVmb3JlIHNpbXBseSB1c2UgdGhlIG1lbW9yeVxuICAgICAgICAgICAgICAgIC8vIGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4TWFuYWdlciA9IG1lbW9yeVBlcnNpc3RlbmNlLmdldEluZGV4TWFuYWdlcih1c2VyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtdXRhdGlvblF1ZXVlID0gSW5kZXhlZERiTXV0YXRpb25RdWV1ZS5mb3JVc2VyKHVzZXIsIHRoaXMuc2VyaWFsaXplciwgaW5kZXhNYW5hZ2VyLCBtZW1vcnlQZXJzaXN0ZW5jZS5yZWZlcmVuY2VEZWxlZ2F0ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxEb2N1bWVudHNWaWV3ID0gbmV3IExvY2FsRG9jdW1lbnRzVmlldyhyZW1vdGVEb2N1bWVudENhY2hlLCBtdXRhdGlvblF1ZXVlLCBkb2N1bWVudE92ZXJsYXlDYWNoZSwgaW5kZXhNYW5hZ2VyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxEb2N1bWVudHNWaWV3XG4gICAgICAgICAgICAgICAgICAgIC5yZWNhbGN1bGF0ZUFuZFNhdmVPdmVybGF5c0ZvckRvY3VtZW50S2V5cyhuZXcgSW5kZXhlZERiVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIExpc3RlblNlcXVlbmNlLklOVkFMSUQpLCBhbGxEb2N1bWVudEtleXNGb3JVc2VyKVxuICAgICAgICAgICAgICAgICAgICAubmV4dCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlbnRpbmVsS2V5KHBhdGgpIHtcbiAgICByZXR1cm4gWzAsIGVuY29kZVJlc291cmNlUGF0aChwYXRoKV07XG59XG5mdW5jdGlvbiBjcmVhdGVQcmltYXJ5Q2xpZW50U3RvcmUoZGIpIHtcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShEYlByaW1hcnlDbGllbnRTdG9yZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVNdXRhdGlvblF1ZXVlKGRiKSB7XG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJNdXRhdGlvblF1ZXVlU3RvcmUsIHtcbiAgICAgICAga2V5UGF0aDogRGJNdXRhdGlvblF1ZXVlS2V5UGF0aFxuICAgIH0pO1xuICAgIGNvbnN0IG11dGF0aW9uQmF0Y2hlc1N0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJNdXRhdGlvbkJhdGNoU3RvcmUsIHtcbiAgICAgICAga2V5UGF0aDogRGJNdXRhdGlvbkJhdGNoS2V5UGF0aCxcbiAgICAgICAgYXV0b0luY3JlbWVudDogdHJ1ZVxuICAgIH0pO1xuICAgIG11dGF0aW9uQmF0Y2hlc1N0b3JlLmNyZWF0ZUluZGV4KERiTXV0YXRpb25CYXRjaFVzZXJNdXRhdGlvbnNJbmRleCwgRGJNdXRhdGlvbkJhdGNoVXNlck11dGF0aW9uc0tleVBhdGgsIHsgdW5pcXVlOiB0cnVlIH0pO1xuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiRG9jdW1lbnRNdXRhdGlvblN0b3JlKTtcbn1cbi8qKlxuICogVXBncmFkZSBmdW5jdGlvbiB0byBtaWdyYXRlIHRoZSAnbXV0YXRpb25zJyBzdG9yZSBmcm9tIFYxIHRvIFYzLiBMb2Fkc1xuICogYW5kIHJld3JpdGVzIGFsbCBkYXRhLlxuICovXG5mdW5jdGlvbiB1cGdyYWRlTXV0YXRpb25CYXRjaFNjaGVtYUFuZE1pZ3JhdGVEYXRhKGRiLCB0eG4pIHtcbiAgICBjb25zdCB2MU11dGF0aW9uc1N0b3JlID0gdHhuLnN0b3JlKERiTXV0YXRpb25CYXRjaFN0b3JlKTtcbiAgICByZXR1cm4gdjFNdXRhdGlvbnNTdG9yZS5sb2FkQWxsKCkubmV4dChleGlzdGluZ011dGF0aW9ucyA9PiB7XG4gICAgICAgIGRiLmRlbGV0ZU9iamVjdFN0b3JlKERiTXV0YXRpb25CYXRjaFN0b3JlKTtcbiAgICAgICAgY29uc3QgbXV0YXRpb25zU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShEYk11dGF0aW9uQmF0Y2hTdG9yZSwge1xuICAgICAgICAgICAga2V5UGF0aDogRGJNdXRhdGlvbkJhdGNoS2V5UGF0aCxcbiAgICAgICAgICAgIGF1dG9JbmNyZW1lbnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIG11dGF0aW9uc1N0b3JlLmNyZWF0ZUluZGV4KERiTXV0YXRpb25CYXRjaFVzZXJNdXRhdGlvbnNJbmRleCwgRGJNdXRhdGlvbkJhdGNoVXNlck11dGF0aW9uc0tleVBhdGgsIHsgdW5pcXVlOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCB2M011dGF0aW9uc1N0b3JlID0gdHhuLnN0b3JlKERiTXV0YXRpb25CYXRjaFN0b3JlKTtcbiAgICAgICAgY29uc3Qgd3JpdGVBbGwgPSBleGlzdGluZ011dGF0aW9ucy5tYXAobXV0YXRpb24gPT4gdjNNdXRhdGlvbnNTdG9yZS5wdXQobXV0YXRpb24pKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHdyaXRlQWxsKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxlZ2FjeVJlbW90ZURvY3VtZW50Q2FjaGUoZGIpIHtcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShEYlJlbW90ZURvY3VtZW50U3RvcmUkMSk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZW1vdGVEb2N1bWVudENhY2hlKGRiKSB7XG4gICAgY29uc3QgcmVtb3RlRG9jdW1lbnRTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiUmVtb3RlRG9jdW1lbnRTdG9yZSwge1xuICAgICAgICBrZXlQYXRoOiBEYlJlbW90ZURvY3VtZW50S2V5UGF0aFxuICAgIH0pO1xuICAgIHJlbW90ZURvY3VtZW50U3RvcmUuY3JlYXRlSW5kZXgoRGJSZW1vdGVEb2N1bWVudERvY3VtZW50S2V5SW5kZXgsIERiUmVtb3RlRG9jdW1lbnREb2N1bWVudEtleUluZGV4UGF0aCk7XG4gICAgcmVtb3RlRG9jdW1lbnRTdG9yZS5jcmVhdGVJbmRleChEYlJlbW90ZURvY3VtZW50Q29sbGVjdGlvbkdyb3VwSW5kZXgsIERiUmVtb3RlRG9jdW1lbnRDb2xsZWN0aW9uR3JvdXBJbmRleFBhdGgpO1xufVxuZnVuY3Rpb24gY3JlYXRlRG9jdW1lbnRHbG9iYWxTdG9yZShkYikge1xuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiUmVtb3RlRG9jdW1lbnRHbG9iYWxTdG9yZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVRdWVyeUNhY2hlKGRiKSB7XG4gICAgY29uc3QgdGFyZ2V0RG9jdW1lbnRzU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShEYlRhcmdldERvY3VtZW50U3RvcmUsIHtcbiAgICAgICAga2V5UGF0aDogRGJUYXJnZXREb2N1bWVudEtleVBhdGhcbiAgICB9KTtcbiAgICB0YXJnZXREb2N1bWVudHNTdG9yZS5jcmVhdGVJbmRleChEYlRhcmdldERvY3VtZW50RG9jdW1lbnRUYXJnZXRzSW5kZXgsIERiVGFyZ2V0RG9jdW1lbnREb2N1bWVudFRhcmdldHNLZXlQYXRoLCB7IHVuaXF1ZTogdHJ1ZSB9KTtcbiAgICBjb25zdCB0YXJnZXRTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiVGFyZ2V0U3RvcmUsIHtcbiAgICAgICAga2V5UGF0aDogRGJUYXJnZXRLZXlQYXRoXG4gICAgfSk7XG4gICAgLy8gTk9URTogVGhpcyBpcyB1bmlxdWUgb25seSBiZWNhdXNlIHRoZSBUYXJnZXRJZCBpcyB0aGUgc3VmZml4LlxuICAgIHRhcmdldFN0b3JlLmNyZWF0ZUluZGV4KERiVGFyZ2V0UXVlcnlUYXJnZXRzSW5kZXhOYW1lLCBEYlRhcmdldFF1ZXJ5VGFyZ2V0c0tleVBhdGgsIHsgdW5pcXVlOiB0cnVlIH0pO1xuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiVGFyZ2V0R2xvYmFsU3RvcmUpO1xufVxuZnVuY3Rpb24gZHJvcFF1ZXJ5Q2FjaGUoZGIpIHtcbiAgICBkYi5kZWxldGVPYmplY3RTdG9yZShEYlRhcmdldERvY3VtZW50U3RvcmUpO1xuICAgIGRiLmRlbGV0ZU9iamVjdFN0b3JlKERiVGFyZ2V0U3RvcmUpO1xuICAgIGRiLmRlbGV0ZU9iamVjdFN0b3JlKERiVGFyZ2V0R2xvYmFsU3RvcmUpO1xufVxuZnVuY3Rpb24gZHJvcFJlbW90ZURvY3VtZW50Q2hhbmdlc1N0b3JlKGRiKSB7XG4gICAgaWYgKGRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoJ3JlbW90ZURvY3VtZW50Q2hhbmdlcycpKSB7XG4gICAgICAgIGRiLmRlbGV0ZU9iamVjdFN0b3JlKCdyZW1vdGVEb2N1bWVudENoYW5nZXMnKTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgdGhlIHRhcmdldCBnbG9iYWwgc2luZ2xldG9uIHJvdy5cbiAqXG4gKiBAcGFyYW0gdHhuIC0gVGhlIHZlcnNpb24gdXBncmFkZSB0cmFuc2FjdGlvbiBmb3IgaW5kZXhlZGRiXG4gKi9cbmZ1bmN0aW9uIHdyaXRlRW1wdHlUYXJnZXRHbG9iYWxFbnRyeSh0eG4pIHtcbiAgICBjb25zdCBnbG9iYWxTdG9yZSA9IHR4bi5zdG9yZShEYlRhcmdldEdsb2JhbFN0b3JlKTtcbiAgICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICAgICAgaGlnaGVzdFRhcmdldElkOiAwLFxuICAgICAgICBoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXI6IDAsXG4gICAgICAgIGxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb246IFNuYXBzaG90VmVyc2lvbi5taW4oKS50b1RpbWVzdGFtcCgpLFxuICAgICAgICB0YXJnZXRDb3VudDogMFxuICAgIH07XG4gICAgcmV0dXJuIGdsb2JhbFN0b3JlLnB1dChEYlRhcmdldEdsb2JhbEtleSwgbWV0YWRhdGEpO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50TWV0YWRhdGFTdG9yZShkYikge1xuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiQ2xpZW50TWV0YWRhdGFTdG9yZSwge1xuICAgICAgICBrZXlQYXRoOiBEYkNsaWVudE1ldGFkYXRhS2V5UGF0aFxuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQnVuZGxlc1N0b3JlKGRiKSB7XG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJCdW5kbGVTdG9yZSwge1xuICAgICAgICBrZXlQYXRoOiBEYkJ1bmRsZUtleVBhdGhcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU5hbWVkUXVlcmllc1N0b3JlKGRiKSB7XG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJOYW1lZFF1ZXJ5U3RvcmUsIHtcbiAgICAgICAga2V5UGF0aDogRGJOYW1lZFF1ZXJ5S2V5UGF0aFxuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRmllbGRJbmRleChkYikge1xuICAgIGNvbnN0IGluZGV4Q29uZmlndXJhdGlvblN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJJbmRleENvbmZpZ3VyYXRpb25TdG9yZSwge1xuICAgICAgICBrZXlQYXRoOiBEYkluZGV4Q29uZmlndXJhdGlvbktleVBhdGgsXG4gICAgICAgIGF1dG9JbmNyZW1lbnQ6IHRydWVcbiAgICB9KTtcbiAgICBpbmRleENvbmZpZ3VyYXRpb25TdG9yZS5jcmVhdGVJbmRleChEYkluZGV4Q29uZmlndXJhdGlvbkNvbGxlY3Rpb25Hcm91cEluZGV4LCBEYkluZGV4Q29uZmlndXJhdGlvbkNvbGxlY3Rpb25Hcm91cEluZGV4UGF0aCwgeyB1bmlxdWU6IGZhbHNlIH0pO1xuICAgIGNvbnN0IGluZGV4U3RhdGVTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiSW5kZXhTdGF0ZVN0b3JlLCB7XG4gICAgICAgIGtleVBhdGg6IERiSW5kZXhTdGF0ZUtleVBhdGhcbiAgICB9KTtcbiAgICBpbmRleFN0YXRlU3RvcmUuY3JlYXRlSW5kZXgoRGJJbmRleFN0YXRlU2VxdWVuY2VOdW1iZXJJbmRleCwgRGJJbmRleFN0YXRlU2VxdWVuY2VOdW1iZXJJbmRleFBhdGgsIHsgdW5pcXVlOiBmYWxzZSB9KTtcbiAgICBjb25zdCBpbmRleEVudHJ5U3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShEYkluZGV4RW50cnlTdG9yZSwge1xuICAgICAgICBrZXlQYXRoOiBEYkluZGV4RW50cnlLZXlQYXRoXG4gICAgfSk7XG4gICAgaW5kZXhFbnRyeVN0b3JlLmNyZWF0ZUluZGV4KERiSW5kZXhFbnRyeURvY3VtZW50S2V5SW5kZXgsIERiSW5kZXhFbnRyeURvY3VtZW50S2V5SW5kZXhQYXRoLCB7IHVuaXF1ZTogZmFsc2UgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVEb2N1bWVudE92ZXJsYXlTdG9yZShkYikge1xuICAgIGNvbnN0IGRvY3VtZW50T3ZlcmxheVN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJEb2N1bWVudE92ZXJsYXlTdG9yZSwge1xuICAgICAgICBrZXlQYXRoOiBEYkRvY3VtZW50T3ZlcmxheUtleVBhdGhcbiAgICB9KTtcbiAgICBkb2N1bWVudE92ZXJsYXlTdG9yZS5jcmVhdGVJbmRleChEYkRvY3VtZW50T3ZlcmxheUNvbGxlY3Rpb25QYXRoT3ZlcmxheUluZGV4LCBEYkRvY3VtZW50T3ZlcmxheUNvbGxlY3Rpb25QYXRoT3ZlcmxheUluZGV4UGF0aCwgeyB1bmlxdWU6IGZhbHNlIH0pO1xuICAgIGRvY3VtZW50T3ZlcmxheVN0b3JlLmNyZWF0ZUluZGV4KERiRG9jdW1lbnRPdmVybGF5Q29sbGVjdGlvbkdyb3VwT3ZlcmxheUluZGV4LCBEYkRvY3VtZW50T3ZlcmxheUNvbGxlY3Rpb25Hcm91cE92ZXJsYXlJbmRleFBhdGgsIHsgdW5pcXVlOiBmYWxzZSB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUdsb2JhbHNTdG9yZShkYikge1xuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiR2xvYmFsc1N0b3JlLCB7XG4gICAgICAgIGtleVBhdGg6IERiR2xvYmFsc0tleVBhdGhcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RLZXkocmVtb3RlRG9jKSB7XG4gICAgaWYgKHJlbW90ZURvYy5kb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50S2V5KFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKHJlbW90ZURvYy5kb2N1bWVudC5uYW1lKS5wb3BGaXJzdCg1KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlbW90ZURvYy5ub0RvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiBEb2N1bWVudEtleS5mcm9tU2VnbWVudHMocmVtb3RlRG9jLm5vRG9jdW1lbnQucGF0aCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlbW90ZURvYy51bmtub3duRG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIERvY3VtZW50S2V5LmZyb21TZWdtZW50cyhyZW1vdGVEb2MudW5rbm93bkRvY3VtZW50LnBhdGgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBMT0dfVEFHJGMgPSAnSW5kZXhlZERiUGVyc2lzdGVuY2UnO1xuLyoqXG4gKiBPbGRlc3QgYWNjZXB0YWJsZSBhZ2UgaW4gbWlsbGlzZWNvbmRzIGZvciBjbGllbnQgbWV0YWRhdGEgYmVmb3JlIHRoZSBjbGllbnRcbiAqIGlzIGNvbnNpZGVyZWQgaW5hY3RpdmUgYW5kIGl0cyBhc3NvY2lhdGVkIGRhdGEgaXMgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gKi9cbmNvbnN0IE1BWF9DTElFTlRfQUdFX01TID0gMzAgKiA2MCAqIDEwMDA7IC8vIDMwIG1pbnV0ZXNcbi8qKlxuICogT2xkZXN0IGFjY2VwdGFibGUgbWV0YWRhdGEgYWdlIGZvciBjbGllbnRzIHRoYXQgbWF5IHBhcnRpY2lwYXRlIGluIHRoZVxuICogcHJpbWFyeSBsZWFzZSBlbGVjdGlvbi4gQ2xpZW50cyB0aGF0IGhhdmUgbm90IHVwZGF0ZWQgdGhlaXIgY2xpZW50IG1ldGFkYXRhXG4gKiB3aXRoaW4gNSBzZWNvbmRzIGFyZSBub3QgZWxpZ2libGUgdG8gcmVjZWl2ZSBhIHByaW1hcnkgbGVhc2UuXG4gKi9cbmNvbnN0IE1BWF9QUklNQVJZX0VMSUdJQkxFX0FHRV9NUyA9IDUwMDA7XG4vKipcbiAqIFRoZSBpbnRlcnZhbCBhdCB3aGljaCBjbGllbnRzIHdpbGwgdXBkYXRlIHRoZWlyIG1ldGFkYXRhLCBpbmNsdWRpbmdcbiAqIHJlZnJlc2hpbmcgdGhlaXIgcHJpbWFyeSBsZWFzZSBpZiBoZWxkIG9yIHBvdGVudGlhbGx5IHRyeWluZyB0byBhY3F1aXJlIGl0IGlmXG4gKiBub3QgaGVsZC5cbiAqXG4gKiBQcmltYXJ5IGNsaWVudHMgbWF5IG9wcG9ydHVuaXN0aWNhbGx5IHJlZnJlc2ggdGhlaXIgbWV0YWRhdGEgZWFybGllclxuICogaWYgdGhleSdyZSBhbHJlYWR5IHBlcmZvcm1pbmcgYW4gSW5kZXhlZERCIG9wZXJhdGlvbi5cbiAqL1xuY29uc3QgQ0xJRU5UX01FVEFEQVRBX1JFRlJFU0hfSU5URVJWQUxfTVMgPSA0MDAwO1xuLyoqIFVzZXItZmFjaW5nIGVycm9yIHdoZW4gdGhlIHByaW1hcnkgbGVhc2UgaXMgcmVxdWlyZWQgYnV0IG5vdCBhdmFpbGFibGUuICovXG5jb25zdCBQUklNQVJZX0xFQVNFX0VYQ0xVU0lWRV9FUlJPUl9NU0cgPSAnRmFpbGVkIHRvIG9idGFpbiBleGNsdXNpdmUgYWNjZXNzIHRvIHRoZSBwZXJzaXN0ZW5jZSBsYXllci4gVG8gYWxsb3cgJyArXG4gICAgJ3NoYXJlZCBhY2Nlc3MsIG11bHRpLXRhYiBzeW5jaHJvbml6YXRpb24gaGFzIHRvIGJlIGVuYWJsZWQgaW4gYWxsIHRhYnMuICcgK1xuICAgICdJZiB5b3UgYXJlIHVzaW5nIGBleHBlcmltZW50YWxGb3JjZU93bmluZ1RhYjp0cnVlYCwgbWFrZSBzdXJlIHRoYXQgb25seSAnICtcbiAgICAnb25lIHRhYiBoYXMgcGVyc2lzdGVuY2UgZW5hYmxlZCBhdCBhbnkgZ2l2ZW4gdGltZS4nO1xuY29uc3QgVU5TVVBQT1JURURfUExBVEZPUk1fRVJST1JfTVNHID0gJ1RoaXMgcGxhdGZvcm0gaXMgZWl0aGVyIG1pc3NpbmcgSW5kZXhlZERCIG9yIGlzIGtub3duIHRvIGhhdmUgJyArXG4gICAgJ2FuIGluY29tcGxldGUgaW1wbGVtZW50YXRpb24uIE9mZmxpbmUgcGVyc2lzdGVuY2UgaGFzIGJlZW4gZGlzYWJsZWQuJztcbi8vIFRoZSBmb3JtYXQgb2YgdGhlIExvY2FsU3RvcmFnZSBrZXkgdGhhdCBzdG9yZXMgem9tYmllZCBjbGllbnQgaXM6XG4vLyAgICAgZmlyZXN0b3JlX3pvbWJpZV88cGVyc2lzdGVuY2VfcHJlZml4Pl88aW5zdGFuY2Vfa2V5PlxuY29uc3QgWk9NQklFRF9DTElFTlRTX0tFWV9QUkVGSVggPSAnZmlyZXN0b3JlX3pvbWJpZSc7XG4vKipcbiAqIFRoZSBuYW1lIG9mIHRoZSBtYWluIChhbmQgY3VycmVudGx5IG9ubHkpIEluZGV4ZWREQiBkYXRhYmFzZS4gVGhpcyBuYW1lIGlzXG4gKiBhcHBlbmRlZCB0byB0aGUgcHJlZml4IHByb3ZpZGVkIHRvIHRoZSBJbmRleGVkRGJQZXJzaXN0ZW5jZSBjb25zdHJ1Y3Rvci5cbiAqL1xuY29uc3QgTUFJTl9EQVRBQkFTRSA9ICdtYWluJztcbi8qKlxuICogQW4gSW5kZXhlZERCLWJhY2tlZCBpbnN0YW5jZSBvZiBQZXJzaXN0ZW5jZS4gRGF0YSBpcyBzdG9yZWQgcGVyc2lzdGVudGx5XG4gKiBhY3Jvc3Mgc2Vzc2lvbnMuXG4gKlxuICogT24gV2ViIG9ubHksIHRoZSBGaXJlc3RvcmUgU0RLcyBzdXBwb3J0IHNoYXJlZCBhY2Nlc3MgdG8gaXRzIHBlcnNpc3RlbmNlXG4gKiBsYXllci4gVGhpcyBhbGxvd3MgbXVsdGlwbGUgYnJvd3NlciB0YWJzIHRvIHJlYWQgYW5kIHdyaXRlIHRvIEluZGV4ZWREYiBhbmRcbiAqIHRvIHN5bmNocm9uaXplIHN0YXRlIGV2ZW4gd2l0aG91dCBuZXR3b3JrIGNvbm5lY3Rpdml0eS4gU2hhcmVkIGFjY2VzcyBpc1xuICogY3VycmVudGx5IG9wdGlvbmFsIGFuZCBub3QgZW5hYmxlZCB1bmxlc3MgYWxsIGNsaWVudHMgaW52b2tlXG4gKiBgZW5hYmxlUGVyc2lzdGVuY2UoKWAgd2l0aCBge3N5bmNocm9uaXplVGFiczp0cnVlfWAuXG4gKlxuICogSW4gbXVsdGktdGFiIG1vZGUsIGlmIG11bHRpcGxlIGNsaWVudHMgYXJlIGFjdGl2ZSBhdCB0aGUgc2FtZSB0aW1lLCB0aGUgU0RLXG4gKiB3aWxsIGRlc2lnbmF0ZSBvbmUgY2xpZW50IGFzIHRoZSDigJxwcmltYXJ5IGNsaWVudOKAnS4gQW4gZWZmb3J0IGlzIG1hZGUgdG8gcGlja1xuICogYSB2aXNpYmxlLCBuZXR3b3JrLWNvbm5lY3RlZCBhbmQgYWN0aXZlIGNsaWVudCwgYW5kIHRoaXMgY2xpZW50IGlzXG4gKiByZXNwb25zaWJsZSBmb3IgbGV0dGluZyBvdGhlciBjbGllbnRzIGtub3cgYWJvdXQgaXRzIHByZXNlbmNlLiBUaGUgcHJpbWFyeVxuICogY2xpZW50IHdyaXRlcyBhIHVuaXF1ZSBjbGllbnQtZ2VuZXJhdGVkIGlkZW50aWZpZXIgKHRoZSBjbGllbnQgSUQpIHRvXG4gKiBJbmRleGVkRGLigJlzIOKAnG93bmVy4oCdIHN0b3JlIGV2ZXJ5IDQgc2Vjb25kcy4gSWYgdGhlIHByaW1hcnkgY2xpZW50IGZhaWxzIHRvXG4gKiB1cGRhdGUgdGhpcyBlbnRyeSwgYW5vdGhlciBjbGllbnQgY2FuIGFjcXVpcmUgdGhlIGxlYXNlIGFuZCB0YWtlIG92ZXIgYXNcbiAqIHByaW1hcnkuXG4gKlxuICogU29tZSBwZXJzaXN0ZW5jZSBvcGVyYXRpb25zIGluIHRoZSBTREsgYXJlIGRlc2lnbmF0ZWQgYXMgcHJpbWFyeS1jbGllbnQgb25seVxuICogb3BlcmF0aW9ucy4gVGhpcyBpbmNsdWRlcyB0aGUgYWNrbm93bGVkZ21lbnQgb2YgbXV0YXRpb25zIGFuZCBhbGwgdXBkYXRlcyBvZlxuICogcmVtb3RlIGRvY3VtZW50cy4gVGhlIGVmZmVjdHMgb2YgdGhlc2Ugb3BlcmF0aW9ucyBhcmUgd3JpdHRlbiB0byBwZXJzaXN0ZW5jZVxuICogYW5kIHRoZW4gYnJvYWRjYXN0IHRvIG90aGVyIHRhYnMgdmlhIExvY2FsU3RvcmFnZSAoc2VlXG4gKiBgV2ViU3RvcmFnZVNoYXJlZENsaWVudFN0YXRlYCksIHdoaWNoIHRoZW4gcmVmcmVzaCB0aGVpciBzdGF0ZSBmcm9tXG4gKiBwZXJzaXN0ZW5jZS5cbiAqXG4gKiBTaW1pbGFybHksIHRoZSBwcmltYXJ5IGNsaWVudCBsaXN0ZW5zIHRvIG5vdGlmaWNhdGlvbnMgc2VudCBieSBzZWNvbmRhcnlcbiAqIGNsaWVudHMgdG8gZGlzY292ZXIgcGVyc2lzdGVuY2UgY2hhbmdlcyB3cml0dGVuIGJ5IHNlY29uZGFyeSBjbGllbnRzLCBzdWNoIGFzXG4gKiB0aGUgYWRkaXRpb24gb2YgbmV3IG11dGF0aW9ucyBhbmQgcXVlcnkgdGFyZ2V0cy5cbiAqXG4gKiBJZiBtdWx0aS10YWIgaXMgbm90IGVuYWJsZWQgYW5kIGFub3RoZXIgdGFiIGFscmVhZHkgb2J0YWluZWQgdGhlIHByaW1hcnlcbiAqIGxlYXNlLCBJbmRleGVkRGJQZXJzaXN0ZW5jZSBlbnRlcnMgYSBmYWlsZWQgc3RhdGUgYW5kIGFsbCBzdWJzZXF1ZW50XG4gKiBvcGVyYXRpb25zIHdpbGwgYXV0b21hdGljYWxseSBmYWlsLlxuICpcbiAqIEFkZGl0aW9uYWxseSwgdGhlcmUgaXMgYW4gb3B0aW1pemF0aW9uIHNvIHRoYXQgd2hlbiBhIHRhYiBpcyBjbG9zZWQsIHRoZVxuICogcHJpbWFyeSBsZWFzZSBpcyByZWxlYXNlZCBpbW1lZGlhdGVseSAodGhpcyBpcyBlc3BlY2lhbGx5IGltcG9ydGFudCB0byBtYWtlXG4gKiBzdXJlIHRoYXQgYSByZWZyZXNoZWQgdGFiIGlzIGFibGUgdG8gaW1tZWRpYXRlbHkgcmUtYWNxdWlyZSB0aGUgcHJpbWFyeVxuICogbGVhc2UpLiBVbmZvcnR1bmF0ZWx5LCBJbmRleGVkREIgY2Fubm90IGJlIHJlbGlhYmx5IHVzZWQgaW4gd2luZG93LnVubG9hZFxuICogc2luY2UgaXQgaXMgYW4gYXN5bmNocm9ub3VzIEFQSS4gU28gaW4gYWRkaXRpb24gdG8gYXR0ZW1wdGluZyB0byBnaXZlIHVwIHRoZVxuICogbGVhc2UsIHRoZSBsZWFzZWhvbGRlciB3cml0ZXMgaXRzIGNsaWVudCBJRCB0byBhIFwiem9tYmllZENsaWVudFwiIGVudHJ5IGluXG4gKiBMb2NhbFN0b3JhZ2Ugd2hpY2ggYWN0cyBhcyBhbiBpbmRpY2F0b3IgdGhhdCBhbm90aGVyIHRhYiBzaG91bGQgZ28gYWhlYWQgYW5kXG4gKiB0YWtlIHRoZSBwcmltYXJ5IGxlYXNlIGltbWVkaWF0ZWx5IHJlZ2FyZGxlc3Mgb2YgdGhlIGN1cnJlbnQgbGVhc2UgdGltZXN0YW1wLlxuICpcbiAqIFRPRE8oYi8xMTQyMjYyMzQpOiBSZW1vdmUgYHN5bmNocm9uaXplVGFic2Agc2VjdGlvbiB3aGVuIG11bHRpLXRhYiBpcyBub1xuICogbG9uZ2VyIG9wdGlvbmFsLlxuICovXG5jbGFzcyBJbmRleGVkRGJQZXJzaXN0ZW5jZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBzeW5jaHJvbml6ZSB0aGUgaW4tbWVtb3J5IHN0YXRlIG9mIG11bHRpcGxlIHRhYnMgYW5kIHNoYXJlXG4gICAgICogYWNjZXNzIHRvIGxvY2FsIHBlcnNpc3RlbmNlLlxuICAgICAqL1xuICAgIGFsbG93VGFiU3luY2hyb25pemF0aW9uLCBwZXJzaXN0ZW5jZUtleSwgY2xpZW50SWQsIGxydVBhcmFtcywgcXVldWUsIHdpbmRvdywgZG9jdW1lbnQsIHNlcmlhbGl6ZXIsIHNlcXVlbmNlTnVtYmVyU3luY2VyLCBcbiAgICAvKipcbiAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgZm9yY2VmdWxseSBvYnRhaW5zIGRhdGFiYXNlIGFjY2Vzcy4gRXhpc3RpbmcgdGFicyB3aWxsXG4gICAgICogbm8gbG9uZ2VyIGJlIGFibGUgdG8gYWNjZXNzIEluZGV4ZWREQi5cbiAgICAgKi9cbiAgICBmb3JjZU93bmluZ1RhYiwgc2NoZW1hVmVyc2lvbiA9IFNDSEVNQV9WRVJTSU9OKSB7XG4gICAgICAgIHRoaXMuYWxsb3dUYWJTeW5jaHJvbml6YXRpb24gPSBhbGxvd1RhYlN5bmNocm9uaXphdGlvbjtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZUtleSA9IHBlcnNpc3RlbmNlS2V5O1xuICAgICAgICB0aGlzLmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgICAgIHRoaXMucXVldWUgPSBxdWV1ZTtcbiAgICAgICAgdGhpcy53aW5kb3cgPSB3aW5kb3c7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgdGhpcy5zZXF1ZW5jZU51bWJlclN5bmNlciA9IHNlcXVlbmNlTnVtYmVyU3luY2VyO1xuICAgICAgICB0aGlzLmZvcmNlT3duaW5nVGFiID0gZm9yY2VPd25pbmdUYWI7XG4gICAgICAgIHRoaXMuc2NoZW1hVmVyc2lvbiA9IHNjaGVtYVZlcnNpb247XG4gICAgICAgIHRoaXMubGlzdGVuU2VxdWVuY2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNQcmltYXJ5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMubmV0d29ya0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICAvKiogT3VyIHdpbmRvdy51bmxvYWQgaGFuZGxlciwgaWYgcmVnaXN0ZXJlZC4gKi9cbiAgICAgICAgdGhpcy53aW5kb3dVbmxvYWRIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbkZvcmVncm91bmQgPSBmYWxzZTtcbiAgICAgICAgLyoqIE91ciAndmlzaWJpbGl0eWNoYW5nZScgbGlzdGVuZXIgaWYgcmVnaXN0ZXJlZC4gKi9cbiAgICAgICAgdGhpcy5kb2N1bWVudFZpc2liaWxpdHlIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgLyoqIFRoZSBjbGllbnQgbWV0YWRhdGEgcmVmcmVzaCB0YXNrLiAqL1xuICAgICAgICB0aGlzLmNsaWVudE1ldGFkYXRhUmVmcmVzaGVyID0gbnVsbDtcbiAgICAgICAgLyoqIFRoZSBsYXN0IHRpbWUgd2UgZ2FyYmFnZSBjb2xsZWN0ZWQgdGhlIGNsaWVudCBtZXRhZGF0YSBvYmplY3Qgc3RvcmUuICovXG4gICAgICAgIHRoaXMubGFzdEdhcmJhZ2VDb2xsZWN0aW9uVGltZSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICAgICAgLyoqIEEgbGlzdGVuZXIgdG8gbm90aWZ5IG9uIHByaW1hcnkgc3RhdGUgY2hhbmdlcy4gKi9cbiAgICAgICAgdGhpcy5wcmltYXJ5U3RhdGVMaXN0ZW5lciA9IF8gPT4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIGlmICghSW5kZXhlZERiUGVyc2lzdGVuY2UuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5JTVBMRU1FTlRFRCwgVU5TVVBQT1JURURfUExBVEZPUk1fRVJST1JfTVNHKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZmVyZW5jZURlbGVnYXRlID0gbmV3IEluZGV4ZWREYkxydURlbGVnYXRlSW1wbCh0aGlzLCBscnVQYXJhbXMpO1xuICAgICAgICB0aGlzLmRiTmFtZSA9IHBlcnNpc3RlbmNlS2V5ICsgTUFJTl9EQVRBQkFTRTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gbmV3IExvY2FsU2VyaWFsaXplcihzZXJpYWxpemVyKTtcbiAgICAgICAgdGhpcy5zaW1wbGVEYiA9IG5ldyBTaW1wbGVEYih0aGlzLmRiTmFtZSwgdGhpcy5zY2hlbWFWZXJzaW9uLCBuZXcgU2NoZW1hQ29udmVydGVyKHRoaXMuc2VyaWFsaXplcikpO1xuICAgICAgICB0aGlzLmdsb2JhbHNDYWNoZSA9IG5ldyBJbmRleGVkRGJHbG9iYWxzQ2FjaGUoKTtcbiAgICAgICAgdGhpcy50YXJnZXRDYWNoZSA9IG5ldyBJbmRleGVkRGJUYXJnZXRDYWNoZSh0aGlzLnJlZmVyZW5jZURlbGVnYXRlLCB0aGlzLnNlcmlhbGl6ZXIpO1xuICAgICAgICB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGUgPSBuZXdJbmRleGVkRGJSZW1vdGVEb2N1bWVudENhY2hlKHRoaXMuc2VyaWFsaXplcik7XG4gICAgICAgIHRoaXMuYnVuZGxlQ2FjaGUgPSBuZXcgSW5kZXhlZERiQnVuZGxlQ2FjaGUoKTtcbiAgICAgICAgaWYgKHRoaXMud2luZG93ICYmIHRoaXMud2luZG93LmxvY2FsU3RvcmFnZSkge1xuICAgICAgICAgICAgdGhpcy53ZWJTdG9yYWdlID0gdGhpcy53aW5kb3cubG9jYWxTdG9yYWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53ZWJTdG9yYWdlID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChmb3JjZU93bmluZ1RhYiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBsb2dFcnJvcihMT0dfVEFHJGMsICdMb2NhbFN0b3JhZ2UgaXMgdW5hdmFpbGFibGUuIEFzIGEgcmVzdWx0LCBwZXJzaXN0ZW5jZSBtYXkgbm90IHdvcmsgJyArXG4gICAgICAgICAgICAgICAgICAgICdyZWxpYWJseS4gSW4gcGFydGljdWxhciBlbmFibGVQZXJzaXN0ZW5jZSgpIGNvdWxkIGZhaWwgaW1tZWRpYXRlbHkgJyArXG4gICAgICAgICAgICAgICAgICAgICdhZnRlciByZWZyZXNoaW5nIHRoZSBwYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHQgdG8gc3RhcnQgSW5kZXhlZERiIHBlcnNpc3RlbmNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgV2hldGhlciBwZXJzaXN0ZW5jZSB3YXMgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBzdGFydCgpIHtcbiAgICAgICAgLy8gTk9URTogVGhpcyBpcyBleHBlY3RlZCB0byBmYWlsIHNvbWV0aW1lcyAoaW4gdGhlIGNhc2Ugb2YgYW5vdGhlciB0YWJcbiAgICAgICAgLy8gYWxyZWFkeSBoYXZpbmcgdGhlIHBlcnNpc3RlbmNlIGxvY2spLCBzbyBpdCdzIHRoZSBmaXJzdCB0aGluZyB3ZSBzaG91bGRcbiAgICAgICAgLy8gZG8uXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUNsaWVudE1ldGFkYXRhQW5kVHJ5QmVjb21lUHJpbWFyeSgpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNQcmltYXJ5ICYmICF0aGlzLmFsbG93VGFiU3luY2hyb25pemF0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gRmFpbCBgc3RhcnQoKWAgaWYgYHN5bmNocm9uaXplVGFic2AgaXMgZGlzYWJsZWQgYW5kIHdlIGNhbm5vdFxuICAgICAgICAgICAgICAgIC8vIG9idGFpbiB0aGUgcHJpbWFyeSBsZWFzZS5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCBQUklNQVJZX0xFQVNFX0VYQ0xVU0lWRV9FUlJPUl9NU0cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hdHRhY2hWaXNpYmlsaXR5SGFuZGxlcigpO1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hXaW5kb3dVbmxvYWRIb29rKCk7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlQ2xpZW50TWV0YWRhdGFBbmRQcmltYXJ5TGVhc2VSZWZyZXNoZXMoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1blRyYW5zYWN0aW9uKCdnZXRIaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXInLCAncmVhZG9ubHknLCB0eG4gPT4gdGhpcy50YXJnZXRDYWNoZS5nZXRIaWdoZXN0U2VxdWVuY2VOdW1iZXIodHhuKSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIgPT4ge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5TZXF1ZW5jZSA9IG5ldyBMaXN0ZW5TZXF1ZW5jZShoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIsIHRoaXMuc2VxdWVuY2VOdW1iZXJTeW5jZXIpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2ltcGxlRGIgJiYgdGhpcy5zaW1wbGVEYi5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciB0aGF0IGdldHMgY2FsbGVkIHdoZW4gdGhlIHByaW1hcnkgc3RhdGUgb2YgdGhlXG4gICAgICogaW5zdGFuY2UgY2hhbmdlcy4gVXBvbiByZWdpc3RlcmluZywgdGhpcyBsaXN0ZW5lciBpcyBpbnZva2VkIGltbWVkaWF0ZWx5XG4gICAgICogd2l0aCB0aGUgY3VycmVudCBwcmltYXJ5IHN0YXRlLlxuICAgICAqXG4gICAgICogUE9SVElORyBOT1RFOiBUaGlzIGlzIG9ubHkgdXNlZCBmb3IgV2ViIG11bHRpLXRhYi5cbiAgICAgKi9cbiAgICBzZXRQcmltYXJ5U3RhdGVMaXN0ZW5lcihwcmltYXJ5U3RhdGVMaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnByaW1hcnlTdGF0ZUxpc3RlbmVyID0gYXN5bmMgKHByaW1hcnlTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmltYXJ5U3RhdGVMaXN0ZW5lcihwcmltYXJ5U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcHJpbWFyeVN0YXRlTGlzdGVuZXIodGhpcy5pc1ByaW1hcnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciB0aGF0IGdldHMgY2FsbGVkIHdoZW4gdGhlIGRhdGFiYXNlIHJlY2VpdmVzIGFcbiAgICAgKiB2ZXJzaW9uIGNoYW5nZSBldmVudCBpbmRpY2F0aW5nIHRoYXQgaXQgaGFzIGRlbGV0ZWQuXG4gICAgICpcbiAgICAgKiBQT1JUSU5HIE5PVEU6IFRoaXMgaXMgb25seSB1c2VkIGZvciBXZWIgbXVsdGktdGFiLlxuICAgICAqL1xuICAgIHNldERhdGFiYXNlRGVsZXRlZExpc3RlbmVyKGRhdGFiYXNlRGVsZXRlZExpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc2ltcGxlRGIuc2V0VmVyc2lvbkNoYW5nZUxpc3RlbmVyKGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYW4gYXR0ZW1wdCBpcyBtYWRlIHRvIGRlbGV0ZSBJbmRleGVkREIuXG4gICAgICAgICAgICBpZiAoZXZlbnQubmV3VmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGRhdGFiYXNlRGVsZXRlZExpc3RlbmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGp1c3RzIHRoZSBjdXJyZW50IG5ldHdvcmsgc3RhdGUgaW4gdGhlIGNsaWVudCdzIG1ldGFkYXRhLCBwb3RlbnRpYWxseVxuICAgICAqIGFmZmVjdGluZyB0aGUgcHJpbWFyeSBsZWFzZS5cbiAgICAgKlxuICAgICAqIFBPUlRJTkcgTk9URTogVGhpcyBpcyBvbmx5IHVzZWQgZm9yIFdlYiBtdWx0aS10YWIuXG4gICAgICovXG4gICAgc2V0TmV0d29ya0VuYWJsZWQobmV0d29ya0VuYWJsZWQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV0d29ya0VuYWJsZWQgIT09IG5ldHdvcmtFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLm5ldHdvcmtFbmFibGVkID0gbmV0d29ya0VuYWJsZWQ7XG4gICAgICAgICAgICAvLyBTY2hlZHVsZSBhIHByaW1hcnkgbGVhc2UgcmVmcmVzaCBmb3IgaW1tZWRpYXRlIGV4ZWN1dGlvbi4gVGhlIGV2ZW50dWFsXG4gICAgICAgICAgICAvLyBsZWFzZSB1cGRhdGUgd2lsbCBiZSBwcm9wYWdhdGVkIHZpYSBgcHJpbWFyeVN0YXRlTGlzdGVuZXJgLlxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudXBkYXRlQ2xpZW50TWV0YWRhdGFBbmRUcnlCZWNvbWVQcmltYXJ5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY2xpZW50IG1ldGFkYXRhIGluIEluZGV4ZWREYiBhbmQgYXR0ZW1wdHMgdG8gZWl0aGVyIG9idGFpbiBvclxuICAgICAqIGV4dGVuZCB0aGUgcHJpbWFyeSBsZWFzZSBmb3IgdGhlIGxvY2FsIGNsaWVudC4gQXN5bmNocm9ub3VzbHkgbm90aWZpZXMgdGhlXG4gICAgICogcHJpbWFyeSBzdGF0ZSBsaXN0ZW5lciBpZiB0aGUgY2xpZW50IGVpdGhlciBuZXdseSBvYnRhaW5lZCBvciByZWxlYXNlZCBpdHNcbiAgICAgKiBwcmltYXJ5IGxlYXNlLlxuICAgICAqL1xuICAgIHVwZGF0ZUNsaWVudE1ldGFkYXRhQW5kVHJ5QmVjb21lUHJpbWFyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnVuVHJhbnNhY3Rpb24oJ3VwZGF0ZUNsaWVudE1ldGFkYXRhQW5kVHJ5QmVjb21lUHJpbWFyeScsICdyZWFkd3JpdGUnLCB0eG4gPT4ge1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGFTdG9yZSA9IGNsaWVudE1ldGFkYXRhU3RvcmUodHhuKTtcbiAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YVN0b3JlXG4gICAgICAgICAgICAgICAgLnB1dCh7XG4gICAgICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgdXBkYXRlVGltZU1zOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICAgIG5ldHdvcmtFbmFibGVkOiB0aGlzLm5ldHdvcmtFbmFibGVkLFxuICAgICAgICAgICAgICAgIGluRm9yZWdyb3VuZDogdGhpcy5pbkZvcmVncm91bmRcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUHJpbWFyeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJpZnlQcmltYXJ5TGVhc2UodHhuKS5uZXh0KHN1Y2Nlc3MgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1ByaW1hcnkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmVucXVldWVSZXRyeWFibGUoKCkgPT4gdGhpcy5wcmltYXJ5U3RhdGVMaXN0ZW5lcihmYWxzZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IHRoaXMuY2FuQWN0QXNQcmltYXJ5KHR4bikpXG4gICAgICAgICAgICAgICAgLm5leHQoY2FuQWN0QXNQcmltYXJ5ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1ByaW1hcnkgJiYgIWNhbkFjdEFzUHJpbWFyeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWxlYXNlUHJpbWFyeUxlYXNlSWZIZWxkKHR4bikubmV4dCgoKSA9PiBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNhbkFjdEFzUHJpbWFyeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3F1aXJlT3JFeHRlbmRQcmltYXJ5TGVhc2UodHhuKS5uZXh0KCgpID0+IHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC8qIGNhbkFjdEFzUHJpbWFyeT0gKi8gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGUpKSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRjLCAnRmFpbGVkIHRvIGV4dGVuZCBvd25lciBsZWFzZTogJywgZSk7XG4gICAgICAgICAgICAgICAgLy8gUHJvY2VlZCB3aXRoIHRoZSBleGlzdGluZyBzdGF0ZS4gQW55IHN1YnNlcXVlbnQgYWNjZXNzIHRvXG4gICAgICAgICAgICAgICAgLy8gSW5kZXhlZERCIHdpbGwgdmVyaWZ5IHRoZSBsZWFzZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc1ByaW1hcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dUYWJTeW5jaHJvbml6YXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRjLCAnUmVsZWFzaW5nIG93bmVyIGxlYXNlIGFmdGVyIGVycm9yIGR1cmluZyBsZWFzZSByZWZyZXNoJywgZSk7XG4gICAgICAgICAgICByZXR1cm4gLyogaXNQcmltYXJ5PSAqLyBmYWxzZTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGlzUHJpbWFyeSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1ByaW1hcnkgIT09IGlzUHJpbWFyeSkge1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZW5xdWV1ZVJldHJ5YWJsZSgoKSA9PiB0aGlzLnByaW1hcnlTdGF0ZUxpc3RlbmVyKGlzUHJpbWFyeSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pc1ByaW1hcnkgPSBpc1ByaW1hcnk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2ZXJpZnlQcmltYXJ5TGVhc2UodHhuKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gcHJpbWFyeUNsaWVudFN0b3JlKHR4bik7XG4gICAgICAgIHJldHVybiBzdG9yZS5nZXQoRGJQcmltYXJ5Q2xpZW50S2V5KS5uZXh0KHByaW1hcnlDbGllbnQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMuaXNMb2NhbENsaWVudChwcmltYXJ5Q2xpZW50KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVDbGllbnRNZXRhZGF0YSh0eG4pIHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGFTdG9yZSA9IGNsaWVudE1ldGFkYXRhU3RvcmUodHhuKTtcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhU3RvcmUuZGVsZXRlKHRoaXMuY2xpZW50SWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZ2FyYmFnZSBjb2xsZWN0aW9uIHRocmVzaG9sZCBoYXMgcGFzc2VkLCBwcnVuZXMgdGhlXG4gICAgICogUmVtb3RlRG9jdW1lbnRDaGFuZ2VzIGFuZCB0aGUgQ2xpZW50TWV0YWRhdGEgc3RvcmUgYmFzZWQgb24gdGhlIGxhc3QgdXBkYXRlXG4gICAgICogdGltZSBvZiBhbGwgY2xpZW50cy5cbiAgICAgKi9cbiAgICBhc3luYyBtYXliZUdhcmJhZ2VDb2xsZWN0TXVsdGlDbGllbnRTdGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNQcmltYXJ5ICYmXG4gICAgICAgICAgICAhdGhpcy5pc1dpdGhpbkFnZSh0aGlzLmxhc3RHYXJiYWdlQ29sbGVjdGlvblRpbWUsIE1BWF9DTElFTlRfQUdFX01TKSkge1xuICAgICAgICAgICAgdGhpcy5sYXN0R2FyYmFnZUNvbGxlY3Rpb25UaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGNvbnN0IGluYWN0aXZlQ2xpZW50cyA9IGF3YWl0IHRoaXMucnVuVHJhbnNhY3Rpb24oJ21heWJlR2FyYmFnZUNvbGxlY3RNdWx0aUNsaWVudFN0YXRlJywgJ3JlYWR3cml0ZS1wcmltYXJ5JywgdHhuID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YVN0b3JlID0gZ2V0U3RvcmUodHhuLCBEYkNsaWVudE1ldGFkYXRhU3RvcmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YVN0b3JlLmxvYWRBbGwoKS5uZXh0KGV4aXN0aW5nQ2xpZW50cyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuZmlsdGVyQWN0aXZlQ2xpZW50cyhleGlzdGluZ0NsaWVudHMsIE1BWF9DTElFTlRfQUdFX01TKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5hY3RpdmUgPSBleGlzdGluZ0NsaWVudHMuZmlsdGVyKGNsaWVudCA9PiBhY3RpdmUuaW5kZXhPZihjbGllbnQpID09PSAtMSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIERlbGV0ZSBtZXRhZGF0YSBmb3IgY2xpZW50cyB0aGF0IGFyZSBubyBsb25nZXIgY29uc2lkZXJlZCBhY3RpdmUuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChpbmFjdGl2ZSwgKGluYWN0aXZlQ2xpZW50KSA9PiBtZXRhZGF0YVN0b3JlLmRlbGV0ZShpbmFjdGl2ZUNsaWVudC5jbGllbnRJZCkpLm5leHQoKCkgPT4gaW5hY3RpdmUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBwcmltYXJ5IGxlYXNlIHZpb2xhdGlvbnMgb3IgYW55IG90aGVyIHR5cGUgb2YgZXJyb3IuIFRoZSBuZXh0XG4gICAgICAgICAgICAgICAgLy8gcHJpbWFyeSB3aWxsIHJ1biBgbWF5YmVHYXJiYWdlQ29sbGVjdE11bHRpQ2xpZW50U3RhdGUoKWAgYWdhaW4uXG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgdXNlIGBpZ25vcmVJZlByaW1hcnlMZWFzZUxvc3MoKWAgc2luY2Ugd2UgZG9uJ3Qgd2FudCB0byBkZXBlbmRcbiAgICAgICAgICAgICAgICAvLyBvbiBMb2NhbFN0b3JlLlxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gRGVsZXRlIHBvdGVudGlhbCBsZWZ0b3ZlciBlbnRyaWVzIHRoYXQgbWF5IGNvbnRpbnVlIHRvIG1hcmsgdGhlXG4gICAgICAgICAgICAvLyBpbmFjdGl2ZSBjbGllbnRzIGFzIHpvbWJpZWQgaW4gTG9jYWxTdG9yYWdlLlxuICAgICAgICAgICAgLy8gSWRlYWxseSB3ZSdkIGRlbGV0ZSB0aGUgSW5kZXhlZERiIGFuZCBMb2NhbFN0b3JhZ2Ugem9tYmllIGVudHJpZXMgZm9yXG4gICAgICAgICAgICAvLyB0aGUgY2xpZW50IGF0b21pY2FsbHksIGJ1dCB3ZSBjYW4ndC4gU28gd2Ugb3B0IHRvIGRlbGV0ZSB0aGUgSW5kZXhlZERiXG4gICAgICAgICAgICAvLyBlbnRyaWVzIGZpcnN0IHRvIGF2b2lkIHBvdGVudGlhbGx5IHJldml2aW5nIGEgem9tYmllZCBjbGllbnQuXG4gICAgICAgICAgICBpZiAodGhpcy53ZWJTdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpbmFjdGl2ZUNsaWVudCBvZiBpbmFjdGl2ZUNsaWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53ZWJTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy56b21iaWVkQ2xpZW50TG9jYWxTdG9yYWdlS2V5KGluYWN0aXZlQ2xpZW50LmNsaWVudElkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyBhIHJlY3VycmluZyB0aW1lciB0byB1cGRhdGUgdGhlIGNsaWVudCBtZXRhZGF0YSBhbmQgdG8gZWl0aGVyXG4gICAgICogZXh0ZW5kIG9yIGFjcXVpcmUgdGhlIHByaW1hcnkgbGVhc2UgaWYgdGhlIGNsaWVudCBpcyBlbGlnaWJsZS5cbiAgICAgKi9cbiAgICBzY2hlZHVsZUNsaWVudE1ldGFkYXRhQW5kUHJpbWFyeUxlYXNlUmVmcmVzaGVzKCkge1xuICAgICAgICB0aGlzLmNsaWVudE1ldGFkYXRhUmVmcmVzaGVyID0gdGhpcy5xdWV1ZS5lbnF1ZXVlQWZ0ZXJEZWxheShcImNsaWVudF9tZXRhZGF0YV9yZWZyZXNoXCIgLyogVGltZXJJZC5DbGllbnRNZXRhZGF0YVJlZnJlc2ggKi8sIENMSUVOVF9NRVRBREFUQV9SRUZSRVNIX0lOVEVSVkFMX01TLCAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVDbGllbnRNZXRhZGF0YUFuZFRyeUJlY29tZVByaW1hcnkoKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMubWF5YmVHYXJiYWdlQ29sbGVjdE11bHRpQ2xpZW50U3RhdGUoKSlcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLnNjaGVkdWxlQ2xpZW50TWV0YWRhdGFBbmRQcmltYXJ5TGVhc2VSZWZyZXNoZXMoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQ2hlY2tzIHdoZXRoZXIgYGNsaWVudGAgaXMgdGhlIGxvY2FsIGNsaWVudC4gKi9cbiAgICBpc0xvY2FsQ2xpZW50KGNsaWVudCkge1xuICAgICAgICByZXR1cm4gY2xpZW50ID8gY2xpZW50Lm93bmVySWQgPT09IHRoaXMuY2xpZW50SWQgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgdGhlIHN0YXRlIG9mIGFsbCBhY3RpdmUgY2xpZW50cyBhbmQgZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGxvY2FsXG4gICAgICogY2xpZW50IGlzIG9yIGNhbiBhY3QgYXMgdGhlIGhvbGRlciBvZiB0aGUgcHJpbWFyeSBsZWFzZS4gUmV0dXJucyB3aGV0aGVyXG4gICAgICogdGhlIGNsaWVudCBpcyBlbGlnaWJsZSBmb3IgdGhlIGxlYXNlLCBidXQgZG9lcyBub3QgYWN0dWFsbHkgYWNxdWlyZSBpdC5cbiAgICAgKiBNYXkgcmV0dXJuICdmYWxzZScgZXZlbiBpZiB0aGVyZSBpcyBubyBhY3RpdmUgbGVhc2Vob2xkZXIgYW5kIGFub3RoZXJcbiAgICAgKiAoZm9yZWdyb3VuZCkgY2xpZW50IHNob3VsZCBiZWNvbWUgbGVhc2Vob2xkZXIgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBjYW5BY3RBc1ByaW1hcnkodHhuKSB7XG4gICAgICAgIGlmICh0aGlzLmZvcmNlT3duaW5nVGFiKSB7XG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RvcmUgPSBwcmltYXJ5Q2xpZW50U3RvcmUodHhuKTtcbiAgICAgICAgcmV0dXJuIHN0b3JlXG4gICAgICAgICAgICAuZ2V0KERiUHJpbWFyeUNsaWVudEtleSlcbiAgICAgICAgICAgIC5uZXh0KGN1cnJlbnRQcmltYXJ5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMZWFzZUlzVmFsaWQgPSBjdXJyZW50UHJpbWFyeSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuaXNXaXRoaW5BZ2UoY3VycmVudFByaW1hcnkubGVhc2VUaW1lc3RhbXBNcywgTUFYX1BSSU1BUllfRUxJR0lCTEVfQUdFX01TKSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLmlzQ2xpZW50Wm9tYmllZChjdXJyZW50UHJpbWFyeS5vd25lcklkKTtcbiAgICAgICAgICAgIC8vIEEgY2xpZW50IGlzIGVsaWdpYmxlIGZvciB0aGUgcHJpbWFyeSBsZWFzZSBpZjpcbiAgICAgICAgICAgIC8vIC0gaXRzIG5ldHdvcmsgaXMgZW5hYmxlZCBhbmQgdGhlIGNsaWVudCdzIHRhYiBpcyBpbiB0aGUgZm9yZWdyb3VuZC5cbiAgICAgICAgICAgIC8vIC0gaXRzIG5ldHdvcmsgaXMgZW5hYmxlZCBhbmQgbm8gb3RoZXIgY2xpZW50J3MgdGFiIGlzIGluIHRoZVxuICAgICAgICAgICAgLy8gICBmb3JlZ3JvdW5kLlxuICAgICAgICAgICAgLy8gLSBldmVyeSBjbGllbnRzIG5ldHdvcmsgaXMgZGlzYWJsZWQgYW5kIHRoZSBjbGllbnQncyB0YWIgaXMgaW4gdGhlXG4gICAgICAgICAgICAvLyAgIGZvcmVncm91bmQuXG4gICAgICAgICAgICAvLyAtIGV2ZXJ5IGNsaWVudHMgbmV0d29yayBpcyBkaXNhYmxlZCBhbmQgbm8gb3RoZXIgY2xpZW50J3MgdGFiIGlzIGluXG4gICAgICAgICAgICAvLyAgIHRoZSBmb3JlZ3JvdW5kLlxuICAgICAgICAgICAgLy8gLSB0aGUgYGZvcmNlT3duaW5nVGFiYCBzZXR0aW5nIHdhcyBwYXNzZWQgaW4uXG4gICAgICAgICAgICBpZiAoY3VycmVudExlYXNlSXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzTG9jYWxDbGllbnQoY3VycmVudFByaW1hcnkpICYmIHRoaXMubmV0d29ya0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0xvY2FsQ2xpZW50KGN1cnJlbnRQcmltYXJ5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRQcmltYXJ5LmFsbG93VGFiU3luY2hyb25pemF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWlsIHRoZSBgY2FuQWN0QXNQcmltYXJ5YCBjaGVjayBpZiB0aGUgY3VycmVudCBsZWFzZWhvbGRlciBoYXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBvcHRlZCBpbnRvIG11bHRpLXRhYiBzeW5jaHJvbml6YXRpb24uIElmIHRoaXMgaGFwcGVucyBhdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xpZW50IHN0YXJ0dXAsIHdlIHJlamVjdCB0aGUgUHJvbWlzZSByZXR1cm5lZCBieVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYGVuYWJsZVBlcnNpc3RlbmNlKClgIGFuZCB0aGUgdXNlciBjYW4gY29udGludWUgdG8gdXNlIEZpcmVzdG9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCBpbi1tZW1vcnkgcGVyc2lzdGVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGZhaWxzIGR1cmluZyBhIGxlYXNlIHJlZnJlc2gsIHdlIHdpbGwgaW5zdGVhZCBibG9jayB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzeW5jUXVldWUgZnJvbSBleGVjdXRpbmcgZnVydGhlciBvcGVyYXRpb25zLiBOb3RlIHRoYXQgdGhpcyBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWNjZXB0YWJsZSBzaW5jZSBtaXhpbmcgJiBtYXRjaGluZyBkaWZmZXJlbnQgYHN5bmNocm9uaXplVGFic2BcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldHRpbmdzIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhiLzExNDIyNjIzNCk6IFJlbW92ZSB0aGlzIGNoZWNrIHdoZW4gYHN5bmNocm9uaXplVGFic2AgY2FuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBsb25nZXIgYmUgdHVybmVkIG9mZi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sIFBSSU1BUllfTEVBU0VfRVhDTFVTSVZFX0VSUk9SX01TRyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm5ldHdvcmtFbmFibGVkICYmIHRoaXMuaW5Gb3JlZ3JvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2xpZW50TWV0YWRhdGFTdG9yZSh0eG4pXG4gICAgICAgICAgICAgICAgLmxvYWRBbGwoKVxuICAgICAgICAgICAgICAgIC5uZXh0KGV4aXN0aW5nQ2xpZW50cyA9PiB7XG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBhbGwgZXhpc3RpbmcgY2xpZW50cyBhbmQgZGV0ZXJtaW5lIHdoZXRoZXIgYXQgbGVhc3Qgb25lIG9mXG4gICAgICAgICAgICAgICAgLy8gdGhlbSBpcyBiZXR0ZXIgc3VpdGVkIHRvIG9idGFpbiB0aGUgcHJpbWFyeSBsZWFzZS5cbiAgICAgICAgICAgICAgICBjb25zdCBwcmVmZXJyZWRDYW5kaWRhdGUgPSB0aGlzLmZpbHRlckFjdGl2ZUNsaWVudHMoZXhpc3RpbmdDbGllbnRzLCBNQVhfUFJJTUFSWV9FTElHSUJMRV9BR0VfTVMpLmZpbmQob3RoZXJDbGllbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jbGllbnRJZCAhPT0gb3RoZXJDbGllbnQuY2xpZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyQ2xpZW50SGFzQmV0dGVyTmV0d29ya1N0YXRlID0gIXRoaXMubmV0d29ya0VuYWJsZWQgJiYgb3RoZXJDbGllbnQubmV0d29ya0VuYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlckNsaWVudEhhc0JldHRlclZpc2liaWxpdHkgPSAhdGhpcy5pbkZvcmVncm91bmQgJiYgb3RoZXJDbGllbnQuaW5Gb3JlZ3JvdW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJDbGllbnRIYXNTYW1lTmV0d29ya1N0YXRlID0gdGhpcy5uZXR3b3JrRW5hYmxlZCA9PT0gb3RoZXJDbGllbnQubmV0d29ya0VuYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJDbGllbnRIYXNCZXR0ZXJOZXR3b3JrU3RhdGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAob3RoZXJDbGllbnRIYXNCZXR0ZXJWaXNpYmlsaXR5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyQ2xpZW50SGFzU2FtZU5ldHdvcmtTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWZlcnJlZENhbmRpZGF0ZSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dChjYW5BY3RBc1ByaW1hcnkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNQcmltYXJ5ICE9PSBjYW5BY3RBc1ByaW1hcnkpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGMsIGBDbGllbnQgJHtjYW5BY3RBc1ByaW1hcnkgPyAnaXMnIDogJ2lzIG5vdCd9IGVsaWdpYmxlIGZvciBhIHByaW1hcnkgbGVhc2UuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FuQWN0QXNQcmltYXJ5O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgc2h1dGRvd24oKSB7XG4gICAgICAgIC8vIFRoZSBzaHV0ZG93bigpIG9wZXJhdGlvbnMgYXJlIGlkZW1wb3RlbnQgYW5kIGNhbiBiZSBjYWxsZWQgZXZlbiB3aGVuXG4gICAgICAgIC8vIHN0YXJ0KCkgYWJvcnRlZCAoZS5nLiBiZWNhdXNlIGl0IGNvdWxkbid0IGFjcXVpcmUgdGhlIHBlcnNpc3RlbmNlIGxlYXNlKS5cbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1hcmtDbGllbnRab21iaWVkKCk7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE1ldGFkYXRhUmVmcmVzaGVyKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudE1ldGFkYXRhUmVmcmVzaGVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgdGhpcy5jbGllbnRNZXRhZGF0YVJlZnJlc2hlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXRhY2hWaXNpYmlsaXR5SGFuZGxlcigpO1xuICAgICAgICB0aGlzLmRldGFjaFdpbmRvd1VubG9hZEhvb2soKTtcbiAgICAgICAgLy8gVXNlIGBTaW1wbGVEYi5ydW5UcmFuc2FjdGlvbmAgZGlyZWN0bHkgdG8gYXZvaWQgZmFpbGluZyBpZiBhbm90aGVyIHRhYlxuICAgICAgICAvLyBoYXMgb2J0YWluZWQgdGhlIHByaW1hcnkgbGVhc2UuXG4gICAgICAgIGF3YWl0IHRoaXMuc2ltcGxlRGIucnVuVHJhbnNhY3Rpb24oJ3NodXRkb3duJywgJ3JlYWR3cml0ZScsIFtEYlByaW1hcnlDbGllbnRTdG9yZSwgRGJDbGllbnRNZXRhZGF0YVN0b3JlXSwgc2ltcGxlRGJUeG4gPT4ge1xuICAgICAgICAgICAgY29uc3QgcGVyc2lzdGVuY2VUcmFuc2FjdGlvbiA9IG5ldyBJbmRleGVkRGJUcmFuc2FjdGlvbihzaW1wbGVEYlR4biwgTGlzdGVuU2VxdWVuY2UuSU5WQUxJRCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWxlYXNlUHJpbWFyeUxlYXNlSWZIZWxkKHBlcnNpc3RlbmNlVHJhbnNhY3Rpb24pLm5leHQoKCkgPT4gdGhpcy5yZW1vdmVDbGllbnRNZXRhZGF0YShwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNpbXBsZURiLmNsb3NlKCk7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgZW50cnkgbWFya2luZyB0aGUgY2xpZW50IGFzIHpvbWJpZWQgZnJvbSBMb2NhbFN0b3JhZ2Ugc2luY2VcbiAgICAgICAgLy8gd2Ugc3VjY2Vzc2Z1bGx5IGRlbGV0ZWQgaXRzIG1ldGFkYXRhIGZyb20gSW5kZXhlZERiLlxuICAgICAgICB0aGlzLnJlbW92ZUNsaWVudFpvbWJpZWRFbnRyeSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNsaWVudHMgdGhhdCBhcmUgbm90IHpvbWJpZWQgYW5kIGhhdmUgYW4gdXBkYXRlVGltZSB3aXRoaW4gdGhlXG4gICAgICogcHJvdmlkZWQgdGhyZXNob2xkLlxuICAgICAqL1xuICAgIGZpbHRlckFjdGl2ZUNsaWVudHMoY2xpZW50cywgYWN0aXZpdHlUaHJlc2hvbGRNcykge1xuICAgICAgICByZXR1cm4gY2xpZW50cy5maWx0ZXIoY2xpZW50ID0+IHRoaXMuaXNXaXRoaW5BZ2UoY2xpZW50LnVwZGF0ZVRpbWVNcywgYWN0aXZpdHlUaHJlc2hvbGRNcykgJiZcbiAgICAgICAgICAgICF0aGlzLmlzQ2xpZW50Wm9tYmllZChjbGllbnQuY2xpZW50SWQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSURzIG9mIHRoZSBjbGllbnRzIHRoYXQgYXJlIGN1cnJlbnRseSBhY3RpdmUuIElmIG11bHRpLXRhYlxuICAgICAqIGlzIG5vdCBzdXBwb3J0ZWQsIHJldHVybnMgYW4gYXJyYXkgdGhhdCBvbmx5IGNvbnRhaW5zIHRoZSBsb2NhbCBjbGllbnQnc1xuICAgICAqIElELlxuICAgICAqXG4gICAgICogUE9SVElORyBOT1RFOiBUaGlzIGlzIG9ubHkgdXNlZCBmb3IgV2ViIG11bHRpLXRhYi5cbiAgICAgKi9cbiAgICBnZXRBY3RpdmVDbGllbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ydW5UcmFuc2FjdGlvbignZ2V0QWN0aXZlQ2xpZW50cycsICdyZWFkb25seScsIHR4biA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2xpZW50TWV0YWRhdGFTdG9yZSh0eG4pXG4gICAgICAgICAgICAgICAgLmxvYWRBbGwoKVxuICAgICAgICAgICAgICAgIC5uZXh0KGNsaWVudHMgPT4gdGhpcy5maWx0ZXJBY3RpdmVDbGllbnRzKGNsaWVudHMsIE1BWF9DTElFTlRfQUdFX01TKS5tYXAoY2xpZW50TWV0YWRhdGEgPT4gY2xpZW50TWV0YWRhdGEuY2xpZW50SWQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBzdGFydGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhcnRlZDtcbiAgICB9XG4gICAgZ2V0R2xvYmFsc0NhY2hlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWxzQ2FjaGU7XG4gICAgfVxuICAgIGdldE11dGF0aW9uUXVldWUodXNlciwgaW5kZXhNYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybiBJbmRleGVkRGJNdXRhdGlvblF1ZXVlLmZvclVzZXIodXNlciwgdGhpcy5zZXJpYWxpemVyLCBpbmRleE1hbmFnZXIsIHRoaXMucmVmZXJlbmNlRGVsZWdhdGUpO1xuICAgIH1cbiAgICBnZXRUYXJnZXRDYWNoZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0Q2FjaGU7XG4gICAgfVxuICAgIGdldFJlbW90ZURvY3VtZW50Q2FjaGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGU7XG4gICAgfVxuICAgIGdldEluZGV4TWFuYWdlcih1c2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhlZERiSW5kZXhNYW5hZ2VyKHVzZXIsIHRoaXMuc2VyaWFsaXplci5yZW1vdGVTZXJpYWxpemVyLmRhdGFiYXNlSWQpO1xuICAgIH1cbiAgICBnZXREb2N1bWVudE92ZXJsYXlDYWNoZSh1c2VyKSB7XG4gICAgICAgIHJldHVybiBJbmRleGVkRGJEb2N1bWVudE92ZXJsYXlDYWNoZS5mb3JVc2VyKHRoaXMuc2VyaWFsaXplciwgdXNlcik7XG4gICAgfVxuICAgIGdldEJ1bmRsZUNhY2hlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idW5kbGVDYWNoZTtcbiAgICB9XG4gICAgcnVuVHJhbnNhY3Rpb24oYWN0aW9uLCBtb2RlLCB0cmFuc2FjdGlvbk9wZXJhdGlvbikge1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGMsICdTdGFydGluZyB0cmFuc2FjdGlvbjonLCBhY3Rpb24pO1xuICAgICAgICBjb25zdCBzaW1wbGVEYk1vZGUgPSBtb2RlID09PSAncmVhZG9ubHknID8gJ3JlYWRvbmx5JyA6ICdyZWFkd3JpdGUnO1xuICAgICAgICBjb25zdCBvYmplY3RTdG9yZXMgPSBnZXRPYmplY3RTdG9yZXModGhpcy5zY2hlbWFWZXJzaW9uKTtcbiAgICAgICAgbGV0IHBlcnNpc3RlbmNlVHJhbnNhY3Rpb247XG4gICAgICAgIC8vIERvIGFsbCB0cmFuc2FjdGlvbnMgYXMgcmVhZHdyaXRlIGFnYWluc3QgYWxsIG9iamVjdCBzdG9yZXMsIHNpbmNlIHdlXG4gICAgICAgIC8vIGFyZSB0aGUgb25seSByZWFkZXIvd3JpdGVyLlxuICAgICAgICByZXR1cm4gdGhpcy5zaW1wbGVEYlxuICAgICAgICAgICAgLnJ1blRyYW5zYWN0aW9uKGFjdGlvbiwgc2ltcGxlRGJNb2RlLCBvYmplY3RTdG9yZXMsIHNpbXBsZURiVHhuID0+IHtcbiAgICAgICAgICAgIHBlcnNpc3RlbmNlVHJhbnNhY3Rpb24gPSBuZXcgSW5kZXhlZERiVHJhbnNhY3Rpb24oc2ltcGxlRGJUeG4sIHRoaXMubGlzdGVuU2VxdWVuY2VcbiAgICAgICAgICAgICAgICA/IHRoaXMubGlzdGVuU2VxdWVuY2UubmV4dCgpXG4gICAgICAgICAgICAgICAgOiBMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEKTtcbiAgICAgICAgICAgIGlmIChtb2RlID09PSAncmVhZHdyaXRlLXByaW1hcnknKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hpbGUgd2UgbWVyZWx5IHZlcmlmeSB0aGF0IHdlIGhhdmUgKG9yIGNhbiBhY3F1aXJlKSB0aGUgbGVhc2VcbiAgICAgICAgICAgICAgICAvLyBpbW1lZGlhdGVseSwgd2Ugd2FpdCB0byBleHRlbmQgdGhlIHByaW1hcnkgbGVhc2UgdW50aWwgYWZ0ZXJcbiAgICAgICAgICAgICAgICAvLyBleGVjdXRpbmcgdHJhbnNhY3Rpb25PcGVyYXRpb24oKS4gVGhpcyBlbnN1cmVzIHRoYXQgZXZlbiBpZiB0aGVcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2FjdGlvbk9wZXJhdGlvbiB0YWtlcyBhIGxvbmcgdGltZSwgd2UnbGwgdXNlIGEgcmVjZW50XG4gICAgICAgICAgICAgICAgLy8gbGVhc2VUaW1lc3RhbXBNcyBpbiB0aGUgZXh0ZW5kZWQgKG9yIG5ld2x5IGFjcXVpcmVkKSBsZWFzZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJpZnlQcmltYXJ5TGVhc2UocGVyc2lzdGVuY2VUcmFuc2FjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgLm5leHQoaG9sZHNQcmltYXJ5TGVhc2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZHNQcmltYXJ5TGVhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAvKiBob2xkc1ByaW1hcnlMZWFzZT0gKi8gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYW5BY3RBc1ByaW1hcnkocGVyc2lzdGVuY2VUcmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm5leHQoaG9sZHNQcmltYXJ5TGVhc2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhvbGRzUHJpbWFyeUxlYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dFcnJvcihgRmFpbGVkIHRvIG9idGFpbiBwcmltYXJ5IGxlYXNlIGZvciBhY3Rpb24gJyR7YWN0aW9ufScuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzUHJpbWFyeSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbnF1ZXVlUmV0cnlhYmxlKCgpID0+IHRoaXMucHJpbWFyeVN0YXRlTGlzdGVuZXIoZmFsc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sIFBSSU1BUllfTEVBU0VfTE9TVF9FUlJPUl9NU0cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbk9wZXJhdGlvbihwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAubmV4dChyZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3F1aXJlT3JFeHRlbmRQcmltYXJ5TGVhc2UocGVyc2lzdGVuY2VUcmFuc2FjdGlvbikubmV4dCgoKSA9PiByZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVyaWZ5QWxsb3dUYWJTeW5jaHJvbml6YXRpb24ocGVyc2lzdGVuY2VUcmFuc2FjdGlvbikubmV4dCgoKSA9PiB0cmFuc2FjdGlvbk9wZXJhdGlvbihwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgcGVyc2lzdGVuY2VUcmFuc2FjdGlvbi5yYWlzZU9uQ29tbWl0dGVkRXZlbnQoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyB0aGF0IHRoZSBjdXJyZW50IHRhYiBpcyB0aGUgcHJpbWFyeSBsZWFzZWhvbGRlciBvciBhbHRlcm5hdGl2ZWx5XG4gICAgICogdGhhdCB0aGUgbGVhc2Vob2xkZXIgaGFzIG9wdGVkIGludG8gbXVsdGktdGFiIHN5bmNocm9uaXphdGlvbi5cbiAgICAgKi9cbiAgICAvLyBUT0RPKGIvMTE0MjI2MjM0KTogUmVtb3ZlIHRoaXMgY2hlY2sgd2hlbiBgc3luY2hyb25pemVUYWJzYCBjYW4gbm8gbG9uZ2VyXG4gICAgLy8gYmUgdHVybmVkIG9mZi5cbiAgICB2ZXJpZnlBbGxvd1RhYlN5bmNocm9uaXphdGlvbih0eG4pIHtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBwcmltYXJ5Q2xpZW50U3RvcmUodHhuKTtcbiAgICAgICAgcmV0dXJuIHN0b3JlLmdldChEYlByaW1hcnlDbGllbnRLZXkpLm5leHQoY3VycmVudFByaW1hcnkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudExlYXNlSXNWYWxpZCA9IGN1cnJlbnRQcmltYXJ5ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgdGhpcy5pc1dpdGhpbkFnZShjdXJyZW50UHJpbWFyeS5sZWFzZVRpbWVzdGFtcE1zLCBNQVhfUFJJTUFSWV9FTElHSUJMRV9BR0VfTVMpICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuaXNDbGllbnRab21iaWVkKGN1cnJlbnRQcmltYXJ5Lm93bmVySWQpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRMZWFzZUlzVmFsaWQgJiYgIXRoaXMuaXNMb2NhbENsaWVudChjdXJyZW50UHJpbWFyeSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZm9yY2VPd25pbmdUYWIgJiZcbiAgICAgICAgICAgICAgICAgICAgKCF0aGlzLmFsbG93VGFiU3luY2hyb25pemF0aW9uIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhY3VycmVudFByaW1hcnkuYWxsb3dUYWJTeW5jaHJvbml6YXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sIFBSSU1BUllfTEVBU0VfRVhDTFVTSVZFX0VSUk9SX01TRyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT2J0YWlucyBvciBleHRlbmRzIHRoZSBuZXcgcHJpbWFyeSBsZWFzZSBmb3IgdGhlIGxvY2FsIGNsaWVudC4gVGhpc1xuICAgICAqIG1ldGhvZCBkb2VzIG5vdCB2ZXJpZnkgdGhhdCB0aGUgY2xpZW50IGlzIGVsaWdpYmxlIGZvciB0aGlzIGxlYXNlLlxuICAgICAqL1xuICAgIGFjcXVpcmVPckV4dGVuZFByaW1hcnlMZWFzZSh0eG4pIHtcbiAgICAgICAgY29uc3QgbmV3UHJpbWFyeSA9IHtcbiAgICAgICAgICAgIG93bmVySWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICAgICAgICBhbGxvd1RhYlN5bmNocm9uaXphdGlvbjogdGhpcy5hbGxvd1RhYlN5bmNocm9uaXphdGlvbixcbiAgICAgICAgICAgIGxlYXNlVGltZXN0YW1wTXM6IERhdGUubm93KClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHByaW1hcnlDbGllbnRTdG9yZSh0eG4pLnB1dChEYlByaW1hcnlDbGllbnRLZXksIG5ld1ByaW1hcnkpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNBdmFpbGFibGUoKSB7XG4gICAgICAgIHJldHVybiBTaW1wbGVEYi5pc0F2YWlsYWJsZSgpO1xuICAgIH1cbiAgICAvKiogQ2hlY2tzIHRoZSBwcmltYXJ5IGxlYXNlIGFuZCByZW1vdmVzIGl0IGlmIHdlIGFyZSB0aGUgY3VycmVudCBwcmltYXJ5LiAqL1xuICAgIHJlbGVhc2VQcmltYXJ5TGVhc2VJZkhlbGQodHhuKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gcHJpbWFyeUNsaWVudFN0b3JlKHR4bik7XG4gICAgICAgIHJldHVybiBzdG9yZS5nZXQoRGJQcmltYXJ5Q2xpZW50S2V5KS5uZXh0KHByaW1hcnlDbGllbnQgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNMb2NhbENsaWVudChwcmltYXJ5Q2xpZW50KSkge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckYywgJ1JlbGVhc2luZyBwcmltYXJ5IGxlYXNlLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZS5kZWxldGUoRGJQcmltYXJ5Q2xpZW50S2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIFZlcmlmaWVzIHRoYXQgYHVwZGF0ZVRpbWVNc2AgaXMgd2l0aGluIGBtYXhBZ2VNc2AuICovXG4gICAgaXNXaXRoaW5BZ2UodXBkYXRlVGltZU1zLCBtYXhBZ2VNcykge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBtaW5BY2NlcHRhYmxlID0gbm93IC0gbWF4QWdlTXM7XG4gICAgICAgIGNvbnN0IG1heEFjY2VwdGFibGUgPSBub3c7XG4gICAgICAgIGlmICh1cGRhdGVUaW1lTXMgPCBtaW5BY2NlcHRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodXBkYXRlVGltZU1zID4gbWF4QWNjZXB0YWJsZSkge1xuICAgICAgICAgICAgbG9nRXJyb3IoYERldGVjdGVkIGFuIHVwZGF0ZSB0aW1lIHRoYXQgaXMgaW4gdGhlIGZ1dHVyZTogJHt1cGRhdGVUaW1lTXN9ID4gJHttYXhBY2NlcHRhYmxlfWApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhdHRhY2hWaXNpYmlsaXR5SGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9jdW1lbnQgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiB0aGlzLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRWaXNpYmlsaXR5SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmVucXVldWVBbmRGb3JnZXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluRm9yZWdyb3VuZCA9IHRoaXMuZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAndmlzaWJsZSc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUNsaWVudE1ldGFkYXRhQW5kVHJ5QmVjb21lUHJpbWFyeSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHRoaXMuZG9jdW1lbnRWaXNpYmlsaXR5SGFuZGxlcik7XG4gICAgICAgICAgICB0aGlzLmluRm9yZWdyb3VuZCA9IHRoaXMuZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAndmlzaWJsZSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGV0YWNoVmlzaWJpbGl0eUhhbmRsZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50VmlzaWJpbGl0eUhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHRoaXMuZG9jdW1lbnRWaXNpYmlsaXR5SGFuZGxlcik7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50VmlzaWJpbGl0eUhhbmRsZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGEgd2luZG93LnVubG9hZCBoYW5kbGVyIHRoYXQgd2lsbCBzeW5jaHJvbm91c2x5IHdyaXRlIG91clxuICAgICAqIGNsaWVudElkIHRvIGEgXCJ6b21iaWUgY2xpZW50IGlkXCIgbG9jYXRpb24gaW4gTG9jYWxTdG9yYWdlLiBUaGlzIGNhbiBiZSB1c2VkXG4gICAgICogYnkgdGFicyB0cnlpbmcgdG8gYWNxdWlyZSB0aGUgcHJpbWFyeSBsZWFzZSB0byBkZXRlcm1pbmUgdGhhdCB0aGUgbGVhc2VcbiAgICAgKiBpcyBubyBsb25nZXIgdmFsaWQgZXZlbiBpZiB0aGUgdGltZXN0YW1wIGlzIHJlY2VudC4gVGhpcyBpcyBwYXJ0aWN1bGFybHlcbiAgICAgKiBpbXBvcnRhbnQgZm9yIHRoZSByZWZyZXNoIGNhc2UgKHNvIHRoZSB0YWIgY29ycmVjdGx5IHJlLWFjcXVpcmVzIHRoZVxuICAgICAqIHByaW1hcnkgbGVhc2UpLiBMb2NhbFN0b3JhZ2UgaXMgdXNlZCBmb3IgdGhpcyByYXRoZXIgdGhhbiBJbmRleGVkRGIgYmVjYXVzZVxuICAgICAqIGl0IGlzIGEgc3luY2hyb25vdXMgQVBJIGFuZCBzbyBjYW4gYmUgdXNlZCByZWxpYWJseSBmcm9tICBhbiB1bmxvYWRcbiAgICAgKiBoYW5kbGVyLlxuICAgICAqL1xuICAgIGF0dGFjaFdpbmRvd1VubG9hZEhvb2soKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHR5cGVvZiAoKF9hID0gdGhpcy53aW5kb3cpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGRFdmVudExpc3RlbmVyKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy53aW5kb3dVbmxvYWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIE5vdGU6IEluIHRoZW9yeSwgdGhpcyBzaG91bGQgYmUgc2NoZWR1bGVkIG9uIHRoZSBBc3luY1F1ZXVlIHNpbmNlIGl0XG4gICAgICAgICAgICAgICAgLy8gYWNjZXNzZXMgaW50ZXJuYWwgc3RhdGUuIFdlIGV4ZWN1dGUgdGhpcyBjb2RlIGRpcmVjdGx5IGR1cmluZyBzaHV0ZG93blxuICAgICAgICAgICAgICAgIC8vIHRvIG1ha2Ugc3VyZSBpdCBnZXRzIGEgY2hhbmNlIHRvIHJ1bi5cbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtDbGllbnRab21iaWVkKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2FmYXJpSW5kZXhkYkJ1Z1ZlcnNpb25SZWdleCA9IC8oPzpWZXJzaW9ufE1vYmlsZSlcXC8xWzQ1Nl0vO1xuICAgICAgICAgICAgICAgIGlmIChpc1NhZmFyaSgpICYmXG4gICAgICAgICAgICAgICAgICAgIChuYXZpZ2F0b3IuYXBwVmVyc2lvbi5tYXRjaChzYWZhcmlJbmRleGRiQnVnVmVyc2lvblJlZ2V4KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaChzYWZhcmlJbmRleGRiQnVnVmVyc2lvblJlZ2V4KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT24gU2FmYXJpIDE0LCAxNSwgYW5kIDE2LCB3ZSBkbyBub3QgcnVuIGFueSBjbGVhbnVwIGFjdGlvbnMgYXMgaXQgbWlnaHRcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJpZ2dlciBhIGJ1ZyB0aGF0IHByZXZlbnRzIFNhZmFyaSBmcm9tIHJlLW9wZW5pbmcgSW5kZXhlZERCIGR1cmluZ1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbmV4dCBwYWdlIGxvYWQuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjI2NTQ3XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZW50ZXJSZXN0cmljdGVkTW9kZSgvKiBwdXJnZUV4aXN0aW5nVGFza3M9ICovIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmVucXVldWVBbmRGb3JnZXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IGdyYWNlZnVsIHNodXRkb3duIChpbmNsdWRpbmcgcmVsZWFzaW5nIG91ciBwcmltYXJ5IGxlYXNlKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHRoZXJlJ3Mgbm8gZ3VhcmFudGVlIGl0IHdpbGwgY29tcGxldGUuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNodXRkb3duKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCB0aGlzLndpbmRvd1VubG9hZEhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRldGFjaFdpbmRvd1VubG9hZEhvb2soKSB7XG4gICAgICAgIGlmICh0aGlzLndpbmRvd1VubG9hZEhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMud2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgdGhpcy53aW5kb3dVbmxvYWRIYW5kbGVyKTtcbiAgICAgICAgICAgIHRoaXMud2luZG93VW5sb2FkSGFuZGxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIGEgY2xpZW50IGlzIFwiem9tYmllZFwiIGJhc2VkIG9uIGl0cyBMb2NhbFN0b3JhZ2UgZW50cnkuXG4gICAgICogQ2xpZW50cyBiZWNvbWUgem9tYmllZCB3aGVuIHRoZWlyIHRhYiBjbG9zZXMgd2l0aG91dCBydW5uaW5nIGFsbCBvZiB0aGVcbiAgICAgKiBjbGVhbnVwIGxvZ2ljIGluIGBzaHV0ZG93bigpYC5cbiAgICAgKi9cbiAgICBpc0NsaWVudFpvbWJpZWQoY2xpZW50SWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaXNab21iaWVkID0gKChfYSA9IHRoaXMud2ViU3RvcmFnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldEl0ZW0odGhpcy56b21iaWVkQ2xpZW50TG9jYWxTdG9yYWdlS2V5KGNsaWVudElkKSkpICE9PSBudWxsO1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRjLCBgQ2xpZW50ICcke2NsaWVudElkfScgJHtpc1pvbWJpZWQgPyAnaXMnIDogJ2lzIG5vdCd9IHpvbWJpZWQgaW4gTG9jYWxTdG9yYWdlYCk7XG4gICAgICAgICAgICByZXR1cm4gaXNab21iaWVkO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBHcmFjZWZ1bGx5IGhhbmRsZSBpZiBMb2NhbFN0b3JhZ2UgaXNuJ3Qgd29ya2luZy5cbiAgICAgICAgICAgIGxvZ0Vycm9yKExPR19UQUckYywgJ0ZhaWxlZCB0byBnZXQgem9tYmllZCBjbGllbnQgaWQuJywgZSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjb3JkIGNsaWVudCBhcyB6b21iaWVkIChhIGNsaWVudCB0aGF0IGhhZCBpdHMgdGFiIGNsb3NlZCkuIFpvbWJpZWRcbiAgICAgKiBjbGllbnRzIGFyZSBpZ25vcmVkIGR1cmluZyBwcmltYXJ5IHRhYiBzZWxlY3Rpb24uXG4gICAgICovXG4gICAgbWFya0NsaWVudFpvbWJpZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy53ZWJTdG9yYWdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMud2ViU3RvcmFnZS5zZXRJdGVtKHRoaXMuem9tYmllZENsaWVudExvY2FsU3RvcmFnZUtleSh0aGlzLmNsaWVudElkKSwgU3RyaW5nKERhdGUubm93KCkpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gR3JhY2VmdWxseSBoYW5kbGUgaWYgTG9jYWxTdG9yYWdlIGlzbid0IGF2YWlsYWJsZSAvIHdvcmtpbmcuXG4gICAgICAgICAgICBsb2dFcnJvcignRmFpbGVkIHRvIHNldCB6b21iaWUgY2xpZW50IGlkLicsIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBSZW1vdmVzIHRoZSB6b21iaWVkIGNsaWVudCBlbnRyeSBpZiBpdCBleGlzdHMuICovXG4gICAgcmVtb3ZlQ2xpZW50Wm9tYmllZEVudHJ5KCkge1xuICAgICAgICBpZiAoIXRoaXMud2ViU3RvcmFnZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLndlYlN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLnpvbWJpZWRDbGllbnRMb2NhbFN0b3JhZ2VLZXkodGhpcy5jbGllbnRJZCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmVcbiAgICAgICAgfVxuICAgIH1cbiAgICB6b21iaWVkQ2xpZW50TG9jYWxTdG9yYWdlS2V5KGNsaWVudElkKSB7XG4gICAgICAgIHJldHVybiBgJHtaT01CSUVEX0NMSUVOVFNfS0VZX1BSRUZJWH1fJHt0aGlzLnBlcnNpc3RlbmNlS2V5fV8ke2NsaWVudElkfWA7XG4gICAgfVxufVxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIHByaW1hcnkgY2xpZW50IG9iamVjdCBzdG9yZS5cbiAqL1xuZnVuY3Rpb24gcHJpbWFyeUNsaWVudFN0b3JlKHR4bikge1xuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiUHJpbWFyeUNsaWVudFN0b3JlKTtcbn1cbi8qKlxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBjbGllbnQgbWV0YWRhdGEgb2JqZWN0IHN0b3JlLlxuICovXG5mdW5jdGlvbiBjbGllbnRNZXRhZGF0YVN0b3JlKHR4bikge1xuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiQ2xpZW50TWV0YWRhdGFTdG9yZSk7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHN0cmluZyB1c2VkIGFzIGEgcHJlZml4IHdoZW4gc3RvcmluZyBkYXRhIGluIEluZGV4ZWREQiBhbmRcbiAqIExvY2FsU3RvcmFnZS5cbiAqL1xuZnVuY3Rpb24gaW5kZXhlZERiU3RvcmFnZVByZWZpeChkYXRhYmFzZUlkLCBwZXJzaXN0ZW5jZUtleSkge1xuICAgIC8vIFVzZSB0d28gZGlmZmVyZW50IHByZWZpeCBmb3JtYXRzOlxuICAgIC8vXG4gICAgLy8gICAqIGZpcmVzdG9yZSAvIHBlcnNpc3RlbmNlS2V5IC8gcHJvamVjdElEIC4gZGF0YWJhc2VJRCAvIC4uLlxuICAgIC8vICAgKiBmaXJlc3RvcmUgLyBwZXJzaXN0ZW5jZUtleSAvIHByb2plY3RJRCAvIC4uLlxuICAgIC8vXG4gICAgLy8gcHJvamVjdElEcyBhcmUgRE5TLWNvbXBhdGlibGUgbmFtZXMgYW5kIGNhbm5vdCBjb250YWluIGRvdHNcbiAgICAvLyBzbyB0aGVyZSdzIG5vIGRhbmdlciBvZiBjb2xsaXNpb25zLlxuICAgIGxldCBkYXRhYmFzZSA9IGRhdGFiYXNlSWQucHJvamVjdElkO1xuICAgIGlmICghZGF0YWJhc2VJZC5pc0RlZmF1bHREYXRhYmFzZSkge1xuICAgICAgICBkYXRhYmFzZSArPSAnLicgKyBkYXRhYmFzZUlkLmRhdGFiYXNlO1xuICAgIH1cbiAgICByZXR1cm4gJ2ZpcmVzdG9yZS8nICsgcGVyc2lzdGVuY2VLZXkgKyAnLycgKyBkYXRhYmFzZSArICcvJztcbn1cbmFzeW5jIGZ1bmN0aW9uIGluZGV4ZWREYkNsZWFyUGVyc2lzdGVuY2UocGVyc2lzdGVuY2VLZXkpIHtcbiAgICBpZiAoIVNpbXBsZURiLmlzQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBkYk5hbWUgPSBwZXJzaXN0ZW5jZUtleSArIE1BSU5fREFUQUJBU0U7XG4gICAgYXdhaXQgU2ltcGxlRGIuZGVsZXRlKGRiTmFtZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIENvbXBhcmVzIHR3byBhcnJheSBmb3IgZXF1YWxpdHkgdXNpbmcgY29tcGFyYXRvci4gVGhlIG1ldGhvZCBjb21wdXRlcyB0aGVcbiAqIGludGVyc2VjdGlvbiBhbmQgaW52b2tlcyBgb25BZGRgIGZvciBldmVyeSBlbGVtZW50IHRoYXQgaXMgaW4gYGFmdGVyYCBidXQgbm90XG4gKiBgYmVmb3JlYC4gYG9uUmVtb3ZlYCBpcyBpbnZva2VkIGZvciBldmVyeSBlbGVtZW50IGluIGBiZWZvcmVgIGJ1dCBtaXNzaW5nXG4gKiBmcm9tIGBhZnRlcmAuXG4gKlxuICogVGhlIG1ldGhvZCBjcmVhdGVzIGEgY29weSBvZiBib3RoIGBiZWZvcmVgIGFuZCBgYWZ0ZXJgIGFuZCBydW5zIGluIE8obiBsb2dcbiAqIG4pLCB3aGVyZSBuIGlzIHRoZSBzaXplIG9mIHRoZSB0d28gbGlzdHMuXG4gKlxuICogQHBhcmFtIGJlZm9yZSAtIFRoZSBlbGVtZW50cyB0aGF0IGV4aXN0IGluIHRoZSBvcmlnaW5hbCBhcnJheS5cbiAqIEBwYXJhbSBhZnRlciAtIFRoZSBlbGVtZW50cyB0byBkaWZmIGFnYWluc3QgdGhlIG9yaWdpbmFsIGFycmF5LlxuICogQHBhcmFtIGNvbXBhcmF0b3IgLSBUaGUgY29tcGFyYXRvciBmb3IgdGhlIGVsZW1lbnRzIGluIGJlZm9yZSBhbmQgYWZ0ZXIuXG4gKiBAcGFyYW0gb25BZGQgLSBBIGZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZXZlcnkgZWxlbWVudCB0aGF0IGlzIHBhcnQgb2YgYFxuICogYWZ0ZXJgIGJ1dCBub3QgYGJlZm9yZWAuXG4gKiBAcGFyYW0gb25SZW1vdmUgLSBBIGZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZXZlcnkgZWxlbWVudCB0aGF0IGlzIHBhcnQgb2ZcbiAqIGBiZWZvcmVgIGJ1dCBub3QgYGFmdGVyYC5cbiAqL1xuZnVuY3Rpb24gZGlmZkFycmF5cyhiZWZvcmUsIGFmdGVyLCBjb21wYXJhdG9yLCBvbkFkZCwgb25SZW1vdmUpIHtcbiAgICBiZWZvcmUgPSBbLi4uYmVmb3JlXTtcbiAgICBhZnRlciA9IFsuLi5hZnRlcl07XG4gICAgYmVmb3JlLnNvcnQoY29tcGFyYXRvcik7XG4gICAgYWZ0ZXIuc29ydChjb21wYXJhdG9yKTtcbiAgICBjb25zdCBiTGVuID0gYmVmb3JlLmxlbmd0aDtcbiAgICBjb25zdCBhTGVuID0gYWZ0ZXIubGVuZ3RoO1xuICAgIGxldCBhID0gMDtcbiAgICBsZXQgYiA9IDA7XG4gICAgd2hpbGUgKGEgPCBhTGVuICYmIGIgPCBiTGVuKSB7XG4gICAgICAgIGNvbnN0IGNtcCA9IGNvbXBhcmF0b3IoYmVmb3JlW2JdLCBhZnRlclthXSk7XG4gICAgICAgIGlmIChjbXAgPCAwKSB7XG4gICAgICAgICAgICAvLyBUaGUgZWxlbWVudCB3YXMgcmVtb3ZlZCBpZiB0aGUgbmV4dCBlbGVtZW50IGluIG91ciBvcmRlcmVkXG4gICAgICAgICAgICAvLyB3YWxrdGhyb3VnaCBpcyBvbmx5IGluIGBiZWZvcmVgLlxuICAgICAgICAgICAgb25SZW1vdmUoYmVmb3JlW2IrK10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IHdhcyBhZGRlZCBpZiB0aGUgbmV4dCBlbGVtZW50IGluIG91ciBvcmRlcmVkIHdhbGt0aHJvdWdoXG4gICAgICAgICAgICAvLyBpcyBvbmx5IGluIGBhZnRlcmAuXG4gICAgICAgICAgICBvbkFkZChhZnRlclthKytdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGErKztcbiAgICAgICAgICAgIGIrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoYSA8IGFMZW4pIHtcbiAgICAgICAgb25BZGQoYWZ0ZXJbYSsrXSk7XG4gICAgfVxuICAgIHdoaWxlIChiIDwgYkxlbikge1xuICAgICAgICBvblJlbW92ZShiZWZvcmVbYisrXSk7XG4gICAgfVxufVxuLyoqXG4gKiBWZXJpZmllcyBlcXVhbGl0eSBmb3IgYW4gYXJyYXkgb2YgcHJpbWl0aXZlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGludGVybmFsXG4gKiBAcGFyYW0gbGVmdCBBcnJheSBvZiBwcmltaXRpdmVzLlxuICogQHBhcmFtIHJpZ2h0IEFycmF5IG9mIHByaW1pdGl2ZXMuXG4gKiBAcmV0dXJuIFRydWUgaWYgYXJyYXlzIGFyZSBlcXVhbC5cbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmVBcnJheUVxdWFsKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQubGVuZ3RoICE9PSByaWdodC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlZnQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGxlZnRbaV0gIT09IHJpZ2h0W2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBMT0dfVEFHJGIgPSAnTG9jYWxTdG9yZSc7XG4vKipcbiAqIFRoZSBtYXhpbXVtIHRpbWUgdG8gbGVhdmUgYSByZXN1bWUgdG9rZW4gYnVmZmVyZWQgd2l0aG91dCB3cml0aW5nIGl0IG91dC5cbiAqIFRoaXMgdmFsdWUgaXMgYXJiaXRyYXJ5OiBpdCdzIGxvbmcgZW5vdWdoIHRvIGF2b2lkIHNldmVyYWwgd3JpdGVzXG4gKiAocG9zc2libHkgaW5kZWZpbml0ZWx5IGlmIHVwZGF0ZXMgY29tZSBtb3JlIGZyZXF1ZW50bHkgdGhhbiB0aGlzKSBidXRcbiAqIHNob3J0IGVub3VnaCB0aGF0IHJlc3RhcnRpbmcgYWZ0ZXIgY3Jhc2hpbmcgd2lsbCBzdGlsbCBoYXZlIGEgcHJldHR5XG4gKiByZWNlbnQgcmVzdW1lIHRva2VuLlxuICovXG5jb25zdCBSRVNVTUVfVE9LRU5fTUFYX0FHRV9NSUNST1MgPSA1ICogNjAgKiAxZTY7XG4vKipcbiAqIEltcGxlbWVudHMgYExvY2FsU3RvcmVgIGludGVyZmFjZS5cbiAqXG4gKiBOb3RlOiBzb21lIGZpZWxkIGRlZmluZWQgaW4gdGhpcyBjbGFzcyBtaWdodCBoYXZlIHB1YmxpYyBhY2Nlc3MgbGV2ZWwsIGJ1dFxuICogdGhlIGNsYXNzIGlzIG5vdCBleHBvcnRlZCBzbyB0aGV5IGFyZSBvbmx5IGFjY2Vzc2libGUgZnJvbSB0aGlzIG1vZHVsZS5cbiAqIFRoaXMgaXMgdXNlZnVsIHRvIGltcGxlbWVudCBvcHRpb25hbCBmZWF0dXJlcyAobGlrZSBidW5kbGVzKSBpbiBmcmVlXG4gKiBmdW5jdGlvbnMsIHN1Y2ggdGhhdCB0aGV5IGFyZSB0cmVlLXNoYWtlYWJsZS5cbiAqL1xuY2xhc3MgTG9jYWxTdG9yZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBNYW5hZ2VzIG91ciBpbi1tZW1vcnkgb3IgZHVyYWJsZSBwZXJzaXN0ZW5jZS4gKi9cbiAgICBwZXJzaXN0ZW5jZSwgcXVlcnlFbmdpbmUsIGluaXRpYWxVc2VyLCBzZXJpYWxpemVyKSB7XG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2UgPSBwZXJzaXN0ZW5jZTtcbiAgICAgICAgdGhpcy5xdWVyeUVuZ2luZSA9IHF1ZXJ5RW5naW5lO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFwcyBhIHRhcmdldElEIHRvIGRhdGEgYWJvdXQgaXRzIHRhcmdldC5cbiAgICAgICAgICpcbiAgICAgICAgICogUE9SVElORyBOT1RFOiBXZSBhcmUgdXNpbmcgYW4gaW1tdXRhYmxlIGRhdGEgc3RydWN0dXJlIG9uIFdlYiB0byBtYWtlIHJlLXJ1bnNcbiAgICAgICAgICogb2YgYGFwcGx5UmVtb3RlRXZlbnQoKWAgaWRlbXBvdGVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGFyZ2V0RGF0YUJ5VGFyZ2V0ID0gbmV3IFNvcnRlZE1hcChwcmltaXRpdmVDb21wYXJhdG9yKTtcbiAgICAgICAgLyoqIE1hcHMgYSB0YXJnZXQgdG8gaXRzIHRhcmdldElELiAqL1xuICAgICAgICAvLyBUT0RPKHd1YW5keSk6IEV2YWx1YXRlIGlmIFRhcmdldElkIGNhbiBiZSBwYXJ0IG9mIFRhcmdldC5cbiAgICAgICAgdGhpcy50YXJnZXRJZEJ5VGFyZ2V0ID0gbmV3IE9iamVjdE1hcCh0ID0+IGNhbm9uaWZ5VGFyZ2V0KHQpLCB0YXJnZXRFcXVhbHMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBwZXIgY29sbGVjdGlvbiBncm91cCBpbmRleCBvZiB0aGUgbGFzdCByZWFkIHRpbWUgcHJvY2Vzc2VkIGJ5XG4gICAgICAgICAqIGBnZXROZXdEb2N1bWVudENoYW5nZXMoKWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIFBPUlRJTkcgTk9URTogVGhpcyBpcyBvbmx5IHVzZWQgZm9yIG11bHRpLXRhYiBzeW5jaHJvbml6YXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25Hcm91cFJlYWRUaW1lID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnJlbW90ZURvY3VtZW50cyA9IHBlcnNpc3RlbmNlLmdldFJlbW90ZURvY3VtZW50Q2FjaGUoKTtcbiAgICAgICAgdGhpcy50YXJnZXRDYWNoZSA9IHBlcnNpc3RlbmNlLmdldFRhcmdldENhY2hlKCk7XG4gICAgICAgIHRoaXMuYnVuZGxlQ2FjaGUgPSBwZXJzaXN0ZW5jZS5nZXRCdW5kbGVDYWNoZSgpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVVc2VyQ29tcG9uZW50cyhpbml0aWFsVXNlcik7XG4gICAgfVxuICAgIGluaXRpYWxpemVVc2VyQ29tcG9uZW50cyh1c2VyKSB7XG4gICAgICAgIC8vIFRPRE8oaW5kZXhpbmcpOiBBZGQgc3BlYyB0ZXN0cyB0aGF0IHRlc3QgdGhlc2UgY29tcG9uZW50cyBjaGFuZ2UgYWZ0ZXIgYVxuICAgICAgICAvLyB1c2VyIGNoYW5nZVxuICAgICAgICB0aGlzLmRvY3VtZW50T3ZlcmxheUNhY2hlID0gdGhpcy5wZXJzaXN0ZW5jZS5nZXREb2N1bWVudE92ZXJsYXlDYWNoZSh1c2VyKTtcbiAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIgPSB0aGlzLnBlcnNpc3RlbmNlLmdldEluZGV4TWFuYWdlcih1c2VyKTtcbiAgICAgICAgdGhpcy5tdXRhdGlvblF1ZXVlID0gdGhpcy5wZXJzaXN0ZW5jZS5nZXRNdXRhdGlvblF1ZXVlKHVzZXIsIHRoaXMuaW5kZXhNYW5hZ2VyKTtcbiAgICAgICAgdGhpcy5sb2NhbERvY3VtZW50cyA9IG5ldyBMb2NhbERvY3VtZW50c1ZpZXcodGhpcy5yZW1vdGVEb2N1bWVudHMsIHRoaXMubXV0YXRpb25RdWV1ZSwgdGhpcy5kb2N1bWVudE92ZXJsYXlDYWNoZSwgdGhpcy5pbmRleE1hbmFnZXIpO1xuICAgICAgICB0aGlzLnJlbW90ZURvY3VtZW50cy5zZXRJbmRleE1hbmFnZXIodGhpcy5pbmRleE1hbmFnZXIpO1xuICAgICAgICB0aGlzLnF1ZXJ5RW5naW5lLmluaXRpYWxpemUodGhpcy5sb2NhbERvY3VtZW50cywgdGhpcy5pbmRleE1hbmFnZXIpO1xuICAgIH1cbiAgICBjb2xsZWN0R2FyYmFnZShnYXJiYWdlQ29sbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdDb2xsZWN0IGdhcmJhZ2UnLCAncmVhZHdyaXRlLXByaW1hcnknLCB0eG4gPT4gZ2FyYmFnZUNvbGxlY3Rvci5jb2xsZWN0KHR4biwgdGhpcy50YXJnZXREYXRhQnlUYXJnZXQpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBuZXdMb2NhbFN0b3JlKFxuLyoqIE1hbmFnZXMgb3VyIGluLW1lbW9yeSBvciBkdXJhYmxlIHBlcnNpc3RlbmNlLiAqL1xucGVyc2lzdGVuY2UsIHF1ZXJ5RW5naW5lLCBpbml0aWFsVXNlciwgc2VyaWFsaXplcikge1xuICAgIHJldHVybiBuZXcgTG9jYWxTdG9yZUltcGwocGVyc2lzdGVuY2UsIHF1ZXJ5RW5naW5lLCBpbml0aWFsVXNlciwgc2VyaWFsaXplcik7XG59XG4vKipcbiAqIFRlbGxzIHRoZSBMb2NhbFN0b3JlIHRoYXQgdGhlIGN1cnJlbnRseSBhdXRoZW50aWNhdGVkIHVzZXIgaGFzIGNoYW5nZWQuXG4gKlxuICogSW4gcmVzcG9uc2UgdGhlIGxvY2FsIHN0b3JlIHN3aXRjaGVzIHRoZSBtdXRhdGlvbiBxdWV1ZSB0byB0aGUgbmV3IHVzZXIgYW5kXG4gKiByZXR1cm5zIGFueSByZXN1bHRpbmcgZG9jdW1lbnQgY2hhbmdlcy5cbiAqL1xuLy8gUE9SVElORyBOT1RFOiBBbmRyb2lkIGFuZCBpT1Mgb25seSByZXR1cm4gdGhlIGRvY3VtZW50cyBhZmZlY3RlZCBieSB0aGVcbi8vIGNoYW5nZS5cbmFzeW5jIGZ1bmN0aW9uIGxvY2FsU3RvcmVIYW5kbGVVc2VyQ2hhbmdlKGxvY2FsU3RvcmUsIHVzZXIpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignSGFuZGxlIHVzZXIgY2hhbmdlJywgJ3JlYWRvbmx5JywgdHhuID0+IHtcbiAgICAgICAgLy8gU3dhcCBvdXQgdGhlIG11dGF0aW9uIHF1ZXVlLCBncmFiYmluZyB0aGUgcGVuZGluZyBtdXRhdGlvbiBiYXRjaGVzXG4gICAgICAgIC8vIGJlZm9yZSBhbmQgYWZ0ZXIuXG4gICAgICAgIGxldCBvbGRCYXRjaGVzO1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwubXV0YXRpb25RdWV1ZVxuICAgICAgICAgICAgLmdldEFsbE11dGF0aW9uQmF0Y2hlcyh0eG4pXG4gICAgICAgICAgICAubmV4dChwcm9taXNlZE9sZEJhdGNoZXMgPT4ge1xuICAgICAgICAgICAgb2xkQmF0Y2hlcyA9IHByb21pc2VkT2xkQmF0Y2hlcztcbiAgICAgICAgICAgIGxvY2FsU3RvcmVJbXBsLmluaXRpYWxpemVVc2VyQ29tcG9uZW50cyh1c2VyKTtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5tdXRhdGlvblF1ZXVlLmdldEFsbE11dGF0aW9uQmF0Y2hlcyh0eG4pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQobmV3QmF0Y2hlcyA9PiB7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVkQmF0Y2hJZHMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGFkZGVkQmF0Y2hJZHMgPSBbXTtcbiAgICAgICAgICAgIC8vIFVuaW9uIHRoZSBvbGQvbmV3IGNoYW5nZWQga2V5cy5cbiAgICAgICAgICAgIGxldCBjaGFuZ2VkS2V5cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGJhdGNoIG9mIG9sZEJhdGNoZXMpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVkQmF0Y2hJZHMucHVzaChiYXRjaC5iYXRjaElkKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIGJhdGNoLm11dGF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkS2V5cyA9IGNoYW5nZWRLZXlzLmFkZChtdXRhdGlvbi5rZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgYmF0Y2ggb2YgbmV3QmF0Y2hlcykge1xuICAgICAgICAgICAgICAgIGFkZGVkQmF0Y2hJZHMucHVzaChiYXRjaC5iYXRjaElkKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIGJhdGNoLm11dGF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkS2V5cyA9IGNoYW5nZWRLZXlzLmFkZChtdXRhdGlvbi5rZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgc2V0IG9mIGFsbCAocG90ZW50aWFsbHkpIGNoYW5nZWQgZG9jdW1lbnRzIGFuZCB0aGUgbGlzdFxuICAgICAgICAgICAgLy8gb2YgbXV0YXRpb24gYmF0Y2ggSURzIHRoYXQgd2VyZSBhZmZlY3RlZCBieSBjaGFuZ2UuXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHNcbiAgICAgICAgICAgICAgICAuZ2V0RG9jdW1lbnRzKHR4biwgY2hhbmdlZEtleXMpXG4gICAgICAgICAgICAgICAgLm5leHQoYWZmZWN0ZWREb2N1bWVudHMgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkRG9jdW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkQmF0Y2hJZHMsXG4gICAgICAgICAgICAgICAgICAgIGFkZGVkQmF0Y2hJZHNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKiBBY2NlcHRzIGxvY2FsbHkgZ2VuZXJhdGVkIE11dGF0aW9ucyBhbmQgY29tbWl0IHRoZW0gdG8gc3RvcmFnZS4gKi9cbmZ1bmN0aW9uIGxvY2FsU3RvcmVXcml0ZUxvY2FsbHkobG9jYWxTdG9yZSwgbXV0YXRpb25zKSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgY29uc3QgbG9jYWxXcml0ZVRpbWUgPSBUaW1lc3RhbXAubm93KCk7XG4gICAgY29uc3Qga2V5cyA9IG11dGF0aW9ucy5yZWR1Y2UoKGtleXMsIG0pID0+IGtleXMuYWRkKG0ua2V5KSwgZG9jdW1lbnRLZXlTZXQoKSk7XG4gICAgbGV0IG92ZXJsYXllZERvY3VtZW50cztcbiAgICBsZXQgbXV0YXRpb25CYXRjaDtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2VcbiAgICAgICAgLnJ1blRyYW5zYWN0aW9uKCdMb2NhbGx5IHdyaXRlIG11dGF0aW9ucycsICdyZWFkd3JpdGUnLCB0eG4gPT4ge1xuICAgICAgICAvLyBGaWd1cmUgb3V0IHdoaWNoIGtleXMgZG8gbm90IGhhdmUgYSByZW1vdGUgdmVyc2lvbiBpbiB0aGUgY2FjaGUsIHRoaXNcbiAgICAgICAgLy8gaXMgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgcmlnaHQgb3ZlcmxheSBtdXRhdGlvbjogaWYgbm8gcmVtb3RlIHZlcnNpb25cbiAgICAgICAgLy8gcHJlc2VudHMsIHdlIGRvIG5vdCBuZWVkIHRvIGNyZWF0ZSBvdmVybGF5cyBhcyBwYXRjaCBtdXRhdGlvbnMuXG4gICAgICAgIC8vIFRPRE8oT3ZlcmxheSk6IElzIHRoZXJlIGEgYmV0dGVyIHdheSB0byBkZXRlcm1pbmUgdGhpcz8gVXNpbmcgdGhlXG4gICAgICAgIC8vICBkb2N1bWVudCB2ZXJzaW9uIGRvZXMgbm90IHdvcmsgYmVjYXVzZSBsb2NhbCBtdXRhdGlvbnMgc2V0IHRoZW0gYmFja1xuICAgICAgICAvLyAgdG8gMC5cbiAgICAgICAgbGV0IHJlbW90ZURvY3MgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcbiAgICAgICAgbGV0IGRvY3NXaXRob3V0UmVtb3RlVmVyc2lvbiA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5yZW1vdGVEb2N1bWVudHNcbiAgICAgICAgICAgIC5nZXRFbnRyaWVzKHR4biwga2V5cylcbiAgICAgICAgICAgIC5uZXh0KGRvY3MgPT4ge1xuICAgICAgICAgICAgcmVtb3RlRG9jcyA9IGRvY3M7XG4gICAgICAgICAgICByZW1vdGVEb2NzLmZvckVhY2goKGtleSwgZG9jKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFkb2MuaXNWYWxpZERvY3VtZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jc1dpdGhvdXRSZW1vdGVWZXJzaW9uID0gZG9jc1dpdGhvdXRSZW1vdGVWZXJzaW9uLmFkZChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgLy8gTG9hZCBhbmQgYXBwbHkgYWxsIGV4aXN0aW5nIG11dGF0aW9ucy4gVGhpcyBsZXRzIHVzIGNvbXB1dGUgdGhlXG4gICAgICAgICAgICAvLyBjdXJyZW50IGJhc2Ugc3RhdGUgZm9yIGFsbCBub24taWRlbXBvdGVudCB0cmFuc2Zvcm1zIGJlZm9yZSBhcHBseWluZ1xuICAgICAgICAgICAgLy8gYW55IGFkZGl0aW9uYWwgdXNlci1wcm92aWRlZCB3cml0ZXMuXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMuZ2V0T3ZlcmxheWVkRG9jdW1lbnRzKHR4biwgcmVtb3RlRG9jcyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoZG9jcykgPT4ge1xuICAgICAgICAgICAgb3ZlcmxheWVkRG9jdW1lbnRzID0gZG9jcztcbiAgICAgICAgICAgIC8vIEZvciBub24taWRlbXBvdGVudCBtdXRhdGlvbnMgKHN1Y2ggYXMgYEZpZWxkVmFsdWUuaW5jcmVtZW50KClgKSxcbiAgICAgICAgICAgIC8vIHdlIHJlY29yZCB0aGUgYmFzZSBzdGF0ZSBpbiBhIHNlcGFyYXRlIHBhdGNoIG11dGF0aW9uLiBUaGlzIGlzXG4gICAgICAgICAgICAvLyBsYXRlciB1c2VkIHRvIGd1YXJhbnRlZSBjb25zaXN0ZW50IHZhbHVlcyBhbmQgcHJldmVudHMgZmxpY2tlclxuICAgICAgICAgICAgLy8gZXZlbiBpZiB0aGUgYmFja2VuZCBzZW5kcyB1cyBhbiB1cGRhdGUgdGhhdCBhbHJlYWR5IGluY2x1ZGVzIG91clxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtLlxuICAgICAgICAgICAgY29uc3QgYmFzZU11dGF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlVmFsdWUgPSBtdXRhdGlvbkV4dHJhY3RCYXNlVmFsdWUobXV0YXRpb24sIG92ZXJsYXllZERvY3VtZW50cy5nZXQobXV0YXRpb24ua2V5KS5vdmVybGF5ZWREb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGJhc2VWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IFRoZSBiYXNlIHN0YXRlIHNob3VsZCBvbmx5IGJlIGFwcGxpZWQgaWYgdGhlcmUncyBzb21lXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4aXN0aW5nIGRvY3VtZW50IHRvIG92ZXJyaWRlLCBzbyB1c2UgYSBQcmVjb25kaXRpb24gb2ZcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhpc3RzPXRydWVcbiAgICAgICAgICAgICAgICAgICAgYmFzZU11dGF0aW9ucy5wdXNoKG5ldyBQYXRjaE11dGF0aW9uKG11dGF0aW9uLmtleSwgYmFzZVZhbHVlLCBleHRyYWN0RmllbGRNYXNrKGJhc2VWYWx1ZS52YWx1ZS5tYXBWYWx1ZSksIFByZWNvbmRpdGlvbi5leGlzdHModHJ1ZSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwubXV0YXRpb25RdWV1ZS5hZGRNdXRhdGlvbkJhdGNoKHR4biwgbG9jYWxXcml0ZVRpbWUsIGJhc2VNdXRhdGlvbnMsIG11dGF0aW9ucyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dChiYXRjaCA9PiB7XG4gICAgICAgICAgICBtdXRhdGlvbkJhdGNoID0gYmF0Y2g7XG4gICAgICAgICAgICBjb25zdCBvdmVybGF5cyA9IGJhdGNoLmFwcGx5VG9Mb2NhbERvY3VtZW50U2V0KG92ZXJsYXllZERvY3VtZW50cywgZG9jc1dpdGhvdXRSZW1vdGVWZXJzaW9uKTtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5kb2N1bWVudE92ZXJsYXlDYWNoZS5zYXZlT3ZlcmxheXModHhuLCBiYXRjaC5iYXRjaElkLCBvdmVybGF5cyk7XG4gICAgICAgIH0pO1xuICAgIH0pXG4gICAgICAgIC50aGVuKCgpID0+ICh7XG4gICAgICAgIGJhdGNoSWQ6IG11dGF0aW9uQmF0Y2guYmF0Y2hJZCxcbiAgICAgICAgY2hhbmdlczogY29udmVydE92ZXJsYXllZERvY3VtZW50TWFwVG9Eb2N1bWVudE1hcChvdmVybGF5ZWREb2N1bWVudHMpXG4gICAgfSkpO1xufVxuLyoqXG4gKiBBY2tub3dsZWRnZXMgdGhlIGdpdmVuIGJhdGNoLlxuICpcbiAqIE9uIHRoZSBoYXBweSBwYXRoIHdoZW4gYSBiYXRjaCBpcyBhY2tub3dsZWRnZWQsIHRoZSBsb2NhbCBzdG9yZSB3aWxsXG4gKlxuICogICsgcmVtb3ZlIHRoZSBiYXRjaCBmcm9tIHRoZSBtdXRhdGlvbiBxdWV1ZTtcbiAqICArIGFwcGx5IHRoZSBjaGFuZ2VzIHRvIHRoZSByZW1vdGUgZG9jdW1lbnQgY2FjaGU7XG4gKiAgKyByZWNhbGN1bGF0ZSB0aGUgbGF0ZW5jeSBjb21wZW5zYXRlZCB2aWV3IGltcGxpZWQgYnkgdGhvc2UgY2hhbmdlcyAodGhlcmVcbiAqICAgIG1heSBiZSBtdXRhdGlvbnMgaW4gdGhlIHF1ZXVlIHRoYXQgYWZmZWN0IHRoZSBkb2N1bWVudHMgYnV0IGhhdmVuJ3QgYmVlblxuICogICAgYWNrbm93bGVkZ2VkIHlldCk7IGFuZFxuICogICsgZ2l2ZSB0aGUgY2hhbmdlZCBkb2N1bWVudHMgYmFjayB0aGUgc3luYyBlbmdpbmVcbiAqXG4gKiBAcmV0dXJucyBUaGUgcmVzdWx0aW5nIChtb2RpZmllZCkgZG9jdW1lbnRzLlxuICovXG5mdW5jdGlvbiBsb2NhbFN0b3JlQWNrbm93bGVkZ2VCYXRjaChsb2NhbFN0b3JlLCBiYXRjaFJlc3VsdCkge1xuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignQWNrbm93bGVkZ2UgYmF0Y2gnLCAncmVhZHdyaXRlLXByaW1hcnknLCB0eG4gPT4ge1xuICAgICAgICBjb25zdCBhZmZlY3RlZCA9IGJhdGNoUmVzdWx0LmJhdGNoLmtleXMoKTtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRCdWZmZXIgPSBsb2NhbFN0b3JlSW1wbC5yZW1vdGVEb2N1bWVudHMubmV3Q2hhbmdlQnVmZmVyKHtcbiAgICAgICAgICAgIHRyYWNrUmVtb3ZhbHM6IHRydWUgLy8gTWFrZSBzdXJlIGRvY3VtZW50IHJlbW92YWxzIHNob3cgdXAgaW4gYGdldE5ld0RvY3VtZW50Q2hhbmdlcygpYFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFwcGx5V3JpdGVUb1JlbW90ZURvY3VtZW50cyhsb2NhbFN0b3JlSW1wbCwgdHhuLCBiYXRjaFJlc3VsdCwgZG9jdW1lbnRCdWZmZXIpXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBkb2N1bWVudEJ1ZmZlci5hcHBseSh0eG4pKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwubXV0YXRpb25RdWV1ZS5wZXJmb3JtQ29uc2lzdGVuY3lDaGVjayh0eG4pKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwuZG9jdW1lbnRPdmVybGF5Q2FjaGUucmVtb3ZlT3ZlcmxheXNGb3JCYXRjaElkKHR4biwgYWZmZWN0ZWQsIGJhdGNoUmVzdWx0LmJhdGNoLmJhdGNoSWQpKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMucmVjYWxjdWxhdGVBbmRTYXZlT3ZlcmxheXNGb3JEb2N1bWVudEtleXModHhuLCBnZXRLZXlzV2l0aFRyYW5zZm9ybVJlc3VsdHMoYmF0Y2hSZXN1bHQpKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLmxvY2FsRG9jdW1lbnRzLmdldERvY3VtZW50cyh0eG4sIGFmZmVjdGVkKSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRLZXlzV2l0aFRyYW5zZm9ybVJlc3VsdHMoYmF0Y2hSZXN1bHQpIHtcbiAgICBsZXQgcmVzdWx0ID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhdGNoUmVzdWx0Lm11dGF0aW9uUmVzdWx0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBtdXRhdGlvblJlc3VsdCA9IGJhdGNoUmVzdWx0Lm11dGF0aW9uUmVzdWx0c1tpXTtcbiAgICAgICAgaWYgKG11dGF0aW9uUmVzdWx0LnRyYW5zZm9ybVJlc3VsdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZChiYXRjaFJlc3VsdC5iYXRjaC5tdXRhdGlvbnNbaV0ua2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBSZW1vdmVzIG11dGF0aW9ucyBmcm9tIHRoZSBNdXRhdGlvblF1ZXVlIGZvciB0aGUgc3BlY2lmaWVkIGJhdGNoO1xuICogTG9jYWxEb2N1bWVudHMgd2lsbCBiZSByZWNhbGN1bGF0ZWQuXG4gKlxuICogQHJldHVybnMgVGhlIHJlc3VsdGluZyBtb2RpZmllZCBkb2N1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIGxvY2FsU3RvcmVSZWplY3RCYXRjaChsb2NhbFN0b3JlLCBiYXRjaElkKSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdSZWplY3QgYmF0Y2gnLCAncmVhZHdyaXRlLXByaW1hcnknLCB0eG4gPT4ge1xuICAgICAgICBsZXQgYWZmZWN0ZWRLZXlzO1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwubXV0YXRpb25RdWV1ZVxuICAgICAgICAgICAgLmxvb2t1cE11dGF0aW9uQmF0Y2godHhuLCBiYXRjaElkKVxuICAgICAgICAgICAgLm5leHQoKGJhdGNoKSA9PiB7XG4gICAgICAgICAgICBoYXJkQXNzZXJ0KGJhdGNoICE9PSBudWxsKTtcbiAgICAgICAgICAgIGFmZmVjdGVkS2V5cyA9IGJhdGNoLmtleXMoKTtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5tdXRhdGlvblF1ZXVlLnJlbW92ZU11dGF0aW9uQmF0Y2godHhuLCBiYXRjaCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC5tdXRhdGlvblF1ZXVlLnBlcmZvcm1Db25zaXN0ZW5jeUNoZWNrKHR4bikpXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC5kb2N1bWVudE92ZXJsYXlDYWNoZS5yZW1vdmVPdmVybGF5c0ZvckJhdGNoSWQodHhuLCBhZmZlY3RlZEtleXMsIGJhdGNoSWQpKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMucmVjYWxjdWxhdGVBbmRTYXZlT3ZlcmxheXNGb3JEb2N1bWVudEtleXModHhuLCBhZmZlY3RlZEtleXMpKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMuZ2V0RG9jdW1lbnRzKHR4biwgYWZmZWN0ZWRLZXlzKSk7XG4gICAgfSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGxhcmdlc3QgKGxhdGVzdCkgYmF0Y2ggaWQgaW4gbXV0YXRpb24gcXVldWUgdGhhdCBpcyBwZW5kaW5nXG4gKiBzZXJ2ZXIgcmVzcG9uc2UuXG4gKlxuICogUmV0dXJucyBgQkFUQ0hJRF9VTktOT1dOYCBpZiB0aGUgcXVldWUgaXMgZW1wdHkuXG4gKi9cbmZ1bmN0aW9uIGxvY2FsU3RvcmVHZXRIaWdoZXN0VW5hY2tub3dsZWRnZWRCYXRjaElkKGxvY2FsU3RvcmUpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0dldCBoaWdoZXN0IHVuYWNrbm93bGVkZ2VkIGJhdGNoIGlkJywgJ3JlYWRvbmx5JywgdHhuID0+IGxvY2FsU3RvcmVJbXBsLm11dGF0aW9uUXVldWUuZ2V0SGlnaGVzdFVuYWNrbm93bGVkZ2VkQmF0Y2hJZCh0eG4pKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbGFzdCBjb25zaXN0ZW50IHNuYXBzaG90IHByb2Nlc3NlZCAodXNlZCBieSB0aGUgUmVtb3RlU3RvcmUgdG9cbiAqIGRldGVybWluZSB3aGV0aGVyIHRvIGJ1ZmZlciBpbmNvbWluZyBzbmFwc2hvdHMgZnJvbSB0aGUgYmFja2VuZCkuXG4gKi9cbmZ1bmN0aW9uIGxvY2FsU3RvcmVHZXRMYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKGxvY2FsU3RvcmUpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0dldCBsYXN0IHJlbW90ZSBzbmFwc2hvdCB2ZXJzaW9uJywgJ3JlYWRvbmx5JywgdHhuID0+IGxvY2FsU3RvcmVJbXBsLnRhcmdldENhY2hlLmdldExhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24odHhuKSk7XG59XG4vKipcbiAqIFVwZGF0ZXMgdGhlIFwiZ3JvdW5kLXN0YXRlXCIgKHJlbW90ZSkgZG9jdW1lbnRzLiBXZSBhc3N1bWUgdGhhdCB0aGUgcmVtb3RlXG4gKiBldmVudCByZWZsZWN0cyBhbnkgd3JpdGUgYmF0Y2hlcyB0aGF0IGhhdmUgYmVlbiBhY2tub3dsZWRnZWQgb3IgcmVqZWN0ZWRcbiAqIChpLmUuIHdlIGRvIG5vdCByZS1hcHBseSBsb2NhbCBtdXRhdGlvbnMgdG8gdXBkYXRlcyBmcm9tIHRoaXMgZXZlbnQpLlxuICpcbiAqIExvY2FsRG9jdW1lbnRzIGFyZSByZS1jYWxjdWxhdGVkIGlmIHRoZXJlIGFyZSByZW1haW5pbmcgbXV0YXRpb25zIGluIHRoZVxuICogcXVldWUuXG4gKi9cbmZ1bmN0aW9uIGxvY2FsU3RvcmVBcHBseVJlbW90ZUV2ZW50VG9Mb2NhbENhY2hlKGxvY2FsU3RvcmUsIHJlbW90ZUV2ZW50KSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgY29uc3QgcmVtb3RlVmVyc2lvbiA9IHJlbW90ZUV2ZW50LnNuYXBzaG90VmVyc2lvbjtcbiAgICBsZXQgbmV3VGFyZ2V0RGF0YUJ5VGFyZ2V0TWFwID0gbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0O1xuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZVxuICAgICAgICAucnVuVHJhbnNhY3Rpb24oJ0FwcGx5IHJlbW90ZSBldmVudCcsICdyZWFkd3JpdGUtcHJpbWFyeScsIHR4biA9PiB7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50QnVmZmVyID0gbG9jYWxTdG9yZUltcGwucmVtb3RlRG9jdW1lbnRzLm5ld0NoYW5nZUJ1ZmZlcih7XG4gICAgICAgICAgICB0cmFja1JlbW92YWxzOiB0cnVlIC8vIE1ha2Ugc3VyZSBkb2N1bWVudCByZW1vdmFscyBzaG93IHVwIGluIGBnZXROZXdEb2N1bWVudENoYW5nZXMoKWBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJlc2V0IG5ld1RhcmdldERhdGFCeVRhcmdldE1hcCBpbiBjYXNlIHRoaXMgdHJhbnNhY3Rpb24gZ2V0cyByZS1ydW4uXG4gICAgICAgIG5ld1RhcmdldERhdGFCeVRhcmdldE1hcCA9IGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldDtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgcmVtb3RlRXZlbnQudGFyZ2V0Q2hhbmdlcy5mb3JFYWNoKChjaGFuZ2UsIHRhcmdldElkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvbGRUYXJnZXREYXRhID0gbmV3VGFyZ2V0RGF0YUJ5VGFyZ2V0TWFwLmdldCh0YXJnZXRJZCk7XG4gICAgICAgICAgICBpZiAoIW9sZFRhcmdldERhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPbmx5IHVwZGF0ZSB0aGUgcmVtb3RlIGtleXMgaWYgdGhlIHRhcmdldCBpcyBzdGlsbCBhY3RpdmUuIFRoaXNcbiAgICAgICAgICAgIC8vIGVuc3VyZXMgdGhhdCB3ZSBjYW4gcGVyc2lzdCB0aGUgdXBkYXRlZCB0YXJnZXQgZGF0YSBhbG9uZyB3aXRoXG4gICAgICAgICAgICAvLyB0aGUgdXBkYXRlZCBhc3NpZ25tZW50LlxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZVxuICAgICAgICAgICAgICAgIC5yZW1vdmVNYXRjaGluZ0tleXModHhuLCBjaGFuZ2UucmVtb3ZlZERvY3VtZW50cywgdGFyZ2V0SWQpXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZS5hZGRNYXRjaGluZ0tleXModHhuLCBjaGFuZ2UuYWRkZWREb2N1bWVudHMsIHRhcmdldElkKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGxldCBuZXdUYXJnZXREYXRhID0gb2xkVGFyZ2V0RGF0YS53aXRoU2VxdWVuY2VOdW1iZXIodHhuLmN1cnJlbnRTZXF1ZW5jZU51bWJlcik7XG4gICAgICAgICAgICBpZiAocmVtb3RlRXZlbnQudGFyZ2V0TWlzbWF0Y2hlcy5nZXQodGFyZ2V0SWQpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmV3VGFyZ2V0RGF0YSA9IG5ld1RhcmdldERhdGFcbiAgICAgICAgICAgICAgICAgICAgLndpdGhSZXN1bWVUb2tlbihCeXRlU3RyaW5nLkVNUFRZX0JZVEVfU1RSSU5HLCBTbmFwc2hvdFZlcnNpb24ubWluKCkpXG4gICAgICAgICAgICAgICAgICAgIC53aXRoTGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbihTbmFwc2hvdFZlcnNpb24ubWluKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnJlc3VtZVRva2VuLmFwcHJveGltYXRlQnl0ZVNpemUoKSA+IDApIHtcbiAgICAgICAgICAgICAgICBuZXdUYXJnZXREYXRhID0gbmV3VGFyZ2V0RGF0YS53aXRoUmVzdW1lVG9rZW4oY2hhbmdlLnJlc3VtZVRva2VuLCByZW1vdGVWZXJzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1RhcmdldERhdGFCeVRhcmdldE1hcCA9IG5ld1RhcmdldERhdGFCeVRhcmdldE1hcC5pbnNlcnQodGFyZ2V0SWQsIG5ld1RhcmdldERhdGEpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB0YXJnZXQgZGF0YSBpZiB0aGVyZSBhcmUgdGFyZ2V0IGNoYW5nZXMgKG9yIGlmXG4gICAgICAgICAgICAvLyBzdWZmaWNpZW50IHRpbWUgaGFzIHBhc3NlZCBzaW5jZSB0aGUgbGFzdCB1cGRhdGUpLlxuICAgICAgICAgICAgaWYgKHNob3VsZFBlcnNpc3RUYXJnZXREYXRhKG9sZFRhcmdldERhdGEsIG5ld1RhcmdldERhdGEsIGNoYW5nZSkpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGxvY2FsU3RvcmVJbXBsLnRhcmdldENhY2hlLnVwZGF0ZVRhcmdldERhdGEodHhuLCBuZXdUYXJnZXREYXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgY2hhbmdlZERvY3MgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcbiAgICAgICAgbGV0IGV4aXN0ZW5jZUNoYW5nZWRLZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgcmVtb3RlRXZlbnQuZG9jdW1lbnRVcGRhdGVzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGlmIChyZW1vdGVFdmVudC5yZXNvbHZlZExpbWJvRG9jdW1lbnRzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5yZWZlcmVuY2VEZWxlZ2F0ZS51cGRhdGVMaW1ib0RvY3VtZW50KHR4biwga2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBFYWNoIGxvb3AgaXRlcmF0aW9uIG9ubHkgYWZmZWN0cyBpdHMgXCJvd25cIiBkb2MsIHNvIGl0J3Mgc2FmZSB0byBnZXQgYWxsXG4gICAgICAgIC8vIHRoZSByZW1vdGUgZG9jdW1lbnRzIGluIGFkdmFuY2UgaW4gYSBzaW5nbGUgY2FsbC5cbiAgICAgICAgcHJvbWlzZXMucHVzaChwb3B1bGF0ZURvY3VtZW50Q2hhbmdlQnVmZmVyKHR4biwgZG9jdW1lbnRCdWZmZXIsIHJlbW90ZUV2ZW50LmRvY3VtZW50VXBkYXRlcykubmV4dChyZXN1bHQgPT4ge1xuICAgICAgICAgICAgY2hhbmdlZERvY3MgPSByZXN1bHQuY2hhbmdlZERvY3VtZW50cztcbiAgICAgICAgICAgIGV4aXN0ZW5jZUNoYW5nZWRLZXlzID0gcmVzdWx0LmV4aXN0ZW5jZUNoYW5nZWRLZXlzO1xuICAgICAgICB9KSk7XG4gICAgICAgIC8vIEhBQ0s6IFRoZSBvbmx5IHJlYXNvbiB3ZSBhbGxvdyBhIG51bGwgc25hcHNob3QgdmVyc2lvbiBpcyBzbyB0aGF0IHdlXG4gICAgICAgIC8vIGNhbiBzeW50aGVzaXplIHJlbW90ZSBldmVudHMgd2hlbiB3ZSBnZXQgcGVybWlzc2lvbiBkZW5pZWQgZXJyb3JzIHdoaWxlXG4gICAgICAgIC8vIHRyeWluZyB0byByZXNvbHZlIHRoZSBzdGF0ZSBvZiBhIGxvY2FsbHkgY2FjaGVkIGRvY3VtZW50IHRoYXQgaXMgaW5cbiAgICAgICAgLy8gbGltYm8uXG4gICAgICAgIGlmICghcmVtb3RlVmVyc2lvbi5pc0VxdWFsKFNuYXBzaG90VmVyc2lvbi5taW4oKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVJlbW90ZVZlcnNpb24gPSBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZVxuICAgICAgICAgICAgICAgIC5nZXRMYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKHR4bilcbiAgICAgICAgICAgICAgICAubmV4dChsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGUuc2V0VGFyZ2V0c01ldGFkYXRhKHR4biwgdHhuLmN1cnJlbnRTZXF1ZW5jZU51bWJlciwgcmVtb3RlVmVyc2lvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godXBkYXRlUmVtb3RlVmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZG9jdW1lbnRCdWZmZXIuYXBwbHkodHhuKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLmxvY2FsRG9jdW1lbnRzLmdldExvY2FsVmlld09mRG9jdW1lbnRzKHR4biwgY2hhbmdlZERvY3MsIGV4aXN0ZW5jZUNoYW5nZWRLZXlzKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGNoYW5nZWREb2NzKTtcbiAgICB9KVxuICAgICAgICAudGhlbihjaGFuZ2VkRG9jcyA9PiB7XG4gICAgICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldCA9IG5ld1RhcmdldERhdGFCeVRhcmdldE1hcDtcbiAgICAgICAgcmV0dXJuIGNoYW5nZWREb2NzO1xuICAgIH0pO1xufVxuLyoqXG4gKiBQb3B1bGF0ZXMgZG9jdW1lbnQgY2hhbmdlIGJ1ZmZlciB3aXRoIGRvY3VtZW50cyBmcm9tIGJhY2tlbmQgb3IgYSBidW5kbGUuXG4gKiBSZXR1cm5zIHRoZSBkb2N1bWVudCBjaGFuZ2VzIHJlc3VsdGluZyBmcm9tIGFwcGx5aW5nIHRob3NlIGRvY3VtZW50cywgYW5kXG4gKiBhbHNvIGEgc2V0IG9mIGRvY3VtZW50cyB3aG9zZSBleGlzdGVuY2Ugc3RhdGUgYXJlIGNoYW5nZWQgYXMgYSByZXN1bHQuXG4gKlxuICogQHBhcmFtIHR4biAtIFRyYW5zYWN0aW9uIHRvIHVzZSB0byByZWFkIGV4aXN0aW5nIGRvY3VtZW50cyBmcm9tIHN0b3JhZ2UuXG4gKiBAcGFyYW0gZG9jdW1lbnRCdWZmZXIgLSBEb2N1bWVudCBidWZmZXIgdG8gY29sbGVjdCB0aGUgcmVzdWx0ZWQgY2hhbmdlcyB0byBiZVxuICogICAgICAgIGFwcGxpZWQgdG8gc3RvcmFnZS5cbiAqIEBwYXJhbSBkb2N1bWVudHMgLSBEb2N1bWVudHMgdG8gYmUgYXBwbGllZC5cbiAqL1xuZnVuY3Rpb24gcG9wdWxhdGVEb2N1bWVudENoYW5nZUJ1ZmZlcih0eG4sIGRvY3VtZW50QnVmZmVyLCBkb2N1bWVudHMpIHtcbiAgICBsZXQgdXBkYXRlZEtleXMgPSBkb2N1bWVudEtleVNldCgpO1xuICAgIGxldCBleGlzdGVuY2VDaGFuZ2VkS2V5cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgZG9jdW1lbnRzLmZvckVhY2goayA9PiAodXBkYXRlZEtleXMgPSB1cGRhdGVkS2V5cy5hZGQoaykpKTtcbiAgICByZXR1cm4gZG9jdW1lbnRCdWZmZXIuZ2V0RW50cmllcyh0eG4sIHVwZGF0ZWRLZXlzKS5uZXh0KGV4aXN0aW5nRG9jcyA9PiB7XG4gICAgICAgIGxldCBjaGFuZ2VkRG9jdW1lbnRzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XG4gICAgICAgIGRvY3VtZW50cy5mb3JFYWNoKChrZXksIGRvYykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdEb2MgPSBleGlzdGluZ0RvY3MuZ2V0KGtleSk7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBzZWUgaWYgdGhlcmUgaXMgYSBleGlzdGVuY2Ugc3RhdGUgY2hhbmdlIGZvciB0aGlzIGRvY3VtZW50LlxuICAgICAgICAgICAgaWYgKGRvYy5pc0ZvdW5kRG9jdW1lbnQoKSAhPT0gZXhpc3RpbmdEb2MuaXNGb3VuZERvY3VtZW50KCkpIHtcbiAgICAgICAgICAgICAgICBleGlzdGVuY2VDaGFuZ2VkS2V5cyA9IGV4aXN0ZW5jZUNoYW5nZWRLZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm90ZTogVGhlIG9yZGVyIG9mIHRoZSBzdGVwcyBiZWxvdyBpcyBpbXBvcnRhbnQsIHNpbmNlIHdlIHdhbnRcbiAgICAgICAgICAgIC8vIHRvIGVuc3VyZSB0aGF0IHJlamVjdGVkIGxpbWJvIHJlc29sdXRpb25zICh3aGljaCBmYWJyaWNhdGVcbiAgICAgICAgICAgIC8vIE5vRG9jdW1lbnRzIHdpdGggU25hcHNob3RWZXJzaW9uLm1pbigpKSBuZXZlciBhZGQgZG9jdW1lbnRzIHRvXG4gICAgICAgICAgICAvLyBjYWNoZS5cbiAgICAgICAgICAgIGlmIChkb2MuaXNOb0RvY3VtZW50KCkgJiYgZG9jLnZlcnNpb24uaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpKSB7XG4gICAgICAgICAgICAgICAgLy8gTm9Eb2N1bWVudHMgd2l0aCBTbmFwc2hvdFZlcnNpb24ubWluKCkgYXJlIHVzZWQgaW4gbWFudWZhY3R1cmVkXG4gICAgICAgICAgICAgICAgLy8gZXZlbnRzLiBXZSByZW1vdmUgdGhlc2UgZG9jdW1lbnRzIGZyb20gY2FjaGUgc2luY2Ugd2UgbG9zdFxuICAgICAgICAgICAgICAgIC8vIGFjY2Vzcy5cbiAgICAgICAgICAgICAgICBkb2N1bWVudEJ1ZmZlci5yZW1vdmVFbnRyeShrZXksIGRvYy5yZWFkVGltZSk7XG4gICAgICAgICAgICAgICAgY2hhbmdlZERvY3VtZW50cyA9IGNoYW5nZWREb2N1bWVudHMuaW5zZXJ0KGtleSwgZG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFleGlzdGluZ0RvYy5pc1ZhbGlkRG9jdW1lbnQoKSB8fFxuICAgICAgICAgICAgICAgIGRvYy52ZXJzaW9uLmNvbXBhcmVUbyhleGlzdGluZ0RvYy52ZXJzaW9uKSA+IDAgfHxcbiAgICAgICAgICAgICAgICAoZG9jLnZlcnNpb24uY29tcGFyZVRvKGV4aXN0aW5nRG9jLnZlcnNpb24pID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nRG9jLmhhc1BlbmRpbmdXcml0ZXMpKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnRCdWZmZXIuYWRkRW50cnkoZG9jKTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkRG9jdW1lbnRzID0gY2hhbmdlZERvY3VtZW50cy5pbnNlcnQoa2V5LCBkb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRiLCAnSWdub3Jpbmcgb3V0ZGF0ZWQgd2F0Y2ggdXBkYXRlIGZvciAnLCBrZXksICcuIEN1cnJlbnQgdmVyc2lvbjonLCBleGlzdGluZ0RvYy52ZXJzaW9uLCAnIFdhdGNoIHZlcnNpb246JywgZG9jLnZlcnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlZERvY3VtZW50cywgZXhpc3RlbmNlQ2hhbmdlZEtleXMgfTtcbiAgICB9KTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBuZXdUYXJnZXREYXRhIHNob3VsZCBiZSBwZXJzaXN0ZWQgZHVyaW5nIGFuIHVwZGF0ZSBvZlxuICogYW4gYWN0aXZlIHRhcmdldC4gVGFyZ2V0RGF0YSBzaG91bGQgYWx3YXlzIGJlIHBlcnNpc3RlZCB3aGVuIGEgdGFyZ2V0IGlzXG4gKiBiZWluZyByZWxlYXNlZCBhbmQgc2hvdWxkIG5vdCBjYWxsIHRoaXMgZnVuY3Rpb24uXG4gKlxuICogV2hpbGUgdGhlIHRhcmdldCBpcyBhY3RpdmUsIFRhcmdldERhdGEgdXBkYXRlcyBjYW4gYmUgb21pdHRlZCB3aGVuIG5vdGhpbmdcbiAqIGFib3V0IHRoZSB0YXJnZXQgaGFzIGNoYW5nZWQgZXhjZXB0IG1ldGFkYXRhIGxpa2UgdGhlIHJlc3VtZSB0b2tlbiBvclxuICogc25hcHNob3QgdmVyc2lvbi4gT2NjYXNpb25hbGx5IGl0J3Mgd29ydGggdGhlIGV4dHJhIHdyaXRlIHRvIHByZXZlbnQgdGhlc2VcbiAqIHZhbHVlcyBmcm9tIGdldHRpbmcgdG9vIHN0YWxlIGFmdGVyIGEgY3Jhc2gsIGJ1dCB0aGlzIGRvZXNuJ3QgaGF2ZSB0byBiZVxuICogdG9vIGZyZXF1ZW50LlxuICovXG5mdW5jdGlvbiBzaG91bGRQZXJzaXN0VGFyZ2V0RGF0YShvbGRUYXJnZXREYXRhLCBuZXdUYXJnZXREYXRhLCBjaGFuZ2UpIHtcbiAgICAvLyBBbHdheXMgcGVyc2lzdCB0YXJnZXQgZGF0YSBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgYSByZXN1bWUgdG9rZW4uXG4gICAgaWYgKG9sZFRhcmdldERhdGEucmVzdW1lVG9rZW4uYXBwcm94aW1hdGVCeXRlU2l6ZSgpID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBEb24ndCBhbGxvdyByZXN1bWUgdG9rZW4gY2hhbmdlcyB0byBiZSBidWZmZXJlZCBpbmRlZmluaXRlbHkuIFRoaXNcbiAgICAvLyBhbGxvd3MgdXMgdG8gYmUgcmVhc29uYWJseSB1cC10by1kYXRlIGFmdGVyIGEgY3Jhc2ggYW5kIGF2b2lkcyBuZWVkaW5nXG4gICAgLy8gdG8gbG9vcCBvdmVyIGFsbCBhY3RpdmUgcXVlcmllcyBvbiBzaHV0ZG93bi4gRXNwZWNpYWxseSBpbiB0aGUgYnJvd3NlclxuICAgIC8vIHdlIG1heSBub3QgZ2V0IHRpbWUgdG8gZG8gYW55dGhpbmcgaW50ZXJlc3Rpbmcgd2hpbGUgdGhlIGN1cnJlbnQgdGFiIGlzXG4gICAgLy8gY2xvc2luZy5cbiAgICBjb25zdCB0aW1lRGVsdGEgPSBuZXdUYXJnZXREYXRhLnNuYXBzaG90VmVyc2lvbi50b01pY3Jvc2Vjb25kcygpIC1cbiAgICAgICAgb2xkVGFyZ2V0RGF0YS5zbmFwc2hvdFZlcnNpb24udG9NaWNyb3NlY29uZHMoKTtcbiAgICBpZiAodGltZURlbHRhID49IFJFU1VNRV9UT0tFTl9NQVhfQUdFX01JQ1JPUykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlIGlmIHRoZSBvbmx5IHRoaW5nIHRoYXQgaGFzIGNoYW5nZWQgYWJvdXQgYSB0YXJnZXQgaXMgaXRzIHJlc3VtZVxuICAgIC8vIHRva2VuIGl0J3Mgbm90IHdvcnRoIHBlcnNpc3RpbmcuIE5vdGUgdGhhdCB0aGUgUmVtb3RlU3RvcmUga2VlcHMgYW5cbiAgICAvLyBpbi1tZW1vcnkgdmlldyBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSB0YXJnZXRzIHdoaWNoIGluY2x1ZGVzIHRoZSBjdXJyZW50XG4gICAgLy8gcmVzdW1lIHRva2VuLCBzbyBzdHJlYW0gZmFpbHVyZSBvciB1c2VyIGNoYW5nZXMgd2lsbCBzdGlsbCB1c2UgYW5cbiAgICAvLyB1cC10by1kYXRlIHJlc3VtZSB0b2tlbiByZWdhcmRsZXNzIG9mIHdoYXQgd2UgZG8gaGVyZS5cbiAgICBjb25zdCBjaGFuZ2VzID0gY2hhbmdlLmFkZGVkRG9jdW1lbnRzLnNpemUgK1xuICAgICAgICBjaGFuZ2UubW9kaWZpZWREb2N1bWVudHMuc2l6ZSArXG4gICAgICAgIGNoYW5nZS5yZW1vdmVkRG9jdW1lbnRzLnNpemU7XG4gICAgcmV0dXJuIGNoYW5nZXMgPiAwO1xufVxuLyoqXG4gKiBOb3RpZmllcyBsb2NhbCBzdG9yZSBvZiB0aGUgY2hhbmdlZCB2aWV3cyB0byBsb2NhbGx5IHBpbiBkb2N1bWVudHMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvY2FsU3RvcmVOb3RpZnlMb2NhbFZpZXdDaGFuZ2VzKGxvY2FsU3RvcmUsIHZpZXdDaGFuZ2VzKSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ25vdGlmeUxvY2FsVmlld0NoYW5nZXMnLCAncmVhZHdyaXRlJywgdHhuID0+IHtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaCh2aWV3Q2hhbmdlcywgKHZpZXdDaGFuZ2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2godmlld0NoYW5nZS5hZGRlZEtleXMsIChrZXkpID0+IGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJlZmVyZW5jZURlbGVnYXRlLmFkZFJlZmVyZW5jZSh0eG4sIHZpZXdDaGFuZ2UudGFyZ2V0SWQsIGtleSkpLm5leHQoKCkgPT4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2godmlld0NoYW5nZS5yZW1vdmVkS2V5cywgKGtleSkgPT4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucmVmZXJlbmNlRGVsZWdhdGUucmVtb3ZlUmVmZXJlbmNlKHR4biwgdmlld0NoYW5nZS50YXJnZXRJZCwga2V5KSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoaXNJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGUpKSB7XG4gICAgICAgICAgICAvLyBJZiBgbm90aWZ5TG9jYWxWaWV3Q2hhbmdlc2AgZmFpbHMsIHdlIGRpZCBub3QgYWR2YW5jZSB0aGUgc2VxdWVuY2VcbiAgICAgICAgICAgIC8vIG51bWJlciBmb3IgdGhlIGRvY3VtZW50cyB0aGF0IHdlcmUgaW5jbHVkZWQgaW4gdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgICAgICAgIC8vIFRoaXMgbWlnaHQgdHJpZ2dlciB0aGVtIHRvIGJlIGRlbGV0ZWQgZWFybGllciB0aGFuIHRoZXkgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyB3b3VsZCBoYXZlLCBidXQgaXQgc2hvdWxkIG5vdCBpbnZhbGlkYXRlIHRoZSBpbnRlZ3JpdHkgb2YgdGhlIGRhdGEuXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGIsICdGYWlsZWQgdG8gdXBkYXRlIHNlcXVlbmNlIG51bWJlcnM6ICcgKyBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCB2aWV3Q2hhbmdlIG9mIHZpZXdDaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gdmlld0NoYW5nZS50YXJnZXRJZDtcbiAgICAgICAgaWYgKCF2aWV3Q2hhbmdlLmZyb21DYWNoZSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0RGF0YSA9IGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldC5nZXQodGFyZ2V0SWQpO1xuICAgICAgICAgICAgLy8gQWR2YW5jZSB0aGUgbGFzdCBsaW1ibyBmcmVlIHNuYXBzaG90IHZlcnNpb25cbiAgICAgICAgICAgIGNvbnN0IGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24gPSB0YXJnZXREYXRhLnNuYXBzaG90VmVyc2lvbjtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRUYXJnZXREYXRhID0gdGFyZ2V0RGF0YS53aXRoTGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbihsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uKTtcbiAgICAgICAgICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldCA9XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0Lmluc2VydCh0YXJnZXRJZCwgdXBkYXRlZFRhcmdldERhdGEpO1xuICAgICAgICAgICAgLy8gVE9ETyhiLzI3MjU2NDMxNik6IEFwcGx5IHRoZSBvcHRpbWl6YXRpb24gZG9uZSBvbiBvdGhlciBwbGF0Zm9ybXMuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgcHJvYmxlbSBmb3Igd2ViIGJlY2F1c2Ugc2F2aW5nIHRoZSB1cGRhdGVkIHRhcmdldERhdGEgZnJvbVxuICAgICAgICAgICAgLy8gbm9uLXByaW1hcnkgY2xpZW50IGNvbmZsaWN0cyB3aXRoIHdoYXQgcHJpbWFyeSBjbGllbnQgc2F2ZWQuXG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEdldHMgdGhlIG11dGF0aW9uIGJhdGNoIGFmdGVyIHRoZSBwYXNzZWQgaW4gYmF0Y2hJZCBpbiB0aGUgbXV0YXRpb24gcXVldWVcbiAqIG9yIG51bGwgaWYgZW1wdHkuXG4gKiBAcGFyYW0gYWZ0ZXJCYXRjaElkIC0gSWYgcHJvdmlkZWQsIHRoZSBiYXRjaCB0byBzZWFyY2ggYWZ0ZXIuXG4gKiBAcmV0dXJucyBUaGUgbmV4dCBtdXRhdGlvbiBvciBudWxsIGlmIHRoZXJlIHdhc24ndCBvbmUuXG4gKi9cbmZ1bmN0aW9uIGxvY2FsU3RvcmVHZXROZXh0TXV0YXRpb25CYXRjaChsb2NhbFN0b3JlLCBhZnRlckJhdGNoSWQpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0dldCBuZXh0IG11dGF0aW9uIGJhdGNoJywgJ3JlYWRvbmx5JywgdHhuID0+IHtcbiAgICAgICAgaWYgKGFmdGVyQmF0Y2hJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhZnRlckJhdGNoSWQgPSBCQVRDSElEX1VOS05PV047XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLm11dGF0aW9uUXVldWUuZ2V0TmV4dE11dGF0aW9uQmF0Y2hBZnRlckJhdGNoSWQodHhuLCBhZnRlckJhdGNoSWQpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBSZWFkcyB0aGUgY3VycmVudCB2YWx1ZSBvZiBhIERvY3VtZW50IHdpdGggYSBnaXZlbiBrZXkgb3IgbnVsbCBpZiBub3RcbiAqIGZvdW5kIC0gdXNlZCBmb3IgdGVzdGluZy5cbiAqL1xuZnVuY3Rpb24gbG9jYWxTdG9yZVJlYWREb2N1bWVudChsb2NhbFN0b3JlLCBrZXkpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ3JlYWQgZG9jdW1lbnQnLCAncmVhZG9ubHknLCB0eG4gPT4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMuZ2V0RG9jdW1lbnQodHhuLCBrZXkpKTtcbn1cbi8qKlxuICogQXNzaWducyB0aGUgZ2l2ZW4gdGFyZ2V0IGFuIGludGVybmFsIElEIHNvIHRoYXQgaXRzIHJlc3VsdHMgY2FuIGJlIHBpbm5lZCBzb1xuICogdGhleSBkb24ndCBnZXQgR0MnZC4gQSB0YXJnZXQgbXVzdCBiZSBhbGxvY2F0ZWQgaW4gdGhlIGxvY2FsIHN0b3JlIGJlZm9yZVxuICogdGhlIHN0b3JlIGNhbiBiZSB1c2VkIHRvIG1hbmFnZSBpdHMgdmlldy5cbiAqXG4gKiBBbGxvY2F0aW5nIGFuIGFscmVhZHkgYWxsb2NhdGVkIGBUYXJnZXRgIHdpbGwgcmV0dXJuIHRoZSBleGlzdGluZyBgVGFyZ2V0RGF0YWBcbiAqIGZvciB0aGF0IGBUYXJnZXRgLlxuICovXG5mdW5jdGlvbiBsb2NhbFN0b3JlQWxsb2NhdGVUYXJnZXQobG9jYWxTdG9yZSwgdGFyZ2V0KSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlXG4gICAgICAgIC5ydW5UcmFuc2FjdGlvbignQWxsb2NhdGUgdGFyZ2V0JywgJ3JlYWR3cml0ZScsIHR4biA9PiB7XG4gICAgICAgIGxldCB0YXJnZXREYXRhO1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGVcbiAgICAgICAgICAgIC5nZXRUYXJnZXREYXRhKHR4biwgdGFyZ2V0KVxuICAgICAgICAgICAgLm5leHQoKGNhY2hlZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgdGFyZ2V0IGhhcyBiZWVuIGxpc3RlbmVkIHRvIHByZXZpb3VzbHksIHNvIHJldXNlIHRoZVxuICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzIHRhcmdldElELlxuICAgICAgICAgICAgICAgIC8vIFRPRE8obWNnKTogZnJlc2hlbiBsYXN0IGFjY2Vzc2VkIGRhdGU/XG4gICAgICAgICAgICAgICAgdGFyZ2V0RGF0YSA9IGNhY2hlZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGFyZ2V0RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGVcbiAgICAgICAgICAgICAgICAgICAgLmFsbG9jYXRlVGFyZ2V0SWQodHhuKVxuICAgICAgICAgICAgICAgICAgICAubmV4dCh0YXJnZXRJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldERhdGEgPSBuZXcgVGFyZ2V0RGF0YSh0YXJnZXQsIHRhcmdldElkLCBcIlRhcmdldFB1cnBvc2VMaXN0ZW5cIiAvKiBUYXJnZXRQdXJwb3NlLkxpc3RlbiAqLywgdHhuLmN1cnJlbnRTZXF1ZW5jZU51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZFRhcmdldERhdGEodHhuLCB0YXJnZXREYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gdGFyZ2V0RGF0YSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pXG4gICAgICAgIC50aGVuKHRhcmdldERhdGEgPT4ge1xuICAgICAgICAvLyBJZiBNdWx0aS1UYWIgaXMgZW5hYmxlZCwgdGhlIGV4aXN0aW5nIHRhcmdldCBkYXRhIG1heSBiZSBuZXdlciB0aGFuXG4gICAgICAgIC8vIHRoZSBpbi1tZW1vcnkgZGF0YVxuICAgICAgICBjb25zdCBjYWNoZWRUYXJnZXREYXRhID0gbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0LmdldCh0YXJnZXREYXRhLnRhcmdldElkKTtcbiAgICAgICAgaWYgKGNhY2hlZFRhcmdldERhdGEgPT09IG51bGwgfHxcbiAgICAgICAgICAgIHRhcmdldERhdGEuc25hcHNob3RWZXJzaW9uLmNvbXBhcmVUbyhjYWNoZWRUYXJnZXREYXRhLnNuYXBzaG90VmVyc2lvbikgPlxuICAgICAgICAgICAgICAgIDApIHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldCA9XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0Lmluc2VydCh0YXJnZXREYXRhLnRhcmdldElkLCB0YXJnZXREYXRhKTtcbiAgICAgICAgICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldElkQnlUYXJnZXQuc2V0KHRhcmdldCwgdGFyZ2V0RGF0YS50YXJnZXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldERhdGE7XG4gICAgfSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIFRhcmdldERhdGEgYXMgc2VlbiBieSB0aGUgTG9jYWxTdG9yZSwgaW5jbHVkaW5nIHVwZGF0ZXMgdGhhdCBtYXlcbiAqIGhhdmUgbm90IHlldCBiZWVuIHBlcnNpc3RlZCB0byB0aGUgVGFyZ2V0Q2FjaGUuXG4gKi9cbi8vIFZpc2libGUgZm9yIHRlc3RpbmcuXG5mdW5jdGlvbiBsb2NhbFN0b3JlR2V0VGFyZ2V0RGF0YShsb2NhbFN0b3JlLCB0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgY29uc3QgdGFyZ2V0SWQgPSBsb2NhbFN0b3JlSW1wbC50YXJnZXRJZEJ5VGFyZ2V0LmdldCh0YXJnZXQpO1xuICAgIGlmICh0YXJnZXRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShsb2NhbFN0b3JlSW1wbC50YXJnZXREYXRhQnlUYXJnZXQuZ2V0KHRhcmdldElkKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGUuZ2V0VGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0KTtcbiAgICB9XG59XG4vKipcbiAqIFVucGlucyBhbGwgdGhlIGRvY3VtZW50cyBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIHRhcmdldC4gSWZcbiAqIGBrZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YWAgaXMgc2V0IHRvIGZhbHNlIGFuZCBFYWdlciBHQyBlbmFibGVkLCB0aGUgbWV0aG9kXG4gKiBkaXJlY3RseSByZW1vdmVzIHRoZSBhc3NvY2lhdGVkIHRhcmdldCBkYXRhIGZyb20gdGhlIHRhcmdldCBjYWNoZS5cbiAqXG4gKiBSZWxlYXNpbmcgYSBub24tZXhpc3RpbmcgYFRhcmdldGAgaXMgYSBuby1vcC5cbiAqL1xuLy8gUE9SVElORyBOT1RFOiBga2VlcFBlcnNpc3RlZFRhcmdldERhdGFgIGlzIG11bHRpLXRhYiBvbmx5LlxuYXN5bmMgZnVuY3Rpb24gbG9jYWxTdG9yZVJlbGVhc2VUYXJnZXQobG9jYWxTdG9yZSwgdGFyZ2V0SWQsIGtlZXBQZXJzaXN0ZWRUYXJnZXREYXRhKSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgY29uc3QgdGFyZ2V0RGF0YSA9IGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldC5nZXQodGFyZ2V0SWQpO1xuICAgIGNvbnN0IG1vZGUgPSBrZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YSA/ICdyZWFkd3JpdGUnIDogJ3JlYWR3cml0ZS1wcmltYXJ5JztcbiAgICB0cnkge1xuICAgICAgICBpZiAoIWtlZXBQZXJzaXN0ZWRUYXJnZXREYXRhKSB7XG4gICAgICAgICAgICBhd2FpdCBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignUmVsZWFzZSB0YXJnZXQnLCBtb2RlLCB0eG4gPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5yZWZlcmVuY2VEZWxlZ2F0ZS5yZW1vdmVUYXJnZXQodHhuLCB0YXJnZXREYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChpc0luZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoZSkpIHtcbiAgICAgICAgICAgIC8vIEFsbCBgcmVsZWFzZVRhcmdldGAgZG9lcyBpcyByZWNvcmQgdGhlIGZpbmFsIG1ldGFkYXRhIHN0YXRlIGZvciB0aGVcbiAgICAgICAgICAgIC8vIHRhcmdldCwgYnV0IHdlJ3ZlIGJlZW4gcmVjb3JkaW5nIHRoaXMgcGVyaW9kaWNhbGx5IGR1cmluZyB0YXJnZXRcbiAgICAgICAgICAgIC8vIGFjdGl2aXR5LiBJZiB3ZSBsb3NlIHRoaXMgd3JpdGUgdGhpcyBjb3VsZCBjYXVzZSBhIHZlcnkgc2xpZ2h0XG4gICAgICAgICAgICAvLyBkaWZmZXJlbmNlIGluIHRoZSBvcmRlciBvZiB0YXJnZXQgZGVsZXRpb24gZHVyaW5nIEdDLCBidXQgd2VcbiAgICAgICAgICAgIC8vIGRvbid0IGRlZmluZSBleGFjdCBMUlUgc2VtYW50aWNzIHNvIHRoaXMgaXMgYWNjZXB0YWJsZS5cbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckYiwgYEZhaWxlZCB0byB1cGRhdGUgc2VxdWVuY2UgbnVtYmVycyBmb3IgdGFyZ2V0ICR7dGFyZ2V0SWR9OiAke2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldCA9XG4gICAgICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldC5yZW1vdmUodGFyZ2V0SWQpO1xuICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldElkQnlUYXJnZXQuZGVsZXRlKHRhcmdldERhdGEudGFyZ2V0KTtcbn1cbi8qKlxuICogUnVucyB0aGUgc3BlY2lmaWVkIHF1ZXJ5IGFnYWluc3QgdGhlIGxvY2FsIHN0b3JlIGFuZCByZXR1cm5zIHRoZSByZXN1bHRzLFxuICogcG90ZW50aWFsbHkgdGFraW5nIGFkdmFudGFnZSBvZiBxdWVyeSBkYXRhIGZyb20gcHJldmlvdXMgZXhlY3V0aW9ucyAoc3VjaFxuICogYXMgdGhlIHNldCBvZiByZW1vdGUga2V5cykuXG4gKlxuICogQHBhcmFtIHVzZVByZXZpb3VzUmVzdWx0cyAtIFdoZXRoZXIgcmVzdWx0cyBmcm9tIHByZXZpb3VzIGV4ZWN1dGlvbnMgY2FuXG4gKiBiZSB1c2VkIHRvIG9wdGltaXplIHRoaXMgcXVlcnkgZXhlY3V0aW9uLlxuICovXG5mdW5jdGlvbiBsb2NhbFN0b3JlRXhlY3V0ZVF1ZXJ5KGxvY2FsU3RvcmUsIHF1ZXJ5LCB1c2VQcmV2aW91c1Jlc3VsdHMpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICBsZXQgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiA9IFNuYXBzaG90VmVyc2lvbi5taW4oKTtcbiAgICBsZXQgcmVtb3RlS2V5cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdFeGVjdXRlIHF1ZXJ5JywgJ3JlYWR3cml0ZScsIC8vIFVzZSByZWFkd3JpdGUgaW5zdGVhZCBvZiByZWFkb25seSBzbyBpbmRleGVzIGNhbiBiZSBjcmVhdGVkXG4gICAgLy8gVXNlIHJlYWR3cml0ZSBpbnN0ZWFkIG9mIHJlYWRvbmx5IHNvIGluZGV4ZXMgY2FuIGJlIGNyZWF0ZWRcbiAgICB0eG4gPT4ge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUdldFRhcmdldERhdGEobG9jYWxTdG9yZUltcGwsIHR4biwgcXVlcnlUb1RhcmdldChxdWVyeSkpXG4gICAgICAgICAgICAubmV4dCh0YXJnZXREYXRhID0+IHtcbiAgICAgICAgICAgIGlmICh0YXJnZXREYXRhKSB7XG4gICAgICAgICAgICAgICAgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiA9XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldERhdGEubGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGVcbiAgICAgICAgICAgICAgICAgICAgLmdldE1hdGNoaW5nS2V5c0ZvclRhcmdldElkKHR4biwgdGFyZ2V0RGF0YS50YXJnZXRJZClcbiAgICAgICAgICAgICAgICAgICAgLm5leHQocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlS2V5cyA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLnF1ZXJ5RW5naW5lLmdldERvY3VtZW50c01hdGNoaW5nUXVlcnkodHhuLCBxdWVyeSwgdXNlUHJldmlvdXNSZXN1bHRzXG4gICAgICAgICAgICA/IGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb25cbiAgICAgICAgICAgIDogU25hcHNob3RWZXJzaW9uLm1pbigpLCB1c2VQcmV2aW91c1Jlc3VsdHMgPyByZW1vdGVLZXlzIDogZG9jdW1lbnRLZXlTZXQoKSkpXG4gICAgICAgICAgICAubmV4dChkb2N1bWVudHMgPT4ge1xuICAgICAgICAgICAgc2V0TWF4UmVhZFRpbWUobG9jYWxTdG9yZUltcGwsIHF1ZXJ5Q29sbGVjdGlvbkdyb3VwKHF1ZXJ5KSwgZG9jdW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiB7IGRvY3VtZW50cywgcmVtb3RlS2V5cyB9O1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGFwcGx5V3JpdGVUb1JlbW90ZURvY3VtZW50cyhsb2NhbFN0b3JlSW1wbCwgdHhuLCBiYXRjaFJlc3VsdCwgZG9jdW1lbnRCdWZmZXIpIHtcbiAgICBjb25zdCBiYXRjaCA9IGJhdGNoUmVzdWx0LmJhdGNoO1xuICAgIGNvbnN0IGRvY0tleXMgPSBiYXRjaC5rZXlzKCk7XG4gICAgbGV0IHByb21pc2VDaGFpbiA9IFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgZG9jS2V5cy5mb3JFYWNoKGRvY0tleSA9PiB7XG4gICAgICAgIHByb21pc2VDaGFpbiA9IHByb21pc2VDaGFpblxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZG9jdW1lbnRCdWZmZXIuZ2V0RW50cnkodHhuLCBkb2NLZXkpKVxuICAgICAgICAgICAgLm5leHQoZG9jID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFja1ZlcnNpb24gPSBiYXRjaFJlc3VsdC5kb2NWZXJzaW9ucy5nZXQoZG9jS2V5KTtcbiAgICAgICAgICAgIGhhcmRBc3NlcnQoYWNrVmVyc2lvbiAhPT0gbnVsbCk7XG4gICAgICAgICAgICBpZiAoZG9jLnZlcnNpb24uY29tcGFyZVRvKGFja1ZlcnNpb24pIDwgMCkge1xuICAgICAgICAgICAgICAgIGJhdGNoLmFwcGx5VG9SZW1vdGVEb2N1bWVudChkb2MsIGJhdGNoUmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAoZG9jLmlzVmFsaWREb2N1bWVudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHVzZSB0aGUgY29tbWl0VmVyc2lvbiBhcyB0aGUgcmVhZFRpbWUgcmF0aGVyIHRoYW4gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvY3VtZW50J3MgdXBkYXRlVGltZSBzaW5jZSB0aGUgdXBkYXRlVGltZSBpcyBub3QgYWR2YW5jZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHVwZGF0ZXMgdGhhdCBkbyBub3QgbW9kaWZ5IHRoZSB1bmRlcmx5aW5nIGRvY3VtZW50LlxuICAgICAgICAgICAgICAgICAgICBkb2Muc2V0UmVhZFRpbWUoYmF0Y2hSZXN1bHQuY29tbWl0VmVyc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50QnVmZmVyLmFkZEVudHJ5KGRvYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZUNoYWluLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwubXV0YXRpb25RdWV1ZS5yZW1vdmVNdXRhdGlvbkJhdGNoKHR4biwgYmF0Y2gpKTtcbn1cbi8qKiBSZXR1cm5zIHRoZSBsb2NhbCB2aWV3IG9mIHRoZSBkb2N1bWVudHMgYWZmZWN0ZWQgYnkgYSBtdXRhdGlvbiBiYXRjaC4gKi9cbi8vIFBPUlRJTkcgTk9URTogTXVsdGktVGFiIG9ubHkuXG5mdW5jdGlvbiBsb2NhbFN0b3JlTG9va3VwTXV0YXRpb25Eb2N1bWVudHMobG9jYWxTdG9yZSwgYmF0Y2hJZCkge1xuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xuICAgIGNvbnN0IG11dGF0aW9uUXVldWVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmVJbXBsLm11dGF0aW9uUXVldWUpO1xuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignTG9va3VwIG11dGF0aW9uIGRvY3VtZW50cycsICdyZWFkb25seScsIHR4biA9PiB7XG4gICAgICAgIHJldHVybiBtdXRhdGlvblF1ZXVlSW1wbC5sb29rdXBNdXRhdGlvbktleXModHhuLCBiYXRjaElkKS5uZXh0KGtleXMgPT4ge1xuICAgICAgICAgICAgaWYgKGtleXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMuZ2V0RG9jdW1lbnRzKHR4biwga2V5cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cbmZ1bmN0aW9uIGxvY2FsU3RvcmVSZW1vdmVDYWNoZWRNdXRhdGlvbkJhdGNoTWV0YWRhdGEobG9jYWxTdG9yZSwgYmF0Y2hJZCkge1xuICAgIGNvbnN0IG11dGF0aW9uUXVldWVJbXBsID0gZGVidWdDYXN0KGRlYnVnQ2FzdChsb2NhbFN0b3JlLCBMb2NhbFN0b3JlSW1wbCkubXV0YXRpb25RdWV1ZSk7XG4gICAgbXV0YXRpb25RdWV1ZUltcGwucmVtb3ZlQ2FjaGVkTXV0YXRpb25LZXlzKGJhdGNoSWQpO1xufVxuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cbmZ1bmN0aW9uIGxvY2FsU3RvcmVHZXRBY3RpdmVDbGllbnRzKGxvY2FsU3RvcmUpIHtcbiAgICBjb25zdCBwZXJzaXN0ZW5jZUltcGwgPSBkZWJ1Z0Nhc3QoZGVidWdDYXN0KGxvY2FsU3RvcmUsIExvY2FsU3RvcmVJbXBsKS5wZXJzaXN0ZW5jZSk7XG4gICAgcmV0dXJuIHBlcnNpc3RlbmNlSW1wbC5nZXRBY3RpdmVDbGllbnRzKCk7XG59XG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxuZnVuY3Rpb24gbG9jYWxTdG9yZUdldENhY2hlZFRhcmdldChsb2NhbFN0b3JlLCB0YXJnZXRJZCkge1xuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xuICAgIGNvbnN0IHRhcmdldENhY2hlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZSk7XG4gICAgY29uc3QgY2FjaGVkVGFyZ2V0RGF0YSA9IGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldC5nZXQodGFyZ2V0SWQpO1xuICAgIGlmIChjYWNoZWRUYXJnZXREYXRhKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FjaGVkVGFyZ2V0RGF0YS50YXJnZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdHZXQgdGFyZ2V0IGRhdGEnLCAncmVhZG9ubHknLCB0eG4gPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldENhY2hlSW1wbFxuICAgICAgICAgICAgICAgIC5nZXRUYXJnZXREYXRhRm9yVGFyZ2V0KHR4biwgdGFyZ2V0SWQpXG4gICAgICAgICAgICAgICAgLm5leHQodGFyZ2V0RGF0YSA9PiAodGFyZ2V0RGF0YSA/IHRhcmdldERhdGEudGFyZ2V0IDogbnVsbCkpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHNldCBvZiBkb2N1bWVudHMgdGhhdCBoYXZlIGJlZW4gdXBkYXRlZCBzaW5jZSB0aGUgbGFzdCBjYWxsLlxuICogSWYgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgcmV0dXJucyB0aGUgc2V0IG9mIGNoYW5nZXMgc2luY2UgY2xpZW50XG4gKiBpbml0aWFsaXphdGlvbi4gRnVydGhlciBpbnZvY2F0aW9ucyB3aWxsIHJldHVybiBkb2N1bWVudCB0aGF0IGhhdmUgY2hhbmdlZFxuICogc2luY2UgdGhlIHByaW9yIGNhbGwuXG4gKi9cbi8vIFBPUlRJTkcgTk9URTogTXVsdGktVGFiIG9ubHkuXG5mdW5jdGlvbiBsb2NhbFN0b3JlR2V0TmV3RG9jdW1lbnRDaGFuZ2VzKGxvY2FsU3RvcmUsIGNvbGxlY3Rpb25Hcm91cCkge1xuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xuICAgIC8vIEdldCB0aGUgY3VycmVudCBtYXhpbXVtIHJlYWQgdGltZSBmb3IgdGhlIGNvbGxlY3Rpb24uIFRoaXMgc2hvdWxkIGFsd2F5c1xuICAgIC8vIGV4aXN0LCBidXQgdG8gcmVkdWNlIHRoZSBjaGFuY2UgZm9yIHJlZ3Jlc3Npb25zIHdlIGRlZmF1bHQgdG9cbiAgICAvLyBTbmFwc2hvdFZlcnNpb24uTWluKClcbiAgICAvLyBUT0RPKGluZGV4aW5nKTogQ29uc2lkZXIgcmVtb3ZpbmcgdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgY29uc3QgcmVhZFRpbWUgPSBsb2NhbFN0b3JlSW1wbC5jb2xsZWN0aW9uR3JvdXBSZWFkVGltZS5nZXQoY29sbGVjdGlvbkdyb3VwKSB8fFxuICAgICAgICBTbmFwc2hvdFZlcnNpb24ubWluKCk7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlXG4gICAgICAgIC5ydW5UcmFuc2FjdGlvbignR2V0IG5ldyBkb2N1bWVudCBjaGFuZ2VzJywgJ3JlYWRvbmx5JywgdHhuID0+IGxvY2FsU3RvcmVJbXBsLnJlbW90ZURvY3VtZW50cy5nZXRBbGxGcm9tQ29sbGVjdGlvbkdyb3VwKHR4biwgY29sbGVjdGlvbkdyb3VwLCBuZXdJbmRleE9mZnNldFN1Y2Nlc3NvckZyb21SZWFkVGltZShyZWFkVGltZSwgSU5JVElBTF9MQVJHRVNUX0JBVENIX0lEKSwgXG4gICAgLyogbGltaXQ9ICovIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSlcbiAgICAgICAgLnRoZW4oY2hhbmdlZERvY3MgPT4ge1xuICAgICAgICBzZXRNYXhSZWFkVGltZShsb2NhbFN0b3JlSW1wbCwgY29sbGVjdGlvbkdyb3VwLCBjaGFuZ2VkRG9jcyk7XG4gICAgICAgIHJldHVybiBjaGFuZ2VkRG9jcztcbiAgICB9KTtcbn1cbi8qKiBTZXRzIHRoZSBjb2xsZWN0aW9uIGdyb3VwJ3MgbWF4aW11bSByZWFkIHRpbWUgZnJvbSB0aGUgZ2l2ZW4gZG9jdW1lbnRzLiAqL1xuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cbmZ1bmN0aW9uIHNldE1heFJlYWRUaW1lKGxvY2FsU3RvcmVJbXBsLCBjb2xsZWN0aW9uR3JvdXAsIGNoYW5nZWREb2NzKSB7XG4gICAgbGV0IHJlYWRUaW1lID0gbG9jYWxTdG9yZUltcGwuY29sbGVjdGlvbkdyb3VwUmVhZFRpbWUuZ2V0KGNvbGxlY3Rpb25Hcm91cCkgfHxcbiAgICAgICAgU25hcHNob3RWZXJzaW9uLm1pbigpO1xuICAgIGNoYW5nZWREb2NzLmZvckVhY2goKF8sIGRvYykgPT4ge1xuICAgICAgICBpZiAoZG9jLnJlYWRUaW1lLmNvbXBhcmVUbyhyZWFkVGltZSkgPiAwKSB7XG4gICAgICAgICAgICByZWFkVGltZSA9IGRvYy5yZWFkVGltZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGxvY2FsU3RvcmVJbXBsLmNvbGxlY3Rpb25Hcm91cFJlYWRUaW1lLnNldChjb2xsZWN0aW9uR3JvdXAsIHJlYWRUaW1lKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB0YXJnZXQgdXNpbmcgdGhlIGdpdmVuIGJ1bmRsZSBuYW1lLCB3aGljaCB3aWxsIGJlIHVzZWQgdG9cbiAqIGhvbGQgdGhlIGtleXMgb2YgYWxsIGRvY3VtZW50cyBmcm9tIHRoZSBidW5kbGUgaW4gcXVlcnktZG9jdW1lbnQgbWFwcGluZ3MuXG4gKiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgbG9hZGVkIGRvY3VtZW50cyBkbyBub3QgZ2V0IGdhcmJhZ2UgY29sbGVjdGVkXG4gKiByaWdodCBhd2F5LlxuICovXG5mdW5jdGlvbiB1bWJyZWxsYVRhcmdldChidW5kbGVOYW1lKSB7XG4gICAgLy8gSXQgaXMgT0sgdGhhdCB0aGUgcGF0aCB1c2VkIGZvciB0aGUgcXVlcnkgaXMgbm90IHZhbGlkLCBiZWNhdXNlIHRoaXMgd2lsbFxuICAgIC8vIG5vdCBiZSByZWFkIGFuZCBxdWVyaWVkLlxuICAgIHJldHVybiBxdWVyeVRvVGFyZ2V0KG5ld1F1ZXJ5Rm9yUGF0aChSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhgX19idW5kbGVfXy9kb2NzLyR7YnVuZGxlTmFtZX1gKSkpO1xufVxuLyoqXG4gKiBBcHBsaWVzIHRoZSBkb2N1bWVudHMgZnJvbSBhIGJ1bmRsZSB0byB0aGUgXCJncm91bmQtc3RhdGVcIiAocmVtb3RlKVxuICogZG9jdW1lbnRzLlxuICpcbiAqIExvY2FsRG9jdW1lbnRzIGFyZSByZS1jYWxjdWxhdGVkIGlmIHRoZXJlIGFyZSByZW1haW5pbmcgbXV0YXRpb25zIGluIHRoZVxuICogcXVldWUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvY2FsU3RvcmVBcHBseUJ1bmRsZWREb2N1bWVudHMobG9jYWxTdG9yZSwgYnVuZGxlQ29udmVydGVyLCBkb2N1bWVudHMsIGJ1bmRsZU5hbWUpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICBsZXQgZG9jdW1lbnRLZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICBsZXQgZG9jdW1lbnRNYXAgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGJ1bmRsZURvYyBvZiBkb2N1bWVudHMpIHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRLZXkgPSBidW5kbGVDb252ZXJ0ZXIudG9Eb2N1bWVudEtleShidW5kbGVEb2MubWV0YWRhdGEubmFtZSk7XG4gICAgICAgIGlmIChidW5kbGVEb2MuZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50S2V5cyA9IGRvY3VtZW50S2V5cy5hZGQoZG9jdW1lbnRLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvYyA9IGJ1bmRsZUNvbnZlcnRlci50b011dGFibGVEb2N1bWVudChidW5kbGVEb2MpO1xuICAgICAgICBkb2Muc2V0UmVhZFRpbWUoYnVuZGxlQ29udmVydGVyLnRvU25hcHNob3RWZXJzaW9uKGJ1bmRsZURvYy5tZXRhZGF0YS5yZWFkVGltZSkpO1xuICAgICAgICBkb2N1bWVudE1hcCA9IGRvY3VtZW50TWFwLmluc2VydChkb2N1bWVudEtleSwgZG9jKTtcbiAgICB9XG4gICAgY29uc3QgZG9jdW1lbnRCdWZmZXIgPSBsb2NhbFN0b3JlSW1wbC5yZW1vdGVEb2N1bWVudHMubmV3Q2hhbmdlQnVmZmVyKHtcbiAgICAgICAgdHJhY2tSZW1vdmFsczogdHJ1ZSAvLyBNYWtlIHN1cmUgZG9jdW1lbnQgcmVtb3ZhbHMgc2hvdyB1cCBpbiBgZ2V0TmV3RG9jdW1lbnRDaGFuZ2VzKClgXG4gICAgfSk7XG4gICAgLy8gQWxsb2NhdGVzIGEgdGFyZ2V0IHRvIGhvbGQgYWxsIGRvY3VtZW50IGtleXMgZnJvbSB0aGUgYnVuZGxlLCBzdWNoIHRoYXRcbiAgICAvLyB0aGV5IHdpbGwgbm90IGdldCBnYXJiYWdlIGNvbGxlY3RlZCByaWdodCBhd2F5LlxuICAgIGNvbnN0IHVtYnJlbGxhVGFyZ2V0RGF0YSA9IGF3YWl0IGxvY2FsU3RvcmVBbGxvY2F0ZVRhcmdldChsb2NhbFN0b3JlSW1wbCwgdW1icmVsbGFUYXJnZXQoYnVuZGxlTmFtZSkpO1xuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignQXBwbHkgYnVuZGxlIGRvY3VtZW50cycsICdyZWFkd3JpdGUnLCB0eG4gPT4ge1xuICAgICAgICByZXR1cm4gcG9wdWxhdGVEb2N1bWVudENoYW5nZUJ1ZmZlcih0eG4sIGRvY3VtZW50QnVmZmVyLCBkb2N1bWVudE1hcClcbiAgICAgICAgICAgIC5uZXh0KGRvY3VtZW50Q2hhbmdlUmVzdWx0ID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50QnVmZmVyLmFwcGx5KHR4bik7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnRDaGFuZ2VSZXN1bHQ7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dChkb2N1bWVudENoYW5nZVJlc3VsdCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGVcbiAgICAgICAgICAgICAgICAucmVtb3ZlTWF0Y2hpbmdLZXlzRm9yVGFyZ2V0SWQodHhuLCB1bWJyZWxsYVRhcmdldERhdGEudGFyZ2V0SWQpXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGUuYWRkTWF0Y2hpbmdLZXlzKHR4biwgZG9jdW1lbnRLZXlzLCB1bWJyZWxsYVRhcmdldERhdGEudGFyZ2V0SWQpKVxuICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLmxvY2FsRG9jdW1lbnRzLmdldExvY2FsVmlld09mRG9jdW1lbnRzKHR4biwgZG9jdW1lbnRDaGFuZ2VSZXN1bHQuY2hhbmdlZERvY3VtZW50cywgZG9jdW1lbnRDaGFuZ2VSZXN1bHQuZXhpc3RlbmNlQ2hhbmdlZEtleXMpKVxuICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IGRvY3VtZW50Q2hhbmdlUmVzdWx0LmNoYW5nZWREb2N1bWVudHMpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2Ugb2YgYSBib29sZWFuIHRvIGluZGljYXRlIGlmIHRoZSBnaXZlbiBidW5kbGUgaGFzIGFscmVhZHlcbiAqIGJlZW4gbG9hZGVkIGFuZCB0aGUgY3JlYXRlIHRpbWUgaXMgbmV3ZXIgdGhhbiB0aGUgY3VycmVudCBsb2FkaW5nIGJ1bmRsZS5cbiAqL1xuZnVuY3Rpb24gbG9jYWxTdG9yZUhhc05ld2VyQnVuZGxlKGxvY2FsU3RvcmUsIGJ1bmRsZU1ldGFkYXRhKSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgY29uc3QgY3VycmVudFJlYWRUaW1lID0gZnJvbVZlcnNpb24oYnVuZGxlTWV0YWRhdGEuY3JlYXRlVGltZSk7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlXG4gICAgICAgIC5ydW5UcmFuc2FjdGlvbignaGFzTmV3ZXJCdW5kbGUnLCAncmVhZG9ubHknLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5idW5kbGVDYWNoZS5nZXRCdW5kbGVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgYnVuZGxlTWV0YWRhdGEuaWQpO1xuICAgIH0pXG4gICAgICAgIC50aGVuKGNhY2hlZCA9PiB7XG4gICAgICAgIHJldHVybiAhIWNhY2hlZCAmJiBjYWNoZWQuY3JlYXRlVGltZS5jb21wYXJlVG8oY3VycmVudFJlYWRUaW1lKSA+PSAwO1xuICAgIH0pO1xufVxuLyoqXG4gKiBTYXZlcyB0aGUgZ2l2ZW4gYEJ1bmRsZU1ldGFkYXRhYCB0byBsb2NhbCBwZXJzaXN0ZW5jZS5cbiAqL1xuZnVuY3Rpb24gbG9jYWxTdG9yZVNhdmVCdW5kbGUobG9jYWxTdG9yZSwgYnVuZGxlTWV0YWRhdGEpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ1NhdmUgYnVuZGxlJywgJ3JlYWR3cml0ZScsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLmJ1bmRsZUNhY2hlLnNhdmVCdW5kbGVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgYnVuZGxlTWV0YWRhdGEpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSBvZiBhIGBOYW1lZFF1ZXJ5YCBhc3NvY2lhdGVkIHdpdGggZ2l2ZW4gcXVlcnkgbmFtZS4gUHJvbWlzZVxuICogcmVzb2x2ZXMgdG8gdW5kZWZpbmVkIGlmIG5vIHBlcnNpc3RlZCBkYXRhIGNhbiBiZSBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gbG9jYWxTdG9yZUdldE5hbWVkUXVlcnkobG9jYWxTdG9yZSwgcXVlcnlOYW1lKSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdHZXQgbmFtZWQgcXVlcnknLCAncmVhZG9ubHknLCB0cmFuc2FjdGlvbiA9PiBsb2NhbFN0b3JlSW1wbC5idW5kbGVDYWNoZS5nZXROYW1lZFF1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeU5hbWUpKTtcbn1cbi8qKlxuICogU2F2ZXMgdGhlIGdpdmVuIGBOYW1lZFF1ZXJ5YCB0byBsb2NhbCBwZXJzaXN0ZW5jZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9jYWxTdG9yZVNhdmVOYW1lZFF1ZXJ5KGxvY2FsU3RvcmUsIHF1ZXJ5LCBkb2N1bWVudHMgPSBkb2N1bWVudEtleVNldCgpKSB7XG4gICAgLy8gQWxsb2NhdGUgYSB0YXJnZXQgZm9yIHRoZSBuYW1lZCBxdWVyeSBzdWNoIHRoYXQgaXQgY2FuIGJlIHJlc3VtZWRcbiAgICAvLyBmcm9tIGFzc29jaWF0ZWQgcmVhZCB0aW1lIGlmIHVzZXJzIHVzZSBpdCB0byBsaXN0ZW4uXG4gICAgLy8gTk9URTogdGhpcyBhbHNvIG1lYW5zIGlmIG5vIGNvcnJlc3BvbmRpbmcgdGFyZ2V0IGV4aXN0cywgdGhlIG5ldyB0YXJnZXRcbiAgICAvLyB3aWxsIHJlbWFpbiBhY3RpdmUgYW5kIHdpbGwgbm90IGdldCBjb2xsZWN0ZWQsIHVubGVzcyB1c2VycyBoYXBwZW4gdG9cbiAgICAvLyB1bmxpc3RlbiB0aGUgcXVlcnkgc29tZWhvdy5cbiAgICBjb25zdCBhbGxvY2F0ZWQgPSBhd2FpdCBsb2NhbFN0b3JlQWxsb2NhdGVUYXJnZXQobG9jYWxTdG9yZSwgcXVlcnlUb1RhcmdldChmcm9tQnVuZGxlZFF1ZXJ5KHF1ZXJ5LmJ1bmRsZWRRdWVyeSkpKTtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ1NhdmUgbmFtZWQgcXVlcnknLCAncmVhZHdyaXRlJywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCByZWFkVGltZSA9IGZyb21WZXJzaW9uKHF1ZXJ5LnJlYWRUaW1lKTtcbiAgICAgICAgLy8gU2ltcGx5IHNhdmUgdGhlIHF1ZXJ5IGl0c2VsZiBpZiBpdCBpcyBvbGRlciB0aGFuIHdoYXQgdGhlIFNESyBhbHJlYWR5XG4gICAgICAgIC8vIGhhcy5cbiAgICAgICAgaWYgKGFsbG9jYXRlZC5zbmFwc2hvdFZlcnNpb24uY29tcGFyZVRvKHJlYWRUaW1lKSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwuYnVuZGxlQ2FjaGUuc2F2ZU5hbWVkUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgdGFyZ2V0IGRhdGEgYmVjYXVzZSB0aGUgcXVlcnkgZnJvbSB0aGUgYnVuZGxlIGlzIG5ld2VyLlxuICAgICAgICBjb25zdCBuZXdUYXJnZXREYXRhID0gYWxsb2NhdGVkLndpdGhSZXN1bWVUb2tlbihCeXRlU3RyaW5nLkVNUFRZX0JZVEVfU1RSSU5HLCByZWFkVGltZSk7XG4gICAgICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldCA9XG4gICAgICAgICAgICBsb2NhbFN0b3JlSW1wbC50YXJnZXREYXRhQnlUYXJnZXQuaW5zZXJ0KG5ld1RhcmdldERhdGEudGFyZ2V0SWQsIG5ld1RhcmdldERhdGEpO1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGVcbiAgICAgICAgICAgIC51cGRhdGVUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCBuZXdUYXJnZXREYXRhKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGUucmVtb3ZlTWF0Y2hpbmdLZXlzRm9yVGFyZ2V0SWQodHJhbnNhY3Rpb24sIGFsbG9jYXRlZC50YXJnZXRJZCkpXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZS5hZGRNYXRjaGluZ0tleXModHJhbnNhY3Rpb24sIGRvY3VtZW50cywgYWxsb2NhdGVkLnRhcmdldElkKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLmJ1bmRsZUNhY2hlLnNhdmVOYW1lZFF1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSkpO1xuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9jYWxTdG9yZUNvbmZpZ3VyZUZpZWxkSW5kZXhlcyhsb2NhbFN0b3JlLCBuZXdGaWVsZEluZGV4ZXMpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICBjb25zdCBpbmRleE1hbmFnZXIgPSBsb2NhbFN0b3JlSW1wbC5pbmRleE1hbmFnZXI7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0NvbmZpZ3VyZSBpbmRleGVzJywgJ3JlYWR3cml0ZScsIHRyYW5zYWN0aW9uID0+IGluZGV4TWFuYWdlclxuICAgICAgICAuZ2V0RmllbGRJbmRleGVzKHRyYW5zYWN0aW9uKVxuICAgICAgICAubmV4dChvbGRGaWVsZEluZGV4ZXMgPT4gZGlmZkFycmF5cyhvbGRGaWVsZEluZGV4ZXMsIG5ld0ZpZWxkSW5kZXhlcywgZmllbGRJbmRleFNlbWFudGljQ29tcGFyYXRvciwgZmllbGRJbmRleCA9PiB7XG4gICAgICAgIHByb21pc2VzLnB1c2goaW5kZXhNYW5hZ2VyLmFkZEZpZWxkSW5kZXgodHJhbnNhY3Rpb24sIGZpZWxkSW5kZXgpKTtcbiAgICB9LCBmaWVsZEluZGV4ID0+IHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChpbmRleE1hbmFnZXIuZGVsZXRlRmllbGRJbmRleCh0cmFuc2FjdGlvbiwgZmllbGRJbmRleCkpO1xuICAgIH0pKVxuICAgICAgICAubmV4dCgoKSA9PiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcykpKTtcbn1cbmZ1bmN0aW9uIGxvY2FsU3RvcmVTZXRJbmRleEF1dG9DcmVhdGlvbkVuYWJsZWQobG9jYWxTdG9yZSwgaXNFbmFibGVkKSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgbG9jYWxTdG9yZUltcGwucXVlcnlFbmdpbmUuaW5kZXhBdXRvQ3JlYXRpb25FbmFibGVkID0gaXNFbmFibGVkO1xufVxuZnVuY3Rpb24gbG9jYWxTdG9yZURlbGV0ZUFsbEZpZWxkSW5kZXhlcyhsb2NhbFN0b3JlKSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgY29uc3QgaW5kZXhNYW5hZ2VyID0gbG9jYWxTdG9yZUltcGwuaW5kZXhNYW5hZ2VyO1xuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignRGVsZXRlIEFsbCBJbmRleGVzJywgJ3JlYWR3cml0ZScsIHRyYW5zYWN0aW9uID0+IGluZGV4TWFuYWdlci5kZWxldGVBbGxGaWVsZEluZGV4ZXModHJhbnNhY3Rpb24pKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSB0cmFja2VyIHRvIGtlZXAgYSByZWNvcmQgb2YgaW1wb3J0YW50IGRldGFpbHMgZHVyaW5nIGRhdGFiYXNlIGxvY2FsIHF1ZXJ5XG4gKiBleGVjdXRpb24uXG4gKi9cbmNsYXNzIFF1ZXJ5Q29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb3VudHMgdGhlIG51bWJlciBvZiBkb2N1bWVudHMgcGFzc2VkIHRocm91Z2ggZHVyaW5nIGxvY2FsIHF1ZXJ5IGV4ZWN1dGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2RvY3VtZW50UmVhZENvdW50ID0gMDtcbiAgICB9XG4gICAgZ2V0IGRvY3VtZW50UmVhZENvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZG9jdW1lbnRSZWFkQ291bnQ7XG4gICAgfVxuICAgIGluY3JlbWVudERvY3VtZW50UmVhZENvdW50KGFtb3VudCkge1xuICAgICAgICB0aGlzLl9kb2N1bWVudFJlYWRDb3VudCArPSBhbW91bnQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgREVGQVVMVF9JTkRFWF9BVVRPX0NSRUFUSU9OX01JTl9DT0xMRUNUSU9OX1NJWkUgPSAxMDA7XG4vKipcbiAqIFRoaXMgY29zdCByZXByZXNlbnRzIHRoZSBldmFsdWF0aW9uIHJlc3VsdCBvZlxuICogKChbaW5kZXgsIGRvY0tleV0gKyBbZG9jS2V5LCBkb2NDb250ZW50XSkgcGVyIGRvY3VtZW50IGluIHRoZSByZXN1bHQgc2V0KVxuICogLyAoW2RvY0tleSwgZG9jQ29udGVudF0gcGVyIGRvY3VtZW50cyBpbiBmdWxsIGNvbGxlY3Rpb24gc2NhbikgY29taW5nIGZyb21cbiAqIGV4cGVyaW1lbnQgW2VudGVyIFBSIGV4cGVyaW1lbnQgVVJMIGhlcmVdLlxuICovXG5mdW5jdGlvbiBnZXREZWZhdWx0UmVsYXRpdmVJbmRleFJlYWRDb3N0UGVyRG9jdW1lbnQoKSB7XG4gICAgLy8gVGhlc2UgdmFsdWVzIHdlcmUgZGVyaXZlZCBmcm9tIGFuIGV4cGVyaW1lbnQgd2hlcmUgc2V2ZXJhbCBtZW1iZXJzIG9mIHRoZVxuICAgIC8vIEZpcmVzdG9yZSBTREsgdGVhbSByYW4gYSBwZXJmb3JtYW5jZSB0ZXN0IGluIHZhcmlvdXMgZW52aXJvbm1lbnRzLlxuICAgIC8vIEdvb2dsZXJzIGNhbiBzZWUgYi8yOTkyODQyODcgZm9yIGRldGFpbHMuXG4gICAgaWYgKGlzU2FmYXJpKCkpIHtcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgfVxuICAgIGVsc2UgaWYgKGdldEFuZHJvaWRWZXJzaW9uKGdldFVBKCkpID4gMCkge1xuICAgICAgICByZXR1cm4gNjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbn1cbi8qKlxuICogVGhlIEZpcmVzdG9yZSBxdWVyeSBlbmdpbmUuXG4gKlxuICogRmlyZXN0b3JlIHF1ZXJpZXMgY2FuIGJlIGV4ZWN1dGVkIGluIHRocmVlIG1vZGVzLiBUaGUgUXVlcnkgRW5naW5lIGRldGVybWluZXNcbiAqIHdoYXQgbW9kZSB0byB1c2UgYmFzZWQgb24gd2hhdCBkYXRhIGlzIHBlcnNpc3RlZC4gVGhlIG1vZGUgb25seSBkZXRlcm1pbmVzXG4gKiB0aGUgcnVudGltZSBjb21wbGV4aXR5IG9mIHRoZSBxdWVyeSAtIHRoZSByZXN1bHQgc2V0IGlzIGVxdWl2YWxlbnQgYWNyb3NzIGFsbFxuICogaW1wbGVtZW50YXRpb25zLlxuICpcbiAqIFRoZSBRdWVyeSBlbmdpbmUgd2lsbCB1c2UgaW5kZXhlZC1iYXNlZCBleGVjdXRpb24gaWYgYSB1c2VyIGhhcyBjb25maWd1cmVkXG4gKiBhbnkgaW5kZXggdGhhdCBjYW4gYmUgdXNlZCB0byBleGVjdXRlIHF1ZXJ5ICh2aWEgYHNldEluZGV4Q29uZmlndXJhdGlvbigpYCkuXG4gKiBPdGhlcndpc2UsIHRoZSBlbmdpbmUgd2lsbCB0cnkgdG8gb3B0aW1pemUgdGhlIHF1ZXJ5IGJ5IHJlLXVzaW5nIGEgcHJldmlvdXNseVxuICogcGVyc2lzdGVkIHF1ZXJ5IHJlc3VsdC4gSWYgdGhhdCBpcyBub3QgcG9zc2libGUsIHRoZSBxdWVyeSB3aWxsIGJlIGV4ZWN1dGVkXG4gKiB2aWEgYSBmdWxsIGNvbGxlY3Rpb24gc2Nhbi5cbiAqXG4gKiBJbmRleC1iYXNlZCBleGVjdXRpb24gaXMgdGhlIGRlZmF1bHQgd2hlbiBhdmFpbGFibGUuIFRoZSBxdWVyeSBlbmdpbmVcbiAqIHN1cHBvcnRzIHBhcnRpYWwgaW5kZXhlZCBleGVjdXRpb24gYW5kIG1lcmdlcyB0aGUgcmVzdWx0IGZyb20gdGhlIGluZGV4XG4gKiBsb29rdXAgd2l0aCBkb2N1bWVudHMgdGhhdCBoYXZlIG5vdCB5ZXQgYmVlbiBpbmRleGVkLiBUaGUgaW5kZXggZXZhbHVhdGlvblxuICogbWF0Y2hlcyB0aGUgYmFja2VuZCdzIGZvcm1hdCBhbmQgYXMgc3VjaCwgdGhlIFNESyBjYW4gdXNlIGluZGV4aW5nIGZvciBhbGxcbiAqIHF1ZXJpZXMgdGhhdCB0aGUgYmFja2VuZCBzdXBwb3J0cy5cbiAqXG4gKiBJZiBubyBpbmRleCBleGlzdHMsIHRoZSBxdWVyeSBlbmdpbmUgdHJpZXMgdG8gdGFrZSBhZHZhbnRhZ2Ugb2YgdGhlIHRhcmdldFxuICogZG9jdW1lbnQgbWFwcGluZyBpbiB0aGUgVGFyZ2V0Q2FjaGUuIFRoZXNlIG1hcHBpbmdzIGV4aXN0cyBmb3IgYWxsIHF1ZXJpZXNcbiAqIHRoYXQgaGF2ZSBiZWVuIHN5bmNlZCB3aXRoIHRoZSBiYWNrZW5kIGF0IGxlYXN0IG9uY2UgYW5kIGFsbG93IHRoZSBxdWVyeVxuICogZW5naW5lIHRvIG9ubHkgcmVhZCBkb2N1bWVudHMgdGhhdCBwcmV2aW91c2x5IG1hdGNoZWQgYSBxdWVyeSBwbHVzIGFueVxuICogZG9jdW1lbnRzIHRoYXQgd2VyZSBlZGl0ZWQgYWZ0ZXIgdGhlIHF1ZXJ5IHdhcyBsYXN0IGxpc3RlbmVkIHRvLlxuICpcbiAqIFRoZXJlIGFyZSBzb21lIGNhc2VzIHdoZW4gdGhpcyBvcHRpbWl6YXRpb24gaXMgbm90IGd1YXJhbnRlZWQgdG8gcHJvZHVjZVxuICogdGhlIHNhbWUgcmVzdWx0cyBhcyBmdWxsIGNvbGxlY3Rpb24gc2NhbnMuIEluIHRoZXNlIGNhc2VzLCBxdWVyeVxuICogcHJvY2Vzc2luZyBmYWxscyBiYWNrIHRvIGZ1bGwgc2NhbnMuIFRoZXNlIGNhc2VzIGFyZTpcbiAqXG4gKiAtIExpbWl0IHF1ZXJpZXMgd2hlcmUgYSBkb2N1bWVudCB0aGF0IG1hdGNoZWQgdGhlIHF1ZXJ5IHByZXZpb3VzbHkgbm8gbG9uZ2VyXG4gKiAgIG1hdGNoZXMgdGhlIHF1ZXJ5LlxuICpcbiAqIC0gTGltaXQgcXVlcmllcyB3aGVyZSBhIGRvY3VtZW50IGVkaXQgbWF5IGNhdXNlIHRoZSBkb2N1bWVudCB0byBzb3J0IGJlbG93XG4gKiAgIGFub3RoZXIgZG9jdW1lbnQgdGhhdCBpcyBpbiB0aGUgbG9jYWwgY2FjaGUuXG4gKlxuICogLSBRdWVyaWVzIHRoYXQgaGF2ZSBuZXZlciBiZWVuIENVUlJFTlQgb3IgZnJlZSBvZiBsaW1ibyBkb2N1bWVudHMuXG4gKi9cbmNsYXNzIFF1ZXJ5RW5naW5lIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluZGV4QXV0b0NyZWF0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU0RLIG9ubHkgZGVjaWRlcyB3aGV0aGVyIGl0IHNob3VsZCBjcmVhdGUgaW5kZXggd2hlbiBjb2xsZWN0aW9uIHNpemUgaXNcbiAgICAgICAgICogbGFyZ2VyIHRoYW4gdGhpcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kZXhBdXRvQ3JlYXRpb25NaW5Db2xsZWN0aW9uU2l6ZSA9IERFRkFVTFRfSU5ERVhfQVVUT19DUkVBVElPTl9NSU5fQ09MTEVDVElPTl9TSVpFO1xuICAgICAgICB0aGlzLnJlbGF0aXZlSW5kZXhSZWFkQ29zdFBlckRvY3VtZW50ID0gZ2V0RGVmYXVsdFJlbGF0aXZlSW5kZXhSZWFkQ29zdFBlckRvY3VtZW50KCk7XG4gICAgfVxuICAgIC8qKiBTZXRzIHRoZSBkb2N1bWVudCB2aWV3IHRvIHF1ZXJ5IGFnYWluc3QuICovXG4gICAgaW5pdGlhbGl6ZShsb2NhbERvY3VtZW50cywgaW5kZXhNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMubG9jYWxEb2N1bWVudHNWaWV3ID0gbG9jYWxEb2N1bWVudHM7XG4gICAgICAgIHRoaXMuaW5kZXhNYW5hZ2VyID0gaW5kZXhNYW5hZ2VyO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYWxsIGxvY2FsIGRvY3VtZW50cyBtYXRjaGluZyB0aGUgc3BlY2lmaWVkIHF1ZXJ5LiAqL1xuICAgIGdldERvY3VtZW50c01hdGNoaW5nUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uLCByZW1vdGVLZXlzKSB7XG4gICAgICAgIC8vIFN0b3JlcyB0aGUgcmVzdWx0IGZyb20gZXhlY3V0aW5nIHRoZSBxdWVyeTsgdXNpbmcgdGhpcyBvYmplY3QgaXMgbW9yZVxuICAgICAgICAvLyBjb252ZW5pZW50IHRoYW4gcGFzc2luZyB0aGUgcmVzdWx0IGJldHdlZW4gc3RlcHMgb2YgdGhlIHBlcnNpc3RlbmNlXG4gICAgICAgIC8vIHRyYW5zYWN0aW9uIGFuZCBpbXByb3ZlcyByZWFkYWJpbGl0eSBjb21wYXJhdGl2ZWx5LlxuICAgICAgICBjb25zdCBxdWVyeVJlc3VsdCA9IHsgcmVzdWx0OiBudWxsIH07XG4gICAgICAgIHJldHVybiB0aGlzLnBlcmZvcm1RdWVyeVVzaW5nSW5kZXgodHJhbnNhY3Rpb24sIHF1ZXJ5KVxuICAgICAgICAgICAgLm5leHQocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIHF1ZXJ5UmVzdWx0LnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChxdWVyeVJlc3VsdC5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJmb3JtUXVlcnlVc2luZ1JlbW90ZUtleXModHJhbnNhY3Rpb24sIHF1ZXJ5LCByZW1vdGVLZXlzLCBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uKS5uZXh0KHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgcXVlcnlSZXN1bHQucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAocXVlcnlSZXN1bHQucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IG5ldyBRdWVyeUNvbnRleHQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVGdWxsQ29sbGVjdGlvblNjYW4odHJhbnNhY3Rpb24sIHF1ZXJ5LCBjb250ZXh0KS5uZXh0KHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgcXVlcnlSZXN1bHQucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4QXV0b0NyZWF0aW9uRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVDYWNoZUluZGV4ZXModHJhbnNhY3Rpb24sIHF1ZXJ5LCBjb250ZXh0LCByZXN1bHQuc2l6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBxdWVyeVJlc3VsdC5yZXN1bHQpO1xuICAgIH1cbiAgICBjcmVhdGVDYWNoZUluZGV4ZXModHJhbnNhY3Rpb24sIHF1ZXJ5LCBjb250ZXh0LCByZXN1bHRTaXplKSB7XG4gICAgICAgIGlmIChjb250ZXh0LmRvY3VtZW50UmVhZENvdW50IDwgdGhpcy5pbmRleEF1dG9DcmVhdGlvbk1pbkNvbGxlY3Rpb25TaXplKSB7XG4gICAgICAgICAgICBpZiAoZ2V0TG9nTGV2ZWwoKSA8PSBMb2dMZXZlbC5ERUJVRykge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdRdWVyeUVuZ2luZScsICdTREsgd2lsbCBub3QgY3JlYXRlIGNhY2hlIGluZGV4ZXMgZm9yIHF1ZXJ5OicsIHN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KSwgJ3NpbmNlIGl0IG9ubHkgY3JlYXRlcyBjYWNoZSBpbmRleGVzIGZvciBjb2xsZWN0aW9uIGNvbnRhaW5zJywgJ21vcmUgdGhhbiBvciBlcXVhbCB0bycsIHRoaXMuaW5kZXhBdXRvQ3JlYXRpb25NaW5Db2xsZWN0aW9uU2l6ZSwgJ2RvY3VtZW50cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdldExvZ0xldmVsKCkgPD0gTG9nTGV2ZWwuREVCVUcpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKCdRdWVyeUVuZ2luZScsICdRdWVyeTonLCBzdHJpbmdpZnlRdWVyeShxdWVyeSksICdzY2FucycsIGNvbnRleHQuZG9jdW1lbnRSZWFkQ291bnQsICdsb2NhbCBkb2N1bWVudHMgYW5kIHJldHVybnMnLCByZXN1bHRTaXplLCAnZG9jdW1lbnRzIGFzIHJlc3VsdHMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQuZG9jdW1lbnRSZWFkQ291bnQgPlxuICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZUluZGV4UmVhZENvc3RQZXJEb2N1bWVudCAqIHJlc3VsdFNpemUpIHtcbiAgICAgICAgICAgIGlmIChnZXRMb2dMZXZlbCgpIDw9IExvZ0xldmVsLkRFQlVHKSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ1F1ZXJ5RW5naW5lJywgJ1RoZSBTREsgZGVjaWRlcyB0byBjcmVhdGUgY2FjaGUgaW5kZXhlcyBmb3IgcXVlcnk6Jywgc3RyaW5naWZ5UXVlcnkocXVlcnkpLCAnYXMgdXNpbmcgY2FjaGUgaW5kZXhlcyBtYXkgaGVscCBpbXByb3ZlIHBlcmZvcm1hbmNlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhNYW5hZ2VyLmNyZWF0ZVRhcmdldEluZGV4ZXModHJhbnNhY3Rpb24sIHF1ZXJ5VG9UYXJnZXQocXVlcnkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYW4gaW5kZXhlZCBxdWVyeSB0aGF0IGV2YWx1YXRlcyB0aGUgcXVlcnkgYmFzZWQgb24gYSBjb2xsZWN0aW9uJ3NcbiAgICAgKiBwZXJzaXN0ZWQgaW5kZXggdmFsdWVzLiBSZXR1cm5zIGBudWxsYCBpZiBhbiBpbmRleCBpcyBub3QgYXZhaWxhYmxlLlxuICAgICAqL1xuICAgIHBlcmZvcm1RdWVyeVVzaW5nSW5kZXgodHJhbnNhY3Rpb24sIHF1ZXJ5KSB7XG4gICAgICAgIGlmIChxdWVyeU1hdGNoZXNBbGxEb2N1bWVudHMocXVlcnkpKSB7XG4gICAgICAgICAgICAvLyBRdWVyaWVzIHRoYXQgbWF0Y2ggYWxsIGRvY3VtZW50cyBkb24ndCBiZW5lZml0IGZyb20gdXNpbmdcbiAgICAgICAgICAgIC8vIGtleS1iYXNlZCBsb29rdXBzLiBJdCBpcyBtb3JlIGVmZmljaWVudCB0byBzY2FuIGFsbCBkb2N1bWVudHMgaW4gYVxuICAgICAgICAgICAgLy8gY29sbGVjdGlvbiwgcmF0aGVyIHRoYW4gdG8gcGVyZm9ybSBpbmRpdmlkdWFsIGxvb2t1cHMuXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRhcmdldCA9IHF1ZXJ5VG9UYXJnZXQocXVlcnkpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleE1hbmFnZXJcbiAgICAgICAgICAgIC5nZXRJbmRleFR5cGUodHJhbnNhY3Rpb24sIHRhcmdldClcbiAgICAgICAgICAgIC5uZXh0KGluZGV4VHlwZSA9PiB7XG4gICAgICAgICAgICBpZiAoaW5kZXhUeXBlID09PSAwIC8qIEluZGV4VHlwZS5OT05FICovKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHRhcmdldCBjYW5ub3QgYmUgc2VydmVkIGZyb20gYW55IGluZGV4LlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHF1ZXJ5LmxpbWl0ICE9PSBudWxsICYmIGluZGV4VHlwZSA9PT0gMSAvKiBJbmRleFR5cGUuUEFSVElBTCAqLykge1xuICAgICAgICAgICAgICAgIC8vIFdlIGNhbm5vdCBhcHBseSBhIGxpbWl0IGZvciB0YXJnZXRzIHRoYXQgYXJlIHNlcnZlZCB1c2luZyBhIHBhcnRpYWxcbiAgICAgICAgICAgICAgICAvLyBpbmRleC4gSWYgYSBwYXJ0aWFsIGluZGV4IHdpbGwgYmUgdXNlZCB0byBzZXJ2ZSB0aGUgdGFyZ2V0LCB0aGVcbiAgICAgICAgICAgICAgICAvLyBxdWVyeSBtYXkgcmV0dXJuIGEgc3VwZXJzZXQgb2YgZG9jdW1lbnRzIHRoYXQgbWF0Y2ggdGhlIHRhcmdldFxuICAgICAgICAgICAgICAgIC8vIChlLmcuIGlmIHRoZSBpbmRleCBkb2Vzbid0IGluY2x1ZGUgYWxsIHRoZSB0YXJnZXQncyBmaWx0ZXJzKSwgb3JcbiAgICAgICAgICAgICAgICAvLyBtYXkgcmV0dXJuIHRoZSBjb3JyZWN0IHNldCBvZiBkb2N1bWVudHMgaW4gdGhlIHdyb25nIG9yZGVyIChlLmcuIGlmXG4gICAgICAgICAgICAgICAgLy8gdGhlIGluZGV4IGRvZXNuJ3QgaW5jbHVkZSBhIHNlZ21lbnQgZm9yIG9uZSBvZiB0aGUgb3JkZXJCeXMpLlxuICAgICAgICAgICAgICAgIC8vIFRoZXJlZm9yZSwgYSBsaW1pdCBzaG91bGQgbm90IGJlIGFwcGxpZWQgaW4gc3VjaCBjYXNlcy5cbiAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5V2l0aExpbWl0KHF1ZXJ5LCBudWxsLCBcIkZcIiAvKiBMaW1pdFR5cGUuRmlyc3QgKi8pO1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHF1ZXJ5VG9UYXJnZXQocXVlcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhNYW5hZ2VyXG4gICAgICAgICAgICAgICAgLmdldERvY3VtZW50c01hdGNoaW5nVGFyZ2V0KHRyYW5zYWN0aW9uLCB0YXJnZXQpXG4gICAgICAgICAgICAgICAgLm5leHQoa2V5cyA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc29ydGVkS2V5cyA9IGRvY3VtZW50S2V5U2V0KC4uLmtleXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsRG9jdW1lbnRzVmlld1xuICAgICAgICAgICAgICAgICAgICAuZ2V0RG9jdW1lbnRzKHRyYW5zYWN0aW9uLCBzb3J0ZWRLZXlzKVxuICAgICAgICAgICAgICAgICAgICAubmV4dChpbmRleGVkRG9jdW1lbnRzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhNYW5hZ2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0TWluT2Zmc2V0KHRyYW5zYWN0aW9uLCB0YXJnZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAubmV4dChvZmZzZXQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNSZXN1bHRzID0gdGhpcy5hcHBseVF1ZXJ5KHF1ZXJ5LCBpbmRleGVkRG9jdW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm5lZWRzUmVmaWxsKHF1ZXJ5LCBwcmV2aW91c1Jlc3VsdHMsIHNvcnRlZEtleXMsIG9mZnNldC5yZWFkVGltZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIGxpbWl0IHF1ZXJ5IHdob3NlIGJvdW5kYXJpZXMgY2hhbmdlIGR1ZSB0byBsb2NhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVkaXRzIGNhbiBiZSByZS1ydW4gYWdhaW5zdCB0aGUgY2FjaGUgYnkgZXhjbHVkaW5nIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxpbWl0LiBUaGlzIGVuc3VyZXMgdGhhdCBhbGwgZG9jdW1lbnRzIHRoYXQgbWF0Y2ggdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcXVlcnkncyBmaWx0ZXJzIGFyZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0IHNldC4gVGhlIFNES1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbiB0aGVuIGFwcGx5IHRoZSBsaW1pdCBvbmNlIGFsbCBsb2NhbCBlZGl0cyBhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmNvcnBvcmF0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVyZm9ybVF1ZXJ5VXNpbmdJbmRleCh0cmFuc2FjdGlvbiwgcXVlcnlXaXRoTGltaXQocXVlcnksIG51bGwsIFwiRlwiIC8qIExpbWl0VHlwZS5GaXJzdCAqLykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwZW5kUmVtYWluaW5nUmVzdWx0cyh0cmFuc2FjdGlvbiwgcHJldmlvdXNSZXN1bHRzLCBxdWVyeSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgcXVlcnkgYmFzZWQgb24gdGhlIHRhcmdldCdzIHBlcnNpc3RlZCBxdWVyeSBtYXBwaW5nLiBSZXR1cm5zXG4gICAgICogYG51bGxgIGlmIHRoZSBtYXBwaW5nIGlzIG5vdCBhdmFpbGFibGUgb3IgY2Fubm90IGJlIHVzZWQuXG4gICAgICovXG4gICAgcGVyZm9ybVF1ZXJ5VXNpbmdSZW1vdGVLZXlzKHRyYW5zYWN0aW9uLCBxdWVyeSwgcmVtb3RlS2V5cywgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbikge1xuICAgICAgICBpZiAocXVlcnlNYXRjaGVzQWxsRG9jdW1lbnRzKHF1ZXJ5KSkge1xuICAgICAgICAgICAgLy8gUXVlcmllcyB0aGF0IG1hdGNoIGFsbCBkb2N1bWVudHMgZG9uJ3QgYmVuZWZpdCBmcm9tIHVzaW5nXG4gICAgICAgICAgICAvLyBrZXktYmFzZWQgbG9va3Vwcy4gSXQgaXMgbW9yZSBlZmZpY2llbnQgdG8gc2NhbiBhbGwgZG9jdW1lbnRzIGluIGFcbiAgICAgICAgICAgIC8vIGNvbGxlY3Rpb24sIHJhdGhlciB0aGFuIHRvIHBlcmZvcm0gaW5kaXZpZHVhbCBsb29rdXBzLlxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFF1ZXJpZXMgdGhhdCBoYXZlIG5ldmVyIHNlZW4gYSBzbmFwc2hvdCB3aXRob3V0IGxpbWJvIGZyZWUgZG9jdW1lbnRzXG4gICAgICAgIC8vIHNob3VsZCBhbHNvIGJlIHJ1biBhcyBhIGZ1bGwgY29sbGVjdGlvbiBzY2FuLlxuICAgICAgICBpZiAobGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbi5pc0VxdWFsKFNuYXBzaG90VmVyc2lvbi5taW4oKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbERvY3VtZW50c1ZpZXcuZ2V0RG9jdW1lbnRzKHRyYW5zYWN0aW9uLCByZW1vdGVLZXlzKS5uZXh0KGRvY3VtZW50cyA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c1Jlc3VsdHMgPSB0aGlzLmFwcGx5UXVlcnkocXVlcnksIGRvY3VtZW50cyk7XG4gICAgICAgICAgICBpZiAodGhpcy5uZWVkc1JlZmlsbChxdWVyeSwgcHJldmlvdXNSZXN1bHRzLCByZW1vdGVLZXlzLCBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRMb2dMZXZlbCgpIDw9IExvZ0xldmVsLkRFQlVHKSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ1F1ZXJ5RW5naW5lJywgJ1JlLXVzaW5nIHByZXZpb3VzIHJlc3VsdCBmcm9tICVzIHRvIGV4ZWN1dGUgcXVlcnk6ICVzJywgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbi50b1N0cmluZygpLCBzdHJpbmdpZnlRdWVyeShxdWVyeSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmV0cmlldmUgYWxsIHJlc3VsdHMgZm9yIGRvY3VtZW50cyB0aGF0IHdlcmUgdXBkYXRlZCBzaW5jZSB0aGUgbGFzdFxuICAgICAgICAgICAgLy8gbGltYm8tZG9jdW1lbnQgZnJlZSByZW1vdGUgc25hcHNob3QuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBlbmRSZW1haW5pbmdSZXN1bHRzKHRyYW5zYWN0aW9uLCBwcmV2aW91c1Jlc3VsdHMsIHF1ZXJ5LCBuZXdJbmRleE9mZnNldFN1Y2Nlc3NvckZyb21SZWFkVGltZShsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uLCBJTklUSUFMX0xBUkdFU1RfQkFUQ0hfSUQpKS5uZXh0KHJlc3VsdHMgPT4gcmVzdWx0cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQXBwbGllcyB0aGUgcXVlcnkgZmlsdGVyIGFuZCBzb3J0aW5nIHRvIHRoZSBwcm92aWRlZCBkb2N1bWVudHMuICAqL1xuICAgIGFwcGx5UXVlcnkocXVlcnksIGRvY3VtZW50cykge1xuICAgICAgICAvLyBTb3J0IHRoZSBkb2N1bWVudHMgYW5kIHJlLWFwcGx5IHRoZSBxdWVyeSBmaWx0ZXIgc2luY2UgcHJldmlvdXNseVxuICAgICAgICAvLyBtYXRjaGluZyBkb2N1bWVudHMgZG8gbm90IG5lY2Vzc2FyaWx5IHN0aWxsIG1hdGNoIHRoZSBxdWVyeS5cbiAgICAgICAgbGV0IHF1ZXJ5UmVzdWx0cyA9IG5ldyBTb3J0ZWRTZXQobmV3UXVlcnlDb21wYXJhdG9yKHF1ZXJ5KSk7XG4gICAgICAgIGRvY3VtZW50cy5mb3JFYWNoKChfLCBtYXliZURvYykgPT4ge1xuICAgICAgICAgICAgaWYgKHF1ZXJ5TWF0Y2hlcyhxdWVyeSwgbWF5YmVEb2MpKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlSZXN1bHRzID0gcXVlcnlSZXN1bHRzLmFkZChtYXliZURvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcXVlcnlSZXN1bHRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGEgbGltaXQgcXVlcnkgbmVlZHMgdG8gYmUgcmVmaWxsZWQgZnJvbSBjYWNoZSwgbWFraW5nIGl0XG4gICAgICogaW5lbGlnaWJsZSBmb3IgaW5kZXgtZnJlZSBleGVjdXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcXVlcnkgLSBUaGUgcXVlcnkuXG4gICAgICogQHBhcmFtIHNvcnRlZFByZXZpb3VzUmVzdWx0cyAtIFRoZSBkb2N1bWVudHMgdGhhdCBtYXRjaGVkIHRoZSBxdWVyeSB3aGVuIGl0XG4gICAgICogd2FzIGxhc3Qgc3luY2hyb25pemVkLCBzb3J0ZWQgYnkgdGhlIHF1ZXJ5J3MgY29tcGFyYXRvci5cbiAgICAgKiBAcGFyYW0gcmVtb3RlS2V5cyAtIFRoZSBkb2N1bWVudCBrZXlzIHRoYXQgbWF0Y2hlZCB0aGUgcXVlcnkgYXQgdGhlIGxhc3RcbiAgICAgKiBzbmFwc2hvdC5cbiAgICAgKiBAcGFyYW0gbGltYm9GcmVlU25hcHNob3RWZXJzaW9uIC0gVGhlIHZlcnNpb24gb2YgdGhlIHNuYXBzaG90IHdoZW4gdGhlXG4gICAgICogcXVlcnkgd2FzIGxhc3Qgc3luY2hyb25pemVkLlxuICAgICAqL1xuICAgIG5lZWRzUmVmaWxsKHF1ZXJ5LCBzb3J0ZWRQcmV2aW91c1Jlc3VsdHMsIHJlbW90ZUtleXMsIGxpbWJvRnJlZVNuYXBzaG90VmVyc2lvbikge1xuICAgICAgICBpZiAocXVlcnkubGltaXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFF1ZXJpZXMgd2l0aG91dCBsaW1pdHMgZG8gbm90IG5lZWQgdG8gYmUgcmVmaWxsZWQuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbW90ZUtleXMuc2l6ZSAhPT0gc29ydGVkUHJldmlvdXNSZXN1bHRzLnNpemUpIHtcbiAgICAgICAgICAgIC8vIFRoZSBxdWVyeSBuZWVkcyB0byBiZSByZWZpbGxlZCBpZiBhIHByZXZpb3VzbHkgbWF0Y2hpbmcgZG9jdW1lbnQgbm9cbiAgICAgICAgICAgIC8vIGxvbmdlciBtYXRjaGVzLlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGltaXQgcXVlcmllcyBhcmUgbm90IGVsaWdpYmxlIGZvciBpbmRleC1mcmVlIHF1ZXJ5IGV4ZWN1dGlvbiBpZiB0aGVyZSBpc1xuICAgICAgICAvLyBhIHBvdGVudGlhbCB0aGF0IGFuIG9sZGVyIGRvY3VtZW50IGZyb20gY2FjaGUgbm93IHNvcnRzIGJlZm9yZSBhIGRvY3VtZW50XG4gICAgICAgIC8vIHRoYXQgd2FzIHByZXZpb3VzbHkgcGFydCBvZiB0aGUgbGltaXQuIFRoaXMsIGhvd2V2ZXIsIGNhbiBvbmx5IGhhcHBlbiBpZlxuICAgICAgICAvLyB0aGUgZG9jdW1lbnQgYXQgdGhlIGVkZ2Ugb2YgdGhlIGxpbWl0IGdvZXMgb3V0IG9mIGxpbWl0LlxuICAgICAgICAvLyBJZiBhIGRvY3VtZW50IHRoYXQgaXMgbm90IHRoZSBsaW1pdCBib3VuZGFyeSBzb3J0cyBkaWZmZXJlbnRseSxcbiAgICAgICAgLy8gdGhlIGJvdW5kYXJ5IG9mIHRoZSBsaW1pdCBpdHNlbGYgZGlkIG5vdCBjaGFuZ2UgYW5kIGRvY3VtZW50cyBmcm9tIGNhY2hlXG4gICAgICAgIC8vIHdpbGwgY29udGludWUgdG8gYmUgXCJyZWplY3RlZFwiIGJ5IHRoaXMgYm91bmRhcnkuIFRoZXJlZm9yZSwgd2UgY2FuIGlnbm9yZVxuICAgICAgICAvLyBhbnkgbW9kaWZpY2F0aW9ucyB0aGF0IGRvbid0IGFmZmVjdCB0aGUgbGFzdCBkb2N1bWVudC5cbiAgICAgICAgY29uc3QgZG9jQXRMaW1pdEVkZ2UgPSBxdWVyeS5saW1pdFR5cGUgPT09IFwiRlwiIC8qIExpbWl0VHlwZS5GaXJzdCAqL1xuICAgICAgICAgICAgPyBzb3J0ZWRQcmV2aW91c1Jlc3VsdHMubGFzdCgpXG4gICAgICAgICAgICA6IHNvcnRlZFByZXZpb3VzUmVzdWx0cy5maXJzdCgpO1xuICAgICAgICBpZiAoIWRvY0F0TGltaXRFZGdlKSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIHJlZmlsbCB0aGUgcXVlcnkgaWYgdGhlcmUgd2VyZSBhbHJlYWR5IG5vIGRvY3VtZW50cy5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGRvY0F0TGltaXRFZGdlLmhhc1BlbmRpbmdXcml0ZXMgfHxcbiAgICAgICAgICAgIGRvY0F0TGltaXRFZGdlLnZlcnNpb24uY29tcGFyZVRvKGxpbWJvRnJlZVNuYXBzaG90VmVyc2lvbikgPiAwKTtcbiAgICB9XG4gICAgZXhlY3V0ZUZ1bGxDb2xsZWN0aW9uU2Nhbih0cmFuc2FjdGlvbiwgcXVlcnksIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGdldExvZ0xldmVsKCkgPD0gTG9nTGV2ZWwuREVCVUcpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKCdRdWVyeUVuZ2luZScsICdVc2luZyBmdWxsIGNvbGxlY3Rpb24gc2NhbiB0byBleGVjdXRlIHF1ZXJ5OicsIHN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxEb2N1bWVudHNWaWV3LmdldERvY3VtZW50c01hdGNoaW5nUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBJbmRleE9mZnNldC5taW4oKSwgY29udGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbWJpbmVzIHRoZSByZXN1bHRzIGZyb20gYW4gaW5kZXhlZCBleGVjdXRpb24gd2l0aCB0aGUgcmVtYWluaW5nIGRvY3VtZW50c1xuICAgICAqIHRoYXQgaGF2ZSBub3QgeWV0IGJlZW4gaW5kZXhlZC5cbiAgICAgKi9cbiAgICBhcHBlbmRSZW1haW5pbmdSZXN1bHRzKHRyYW5zYWN0aW9uLCBpbmRleGVkUmVzdWx0cywgcXVlcnksIG9mZnNldCkge1xuICAgICAgICAvLyBSZXRyaWV2ZSBhbGwgcmVzdWx0cyBmb3IgZG9jdW1lbnRzIHRoYXQgd2VyZSB1cGRhdGVkIHNpbmNlIHRoZSBvZmZzZXQuXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsRG9jdW1lbnRzVmlld1xuICAgICAgICAgICAgLmdldERvY3VtZW50c01hdGNoaW5nUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBvZmZzZXQpXG4gICAgICAgICAgICAubmV4dChyZW1haW5pbmdSZXN1bHRzID0+IHtcbiAgICAgICAgICAgIC8vIE1lcmdlIHdpdGggZXhpc3RpbmcgcmVzdWx0c1xuICAgICAgICAgICAgaW5kZXhlZFJlc3VsdHMuZm9yRWFjaChkID0+IHtcbiAgICAgICAgICAgICAgICByZW1haW5pbmdSZXN1bHRzID0gcmVtYWluaW5nUmVzdWx0cy5pbnNlcnQoZC5rZXksIGQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVtYWluaW5nUmVzdWx0cztcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gVGhlIGZvcm1hdCBvZiB0aGUgTG9jYWxTdG9yYWdlIGtleSB0aGF0IHN0b3JlcyB0aGUgY2xpZW50IHN0YXRlIGlzOlxuLy8gICAgIGZpcmVzdG9yZV9jbGllbnRzXzxwZXJzaXN0ZW5jZV9wcmVmaXg+XzxpbnN0YW5jZV9rZXk+XG5jb25zdCBDTElFTlRfU1RBVEVfS0VZX1BSRUZJWCA9ICdmaXJlc3RvcmVfY2xpZW50cyc7XG4vKiogQXNzZW1ibGVzIHRoZSBrZXkgZm9yIGEgY2xpZW50IHN0YXRlIGluIFdlYlN0b3JhZ2UgKi9cbmZ1bmN0aW9uIGNyZWF0ZVdlYlN0b3JhZ2VDbGllbnRTdGF0ZUtleShwZXJzaXN0ZW5jZUtleSwgY2xpZW50SWQpIHtcbiAgICByZXR1cm4gYCR7Q0xJRU5UX1NUQVRFX0tFWV9QUkVGSVh9XyR7cGVyc2lzdGVuY2VLZXl9XyR7Y2xpZW50SWR9YDtcbn1cbi8vIFRoZSBmb3JtYXQgb2YgdGhlIFdlYlN0b3JhZ2Uga2V5IHRoYXQgc3RvcmVzIHRoZSBtdXRhdGlvbiBzdGF0ZSBpczpcbi8vICAgICBmaXJlc3RvcmVfbXV0YXRpb25zXzxwZXJzaXN0ZW5jZV9wcmVmaXg+XzxiYXRjaF9pZD5cbi8vICAgICAoZm9yIHVuYXV0aGVudGljYXRlZCB1c2Vycylcbi8vIG9yOiBmaXJlc3RvcmVfbXV0YXRpb25zXzxwZXJzaXN0ZW5jZV9wcmVmaXg+XzxiYXRjaF9pZD5fPHVzZXJfdWlkPlxuLy9cbi8vICd1c2VyX3VpZCcgaXMgbGFzdCB0byBhdm9pZCBuZWVkaW5nIHRvIGVzY2FwZSAnXycgY2hhcmFjdGVycyB0aGF0IGl0IG1pZ2h0XG4vLyBjb250YWluLlxuY29uc3QgTVVUQVRJT05fQkFUQ0hfS0VZX1BSRUZJWCA9ICdmaXJlc3RvcmVfbXV0YXRpb25zJztcbi8qKiBBc3NlbWJsZXMgdGhlIGtleSBmb3IgYSBtdXRhdGlvbiBiYXRjaCBpbiBXZWJTdG9yYWdlICovXG5mdW5jdGlvbiBjcmVhdGVXZWJTdG9yYWdlTXV0YXRpb25CYXRjaEtleShwZXJzaXN0ZW5jZUtleSwgdXNlciwgYmF0Y2hJZCkge1xuICAgIGxldCBtdXRhdGlvbktleSA9IGAke01VVEFUSU9OX0JBVENIX0tFWV9QUkVGSVh9XyR7cGVyc2lzdGVuY2VLZXl9XyR7YmF0Y2hJZH1gO1xuICAgIGlmICh1c2VyLmlzQXV0aGVudGljYXRlZCgpKSB7XG4gICAgICAgIG11dGF0aW9uS2V5ICs9IGBfJHt1c2VyLnVpZH1gO1xuICAgIH1cbiAgICByZXR1cm4gbXV0YXRpb25LZXk7XG59XG4vLyBUaGUgZm9ybWF0IG9mIHRoZSBXZWJTdG9yYWdlIGtleSB0aGF0IHN0b3JlcyBhIHF1ZXJ5IHRhcmdldCdzIG1ldGFkYXRhIGlzOlxuLy8gICAgIGZpcmVzdG9yZV90YXJnZXRzXzxwZXJzaXN0ZW5jZV9wcmVmaXg+Xzx0YXJnZXRfaWQ+XG5jb25zdCBRVUVSWV9UQVJHRVRfS0VZX1BSRUZJWCA9ICdmaXJlc3RvcmVfdGFyZ2V0cyc7XG4vKiogQXNzZW1ibGVzIHRoZSBrZXkgZm9yIGEgcXVlcnkgc3RhdGUgaW4gV2ViU3RvcmFnZSAqL1xuZnVuY3Rpb24gY3JlYXRlV2ViU3RvcmFnZVF1ZXJ5VGFyZ2V0TWV0YWRhdGFLZXkocGVyc2lzdGVuY2VLZXksIHRhcmdldElkKSB7XG4gICAgcmV0dXJuIGAke1FVRVJZX1RBUkdFVF9LRVlfUFJFRklYfV8ke3BlcnNpc3RlbmNlS2V5fV8ke3RhcmdldElkfWA7XG59XG4vLyBUaGUgV2ViU3RvcmFnZSBwcmVmaXggdGhhdCBzdG9yZXMgdGhlIHByaW1hcnkgdGFiJ3Mgb25saW5lIHN0YXRlLiBUaGVcbi8vIGZvcm1hdCBvZiB0aGUga2V5IGlzOlxuLy8gICAgIGZpcmVzdG9yZV9vbmxpbmVfc3RhdGVfPHBlcnNpc3RlbmNlX3ByZWZpeD5cbmNvbnN0IE9OTElORV9TVEFURV9LRVlfUFJFRklYID0gJ2ZpcmVzdG9yZV9vbmxpbmVfc3RhdGUnO1xuLyoqIEFzc2VtYmxlcyB0aGUga2V5IGZvciB0aGUgb25saW5lIHN0YXRlIG9mIHRoZSBwcmltYXJ5IHRhYi4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVdlYlN0b3JhZ2VPbmxpbmVTdGF0ZUtleShwZXJzaXN0ZW5jZUtleSkge1xuICAgIHJldHVybiBgJHtPTkxJTkVfU1RBVEVfS0VZX1BSRUZJWH1fJHtwZXJzaXN0ZW5jZUtleX1gO1xufVxuLy8gVGhlIFdlYlN0b3JhZ2UgcHJlZml4IHRoYXQgcGxheXMgYXMgYSBldmVudCB0byBpbmRpY2F0ZSB0aGUgcmVtb3RlIGRvY3VtZW50c1xuLy8gbWlnaHQgaGF2ZSBjaGFuZ2VkIGR1ZSB0byBzb21lIHNlY29uZGFyeSB0YWJzIGxvYWRpbmcgYSBidW5kbGUuXG4vLyBmb3JtYXQgb2YgdGhlIGtleSBpczpcbi8vICAgICBmaXJlc3RvcmVfYnVuZGxlX2xvYWRlZF92Ml88cGVyc2lzdGVuY2VLZXk+XG4vLyBUaGUgdmVyc2lvbiBlbmRpbmcgd2l0aCBcInYyXCIgc3RvcmVzIHRoZSBsaXN0IG9mIG1vZGlmaWVkIGNvbGxlY3Rpb24gZ3JvdXBzLlxuY29uc3QgQlVORExFX0xPQURFRF9LRVlfUFJFRklYID0gJ2ZpcmVzdG9yZV9idW5kbGVfbG9hZGVkX3YyJztcbmZ1bmN0aW9uIGNyZWF0ZUJ1bmRsZUxvYWRlZEtleShwZXJzaXN0ZW5jZUtleSkge1xuICAgIHJldHVybiBgJHtCVU5ETEVfTE9BREVEX0tFWV9QUkVGSVh9XyR7cGVyc2lzdGVuY2VLZXl9YDtcbn1cbi8vIFRoZSBXZWJTdG9yYWdlIGtleSBwcmVmaXggZm9yIHRoZSBrZXkgdGhhdCBzdG9yZXMgdGhlIGxhc3Qgc2VxdWVuY2UgbnVtYmVyIGFsbG9jYXRlZC4gVGhlIGtleVxuLy8gbG9va3MgbGlrZSAnZmlyZXN0b3JlX3NlcXVlbmNlX251bWJlcl88cGVyc2lzdGVuY2VfcHJlZml4PicuXG5jb25zdCBTRVFVRU5DRV9OVU1CRVJfS0VZX1BSRUZJWCA9ICdmaXJlc3RvcmVfc2VxdWVuY2VfbnVtYmVyJztcbi8qKiBBc3NlbWJsZXMgdGhlIGtleSBmb3IgdGhlIGN1cnJlbnQgc2VxdWVuY2UgbnVtYmVyLiAqL1xuZnVuY3Rpb24gY3JlYXRlV2ViU3RvcmFnZVNlcXVlbmNlTnVtYmVyS2V5KHBlcnNpc3RlbmNlS2V5KSB7XG4gICAgcmV0dXJuIGAke1NFUVVFTkNFX05VTUJFUl9LRVlfUFJFRklYfV8ke3BlcnNpc3RlbmNlS2V5fWA7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBMT0dfVEFHJGEgPSAnU2hhcmVkQ2xpZW50U3RhdGUnO1xuLyoqXG4gKiBIb2xkcyB0aGUgc3RhdGUgb2YgYSBtdXRhdGlvbiBiYXRjaCwgaW5jbHVkaW5nIGl0cyB1c2VyIElELCBiYXRjaCBJRCBhbmRcbiAqIHdoZXRoZXIgdGhlIGJhdGNoIGlzICdwZW5kaW5nJywgJ2Fja25vd2xlZGdlZCcgb3IgJ3JlamVjdGVkJy5cbiAqL1xuLy8gVmlzaWJsZSBmb3IgdGVzdGluZ1xuY2xhc3MgTXV0YXRpb25NZXRhZGF0YSB7XG4gICAgY29uc3RydWN0b3IodXNlciwgYmF0Y2hJZCwgc3RhdGUsIGVycm9yKSB7XG4gICAgICAgIHRoaXMudXNlciA9IHVzZXI7XG4gICAgICAgIHRoaXMuYmF0Y2hJZCA9IGJhdGNoSWQ7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBNdXRhdGlvbk1ldGFkYXRhIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24gaW4gV2ViU3RvcmFnZS5cbiAgICAgKiBMb2dzIGEgd2FybmluZyBhbmQgcmV0dXJucyBudWxsIGlmIHRoZSBmb3JtYXQgb2YgdGhlIGRhdGEgaXMgbm90IHZhbGlkLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tV2ViU3RvcmFnZUVudHJ5KHVzZXIsIGJhdGNoSWQsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uQmF0Y2ggPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgbGV0IHZhbGlkRGF0YSA9IHR5cGVvZiBtdXRhdGlvbkJhdGNoID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgWydwZW5kaW5nJywgJ2Fja25vd2xlZGdlZCcsICdyZWplY3RlZCddLmluZGV4T2YobXV0YXRpb25CYXRjaC5zdGF0ZSkgIT09XG4gICAgICAgICAgICAgICAgLTEgJiZcbiAgICAgICAgICAgIChtdXRhdGlvbkJhdGNoLmVycm9yID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgbXV0YXRpb25CYXRjaC5lcnJvciA9PT0gJ29iamVjdCcpO1xuICAgICAgICBsZXQgZmlyZXN0b3JlRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh2YWxpZERhdGEgJiYgbXV0YXRpb25CYXRjaC5lcnJvcikge1xuICAgICAgICAgICAgdmFsaWREYXRhID1cbiAgICAgICAgICAgICAgICB0eXBlb2YgbXV0YXRpb25CYXRjaC5lcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgbXV0YXRpb25CYXRjaC5lcnJvci5jb2RlID09PSAnc3RyaW5nJztcbiAgICAgICAgICAgIGlmICh2YWxpZERhdGEpIHtcbiAgICAgICAgICAgICAgICBmaXJlc3RvcmVFcnJvciA9IG5ldyBGaXJlc3RvcmVFcnJvcihtdXRhdGlvbkJhdGNoLmVycm9yLmNvZGUsIG11dGF0aW9uQmF0Y2guZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbGlkRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNdXRhdGlvbk1ldGFkYXRhKHVzZXIsIGJhdGNoSWQsIG11dGF0aW9uQmF0Y2guc3RhdGUsIGZpcmVzdG9yZUVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0Vycm9yKExPR19UQUckYSwgYEZhaWxlZCB0byBwYXJzZSBtdXRhdGlvbiBzdGF0ZSBmb3IgSUQgJyR7YmF0Y2hJZH0nOiAke3ZhbHVlfWApO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9XZWJTdG9yYWdlSlNPTigpIHtcbiAgICAgICAgY29uc3QgYmF0Y2hNZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgdXBkYXRlVGltZU1zOiBEYXRlLm5vdygpIC8vIE1vZGlmeSB0aGUgZXhpc3RpbmcgdmFsdWUgdG8gdHJpZ2dlciB1cGRhdGUuXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICAgICAgICBiYXRjaE1ldGFkYXRhLmVycm9yID0ge1xuICAgICAgICAgICAgICAgIGNvZGU6IHRoaXMuZXJyb3IuY29kZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB0aGlzLmVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGJhdGNoTWV0YWRhdGEpO1xuICAgIH1cbn1cbi8qKlxuICogSG9sZHMgdGhlIHN0YXRlIG9mIGEgcXVlcnkgdGFyZ2V0LCBpbmNsdWRpbmcgaXRzIHRhcmdldCBJRCBhbmQgd2hldGhlciB0aGVcbiAqIHRhcmdldCBpcyAnbm90LWN1cnJlbnQnLCAnY3VycmVudCcgb3IgJ3JlamVjdGVkJy5cbiAqL1xuLy8gVmlzaWJsZSBmb3IgdGVzdGluZ1xuY2xhc3MgUXVlcnlUYXJnZXRNZXRhZGF0YSB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0SWQsIHN0YXRlLCBlcnJvcikge1xuICAgICAgICB0aGlzLnRhcmdldElkID0gdGFyZ2V0SWQ7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBRdWVyeVRhcmdldE1ldGFkYXRhIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24gaW4gV2ViU3RvcmFnZS5cbiAgICAgKiBMb2dzIGEgd2FybmluZyBhbmQgcmV0dXJucyBudWxsIGlmIHRoZSBmb3JtYXQgb2YgdGhlIGRhdGEgaXMgbm90IHZhbGlkLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tV2ViU3RvcmFnZUVudHJ5KHRhcmdldElkLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICBsZXQgdmFsaWREYXRhID0gdHlwZW9mIHRhcmdldFN0YXRlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgWydub3QtY3VycmVudCcsICdjdXJyZW50JywgJ3JlamVjdGVkJ10uaW5kZXhPZih0YXJnZXRTdGF0ZS5zdGF0ZSkgIT09XG4gICAgICAgICAgICAgICAgLTEgJiZcbiAgICAgICAgICAgICh0YXJnZXRTdGF0ZS5lcnJvciA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIHRhcmdldFN0YXRlLmVycm9yID09PSAnb2JqZWN0Jyk7XG4gICAgICAgIGxldCBmaXJlc3RvcmVFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHZhbGlkRGF0YSAmJiB0YXJnZXRTdGF0ZS5lcnJvcikge1xuICAgICAgICAgICAgdmFsaWREYXRhID1cbiAgICAgICAgICAgICAgICB0eXBlb2YgdGFyZ2V0U3RhdGUuZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHRhcmdldFN0YXRlLmVycm9yLmNvZGUgPT09ICdzdHJpbmcnO1xuICAgICAgICAgICAgaWYgKHZhbGlkRGF0YSkge1xuICAgICAgICAgICAgICAgIGZpcmVzdG9yZUVycm9yID0gbmV3IEZpcmVzdG9yZUVycm9yKHRhcmdldFN0YXRlLmVycm9yLmNvZGUsIHRhcmdldFN0YXRlLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWxpZERhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUXVlcnlUYXJnZXRNZXRhZGF0YSh0YXJnZXRJZCwgdGFyZ2V0U3RhdGUuc3RhdGUsIGZpcmVzdG9yZUVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0Vycm9yKExPR19UQUckYSwgYEZhaWxlZCB0byBwYXJzZSB0YXJnZXQgc3RhdGUgZm9yIElEICcke3RhcmdldElkfSc6ICR7dmFsdWV9YCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1dlYlN0b3JhZ2VKU09OKCkge1xuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IHtcbiAgICAgICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgdXBkYXRlVGltZU1zOiBEYXRlLm5vdygpIC8vIE1vZGlmeSB0aGUgZXhpc3RpbmcgdmFsdWUgdG8gdHJpZ2dlciB1cGRhdGUuXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICAgICAgICB0YXJnZXRTdGF0ZS5lcnJvciA9IHtcbiAgICAgICAgICAgICAgICBjb2RlOiB0aGlzLmVycm9yLmNvZGUsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5lcnJvci5tZXNzYWdlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0YXJnZXRTdGF0ZSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgdGhlIGltbXV0YWJsZSBDbGllbnRTdGF0ZSBmb3IgYSBjbGllbnQgcmVhZCBmcm9tXG4gKiBXZWJTdG9yYWdlLCBjb250YWluaW5nIHRoZSBsaXN0IG9mIGFjdGl2ZSBxdWVyeSB0YXJnZXRzLlxuICovXG5jbGFzcyBSZW1vdGVDbGllbnRTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50SWQsIGFjdGl2ZVRhcmdldElkcykge1xuICAgICAgICB0aGlzLmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgICAgIHRoaXMuYWN0aXZlVGFyZ2V0SWRzID0gYWN0aXZlVGFyZ2V0SWRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBSZW1vdGVDbGllbnRTdGF0ZSBmcm9tIHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIGluIFdlYlN0b3JhZ2UuXG4gICAgICogTG9ncyBhIHdhcm5pbmcgYW5kIHJldHVybnMgbnVsbCBpZiB0aGUgZm9ybWF0IG9mIHRoZSBkYXRhIGlzIG5vdCB2YWxpZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVdlYlN0b3JhZ2VFbnRyeShjbGllbnRJZCwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2xpZW50U3RhdGUgPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgbGV0IHZhbGlkRGF0YSA9IHR5cGVvZiBjbGllbnRTdGF0ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIGNsaWVudFN0YXRlLmFjdGl2ZVRhcmdldElkcyBpbnN0YW5jZW9mIEFycmF5O1xuICAgICAgICBsZXQgYWN0aXZlVGFyZ2V0SWRzU2V0ID0gdGFyZ2V0SWRTZXQoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IHZhbGlkRGF0YSAmJiBpIDwgY2xpZW50U3RhdGUuYWN0aXZlVGFyZ2V0SWRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YWxpZERhdGEgPSBpc1NhZmVJbnRlZ2VyKGNsaWVudFN0YXRlLmFjdGl2ZVRhcmdldElkc1tpXSk7XG4gICAgICAgICAgICBhY3RpdmVUYXJnZXRJZHNTZXQgPSBhY3RpdmVUYXJnZXRJZHNTZXQuYWRkKGNsaWVudFN0YXRlLmFjdGl2ZVRhcmdldElkc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbGlkRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZW1vdGVDbGllbnRTdGF0ZShjbGllbnRJZCwgYWN0aXZlVGFyZ2V0SWRzU2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0Vycm9yKExPR19UQUckYSwgYEZhaWxlZCB0byBwYXJzZSBjbGllbnQgZGF0YSBmb3IgaW5zdGFuY2UgJyR7Y2xpZW50SWR9JzogJHt2YWx1ZX1gKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgdGhlIG9ubGluZSBzdGF0ZSBmb3IgYWxsIGNsaWVudHMgcGFydGljaXBhdGluZyBpblxuICogbXVsdGktdGFiLiBUaGUgb25saW5lIHN0YXRlIGlzIG9ubHkgd3JpdHRlbiB0byBieSB0aGUgcHJpbWFyeSBjbGllbnQsIGFuZFxuICogdXNlZCBpbiBzZWNvbmRhcnkgY2xpZW50cyB0byB1cGRhdGUgdGhlaXIgcXVlcnkgdmlld3MuXG4gKi9cbmNsYXNzIFNoYXJlZE9ubGluZVN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnRJZCwgb25saW5lU3RhdGUpIHtcbiAgICAgICAgdGhpcy5jbGllbnRJZCA9IGNsaWVudElkO1xuICAgICAgICB0aGlzLm9ubGluZVN0YXRlID0gb25saW5lU3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIFNoYXJlZE9ubGluZVN0YXRlIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24gaW4gV2ViU3RvcmFnZS5cbiAgICAgKiBMb2dzIGEgd2FybmluZyBhbmQgcmV0dXJucyBudWxsIGlmIHRoZSBmb3JtYXQgb2YgdGhlIGRhdGEgaXMgbm90IHZhbGlkLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tV2ViU3RvcmFnZUVudHJ5KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG9ubGluZVN0YXRlID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHZhbGlkRGF0YSA9IHR5cGVvZiBvbmxpbmVTdGF0ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIFsnVW5rbm93bicsICdPbmxpbmUnLCAnT2ZmbGluZSddLmluZGV4T2Yob25saW5lU3RhdGUub25saW5lU3RhdGUpICE9PVxuICAgICAgICAgICAgICAgIC0xICYmXG4gICAgICAgICAgICB0eXBlb2Ygb25saW5lU3RhdGUuY2xpZW50SWQgPT09ICdzdHJpbmcnO1xuICAgICAgICBpZiAodmFsaWREYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNoYXJlZE9ubGluZVN0YXRlKG9ubGluZVN0YXRlLmNsaWVudElkLCBvbmxpbmVTdGF0ZS5vbmxpbmVTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dFcnJvcihMT0dfVEFHJGEsIGBGYWlsZWQgdG8gcGFyc2Ugb25saW5lIHN0YXRlOiAke3ZhbHVlfWApO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIE1ldGFkYXRhIHN0YXRlIG9mIHRoZSBsb2NhbCBjbGllbnQuIFVubGlrZSBgUmVtb3RlQ2xpZW50U3RhdGVgLCB0aGlzIGNsYXNzIGlzXG4gKiBtdXRhYmxlIGFuZCBrZWVwcyB0cmFjayBvZiBhbGwgcGVuZGluZyBtdXRhdGlvbnMsIHdoaWNoIGFsbG93cyB1cyB0b1xuICogdXBkYXRlIHRoZSByYW5nZSBvZiBwZW5kaW5nIG11dGF0aW9uIGJhdGNoIElEcyBhcyBuZXcgbXV0YXRpb25zIGFyZSBhZGRlZCBvclxuICogcmVtb3ZlZC5cbiAqXG4gKiBUaGUgZGF0YSBpbiBgTG9jYWxDbGllbnRTdGF0ZWAgaXMgbm90IHJlYWQgZnJvbSBXZWJTdG9yYWdlIGFuZCBpbnN0ZWFkXG4gKiB1cGRhdGVkIHZpYSBpdHMgaW5zdGFuY2UgbWV0aG9kcy4gVGhlIHVwZGF0ZWQgc3RhdGUgY2FuIGJlIHNlcmlhbGl6ZWQgdmlhXG4gKiBgdG9XZWJTdG9yYWdlSlNPTigpYC5cbiAqL1xuLy8gVmlzaWJsZSBmb3IgdGVzdGluZy5cbmNsYXNzIExvY2FsQ2xpZW50U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZVRhcmdldElkcyA9IHRhcmdldElkU2V0KCk7XG4gICAgfVxuICAgIGFkZFF1ZXJ5VGFyZ2V0KHRhcmdldElkKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlVGFyZ2V0SWRzID0gdGhpcy5hY3RpdmVUYXJnZXRJZHMuYWRkKHRhcmdldElkKTtcbiAgICB9XG4gICAgcmVtb3ZlUXVlcnlUYXJnZXQodGFyZ2V0SWQpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVUYXJnZXRJZHMgPSB0aGlzLmFjdGl2ZVRhcmdldElkcy5kZWxldGUodGFyZ2V0SWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIGVudHJ5IGludG8gYSBKU09OLWVuY29kZWQgZm9ybWF0IHdlIGNhbiB1c2UgZm9yIFdlYlN0b3JhZ2UuXG4gICAgICogRG9lcyBub3QgZW5jb2RlIGBjbGllbnRJZGAgYXMgaXQgaXMgcGFydCBvZiB0aGUga2V5IGluIFdlYlN0b3JhZ2UuXG4gICAgICovXG4gICAgdG9XZWJTdG9yYWdlSlNPTigpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIGFjdGl2ZVRhcmdldElkczogdGhpcy5hY3RpdmVUYXJnZXRJZHMudG9BcnJheSgpLFxuICAgICAgICAgICAgdXBkYXRlVGltZU1zOiBEYXRlLm5vdygpIC8vIE1vZGlmeSB0aGUgZXhpc3RpbmcgdmFsdWUgdG8gdHJpZ2dlciB1cGRhdGUuXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICB9XG59XG4vKipcbiAqIGBXZWJTdG9yYWdlU2hhcmVkQ2xpZW50U3RhdGVgIHVzZXMgV2ViU3RvcmFnZSAod2luZG93LmxvY2FsU3RvcmFnZSkgYXMgdGhlXG4gKiBiYWNraW5nIHN0b3JlIGZvciB0aGUgU2hhcmVkQ2xpZW50U3RhdGUuIEl0IGtlZXBzIHRyYWNrIG9mIGFsbCBhY3RpdmVcbiAqIGNsaWVudHMgYW5kIHN1cHBvcnRzIG1vZGlmaWNhdGlvbnMgb2YgdGhlIGxvY2FsIGNsaWVudCdzIGRhdGEuXG4gKi9cbmNsYXNzIFdlYlN0b3JhZ2VTaGFyZWRDbGllbnRTdGF0ZSB7XG4gICAgY29uc3RydWN0b3Iod2luZG93LCBxdWV1ZSwgcGVyc2lzdGVuY2VLZXksIGxvY2FsQ2xpZW50SWQsIGluaXRpYWxVc2VyKSB7XG4gICAgICAgIHRoaXMud2luZG93ID0gd2luZG93O1xuICAgICAgICB0aGlzLnF1ZXVlID0gcXVldWU7XG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2VLZXkgPSBwZXJzaXN0ZW5jZUtleTtcbiAgICAgICAgdGhpcy5sb2NhbENsaWVudElkID0gbG9jYWxDbGllbnRJZDtcbiAgICAgICAgdGhpcy5zeW5jRW5naW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZUhhbmRsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnNlcXVlbmNlTnVtYmVySGFuZGxlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcmFnZUxpc3RlbmVyID0gdGhpcy5oYW5kbGVXZWJTdG9yYWdlRXZlbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hY3RpdmVDbGllbnRzID0gbmV3IFNvcnRlZE1hcChwcmltaXRpdmVDb21wYXJhdG9yKTtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYXB0dXJlcyBXZWJTdG9yYWdlIGV2ZW50cyB0aGF0IG9jY3VyIGJlZm9yZSBgc3RhcnQoKWAgaXMgY2FsbGVkLiBUaGVzZVxuICAgICAgICAgKiBldmVudHMgYXJlIHJlcGxheWVkIG9uY2UgYFdlYlN0b3JhZ2VTaGFyZWRDbGllbnRTdGF0ZWAgaXMgc3RhcnRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZWFybHlFdmVudHMgPSBbXTtcbiAgICAgICAgLy8gRXNjYXBlIHRoZSBzcGVjaWFsIGNoYXJhY3RlcnMgbWVudGlvbmVkIGhlcmU6XG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvR3VpZGUvUmVndWxhcl9FeHByZXNzaW9uc1xuICAgICAgICBjb25zdCBlc2NhcGVkUGVyc2lzdGVuY2VLZXkgPSBwZXJzaXN0ZW5jZUtleS5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSB0aGlzLndpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgICAgIHRoaXMuY3VycmVudFVzZXIgPSBpbml0aWFsVXNlcjtcbiAgICAgICAgdGhpcy5sb2NhbENsaWVudFN0b3JhZ2VLZXkgPSBjcmVhdGVXZWJTdG9yYWdlQ2xpZW50U3RhdGVLZXkodGhpcy5wZXJzaXN0ZW5jZUtleSwgdGhpcy5sb2NhbENsaWVudElkKTtcbiAgICAgICAgdGhpcy5zZXF1ZW5jZU51bWJlcktleSA9IGNyZWF0ZVdlYlN0b3JhZ2VTZXF1ZW5jZU51bWJlcktleSh0aGlzLnBlcnNpc3RlbmNlS2V5KTtcbiAgICAgICAgdGhpcy5hY3RpdmVDbGllbnRzID0gdGhpcy5hY3RpdmVDbGllbnRzLmluc2VydCh0aGlzLmxvY2FsQ2xpZW50SWQsIG5ldyBMb2NhbENsaWVudFN0YXRlKCkpO1xuICAgICAgICB0aGlzLmNsaWVudFN0YXRlS2V5UmUgPSBuZXcgUmVnRXhwKGBeJHtDTElFTlRfU1RBVEVfS0VZX1BSRUZJWH1fJHtlc2NhcGVkUGVyc2lzdGVuY2VLZXl9XyhbXl9dKikkYCk7XG4gICAgICAgIHRoaXMubXV0YXRpb25CYXRjaEtleVJlID0gbmV3IFJlZ0V4cChgXiR7TVVUQVRJT05fQkFUQ0hfS0VZX1BSRUZJWH1fJHtlc2NhcGVkUGVyc2lzdGVuY2VLZXl9XyhcXFxcZCspKD86XyguKikpPyRgKTtcbiAgICAgICAgdGhpcy5xdWVyeVRhcmdldEtleVJlID0gbmV3IFJlZ0V4cChgXiR7UVVFUllfVEFSR0VUX0tFWV9QUkVGSVh9XyR7ZXNjYXBlZFBlcnNpc3RlbmNlS2V5fV8oXFxcXGQrKSRgKTtcbiAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZUtleSA9IGNyZWF0ZVdlYlN0b3JhZ2VPbmxpbmVTdGF0ZUtleSh0aGlzLnBlcnNpc3RlbmNlS2V5KTtcbiAgICAgICAgdGhpcy5idW5kbGVMb2FkZWRLZXkgPSBjcmVhdGVCdW5kbGVMb2FkZWRLZXkodGhpcy5wZXJzaXN0ZW5jZUtleSk7XG4gICAgICAgIC8vIFJhdGhlciB0aGFuIGFkZGluZyB0aGUgc3RvcmFnZSBvYnNlcnZlciBkdXJpbmcgc3RhcnQoKSwgd2UgYWRkIHRoZVxuICAgICAgICAvLyBzdG9yYWdlIG9ic2VydmVyIGR1cmluZyBpbml0aWFsaXphdGlvbi4gVGhpcyBlbnN1cmVzIHRoYXQgd2UgY29sbGVjdFxuICAgICAgICAvLyBldmVudHMgYmVmb3JlIG90aGVyIGNvbXBvbmVudHMgcG9wdWxhdGUgdGhlaXIgaW5pdGlhbCBzdGF0ZSAoZHVyaW5nIHRoZWlyXG4gICAgICAgIC8vIHJlc3BlY3RpdmUgc3RhcnQoKSBjYWxscykuIE90aGVyd2lzZSwgd2UgbWlnaHQgZm9yIGV4YW1wbGUgbWlzcyBhXG4gICAgICAgIC8vIG11dGF0aW9uIHRoYXQgaXMgYWRkZWQgYWZ0ZXIgTG9jYWxTdG9yZSdzIHN0YXJ0KCkgcHJvY2Vzc2VkIHRoZSBleGlzdGluZ1xuICAgICAgICAvLyBtdXRhdGlvbnMgYnV0IGJlZm9yZSB3ZSBvYnNlcnZlIFdlYlN0b3JhZ2UgZXZlbnRzLlxuICAgICAgICB0aGlzLndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgdGhpcy5zdG9yYWdlTGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyAndHJ1ZScgaWYgV2ViU3RvcmFnZSBpcyBhdmFpbGFibGUgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuICovXG4gICAgc3RhdGljIGlzQXZhaWxhYmxlKHdpbmRvdykge1xuICAgICAgICByZXR1cm4gISEod2luZG93ICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UpO1xuICAgIH1cbiAgICBhc3luYyBzdGFydCgpIHtcbiAgICAgICAgLy8gUmV0cmlldmUgdGhlIGxpc3Qgb2YgZXhpc3RpbmcgY2xpZW50cyB0byBiYWNrZmlsbCB0aGUgZGF0YSBpblxuICAgICAgICAvLyBTaGFyZWRDbGllbnRTdGF0ZS5cbiAgICAgICAgY29uc3QgZXhpc3RpbmdDbGllbnRzID0gYXdhaXQgdGhpcy5zeW5jRW5naW5lLmdldEFjdGl2ZUNsaWVudHMoKTtcbiAgICAgICAgZm9yIChjb25zdCBjbGllbnRJZCBvZiBleGlzdGluZ0NsaWVudHMpIHtcbiAgICAgICAgICAgIGlmIChjbGllbnRJZCA9PT0gdGhpcy5sb2NhbENsaWVudElkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdG9yYWdlSXRlbSA9IHRoaXMuZ2V0SXRlbShjcmVhdGVXZWJTdG9yYWdlQ2xpZW50U3RhdGVLZXkodGhpcy5wZXJzaXN0ZW5jZUtleSwgY2xpZW50SWQpKTtcbiAgICAgICAgICAgIGlmIChzdG9yYWdlSXRlbSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudFN0YXRlID0gUmVtb3RlQ2xpZW50U3RhdGUuZnJvbVdlYlN0b3JhZ2VFbnRyeShjbGllbnRJZCwgc3RvcmFnZUl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmIChjbGllbnRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUNsaWVudHMgPSB0aGlzLmFjdGl2ZUNsaWVudHMuaW5zZXJ0KGNsaWVudFN0YXRlLmNsaWVudElkLCBjbGllbnRTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVyc2lzdENsaWVudFN0YXRlKCk7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIG9ubGluZSBzdGF0ZSBhbmQgY2FsbCB0aGUgY2FsbGJhY2sgaGFuZGxlclxuICAgICAgICAvLyBpZiBhcHBsaWNhYmxlLlxuICAgICAgICBjb25zdCBvbmxpbmVTdGF0ZUpTT04gPSB0aGlzLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLm9ubGluZVN0YXRlS2V5KTtcbiAgICAgICAgaWYgKG9ubGluZVN0YXRlSlNPTikge1xuICAgICAgICAgICAgY29uc3Qgb25saW5lU3RhdGUgPSB0aGlzLmZyb21XZWJTdG9yYWdlT25saW5lU3RhdGUob25saW5lU3RhdGVKU09OKTtcbiAgICAgICAgICAgIGlmIChvbmxpbmVTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlT25saW5lU3RhdGVFdmVudChvbmxpbmVTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiB0aGlzLmVhcmx5RXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVdlYlN0b3JhZ2VFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lYXJseUV2ZW50cyA9IFtdO1xuICAgICAgICAvLyBSZWdpc3RlciBhIHdpbmRvdyB1bmxvYWQgaG9vayB0byByZW1vdmUgdGhlIGNsaWVudCBtZXRhZGF0YSBlbnRyeSBmcm9tXG4gICAgICAgIC8vIFdlYlN0b3JhZ2UgZXZlbiBpZiBgc2h1dGRvd24oKWAgd2FzIG5vdCBjYWxsZWQuXG4gICAgICAgIHRoaXMud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgKCkgPT4gdGhpcy5zaHV0ZG93bigpKTtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgd3JpdGVTZXF1ZW5jZU51bWJlcihzZXF1ZW5jZU51bWJlcikge1xuICAgICAgICB0aGlzLnNldEl0ZW0odGhpcy5zZXF1ZW5jZU51bWJlcktleSwgSlNPTi5zdHJpbmdpZnkoc2VxdWVuY2VOdW1iZXIpKTtcbiAgICB9XG4gICAgZ2V0QWxsQWN0aXZlUXVlcnlUYXJnZXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHRyYWN0QWN0aXZlUXVlcnlUYXJnZXRzKHRoaXMuYWN0aXZlQ2xpZW50cyk7XG4gICAgfVxuICAgIGlzQWN0aXZlUXVlcnlUYXJnZXQodGFyZ2V0SWQpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWN0aXZlQ2xpZW50cy5mb3JFYWNoKChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUuYWN0aXZlVGFyZ2V0SWRzLmhhcyh0YXJnZXRJZCkpIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIGFkZFBlbmRpbmdNdXRhdGlvbihiYXRjaElkKSB7XG4gICAgICAgIHRoaXMucGVyc2lzdE11dGF0aW9uU3RhdGUoYmF0Y2hJZCwgJ3BlbmRpbmcnKTtcbiAgICB9XG4gICAgdXBkYXRlTXV0YXRpb25TdGF0ZShiYXRjaElkLCBzdGF0ZSwgZXJyb3IpIHtcbiAgICAgICAgdGhpcy5wZXJzaXN0TXV0YXRpb25TdGF0ZShiYXRjaElkLCBzdGF0ZSwgZXJyb3IpO1xuICAgICAgICAvLyBPbmNlIGEgZmluYWwgbXV0YXRpb24gcmVzdWx0IGlzIG9ic2VydmVkIGJ5IG90aGVyIGNsaWVudHMsIHRoZXkgbm8gbG9uZ2VyXG4gICAgICAgIC8vIGFjY2VzcyB0aGUgbXV0YXRpb24ncyBtZXRhZGF0YSBlbnRyeS4gU2luY2UgV2ViU3RvcmFnZSByZXBsYXlzIGV2ZW50c1xuICAgICAgICAvLyBpbiBvcmRlciwgaXQgaXMgc2FmZSB0byBkZWxldGUgdGhlIGVudHJ5IHJpZ2h0IGFmdGVyIHVwZGF0aW5nIGl0LlxuICAgICAgICB0aGlzLnJlbW92ZU11dGF0aW9uU3RhdGUoYmF0Y2hJZCk7XG4gICAgfVxuICAgIGFkZExvY2FsUXVlcnlUYXJnZXQodGFyZ2V0SWQsIGFkZFRvQWN0aXZlVGFyZ2V0SWRzID0gdHJ1ZSkge1xuICAgICAgICBsZXQgcXVlcnlTdGF0ZSA9ICdub3QtY3VycmVudCc7XG4gICAgICAgIC8vIExvb2t1cCBhbiBleGlzdGluZyBxdWVyeSBzdGF0ZSBpZiB0aGUgdGFyZ2V0IElEIHdhcyBhbHJlYWR5IHJlZ2lzdGVyZWRcbiAgICAgICAgLy8gYnkgYW5vdGhlciB0YWJcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmVRdWVyeVRhcmdldCh0YXJnZXRJZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JhZ2VJdGVtID0gdGhpcy5zdG9yYWdlLmdldEl0ZW0oY3JlYXRlV2ViU3RvcmFnZVF1ZXJ5VGFyZ2V0TWV0YWRhdGFLZXkodGhpcy5wZXJzaXN0ZW5jZUtleSwgdGFyZ2V0SWQpKTtcbiAgICAgICAgICAgIGlmIChzdG9yYWdlSXRlbSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gUXVlcnlUYXJnZXRNZXRhZGF0YS5mcm9tV2ViU3RvcmFnZUVudHJ5KHRhcmdldElkLCBzdG9yYWdlSXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5U3RhdGUgPSBtZXRhZGF0YS5zdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHF1ZXJ5IGlzIGxpc3RlbmluZyB0byBjYWNoZSBvbmx5LCB0aGUgdGFyZ2V0IElEIHNob3VsZCBub3QgYmUgcmVnaXN0ZXJlZCB3aXRoIHRoZVxuICAgICAgICAvLyBsb2NhbCBGaXJlc3RvcmUgY2xpZW50IGFzIGFuIGFjdGl2ZSB3YXRjaCB0YXJnZXQuXG4gICAgICAgIGlmIChhZGRUb0FjdGl2ZVRhcmdldElkcykge1xuICAgICAgICAgICAgdGhpcy5sb2NhbENsaWVudFN0YXRlLmFkZFF1ZXJ5VGFyZ2V0KHRhcmdldElkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlcnNpc3RDbGllbnRTdGF0ZSgpO1xuICAgICAgICByZXR1cm4gcXVlcnlTdGF0ZTtcbiAgICB9XG4gICAgcmVtb3ZlTG9jYWxRdWVyeVRhcmdldCh0YXJnZXRJZCkge1xuICAgICAgICB0aGlzLmxvY2FsQ2xpZW50U3RhdGUucmVtb3ZlUXVlcnlUYXJnZXQodGFyZ2V0SWQpO1xuICAgICAgICB0aGlzLnBlcnNpc3RDbGllbnRTdGF0ZSgpO1xuICAgIH1cbiAgICBpc0xvY2FsUXVlcnlUYXJnZXQodGFyZ2V0SWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxDbGllbnRTdGF0ZS5hY3RpdmVUYXJnZXRJZHMuaGFzKHRhcmdldElkKTtcbiAgICB9XG4gICAgY2xlYXJRdWVyeVN0YXRlKHRhcmdldElkKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShjcmVhdGVXZWJTdG9yYWdlUXVlcnlUYXJnZXRNZXRhZGF0YUtleSh0aGlzLnBlcnNpc3RlbmNlS2V5LCB0YXJnZXRJZCkpO1xuICAgIH1cbiAgICB1cGRhdGVRdWVyeVN0YXRlKHRhcmdldElkLCBzdGF0ZSwgZXJyb3IpIHtcbiAgICAgICAgdGhpcy5wZXJzaXN0UXVlcnlUYXJnZXRTdGF0ZSh0YXJnZXRJZCwgc3RhdGUsIGVycm9yKTtcbiAgICB9XG4gICAgaGFuZGxlVXNlckNoYW5nZSh1c2VyLCByZW1vdmVkQmF0Y2hJZHMsIGFkZGVkQmF0Y2hJZHMpIHtcbiAgICAgICAgcmVtb3ZlZEJhdGNoSWRzLmZvckVhY2goYmF0Y2hJZCA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZU11dGF0aW9uU3RhdGUoYmF0Y2hJZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmN1cnJlbnRVc2VyID0gdXNlcjtcbiAgICAgICAgYWRkZWRCYXRjaElkcy5mb3JFYWNoKGJhdGNoSWQgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGRQZW5kaW5nTXV0YXRpb24oYmF0Y2hJZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXRPbmxpbmVTdGF0ZShvbmxpbmVTdGF0ZSkge1xuICAgICAgICB0aGlzLnBlcnNpc3RPbmxpbmVTdGF0ZShvbmxpbmVTdGF0ZSk7XG4gICAgfVxuICAgIG5vdGlmeUJ1bmRsZUxvYWRlZChjb2xsZWN0aW9uR3JvdXBzKSB7XG4gICAgICAgIHRoaXMucGVyc2lzdEJ1bmRsZUxvYWRlZFN0YXRlKGNvbGxlY3Rpb25Hcm91cHMpO1xuICAgIH1cbiAgICBzaHV0ZG93bigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy53aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIHRoaXMuc3RvcmFnZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlSXRlbSh0aGlzLmxvY2FsQ2xpZW50U3RvcmFnZUtleSk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRJdGVtKGtleSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuc3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckYSwgJ1JFQUQnLCBrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXRJdGVtKGtleSwgdmFsdWUpIHtcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRhLCAnU0VUJywga2V5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZW1vdmVJdGVtKGtleSkge1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGEsICdSRU1PVkUnLCBrZXkpO1xuICAgICAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgIH1cbiAgICBoYW5kbGVXZWJTdG9yYWdlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgLy8gTm90ZTogVGhlIGZ1bmN0aW9uIGlzIHR5cGVkIHRvIHRha2UgRXZlbnQgdG8gYmUgaW50ZXJmYWNlLWNvbXBhdGlibGUgd2l0aFxuICAgICAgICAvLyBgV2luZG93LmFkZEV2ZW50TGlzdGVuZXJgLlxuICAgICAgICBjb25zdCBzdG9yYWdlRXZlbnQgPSBldmVudDtcbiAgICAgICAgaWYgKHN0b3JhZ2VFdmVudC5zdG9yYWdlQXJlYSA9PT0gdGhpcy5zdG9yYWdlKSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGEsICdFVkVOVCcsIHN0b3JhZ2VFdmVudC5rZXksIHN0b3JhZ2VFdmVudC5uZXdWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoc3RvcmFnZUV2ZW50LmtleSA9PT0gdGhpcy5sb2NhbENsaWVudFN0b3JhZ2VLZXkpIHtcbiAgICAgICAgICAgICAgICBsb2dFcnJvcignUmVjZWl2ZWQgV2ViU3RvcmFnZSBub3RpZmljYXRpb24gZm9yIGxvY2FsIGNoYW5nZS4gQW5vdGhlciBjbGllbnQgbWlnaHQgaGF2ZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2dhcmJhZ2UtY29sbGVjdGVkIG91ciBzdGF0ZScpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucXVldWUuZW5xdWV1ZVJldHJ5YWJsZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lYXJseUV2ZW50cy5wdXNoKHN0b3JhZ2VFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2VFdmVudC5rZXkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jbGllbnRTdGF0ZUtleVJlLnRlc3Qoc3RvcmFnZUV2ZW50LmtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2VFdmVudC5uZXdWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRTdGF0ZSA9IHRoaXMuZnJvbVdlYlN0b3JhZ2VDbGllbnRTdGF0ZShzdG9yYWdlRXZlbnQua2V5LCBzdG9yYWdlRXZlbnQubmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsaWVudFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlQ2xpZW50U3RhdGVFdmVudChjbGllbnRTdGF0ZS5jbGllbnRJZCwgY2xpZW50U3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpZW50SWQgPSB0aGlzLmZyb21XZWJTdG9yYWdlQ2xpZW50U3RhdGVLZXkoc3RvcmFnZUV2ZW50LmtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVDbGllbnRTdGF0ZUV2ZW50KGNsaWVudElkLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm11dGF0aW9uQmF0Y2hLZXlSZS50ZXN0KHN0b3JhZ2VFdmVudC5rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlRXZlbnQubmV3VmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG11dGF0aW9uTWV0YWRhdGEgPSB0aGlzLmZyb21XZWJTdG9yYWdlTXV0YXRpb25NZXRhZGF0YShzdG9yYWdlRXZlbnQua2V5LCBzdG9yYWdlRXZlbnQubmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVNdXRhdGlvbkJhdGNoRXZlbnQobXV0YXRpb25NZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5xdWVyeVRhcmdldEtleVJlLnRlc3Qoc3RvcmFnZUV2ZW50LmtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2VFdmVudC5uZXdWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcXVlcnlUYXJnZXRNZXRhZGF0YSA9IHRoaXMuZnJvbVdlYlN0b3JhZ2VRdWVyeVRhcmdldE1ldGFkYXRhKHN0b3JhZ2VFdmVudC5rZXksIHN0b3JhZ2VFdmVudC5uZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocXVlcnlUYXJnZXRNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVF1ZXJ5VGFyZ2V0RXZlbnQocXVlcnlUYXJnZXRNZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RvcmFnZUV2ZW50LmtleSA9PT0gdGhpcy5vbmxpbmVTdGF0ZUtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZUV2ZW50Lm5ld1ZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbmxpbmVTdGF0ZSA9IHRoaXMuZnJvbVdlYlN0b3JhZ2VPbmxpbmVTdGF0ZShzdG9yYWdlRXZlbnQubmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9ubGluZVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlT25saW5lU3RhdGVFdmVudChvbmxpbmVTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RvcmFnZUV2ZW50LmtleSA9PT0gdGhpcy5zZXF1ZW5jZU51bWJlcktleSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXF1ZW5jZU51bWJlciA9IGZyb21XZWJTdG9yYWdlU2VxdWVuY2VOdW1iZXIoc3RvcmFnZUV2ZW50Lm5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcXVlbmNlTnVtYmVyICE9PSBMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlcXVlbmNlTnVtYmVySGFuZGxlcihzZXF1ZW5jZU51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RvcmFnZUV2ZW50LmtleSA9PT0gdGhpcy5idW5kbGVMb2FkZWRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvbkdyb3VwcyA9IHRoaXMuZnJvbVdlYlN0b3JlQnVuZGxlTG9hZGVkU3RhdGUoc3RvcmFnZUV2ZW50Lm5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoY29sbGVjdGlvbkdyb3Vwcy5tYXAoY2cgPT4gdGhpcy5zeW5jRW5naW5lLnN5bmNocm9uaXplV2l0aENoYW5nZWREb2N1bWVudHMoY2cpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGxvY2FsQ2xpZW50U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZUNsaWVudHMuZ2V0KHRoaXMubG9jYWxDbGllbnRJZCk7XG4gICAgfVxuICAgIHBlcnNpc3RDbGllbnRTdGF0ZSgpIHtcbiAgICAgICAgdGhpcy5zZXRJdGVtKHRoaXMubG9jYWxDbGllbnRTdG9yYWdlS2V5LCB0aGlzLmxvY2FsQ2xpZW50U3RhdGUudG9XZWJTdG9yYWdlSlNPTigpKTtcbiAgICB9XG4gICAgcGVyc2lzdE11dGF0aW9uU3RhdGUoYmF0Y2hJZCwgc3RhdGUsIGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uU3RhdGUgPSBuZXcgTXV0YXRpb25NZXRhZGF0YSh0aGlzLmN1cnJlbnRVc2VyLCBiYXRjaElkLCBzdGF0ZSwgZXJyb3IpO1xuICAgICAgICBjb25zdCBtdXRhdGlvbktleSA9IGNyZWF0ZVdlYlN0b3JhZ2VNdXRhdGlvbkJhdGNoS2V5KHRoaXMucGVyc2lzdGVuY2VLZXksIHRoaXMuY3VycmVudFVzZXIsIGJhdGNoSWQpO1xuICAgICAgICB0aGlzLnNldEl0ZW0obXV0YXRpb25LZXksIG11dGF0aW9uU3RhdGUudG9XZWJTdG9yYWdlSlNPTigpKTtcbiAgICB9XG4gICAgcmVtb3ZlTXV0YXRpb25TdGF0ZShiYXRjaElkKSB7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uS2V5ID0gY3JlYXRlV2ViU3RvcmFnZU11dGF0aW9uQmF0Y2hLZXkodGhpcy5wZXJzaXN0ZW5jZUtleSwgdGhpcy5jdXJyZW50VXNlciwgYmF0Y2hJZCk7XG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShtdXRhdGlvbktleSk7XG4gICAgfVxuICAgIHBlcnNpc3RPbmxpbmVTdGF0ZShvbmxpbmVTdGF0ZSkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgICAgICAgIGNsaWVudElkOiB0aGlzLmxvY2FsQ2xpZW50SWQsXG4gICAgICAgICAgICBvbmxpbmVTdGF0ZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLm9ubGluZVN0YXRlS2V5LCBKU09OLnN0cmluZ2lmeShlbnRyeSkpO1xuICAgIH1cbiAgICBwZXJzaXN0UXVlcnlUYXJnZXRTdGF0ZSh0YXJnZXRJZCwgc3RhdGUsIGVycm9yKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldEtleSA9IGNyZWF0ZVdlYlN0b3JhZ2VRdWVyeVRhcmdldE1ldGFkYXRhS2V5KHRoaXMucGVyc2lzdGVuY2VLZXksIHRhcmdldElkKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0TWV0YWRhdGEgPSBuZXcgUXVlcnlUYXJnZXRNZXRhZGF0YSh0YXJnZXRJZCwgc3RhdGUsIGVycm9yKTtcbiAgICAgICAgdGhpcy5zZXRJdGVtKHRhcmdldEtleSwgdGFyZ2V0TWV0YWRhdGEudG9XZWJTdG9yYWdlSlNPTigpKTtcbiAgICB9XG4gICAgcGVyc2lzdEJ1bmRsZUxvYWRlZFN0YXRlKGNvbGxlY3Rpb25Hcm91cHMpIHtcbiAgICAgICAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KEFycmF5LmZyb20oY29sbGVjdGlvbkdyb3VwcykpO1xuICAgICAgICB0aGlzLnNldEl0ZW0odGhpcy5idW5kbGVMb2FkZWRLZXksIGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBjbGllbnQgc3RhdGUga2V5IGluIFdlYlN0b3JhZ2UuIFJldHVybnMgbnVsbCBpZiB0aGUga2V5IGRvZXMgbm90XG4gICAgICogbWF0Y2ggdGhlIGV4cGVjdGVkIGtleSBmb3JtYXQuXG4gICAgICovXG4gICAgZnJvbVdlYlN0b3JhZ2VDbGllbnRTdGF0ZUtleShrZXkpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0aGlzLmNsaWVudFN0YXRlS2V5UmUuZXhlYyhrZXkpO1xuICAgICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIGNsaWVudCBzdGF0ZSBpbiBXZWJTdG9yYWdlLiBSZXR1cm5zICdudWxsJyBpZiB0aGUgdmFsdWUgY291bGQgbm90XG4gICAgICogYmUgcGFyc2VkLlxuICAgICAqL1xuICAgIGZyb21XZWJTdG9yYWdlQ2xpZW50U3RhdGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBjbGllbnRJZCA9IHRoaXMuZnJvbVdlYlN0b3JhZ2VDbGllbnRTdGF0ZUtleShrZXkpO1xuICAgICAgICByZXR1cm4gUmVtb3RlQ2xpZW50U3RhdGUuZnJvbVdlYlN0b3JhZ2VFbnRyeShjbGllbnRJZCwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBtdXRhdGlvbiBiYXRjaCBzdGF0ZSBpbiBXZWJTdG9yYWdlLiBSZXR1cm5zICdudWxsJyBpZiB0aGUgdmFsdWVcbiAgICAgKiBjb3VsZCBub3QgYmUgcGFyc2VkLlxuICAgICAqL1xuICAgIGZyb21XZWJTdG9yYWdlTXV0YXRpb25NZXRhZGF0YShrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGhpcy5tdXRhdGlvbkJhdGNoS2V5UmUuZXhlYyhrZXkpO1xuICAgICAgICBjb25zdCBiYXRjaElkID0gTnVtYmVyKG1hdGNoWzFdKTtcbiAgICAgICAgY29uc3QgdXNlcklkID0gbWF0Y2hbMl0gIT09IHVuZGVmaW5lZCA/IG1hdGNoWzJdIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIE11dGF0aW9uTWV0YWRhdGEuZnJvbVdlYlN0b3JhZ2VFbnRyeShuZXcgVXNlcih1c2VySWQpLCBiYXRjaElkLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIHF1ZXJ5IHRhcmdldCBzdGF0ZSBmcm9tIFdlYlN0b3JhZ2UuIFJldHVybnMgJ251bGwnIGlmIHRoZSB2YWx1ZVxuICAgICAqIGNvdWxkIG5vdCBiZSBwYXJzZWQuXG4gICAgICovXG4gICAgZnJvbVdlYlN0b3JhZ2VRdWVyeVRhcmdldE1ldGFkYXRhKGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0aGlzLnF1ZXJ5VGFyZ2V0S2V5UmUuZXhlYyhrZXkpO1xuICAgICAgICBjb25zdCB0YXJnZXRJZCA9IE51bWJlcihtYXRjaFsxXSk7XG4gICAgICAgIHJldHVybiBRdWVyeVRhcmdldE1ldGFkYXRhLmZyb21XZWJTdG9yYWdlRW50cnkodGFyZ2V0SWQsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGFuIG9ubGluZSBzdGF0ZSBmcm9tIFdlYlN0b3JhZ2UuIFJldHVybnMgJ251bGwnIGlmIHRoZSB2YWx1ZVxuICAgICAqIGNvdWxkIG5vdCBiZSBwYXJzZWQuXG4gICAgICovXG4gICAgZnJvbVdlYlN0b3JhZ2VPbmxpbmVTdGF0ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gU2hhcmVkT25saW5lU3RhdGUuZnJvbVdlYlN0b3JhZ2VFbnRyeSh2YWx1ZSk7XG4gICAgfVxuICAgIGZyb21XZWJTdG9yZUJ1bmRsZUxvYWRlZFN0YXRlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTXV0YXRpb25CYXRjaEV2ZW50KG11dGF0aW9uQmF0Y2gpIHtcbiAgICAgICAgaWYgKG11dGF0aW9uQmF0Y2gudXNlci51aWQgIT09IHRoaXMuY3VycmVudFVzZXIudWlkKSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGEsIGBJZ25vcmluZyBtdXRhdGlvbiBmb3Igbm9uLWFjdGl2ZSB1c2VyICR7bXV0YXRpb25CYXRjaC51c2VyLnVpZH1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zeW5jRW5naW5lLmFwcGx5QmF0Y2hTdGF0ZShtdXRhdGlvbkJhdGNoLmJhdGNoSWQsIG11dGF0aW9uQmF0Y2guc3RhdGUsIG11dGF0aW9uQmF0Y2guZXJyb3IpO1xuICAgIH1cbiAgICBoYW5kbGVRdWVyeVRhcmdldEV2ZW50KHRhcmdldE1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bmNFbmdpbmUuYXBwbHlUYXJnZXRTdGF0ZSh0YXJnZXRNZXRhZGF0YS50YXJnZXRJZCwgdGFyZ2V0TWV0YWRhdGEuc3RhdGUsIHRhcmdldE1ldGFkYXRhLmVycm9yKTtcbiAgICB9XG4gICAgaGFuZGxlQ2xpZW50U3RhdGVFdmVudChjbGllbnRJZCwgY2xpZW50U3RhdGUpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlZENsaWVudHMgPSBjbGllbnRTdGF0ZVxuICAgICAgICAgICAgPyB0aGlzLmFjdGl2ZUNsaWVudHMuaW5zZXJ0KGNsaWVudElkLCBjbGllbnRTdGF0ZSlcbiAgICAgICAgICAgIDogdGhpcy5hY3RpdmVDbGllbnRzLnJlbW92ZShjbGllbnRJZCk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVGFyZ2V0cyA9IHRoaXMuZXh0cmFjdEFjdGl2ZVF1ZXJ5VGFyZ2V0cyh0aGlzLmFjdGl2ZUNsaWVudHMpO1xuICAgICAgICBjb25zdCBuZXdUYXJnZXRzID0gdGhpcy5leHRyYWN0QWN0aXZlUXVlcnlUYXJnZXRzKHVwZGF0ZWRDbGllbnRzKTtcbiAgICAgICAgY29uc3QgYWRkZWRUYXJnZXRzID0gW107XG4gICAgICAgIGNvbnN0IHJlbW92ZWRUYXJnZXRzID0gW107XG4gICAgICAgIG5ld1RhcmdldHMuZm9yRWFjaCh0YXJnZXRJZCA9PiB7XG4gICAgICAgICAgICBpZiAoIWV4aXN0aW5nVGFyZ2V0cy5oYXModGFyZ2V0SWQpKSB7XG4gICAgICAgICAgICAgICAgYWRkZWRUYXJnZXRzLnB1c2godGFyZ2V0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZXhpc3RpbmdUYXJnZXRzLmZvckVhY2godGFyZ2V0SWQgPT4ge1xuICAgICAgICAgICAgaWYgKCFuZXdUYXJnZXRzLmhhcyh0YXJnZXRJZCkpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVkVGFyZ2V0cy5wdXNoKHRhcmdldElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bmNFbmdpbmUuYXBwbHlBY3RpdmVUYXJnZXRzQ2hhbmdlKGFkZGVkVGFyZ2V0cywgcmVtb3ZlZFRhcmdldHMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVDbGllbnRzID0gdXBkYXRlZENsaWVudHM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVPbmxpbmVTdGF0ZUV2ZW50KG9ubGluZVN0YXRlKSB7XG4gICAgICAgIC8vIFdlIGNoZWNrIHdoZXRoZXIgdGhlIGNsaWVudCB0aGF0IHdyb3RlIHRoaXMgb25saW5lIHN0YXRlIGlzIHN0aWxsIGFjdGl2ZVxuICAgICAgICAvLyBieSBjb21wYXJpbmcgaXRzIGNsaWVudCBJRCB0byB0aGUgbGlzdCBvZiBjbGllbnRzIGtlcHQgYWN0aXZlIGluXG4gICAgICAgIC8vIEluZGV4ZWREYi4gSWYgYSBjbGllbnQgZG9lcyBub3QgdXBkYXRlIHRoZWlyIEluZGV4ZWREYiBjbGllbnQgc3RhdGVcbiAgICAgICAgLy8gd2l0aGluIDUgc2Vjb25kcywgaXQgaXMgY29uc2lkZXJlZCBpbmFjdGl2ZSBhbmQgd2UgZG9uJ3QgZW1pdCBhbiBvbmxpbmVcbiAgICAgICAgLy8gc3RhdGUgZXZlbnQuXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUNsaWVudHMuZ2V0KG9ubGluZVN0YXRlLmNsaWVudElkKSkge1xuICAgICAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZUhhbmRsZXIob25saW5lU3RhdGUub25saW5lU3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4dHJhY3RBY3RpdmVRdWVyeVRhcmdldHMoY2xpZW50cykge1xuICAgICAgICBsZXQgYWN0aXZlVGFyZ2V0cyA9IHRhcmdldElkU2V0KCk7XG4gICAgICAgIGNsaWVudHMuZm9yRWFjaCgoa2V2LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgYWN0aXZlVGFyZ2V0cyA9IGFjdGl2ZVRhcmdldHMudW5pb25XaXRoKHZhbHVlLmFjdGl2ZVRhcmdldElkcyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYWN0aXZlVGFyZ2V0cztcbiAgICB9XG59XG5mdW5jdGlvbiBmcm9tV2ViU3RvcmFnZVNlcXVlbmNlTnVtYmVyKHNlcVN0cmluZykge1xuICAgIGxldCBzZXF1ZW5jZU51bWJlciA9IExpc3RlblNlcXVlbmNlLklOVkFMSUQ7XG4gICAgaWYgKHNlcVN0cmluZyAhPSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHNlcVN0cmluZyk7XG4gICAgICAgICAgICBoYXJkQXNzZXJ0KHR5cGVvZiBwYXJzZWQgPT09ICdudW1iZXInKTtcbiAgICAgICAgICAgIHNlcXVlbmNlTnVtYmVyID0gcGFyc2VkO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dFcnJvcihMT0dfVEFHJGEsICdGYWlsZWQgdG8gcmVhZCBzZXF1ZW5jZSBudW1iZXIgZnJvbSBXZWJTdG9yYWdlJywgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlcXVlbmNlTnVtYmVyO1xufVxuLyoqXG4gKiBgTWVtb3J5U2hhcmVkQ2xpZW50U3RhdGVgIGlzIGEgc2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIFNoYXJlZENsaWVudFN0YXRlIGZvclxuICogY2xpZW50cyB1c2luZyBtZW1vcnkgcGVyc2lzdGVuY2UuIFRoZSBzdGF0ZSBpbiB0aGlzIGNsYXNzIHJlbWFpbnMgZnVsbHlcbiAqIGlzb2xhdGVkIGFuZCBubyBzeW5jaHJvbml6YXRpb24gaXMgcGVyZm9ybWVkLlxuICovXG5jbGFzcyBNZW1vcnlTaGFyZWRDbGllbnRTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubG9jYWxTdGF0ZSA9IG5ldyBMb2NhbENsaWVudFN0YXRlKCk7XG4gICAgICAgIHRoaXMucXVlcnlTdGF0ZSA9IHt9O1xuICAgICAgICB0aGlzLm9ubGluZVN0YXRlSGFuZGxlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VxdWVuY2VOdW1iZXJIYW5kbGVyID0gbnVsbDtcbiAgICB9XG4gICAgYWRkUGVuZGluZ011dGF0aW9uKGJhdGNoSWQpIHtcbiAgICAgICAgLy8gTm8gb3AuXG4gICAgfVxuICAgIHVwZGF0ZU11dGF0aW9uU3RhdGUoYmF0Y2hJZCwgc3RhdGUsIGVycm9yKSB7XG4gICAgICAgIC8vIE5vIG9wLlxuICAgIH1cbiAgICBhZGRMb2NhbFF1ZXJ5VGFyZ2V0KHRhcmdldElkLCBhZGRUb0FjdGl2ZVRhcmdldElkcyA9IHRydWUpIHtcbiAgICAgICAgaWYgKGFkZFRvQWN0aXZlVGFyZ2V0SWRzKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsU3RhdGUuYWRkUXVlcnlUYXJnZXQodGFyZ2V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5U3RhdGVbdGFyZ2V0SWRdIHx8ICdub3QtY3VycmVudCc7XG4gICAgfVxuICAgIHVwZGF0ZVF1ZXJ5U3RhdGUodGFyZ2V0SWQsIHN0YXRlLCBlcnJvcikge1xuICAgICAgICB0aGlzLnF1ZXJ5U3RhdGVbdGFyZ2V0SWRdID0gc3RhdGU7XG4gICAgfVxuICAgIHJlbW92ZUxvY2FsUXVlcnlUYXJnZXQodGFyZ2V0SWQpIHtcbiAgICAgICAgdGhpcy5sb2NhbFN0YXRlLnJlbW92ZVF1ZXJ5VGFyZ2V0KHRhcmdldElkKTtcbiAgICB9XG4gICAgaXNMb2NhbFF1ZXJ5VGFyZ2V0KHRhcmdldElkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsU3RhdGUuYWN0aXZlVGFyZ2V0SWRzLmhhcyh0YXJnZXRJZCk7XG4gICAgfVxuICAgIGNsZWFyUXVlcnlTdGF0ZSh0YXJnZXRJZCkge1xuICAgICAgICBkZWxldGUgdGhpcy5xdWVyeVN0YXRlW3RhcmdldElkXTtcbiAgICB9XG4gICAgZ2V0QWxsQWN0aXZlUXVlcnlUYXJnZXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFN0YXRlLmFjdGl2ZVRhcmdldElkcztcbiAgICB9XG4gICAgaXNBY3RpdmVRdWVyeVRhcmdldCh0YXJnZXRJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFN0YXRlLmFjdGl2ZVRhcmdldElkcy5oYXModGFyZ2V0SWQpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5sb2NhbFN0YXRlID0gbmV3IExvY2FsQ2xpZW50U3RhdGUoKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBoYW5kbGVVc2VyQ2hhbmdlKHVzZXIsIHJlbW92ZWRCYXRjaElkcywgYWRkZWRCYXRjaElkcykge1xuICAgICAgICAvLyBObyBvcC5cbiAgICB9XG4gICAgc2V0T25saW5lU3RhdGUob25saW5lU3RhdGUpIHtcbiAgICAgICAgLy8gTm8gb3AuXG4gICAgfVxuICAgIHNodXRkb3duKCkgeyB9XG4gICAgd3JpdGVTZXF1ZW5jZU51bWJlcihzZXF1ZW5jZU51bWJlcikgeyB9XG4gICAgbm90aWZ5QnVuZGxlTG9hZGVkKGNvbGxlY3Rpb25Hcm91cHMpIHtcbiAgICAgICAgLy8gTm8gb3AuXG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgTm9vcENvbm5lY3Rpdml0eU1vbml0b3Ige1xuICAgIGFkZENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIE5vLW9wLlxuICAgIH1cbiAgICBzaHV0ZG93bigpIHtcbiAgICAgICAgLy8gTm8tb3AuXG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBQcm92aWRlcyBhIHNpbXBsZSBoZWxwZXIgY2xhc3MgdGhhdCBpbXBsZW1lbnRzIHRoZSBTdHJlYW0gaW50ZXJmYWNlIHRvXG4gKiBicmlkZ2UgdG8gb3RoZXIgaW1wbGVtZW50YXRpb25zIHRoYXQgYXJlIHN0cmVhbXMgYnV0IGRvIG5vdCBpbXBsZW1lbnQgdGhlXG4gKiBpbnRlcmZhY2UuIFRoZSBzdHJlYW0gY2FsbGJhY2tzIGFyZSBpbnZva2VkIHdpdGggdGhlIGNhbGxPbi4uLiBtZXRob2RzLlxuICovXG5jbGFzcyBTdHJlYW1CcmlkZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICAgICAgdGhpcy5zZW5kRm4gPSBhcmdzLnNlbmRGbjtcbiAgICAgICAgdGhpcy5jbG9zZUZuID0gYXJncy5jbG9zZUZuO1xuICAgIH1cbiAgICBvbkNvbm5lY3RlZChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLndyYXBwZWRPbkNvbm5lY3RlZCA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBvbk9wZW4oY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy53cmFwcGVkT25PcGVuID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIG9uQ2xvc2UoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy53cmFwcGVkT25DbG9zZSA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBvbk1lc3NhZ2UoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy53cmFwcGVkT25NZXNzYWdlID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLmNsb3NlRm4oKTtcbiAgICB9XG4gICAgc2VuZChtc2cpIHtcbiAgICAgICAgdGhpcy5zZW5kRm4obXNnKTtcbiAgICB9XG4gICAgY2FsbE9uQ29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLndyYXBwZWRPbkNvbm5lY3RlZCgpO1xuICAgIH1cbiAgICBjYWxsT25PcGVuKCkge1xuICAgICAgICB0aGlzLndyYXBwZWRPbk9wZW4oKTtcbiAgICB9XG4gICAgY2FsbE9uQ2xvc2UoZXJyKSB7XG4gICAgICAgIHRoaXMud3JhcHBlZE9uQ2xvc2UoZXJyKTtcbiAgICB9XG4gICAgY2FsbE9uTWVzc2FnZShtc2cpIHtcbiAgICAgICAgdGhpcy53cmFwcGVkT25NZXNzYWdlKG1zZyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaGUgdmFsdWUgcmV0dXJuZWQgZnJvbSB0aGUgbW9zdCByZWNlbnQgaW52b2NhdGlvbiBvZlxuICogYGdlbmVyYXRlVW5pcXVlRGVidWdJZCgpYCwgb3IgbnVsbCBpZiBpdCBoYXMgbmV2ZXIgYmVlbiBpbnZva2VkLlxuICovXG5sZXQgbGFzdFVuaXF1ZURlYnVnSWQgPSBudWxsO1xuLyoqXG4gKiBHZW5lcmF0ZXMgYW5kIHJldHVybnMgYW4gaW5pdGlhbCB2YWx1ZSBmb3IgYGxhc3RVbmlxdWVEZWJ1Z0lkYC5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgdmFsdWUgaXMgcmFuZG9tbHkgc2VsZWN0ZWQgZnJvbSBhIHJhbmdlIG9mIGludGVnZXJzIHRoYXQgYXJlXG4gKiByZXByZXNlbnRlZCBhcyA4IGhleGFkZWNpbWFsIGRpZ2l0cy4gVGhpcyBtZWFucyB0aGF0ICh3aXRoaW4gcmVhc29uKSBhbnlcbiAqIG51bWJlcnMgZ2VuZXJhdGVkIGJ5IGluY3JlbWVudGluZyB0aGUgcmV0dXJuZWQgbnVtYmVyIGJ5IDEgd2lsbCBhbHNvIGJlXG4gKiByZXByZXNlbnRlZCBieSA4IGhleGFkZWNpbWFsIGRpZ2l0cy4gVGhpcyBsZWFkcyB0byBhbGwgXCJJRHNcIiBoYXZpbmcgdGhlIHNhbWVcbiAqIGxlbmd0aCB3aGVuIGNvbnZlcnRlZCB0byBhIGhleGFkZWNpbWFsIHN0cmluZywgbWFraW5nIHJlYWRpbmcgbG9ncyBjb250YWluaW5nXG4gKiB0aGVzZSBJRHMgZWFzaWVyIHRvIGZvbGxvdy4gQW5kIHNpbmNlIHRoZSByZXR1cm4gdmFsdWUgaXMgcmFuZG9tbHkgc2VsZWN0ZWRcbiAqIGl0IHdpbGwgaGVscCB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gbG9ncyBmcm9tIGRpZmZlcmVudCBleGVjdXRpb25zLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUluaXRpYWxVbmlxdWVEZWJ1Z0lkKCkge1xuICAgIGNvbnN0IG1pblJlc3VsdCA9IDB4MTAwMDAwMDA7XG4gICAgY29uc3QgbWF4UmVzdWx0ID0gMHg5MDAwMDAwMDtcbiAgICBjb25zdCByZXN1bHRSYW5nZSA9IG1heFJlc3VsdCAtIG1pblJlc3VsdDtcbiAgICBjb25zdCByZXN1bHRPZmZzZXQgPSBNYXRoLnJvdW5kKHJlc3VsdFJhbmdlICogTWF0aC5yYW5kb20oKSk7XG4gICAgcmV0dXJuIG1pblJlc3VsdCArIHJlc3VsdE9mZnNldDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGFuZCByZXR1cm5zIGEgdW5pcXVlIElEIGFzIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICpcbiAqIFRoZSByZXR1cm5lZCBJRCBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIGluIGRlYnVnIGxvZ2dpbmcgbWVzc2FnZXMgdG8gaGVscFxuICogY29ycmVsYXRlIGxvZyBtZXNzYWdlcyB0aGF0IG1heSBiZSBzcGF0aWFsbHkgc2VwYXJhdGVkIGluIHRoZSBsb2dzLCBidXRcbiAqIGxvZ2ljYWxseSByZWxhdGVkLiBGb3IgZXhhbXBsZSwgYSBuZXR3b3JrIGNvbm5lY3Rpb24gY291bGQgaW5jbHVkZSB0aGUgc2FtZVxuICogXCJkZWJ1ZyBJRFwiIHN0cmluZyBpbiBhbGwgb2YgaXRzIGxvZyBtZXNzYWdlcyB0byBoZWxwIHRyYWNlIGEgc3BlY2lmaWNcbiAqIGNvbm5lY3Rpb24gb3ZlciB0aW1lLlxuICpcbiAqIEByZXR1cm4gdGhlIDEwLWNoYXJhY3RlciBnZW5lcmF0ZWQgSUQgKGUuZy4gXCIweGExYjJjM2Q0XCIpLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVVuaXF1ZURlYnVnSWQoKSB7XG4gICAgaWYgKGxhc3RVbmlxdWVEZWJ1Z0lkID09PSBudWxsKSB7XG4gICAgICAgIGxhc3RVbmlxdWVEZWJ1Z0lkID0gZ2VuZXJhdGVJbml0aWFsVW5pcXVlRGVidWdJZCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGFzdFVuaXF1ZURlYnVnSWQrKztcbiAgICB9XG4gICAgcmV0dXJuICcweCcgKyBsYXN0VW5pcXVlRGVidWdJZC50b1N0cmluZygxNik7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKlxuICogVXRpbGl0aWVzIGZvciBkZWFsaW5nIHdpdGggbm9kZS5qcy1zdHlsZSBBUElzLiBTZWUgbm9kZVByb21pc2UgZm9yIG1vcmVcbiAqIGRldGFpbHMuXG4gKi9cbi8qKlxuICogQ3JlYXRlcyBhIG5vZGUtc3R5bGUgY2FsbGJhY2sgdGhhdCByZXNvbHZlcyBvciByZWplY3RzIGEgbmV3IFByb21pc2UuIFRoZVxuICogY2FsbGJhY2sgaXMgcGFzc2VkIHRvIHRoZSBnaXZlbiBhY3Rpb24gd2hpY2ggY2FuIHRoZW4gdXNlIHRoZSBjYWxsYmFjayBhc1xuICogYSBwYXJhbWV0ZXIgdG8gYSBub2RlLXN0eWxlIGZ1bmN0aW9uLlxuICpcbiAqIFRoZSBpbnRlbnQgaXMgdG8gZGlyZWN0bHkgYnJpZGdlIGEgbm9kZS1zdHlsZSBmdW5jdGlvbiAod2hpY2ggdGFrZXMgYVxuICogY2FsbGJhY2spIGludG8gYSBQcm9taXNlIHdpdGhvdXQgbWFudWFsbHkgY29udmVydGluZyBiZXR3ZWVuIHRoZSBub2RlLXN0eWxlXG4gKiBjYWxsYmFjayBhbmQgdGhlIHByb21pc2UgYXQgZWFjaCBjYWxsLlxuICpcbiAqIEluIGVmZmVjdCBpdCBhbGxvd3MgeW91IHRvIGNvbnZlcnQ6XG4gKlxuICogQGV4YW1wbGVcbiAqIG5ldyBQcm9taXNlKChyZXNvbHZlOiAodmFsdWU/OiBmcy5TdGF0cykgPT4gdm9pZCxcbiAqICAgICAgICAgICAgICByZWplY3Q6IChlcnJvcj86IGFueSkgPT4gdm9pZCkgPT4ge1xuICogICBmcy5zdGF0KHBhdGgsIChlcnJvcj86IGFueSwgc3RhdD86IGZzLlN0YXRzKSA9PiB7XG4gKiAgICAgaWYgKGVycm9yKSB7XG4gKiAgICAgICByZWplY3QoZXJyb3IpO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICByZXNvbHZlKHN0YXQpO1xuICogICAgIH1cbiAqICAgfSk7XG4gKiB9KTtcbiAqXG4gKiBJbnRvXG4gKiBAZXhhbXBsZVxuICogbm9kZVByb21pc2UoKGNhbGxiYWNrOiBOb2RlQ2FsbGJhY2s8ZnMuU3RhdHM+KSA9PiB7XG4gKiAgIGZzLnN0YXQocGF0aCwgY2FsbGJhY2spO1xuICogfSk7XG4gKlxuICogQHBhcmFtIGFjdGlvbiAtIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIG5vZGUtc3R5bGUgY2FsbGJhY2sgYXMgYW4gYXJndW1lbnRcbiAqICAgICBhbmQgdGhlbiB1c2VzIHRoYXQgY2FsbGJhY2sgdG8gaW52b2tlIHNvbWUgbm9kZS1zdHlsZSBBUEkuXG4gKiBAcmV0dXJucyBhIG5ldyBQcm9taXNlIHdoaWNoIHdpbGwgYmUgcmVqZWN0ZWQgaWYgdGhlIGNhbGxiYWNrIGlzIGdpdmVuIHRoZVxuICogICAgIGZpcnN0IEVycm9yIHBhcmFtZXRlciBvciB3aWxsIHJlc29sdmUgdG8gdGhlIHZhbHVlIGdpdmVuIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gbm9kZVByb21pc2UoYWN0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgYWN0aW9uKChlcnJvciwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBUT0RPOiBGZXRjaCBydW50aW1lIHZlcnNpb24gZnJvbSBncnBjLWpzL3BhY2thZ2UuanNvbiBpbnN0ZWFkXG4vLyB3aGVuIHRoZXJlJ3MgYSBjbGVhbmVyIHdheSB0byBkeW5hbWljIHJlcXVpcmUgSlNPTiBpbiBib3RoIE5vZGUgRVNNIGFuZCBDSlNcbmNvbnN0IGdycGNWZXJzaW9uID0gJzEuOS4xJztcbmNvbnN0IExPR19UQUckOSA9ICdHcnBjQ29ubmVjdGlvbic7XG5jb25zdCBYX0dPT0dfQVBJX0NMSUVOVF9WQUxVRSA9IGBnbC1ub2RlLyR7cHJvY2Vzcy52ZXJzaW9ucy5ub2RlfSBmaXJlLyR7U0RLX1ZFUlNJT059IGdycGMvJHtncnBjVmVyc2lvbn1gO1xuZnVuY3Rpb24gY3JlYXRlTWV0YWRhdGEoZGF0YWJhc2VQYXRoLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4sIGFwcElkKSB7XG4gICAgaGFyZEFzc2VydChhdXRoVG9rZW4gPT09IG51bGwgfHwgYXV0aFRva2VuLnR5cGUgPT09ICdPQXV0aCcpO1xuICAgIGNvbnN0IG1ldGFkYXRhID0gbmV3IGdycGMuTWV0YWRhdGEoKTtcbiAgICBpZiAoYXV0aFRva2VuKSB7XG4gICAgICAgIGF1dGhUb2tlbi5oZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IG1ldGFkYXRhLnNldChrZXksIHZhbHVlKSk7XG4gICAgfVxuICAgIGlmIChhcHBDaGVja1Rva2VuKSB7XG4gICAgICAgIGFwcENoZWNrVG9rZW4uaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiBtZXRhZGF0YS5zZXQoa2V5LCB2YWx1ZSkpO1xuICAgIH1cbiAgICBpZiAoYXBwSWQpIHtcbiAgICAgICAgbWV0YWRhdGEuc2V0KCdYLUZpcmViYXNlLUdNUElEJywgYXBwSWQpO1xuICAgIH1cbiAgICBtZXRhZGF0YS5zZXQoJ1gtR29vZy1BcGktQ2xpZW50JywgWF9HT09HX0FQSV9DTElFTlRfVkFMVUUpO1xuICAgIC8vIFRoZXNlIGhlYWRlcnMgYXJlIHVzZWQgdG8gaW1wcm92ZSByb3V0aW5nIGFuZCBwcm9qZWN0IGlzb2xhdGlvbiBieSB0aGVcbiAgICAvLyBiYWNrZW5kLlxuICAgIC8vIFRPRE8oYi8xOTk3Njc3MTIpOiBXZSBhcmUga2VlcGluZyAnR29vZ2xlLUNsb3VkLVJlc291cmNlLVByZWZpeCcgdW50aWwgRW11bGF0b3JzIGNhbiBiZVxuICAgIC8vIHJlbGVhc2VkIHdpdGggY2wvNDI4ODIwMDQ2LiBDdXJyZW50bHkgYmxvY2tlZCBiZWNhdXNlIEVtdWxhdG9ycyBhcmUgbm93IGJ1aWx0IHdpdGggSmF2YVxuICAgIC8vIDExIGZyb20gR29vZ2xlMy5cbiAgICBtZXRhZGF0YS5zZXQoJ0dvb2dsZS1DbG91ZC1SZXNvdXJjZS1QcmVmaXgnLCBkYXRhYmFzZVBhdGgpO1xuICAgIG1ldGFkYXRhLnNldCgneC1nb29nLXJlcXVlc3QtcGFyYW1zJywgZGF0YWJhc2VQYXRoKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG59XG4vKipcbiAqIEEgQ29ubmVjdGlvbiBpbXBsZW1lbnRlZCBieSBHUlBDLU5vZGUuXG4gKi9cbmNsYXNzIEdycGNDb25uZWN0aW9uIHtcbiAgICBnZXQgc2hvdWxkUmVzb3VyY2VQYXRoQmVJbmNsdWRlZEluUmVxdWVzdCgpIHtcbiAgICAgICAgLy8gQm90aCBgaW52b2tlUlBDKClgIGFuZCBgaW52b2tlU3RyZWFtaW5nUlBDKClgIGlnbm9yZSB0aGVpciBgcGF0aGAgYXJndW1lbnRzLCBhbmQgZXhwZWN0XG4gICAgICAgIC8vIHRoZSBcInBhdGhcIiB0byBiZSBwYXJ0IG9mIHRoZSBnaXZlbiBgcmVxdWVzdGAuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihwcm90b3MsIGRhdGFiYXNlSW5mbykge1xuICAgICAgICB0aGlzLmRhdGFiYXNlSW5mbyA9IGRhdGFiYXNlSW5mbztcbiAgICAgICAgLy8gV2UgY2FjaGUgc3R1YnMgZm9yIHRoZSBtb3N0LXJlY2VudGx5LXVzZWQgdG9rZW4uXG4gICAgICAgIHRoaXMuY2FjaGVkU3R1YiA9IG51bGw7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHRoaXMuZmlyZXN0b3JlID0gcHJvdG9zWydnb29nbGUnXVsnZmlyZXN0b3JlJ11bJ3YxJ107XG4gICAgICAgIHRoaXMuZGF0YWJhc2VQYXRoID0gYHByb2plY3RzLyR7ZGF0YWJhc2VJbmZvLmRhdGFiYXNlSWQucHJvamVjdElkfS9kYXRhYmFzZXMvJHtkYXRhYmFzZUluZm8uZGF0YWJhc2VJZC5kYXRhYmFzZX1gO1xuICAgIH1cbiAgICBlbnN1cmVBY3RpdmVTdHViKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2FjaGVkU3R1Yikge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ5LCAnQ3JlYXRpbmcgRmlyZXN0b3JlIHN0dWIuJyk7XG4gICAgICAgICAgICBjb25zdCBjcmVkZW50aWFscyA9IHRoaXMuZGF0YWJhc2VJbmZvLnNzbFxuICAgICAgICAgICAgICAgID8gZ3JwYy5jcmVkZW50aWFscy5jcmVhdGVTc2woKVxuICAgICAgICAgICAgICAgIDogZ3JwYy5jcmVkZW50aWFscy5jcmVhdGVJbnNlY3VyZSgpO1xuICAgICAgICAgICAgdGhpcy5jYWNoZWRTdHViID0gbmV3IHRoaXMuZmlyZXN0b3JlLkZpcmVzdG9yZSh0aGlzLmRhdGFiYXNlSW5mby5ob3N0LCBjcmVkZW50aWFscyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkU3R1YjtcbiAgICB9XG4gICAgaW52b2tlUlBDKHJwY05hbWUsIHBhdGgsIHJlcXVlc3QsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbikge1xuICAgICAgICBjb25zdCBzdHJlYW1JZCA9IGdlbmVyYXRlVW5pcXVlRGVidWdJZCgpO1xuICAgICAgICBjb25zdCBzdHViID0gdGhpcy5lbnN1cmVBY3RpdmVTdHViKCk7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gY3JlYXRlTWV0YWRhdGEodGhpcy5kYXRhYmFzZVBhdGgsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbiwgdGhpcy5kYXRhYmFzZUluZm8uYXBwSWQpO1xuICAgICAgICBjb25zdCBqc29uUmVxdWVzdCA9IE9iamVjdC5hc3NpZ24oeyBkYXRhYmFzZTogdGhpcy5kYXRhYmFzZVBhdGggfSwgcmVxdWVzdCk7XG4gICAgICAgIHJldHVybiBub2RlUHJvbWlzZSgoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgJHtzdHJlYW1JZH0gaW52b2tlZCB3aXRoIHJlcXVlc3Q6YCwgcmVxdWVzdCk7XG4gICAgICAgICAgICByZXR1cm4gc3R1YltycGNOYW1lXShqc29uUmVxdWVzdCwgbWV0YWRhdGEsIChncnBjRXJyb3IsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGdycGNFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nICR7c3RyZWFtSWR9IGZhaWxlZCB3aXRoIGVycm9yOmAsIGdycGNFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBGaXJlc3RvcmVFcnJvcihtYXBDb2RlRnJvbVJwY0NvZGUoZ3JwY0Vycm9yLmNvZGUpLCBncnBjRXJyb3IubWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ5LCBgUlBDICcke3JwY05hbWV9JyAke3N0cmVhbUlkfSBjb21wbGV0ZWQgd2l0aCByZXNwb25zZTpgLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW52b2tlU3RyZWFtaW5nUlBDKHJwY05hbWUsIHBhdGgsIHJlcXVlc3QsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbiwgZXhwZWN0ZWRSZXNwb25zZUNvdW50KSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbUlkID0gZ2VuZXJhdGVVbmlxdWVEZWJ1Z0lkKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VEZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nICR7c3RyZWFtSWR9IGludm9rZWQgKHN0cmVhbWluZykgd2l0aCByZXF1ZXN0OmAsIHJlcXVlc3QpO1xuICAgICAgICBjb25zdCBzdHViID0gdGhpcy5lbnN1cmVBY3RpdmVTdHViKCk7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gY3JlYXRlTWV0YWRhdGEodGhpcy5kYXRhYmFzZVBhdGgsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbiwgdGhpcy5kYXRhYmFzZUluZm8uYXBwSWQpO1xuICAgICAgICBjb25zdCBqc29uUmVxdWVzdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdCksIHsgZGF0YWJhc2U6IHRoaXMuZGF0YWJhc2VQYXRoIH0pO1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBzdHViW3JwY05hbWVdKGpzb25SZXF1ZXN0LCBtZXRhZGF0YSk7XG4gICAgICAgIGxldCBjYWxsYmFja0ZpcmVkID0gZmFsc2U7XG4gICAgICAgIHN0cmVhbS5vbignZGF0YScsIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ5LCBgUlBDICR7cnBjTmFtZX0gJHtzdHJlYW1JZH0gcmVjZWl2ZWQgcmVzdWx0OmAsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXNwb25zZSk7XG4gICAgICAgICAgICBpZiAoZXhwZWN0ZWRSZXNwb25zZUNvdW50ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICByZXN1bHRzLmxlbmd0aCA9PT0gZXhwZWN0ZWRSZXNwb25zZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tGaXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VEZWZlcnJlZC5yZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nICR7c3RyZWFtSWR9IGNvbXBsZXRlZC5gKTtcbiAgICAgICAgICAgIGlmICghY2FsbGJhY2tGaXJlZCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrRmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlRGVmZXJyZWQucmVzb2x2ZShyZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHN0cmVhbS5vbignZXJyb3InLCAoZ3JwY0Vycm9yKSA9PiB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nICR7c3RyZWFtSWR9IGZhaWxlZCB3aXRoIGVycm9yOmAsIGdycGNFcnJvcik7XG4gICAgICAgICAgICBjb25zdCBjb2RlID0gbWFwQ29kZUZyb21ScGNDb2RlKGdycGNFcnJvci5jb2RlKTtcbiAgICAgICAgICAgIHJlc3BvbnNlRGVmZXJyZWQucmVqZWN0KG5ldyBGaXJlc3RvcmVFcnJvcihjb2RlLCBncnBjRXJyb3IubWVzc2FnZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlRGVmZXJyZWQucHJvbWlzZTtcbiAgICB9XG4gICAgLy8gVE9ETyhtaWtlbGVoZW4pOiBUaGlzIFwibWV0aG9kXCIgaXMgYSBtb25zdGVyLiBTaG91bGQgYmUgcmVmYWN0b3JlZC5cbiAgICBvcGVuU3RyZWFtKHJwY05hbWUsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbikge1xuICAgICAgICBjb25zdCBzdHJlYW1JZCA9IGdlbmVyYXRlVW5pcXVlRGVidWdJZCgpO1xuICAgICAgICBjb25zdCBzdHViID0gdGhpcy5lbnN1cmVBY3RpdmVTdHViKCk7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gY3JlYXRlTWV0YWRhdGEodGhpcy5kYXRhYmFzZVBhdGgsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbiwgdGhpcy5kYXRhYmFzZUluZm8uYXBwSWQpO1xuICAgICAgICBjb25zdCBncnBjU3RyZWFtID0gc3R1YltycGNOYW1lXShtZXRhZGF0YSk7XG4gICAgICAgIGxldCBjbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY2xvc2UgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNsb3NlZCkge1xuICAgICAgICAgICAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmNhbGxPbkNsb3NlKGVycik7XG4gICAgICAgICAgICAgICAgZ3JwY1N0cmVhbS5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IFN0cmVhbUJyaWRnZSh7XG4gICAgICAgICAgICBzZW5kRm46IChtc2cpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nIHN0cmVhbSAke3N0cmVhbUlkfSBzZW5kaW5nOmAsIG1zZyk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncnBjU3RyZWFtLndyaXRlKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcHJvYmFibHkgbWVhbnMgd2UgZGlkbid0IGNvbmZvcm0gdG8gdGhlIHByb3RvLiAgTWFrZSBzdXJlIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsb2cgdGhlIG1lc3NhZ2Ugd2Ugc2VudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0Vycm9yKCdGYWlsdXJlIHNlbmRpbmc6JywgbXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0Vycm9yKCdFcnJvcjonLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgc3RyZWFtICR7c3RyZWFtSWR9IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ25vdCBzZW5kaW5nIGJlY2F1c2UgZ1JQQyBzdHJlYW0gaXMgY2xvc2VkOicsIG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlRm46ICgpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nIHN0cmVhbSAke3N0cmVhbUlkfSBjbG9zZWQgbG9jYWxseSB2aWEgY2xvc2UoKS5gKTtcbiAgICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IG9uQ29ubmVjdGVkU2VudCA9IGZhbHNlO1xuICAgICAgICBncnBjU3RyZWFtLm9uKCdkYXRhJywgKG1zZykgPT4ge1xuICAgICAgICAgICAgaWYgKCFjbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nIHN0cmVhbSAke3N0cmVhbUlkfSByZWNlaXZlZDpgLCBtc2cpO1xuICAgICAgICAgICAgICAgIC8vIEVtdWxhdGUgdGhlIFwib25Db25uZWN0ZWRcIiBldmVudCB0aGF0IFdlYkNoYW5uZWxDb25uZWN0aW9uIHNlbmRzLlxuICAgICAgICAgICAgICAgIGlmICghb25Db25uZWN0ZWRTZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5jYWxsT25Db25uZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgb25Db25uZWN0ZWRTZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyZWFtLmNhbGxPbk1lc3NhZ2UobXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGdycGNTdHJlYW0ub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgc3RyZWFtICR7c3RyZWFtSWR9IGVuZGVkLmApO1xuICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGdycGNTdHJlYW0ub24oJ2Vycm9yJywgKGdycGNFcnJvcikgPT4ge1xuICAgICAgICAgICAgaWYgKCFjbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBsb2dXYXJuKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgc3RyZWFtICR7c3RyZWFtSWR9IGVycm9yLiBDb2RlOmAsIGdycGNFcnJvci5jb2RlLCAnTWVzc2FnZTonLCBncnBjRXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IG1hcENvZGVGcm9tUnBjQ29kZShncnBjRXJyb3IuY29kZSk7XG4gICAgICAgICAgICAgICAgY2xvc2UobmV3IEZpcmVzdG9yZUVycm9yKGNvZGUsIGdycGNFcnJvci5tZXNzYWdlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBPcGVuaW5nIFJQQyAnJHtycGNOYW1lfScgc3RyZWFtICR7c3RyZWFtSWR9IGAgK1xuICAgICAgICAgICAgYHRvICR7dGhpcy5kYXRhYmFzZUluZm8uaG9zdH1gKTtcbiAgICAgICAgLy8gVE9ETyhkaW1vbmQpOiBTaW5jZSBncnBjIGhhcyBubyBleHBsaWNpdCBvcGVuIHN0YXR1cyAob3IgZG9lcyBpdD8pIHdlXG4gICAgICAgIC8vIHNpbXVsYXRlIGFuIG9uT3BlbiBpbiB0aGUgbmV4dCBsb29wIGFmdGVyIHRoZSBzdHJlYW0gaGFkIGl0J3MgbGlzdGVuZXJzXG4gICAgICAgIC8vIHJlZ2lzdGVyZWRcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBzdHJlYW0uY2FsbE9uT3BlbigpO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIGFuZCBjbGVhbnMgdXAgYW55IHJlc291cmNlcyBhc3NvY2lhdGVkIHdpdGggdGhlIEdycGNDb25uZWN0aW9uLlxuICAgICAqIElmIGEgZ1JQQyBjbGllbnQgaGFzIGJlZW4gZ2VuZXJhdGVkIGZvciB0aGlzIGNvbm5lY3Rpb24sIHRoZSBnUlBDIGNsaWVudFxuICAgICAqIGlzIGNsb3NlZC4gRmFpbHVyZSB0byBjYWxsIHRlcm1pbmF0ZSBvbiBhIEdycGNDb25uZWN0aW9uIGNhbiByZXN1bHRcbiAgICAgKiBpbiBsZWFrZWQgcmVzb3VyY2VzIG9mIHRoZSBnUlBDIGNsaWVudC5cbiAgICAgKi9cbiAgICB0ZXJtaW5hdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlZFN0dWIpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkU3R1Yi5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5jYWNoZWRTdHViID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBuZXN0ZWQgPSB7XG5cdGdvb2dsZToge1xuXHRcdG5lc3RlZDoge1xuXHRcdFx0cHJvdG9idWY6IHtcblx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdGNzaGFycF9uYW1lc3BhY2U6IFwiR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzXCIsXG5cdFx0XHRcdFx0Z29fcGFja2FnZTogXCJnaXRodWIuY29tL2dvbGFuZy9wcm90b2J1Zi9wdHlwZXMvd3JhcHBlcnNcIixcblx0XHRcdFx0XHRqYXZhX3BhY2thZ2U6IFwiY29tLmdvb2dsZS5wcm90b2J1ZlwiLFxuXHRcdFx0XHRcdGphdmFfb3V0ZXJfY2xhc3NuYW1lOiBcIldyYXBwZXJzUHJvdG9cIixcblx0XHRcdFx0XHRqYXZhX211bHRpcGxlX2ZpbGVzOiB0cnVlLFxuXHRcdFx0XHRcdG9iamNfY2xhc3NfcHJlZml4OiBcIkdQQlwiLFxuXHRcdFx0XHRcdGNjX2VuYWJsZV9hcmVuYXM6IHRydWUsXG5cdFx0XHRcdFx0b3B0aW1pemVfZm9yOiBcIlNQRUVEXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0VGltZXN0YW1wOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0c2Vjb25kczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50NjRcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRuYW5vczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRGaWxlRGVzY3JpcHRvclNldDoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdGZpbGU6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWxlRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RmlsZURlc2NyaXB0b3JQcm90bzoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdG5hbWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFwicGFja2FnZVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRkZXBlbmRlbmN5OiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0cHVibGljRGVwZW5kZW5jeToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDEwLFxuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHBhY2tlZDogZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHdlYWtEZXBlbmRlbmN5OiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMTEsXG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGFja2VkOiBmYWxzZVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bWVzc2FnZVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEZXNjcmlwdG9yUHJvdG9cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRlbnVtVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkVudW1EZXNjcmlwdG9yUHJvdG9cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRzZXJ2aWNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiU2VydmljZURlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGV4dGVuc2lvbjoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpZWxkRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmlsZU9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRzb3VyY2VDb2RlSW5mbzoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiU291cmNlQ29kZUluZm9cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRzeW50YXg6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxMlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHREZXNjcmlwdG9yUHJvdG86IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRmaWVsZDoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpZWxkRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZXh0ZW5zaW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGREZXNjcmlwdG9yUHJvdG9cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRuZXN0ZWRUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZW51bVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJFbnVtRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZXh0ZW5zaW9uUmFuZ2U6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJFeHRlbnNpb25SYW5nZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9uZW9mRGVjbDoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk9uZW9mRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDhcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiTWVzc2FnZU9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogN1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRyZXNlcnZlZFJhbmdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiUmVzZXJ2ZWRSYW5nZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHJlc2VydmVkTmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxMFxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdEV4dGVuc2lvblJhbmdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGFydDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZW5kOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFJlc2VydmVkUmFuZ2U6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXJ0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRlbmQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RmllbGREZXNjcmlwdG9yUHJvdG86IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRudW1iZXI6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bGFiZWw6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkxhYmVsXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0dHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVHlwZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHR5cGVOYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRleHRlbmRlZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogN1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvbmVvZkluZGV4OiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGpzb25OYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMTBcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGRPcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDhcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX0RPVUJMRTogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfRkxPQVQ6IDIsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX0lOVDY0OiAzLFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9VSU5UNjQ6IDQsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX0lOVDMyOiA1LFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9GSVhFRDY0OiA2LFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9GSVhFRDMyOiA3LFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9CT09MOiA4LFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9TVFJJTkc6IDksXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX0dST1VQOiAxMCxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfTUVTU0FHRTogMTEsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX0JZVEVTOiAxMixcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfVUlOVDMyOiAxMyxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfRU5VTTogMTQsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX1NGSVhFRDMyOiAxNSxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfU0ZJWEVENjQ6IDE2LFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9TSU5UMzI6IDE3LFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9TSU5UNjQ6IDE4XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRMYWJlbDoge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0TEFCRUxfT1BUSU9OQUw6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRMQUJFTF9SRVFVSVJFRDogMixcblx0XHRcdFx0XHRcdFx0XHRcdExBQkVMX1JFUEVBVEVEOiAzXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRPbmVvZkRlc2NyaXB0b3JQcm90bzoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdG5hbWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk9uZW9mT3B0aW9uc1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEVudW1EZXNjcmlwdG9yUHJvdG86IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkVudW1WYWx1ZURlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkVudW1PcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RW51bVZhbHVlRGVzY3JpcHRvclByb3RvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bnVtYmVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkVudW1WYWx1ZU9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRTZXJ2aWNlRGVzY3JpcHRvclByb3RvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bWV0aG9kOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiTWV0aG9kRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiU2VydmljZU9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRNZXRob2REZXNjcmlwdG9yUHJvdG86IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRpbnB1dFR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG91dHB1dFR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk1ldGhvZE9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRjbGllbnRTdHJlYW1pbmc6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRzZXJ2ZXJTdHJlYW1pbmc6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRGaWxlT3B0aW9uczoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdGphdmFQYWNrYWdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRqYXZhT3V0ZXJDbGFzc25hbWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA4XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGphdmFNdWx0aXBsZUZpbGVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDEwXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGphdmFHZW5lcmF0ZUVxdWFsc0FuZEhhc2g6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMjAsXG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGVwcmVjYXRlZDogdHJ1ZVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0amF2YVN0cmluZ0NoZWNrVXRmODoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyN1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvcHRpbWl6ZUZvcjoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiT3B0aW1pemVNb2RlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDksXG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiU1BFRURcIlxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0Z29QYWNrYWdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMTFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0Y2NHZW5lcmljU2VydmljZXM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMTZcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0amF2YUdlbmVyaWNTZXJ2aWNlczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxN1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRweUdlbmVyaWNTZXJ2aWNlczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxOFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRkZXByZWNhdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDIzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGNjRW5hYmxlQXJlbmFzOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDMxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9iamNDbGFzc1ByZWZpeDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDM2XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGNzaGFycE5hbWVzcGFjZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDM3XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHVuaW50ZXJwcmV0ZWRPcHRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJVbmludGVycHJldGVkT3B0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDk5OVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZXh0ZW5zaW9uczogW1xuXHRcdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdFx0MTAwMCxcblx0XHRcdFx0XHRcdFx0XHQ1MzY4NzA5MTFcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdHJlc2VydmVkOiBbXG5cdFx0XHRcdFx0XHRcdFtcblx0XHRcdFx0XHRcdFx0XHQzOCxcblx0XHRcdFx0XHRcdFx0XHQzOFxuXHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRdLFxuXHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdE9wdGltaXplTW9kZToge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0U1BFRUQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRDT0RFX1NJWkU6IDIsXG5cdFx0XHRcdFx0XHRcdFx0XHRMSVRFX1JVTlRJTUU6IDNcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdE1lc3NhZ2VPcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bWVzc2FnZVNldFdpcmVGb3JtYXQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRub1N0YW5kYXJkRGVzY3JpcHRvckFjY2Vzc29yOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZGVwcmVjYXRlZDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG1hcEVudHJ5OiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0dW5pbnRlcnByZXRlZE9wdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlVuaW50ZXJwcmV0ZWRPcHRpb25cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOTk5XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRleHRlbnNpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFtcblx0XHRcdFx0XHRcdFx0XHQxMDAwLFxuXHRcdFx0XHRcdFx0XHRcdDUzNjg3MDkxMVxuXHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRdLFxuXHRcdFx0XHRcdFx0cmVzZXJ2ZWQ6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDgsXG5cdFx0XHRcdFx0XHRcdFx0OFxuXHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRGaWVsZE9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRjdHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQ1R5cGVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcImRlZmF1bHRcIjogXCJTVFJJTkdcIlxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0cGFja2VkOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0anN0eXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJKU1R5cGVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNixcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcImRlZmF1bHRcIjogXCJKU19OT1JNQUxcIlxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bGF6eToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGRlcHJlY2F0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR3ZWFrOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDEwXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHVuaW50ZXJwcmV0ZWRPcHRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJVbmludGVycHJldGVkT3B0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDk5OVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZXh0ZW5zaW9uczogW1xuXHRcdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdFx0MTAwMCxcblx0XHRcdFx0XHRcdFx0XHQ1MzY4NzA5MTFcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdHJlc2VydmVkOiBbXG5cdFx0XHRcdFx0XHRcdFtcblx0XHRcdFx0XHRcdFx0XHQ0LFxuXHRcdFx0XHRcdFx0XHRcdDRcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRDVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0U1RSSU5HOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0Q09SRDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFNUUklOR19QSUVDRTogMlxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0SlNUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRKU19OT1JNQUw6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRKU19TVFJJTkc6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRKU19OVU1CRVI6IDJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdE9uZW9mT3B0aW9uczoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHVuaW50ZXJwcmV0ZWRPcHRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJVbmludGVycHJldGVkT3B0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDk5OVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZXh0ZW5zaW9uczogW1xuXHRcdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdFx0MTAwMCxcblx0XHRcdFx0XHRcdFx0XHQ1MzY4NzA5MTFcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RW51bU9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRhbGxvd0FsaWFzOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZGVwcmVjYXRlZDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHVuaW50ZXJwcmV0ZWRPcHRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJVbmludGVycHJldGVkT3B0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDk5OVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZXh0ZW5zaW9uczogW1xuXHRcdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdFx0MTAwMCxcblx0XHRcdFx0XHRcdFx0XHQ1MzY4NzA5MTFcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RW51bVZhbHVlT3B0aW9uczoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdGRlcHJlY2F0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFNlcnZpY2VPcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0ZGVwcmVjYXRlZDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdE1ldGhvZE9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRkZXByZWNhdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDMzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHVuaW50ZXJwcmV0ZWRPcHRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJVbmludGVycHJldGVkT3B0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDk5OVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZXh0ZW5zaW9uczogW1xuXHRcdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdFx0MTAwMCxcblx0XHRcdFx0XHRcdFx0XHQ1MzY4NzA5MTFcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0VW5pbnRlcnByZXRlZE9wdGlvbjoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdG5hbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJOYW1lUGFydFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGlkZW50aWZpZXJWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0cG9zaXRpdmVJbnRWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwidWludDY0XCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bmVnYXRpdmVJbnRWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50NjRcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRkb3VibGVWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZG91YmxlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0c3RyaW5nVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0YWdncmVnYXRlVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA4XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0TmFtZVBhcnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdG5hbWVQYXJ0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVxdWlyZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRpc0V4dGVuc2lvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcXVpcmVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0U291cmNlQ29kZUluZm86IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRsb2NhdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkxvY2F0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRMb2NhdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGF0aDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzcGFuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGxlYWRpbmdDb21tZW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYWlsaW5nQ29tbWVudHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRsZWFkaW5nRGV0YWNoZWRDb21tZW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRHZW5lcmF0ZWRDb2RlSW5mbzoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdGFubm90YXRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJBbm5vdGF0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRBbm5vdGF0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXRoOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHNvdXJjZUZpbGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRiZWdpbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZW5kOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFN0cnVjdDoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdGtleVR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0a2luZDoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcIm51bGxWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XCJudW1iZXJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XCJzdHJpbmdWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XCJib29sVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwic3RydWN0VmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwibGlzdFZhbHVlXCJcblx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bnVsbFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJOdWxsVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRudW1iZXJWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZG91YmxlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0c3RyaW5nVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGJvb2xWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHN0cnVjdFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJTdHJ1Y3RcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRsaXN0VmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkxpc3RWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdE51bGxWYWx1ZToge1xuXHRcdFx0XHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdFx0XHRcdE5VTExfVkFMVUU6IDBcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdExpc3RWYWx1ZToge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RW1wdHk6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RG91YmxlVmFsdWU6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZG91YmxlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RmxvYXRWYWx1ZToge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJmbG9hdFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEludDY0VmFsdWU6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50NjRcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRVSW50NjRWYWx1ZToge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJ1aW50NjRcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRJbnQzMlZhbHVlOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0VUludDMyVmFsdWU6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwidWludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0Qm9vbFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRTdHJpbmdWYWx1ZToge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRCeXRlc1ZhbHVlOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0QW55OiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0dHlwZVVybDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGZpcmVzdG9yZToge1xuXHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHR2MToge1xuXHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRjc2hhcnBfbmFtZXNwYWNlOiBcIkdvb2dsZS5DbG91ZC5GaXJlc3RvcmUuVjFcIixcblx0XHRcdFx0XHRcdFx0Z29fcGFja2FnZTogXCJnb29nbGUuZ29sYW5nLm9yZy9nZW5wcm90by9nb29nbGVhcGlzL2ZpcmVzdG9yZS92MTtmaXJlc3RvcmVcIixcblx0XHRcdFx0XHRcdFx0amF2YV9tdWx0aXBsZV9maWxlczogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0amF2YV9vdXRlcl9jbGFzc25hbWU6IFwiV3JpdGVQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRqYXZhX3BhY2thZ2U6IFwiY29tLmdvb2dsZS5maXJlc3RvcmUudjFcIixcblx0XHRcdFx0XHRcdFx0b2JqY19jbGFzc19wcmVmaXg6IFwiR0NGU1wiLFxuXHRcdFx0XHRcdFx0XHRwaHBfbmFtZXNwYWNlOiBcIkdvb2dsZVxcXFxDbG91ZFxcXFxGaXJlc3RvcmVcXFxcVjFcIixcblx0XHRcdFx0XHRcdFx0cnVieV9wYWNrYWdlOiBcIkdvb2dsZTo6Q2xvdWQ6OkZpcmVzdG9yZTo6VjFcIlxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRBZ2dyZWdhdGlvblJlc3VsdDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0YWdncmVnYXRlRmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGtleVR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEJpdFNlcXVlbmNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRiaXRtYXA6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHBhZGRpbmc6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0Qmxvb21GaWx0ZXI6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGJpdHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJCaXRTZXF1ZW5jZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGhhc2hDb3VudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHREb2N1bWVudE1hc2s6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkUGF0aHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0UHJlY29uZGl0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25kaXRpb25UeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJleGlzdHNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInVwZGF0ZVRpbWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGV4aXN0czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR1cGRhdGVUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0VHJhbnNhY3Rpb25PcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRtb2RlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZWFkT25seVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVhZFdyaXRlXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkT25seToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlJlYWRPbmx5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFdyaXRlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiUmVhZFdyaXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFJlYWRXcml0ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXRyeVRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFJlYWRPbmx5OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnNpc3RlbmN5U2VsZWN0b3I6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVhZFRpbWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdERvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGtleVR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRjcmVhdGVUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHVwZGF0ZVRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFsdWVUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJudWxsVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImJvb2xlYW5WYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiaW50ZWdlclZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJkb3VibGVWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidGltZXN0YW1wVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInN0cmluZ1ZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJieXRlc1ZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZWZlcmVuY2VWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZ2VvUG9pbnRWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiYXJyYXlWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwibWFwVmFsdWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdG51bGxWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDExXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Ym9vbGVhblZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGludGVnZXJWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDY0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZG91YmxlVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJkb3VibGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0aW1lc3RhbXBWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEwXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0c3RyaW5nVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDE3XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Ynl0ZXNWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxOFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlZmVyZW5jZVZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Z2VvUG9pbnRWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS50eXBlLkxhdExuZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogOFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGFycmF5VmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJBcnJheVZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA5XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bWFwVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJNYXBWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0QXJyYXlWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0TWFwVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRGaXJlc3RvcmU6IHtcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmRlZmF1bHRfaG9zdClcIjogXCJmaXJlc3RvcmUuZ29vZ2xlYXBpcy5jb21cIixcblx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkub2F1dGhfc2NvcGVzKVwiOiBcImh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvY2xvdWQtcGxhdGZvcm0saHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYXV0aC9kYXRhc3RvcmVcIlxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0bWV0aG9kczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0R2V0RG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiR2V0RG9jdW1lbnRSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJEb2N1bWVudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5nZXRcIjogXCIvdjEve25hbWU9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn1cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGdldDogXCIvdjEve25hbWU9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn1cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdExpc3REb2N1bWVudHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiTGlzdERvY3VtZW50c1JlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIkxpc3REb2N1bWVudHNSZXNwb25zZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5nZXRcIjogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfS97Y29sbGVjdGlvbl9pZH1cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGdldDogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfS97Y29sbGVjdGlvbl9pZH1cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFVwZGF0ZURvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIlVwZGF0ZURvY3VtZW50UmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiRG9jdW1lbnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucGF0Y2hcIjogXCIvdjEve2RvY3VtZW50Lm5hbWU9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCJkb2N1bWVudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJkb2N1bWVudCx1cGRhdGVfbWFza1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cGF0Y2g6IFwiL3YxL3tkb2N1bWVudC5uYW1lPXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiZG9jdW1lbnRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcImRvY3VtZW50LHVwZGF0ZV9tYXNrXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHREZWxldGVEb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJEZWxldGVEb2N1bWVudFJlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcImdvb2dsZS5wcm90b2J1Zi5FbXB0eVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5kZWxldGVcIjogXCIvdjEve25hbWU9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLm1ldGhvZF9zaWduYXR1cmUpXCI6IFwibmFtZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJkZWxldGVcIjogXCIvdjEve25hbWU9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn1cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcIm5hbWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdEJhdGNoR2V0RG9jdW1lbnRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIkJhdGNoR2V0RG9jdW1lbnRzUmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiQmF0Y2hHZXREb2N1bWVudHNSZXNwb25zZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVN0cmVhbTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOmJhdGNoR2V0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5ib2R5XCI6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpiYXRjaEdldFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdEJlZ2luVHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiQmVnaW5UcmFuc2FjdGlvblJlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIkJlZ2luVHJhbnNhY3Rpb25SZXNwb25zZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5wb3N0XCI6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6YmVnaW5UcmFuc2FjdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLm1ldGhvZF9zaWduYXR1cmUpXCI6IFwiZGF0YWJhc2VcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6YmVnaW5UcmFuc2FjdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcImRhdGFiYXNlXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRDb21taXQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiQ29tbWl0UmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiQ29tbWl0UmVzcG9uc2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOmNvbW1pdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLm1ldGhvZF9zaWduYXR1cmUpXCI6IFwiZGF0YWJhc2Usd3JpdGVzXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VkT3B0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cClcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOmNvbW1pdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcImRhdGFiYXNlLHdyaXRlc1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Um9sbGJhY2s6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiUm9sbGJhY2tSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJnb29nbGUucHJvdG9idWYuRW1wdHlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOnJvbGxiYWNrXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5ib2R5XCI6IFwiKlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJkYXRhYmFzZSx0cmFuc2FjdGlvblwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpyb2xsYmFja1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcImRhdGFiYXNlLHRyYW5zYWN0aW9uXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRSdW5RdWVyeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJSdW5RdWVyeVJlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIlJ1blF1ZXJ5UmVzcG9uc2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VTdHJlYW06IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50c306cnVuUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5hZGRpdGlvbmFsX2JpbmRpbmdzLnBvc3RcIjogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfTpydW5RdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYWRkaXRpb25hbF9iaW5kaW5ncy5ib2R5XCI6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50c306cnVuUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFkZGl0aW9uYWxfYmluZGluZ3M6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9OnJ1blF1ZXJ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFJ1bkFnZ3JlZ2F0aW9uUXVlcnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiUnVuQWdncmVnYXRpb25RdWVyeVJlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIlJ1bkFnZ3JlZ2F0aW9uUXVlcnlSZXNwb25zZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVN0cmVhbTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzfTpydW5BZ2dyZWdhdGlvblF1ZXJ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5ib2R5XCI6IFwiKlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYWRkaXRpb25hbF9iaW5kaW5ncy5wb3N0XCI6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn06cnVuQWdncmVnYXRpb25RdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYWRkaXRpb25hbF9iaW5kaW5ncy5ib2R5XCI6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50c306cnVuQWdncmVnYXRpb25RdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkaXRpb25hbF9iaW5kaW5nczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn06cnVuQWdncmVnYXRpb25RdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRQYXJ0aXRpb25RdWVyeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJQYXJ0aXRpb25RdWVyeVJlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIlBhcnRpdGlvblF1ZXJ5UmVzcG9uc2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzfTpwYXJ0aXRpb25RdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmFkZGl0aW9uYWxfYmluZGluZ3MucG9zdFwiOiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9OnBhcnRpdGlvblF1ZXJ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5hZGRpdGlvbmFsX2JpbmRpbmdzLmJvZHlcIjogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VkT3B0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cClcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzfTpwYXJ0aXRpb25RdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkaXRpb25hbF9iaW5kaW5nczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn06cGFydGl0aW9uUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0V3JpdGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiV3JpdGVSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RTdHJlYW06IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJXcml0ZVJlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlU3RyZWFtOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5wb3N0XCI6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6d3JpdGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VkT3B0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cClcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOndyaXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0TGlzdGVuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIkxpc3RlblJlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFN0cmVhbTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIkxpc3RlblJlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlU3RyZWFtOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5wb3N0XCI6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6bGlzdGVuXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5ib2R5XCI6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpsaXN0ZW5cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRMaXN0Q29sbGVjdGlvbklkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJMaXN0Q29sbGVjdGlvbklkc1JlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIkxpc3RDb2xsZWN0aW9uSWRzUmVzcG9uc2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzfTpsaXN0Q29sbGVjdGlvbklkc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmFkZGl0aW9uYWxfYmluZGluZ3MucG9zdFwiOiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9Omxpc3RDb2xsZWN0aW9uSWRzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5hZGRpdGlvbmFsX2JpbmRpbmdzLmJvZHlcIjogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcInBhcmVudFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50c306bGlzdENvbGxlY3Rpb25JZHNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFkZGl0aW9uYWxfYmluZGluZ3M6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9Omxpc3RDb2xsZWN0aW9uSWRzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcInBhcmVudFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0QmF0Y2hXcml0ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJCYXRjaFdyaXRlUmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiQmF0Y2hXcml0ZVJlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpiYXRjaFdyaXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5ib2R5XCI6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpiYXRjaFdyaXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Q3JlYXRlRG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiQ3JlYXRlRG9jdW1lbnRSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJEb2N1bWVudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5wb3N0XCI6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKip9L3tjb2xsZWN0aW9uX2lkfVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcImRvY3VtZW50XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VkT3B0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cClcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyoqfS97Y29sbGVjdGlvbl9pZH1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCJkb2N1bWVudFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRHZXREb2N1bWVudFJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnNpc3RlbmN5U2VsZWN0b3I6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInRyYW5zYWN0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZWFkVGltZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bWFzazoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50TWFza1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdExpc3REb2N1bWVudHNSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zaXN0ZW5jeVNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ0cmFuc2FjdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVhZFRpbWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHBhcmVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29sbGVjdGlvbklkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRwYWdlU2l6ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cGFnZVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0b3JkZXJCeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG1hc2s6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudE1hc2tcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA4XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxMFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHNob3dNaXNzaW5nOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMTJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdExpc3REb2N1bWVudHNSZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG5leHRQYWdlVG9rZW46IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdENyZWF0ZURvY3VtZW50UmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRjb2xsZWN0aW9uSWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50SWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRtYXNrOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRNYXNrXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRVcGRhdGVEb2N1bWVudFJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHVwZGF0ZU1hc2s6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudE1hc2tcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRtYXNrOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRNYXNrXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudERvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiUHJlY29uZGl0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHREZWxldGVEb2N1bWVudFJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdG5hbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnREb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlByZWNvbmRpdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0QmF0Y2hHZXREb2N1bWVudHNSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zaXN0ZW5jeVNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ0cmFuc2FjdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwibmV3VHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInJlYWRUaW1lXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhYmFzZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRtYXNrOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRNYXNrXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG5ld1RyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVHJhbnNhY3Rpb25PcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRCYXRjaEdldERvY3VtZW50c1Jlc3BvbnNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXN1bHQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImZvdW5kXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJtaXNzaW5nXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmb3VuZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bWlzc2luZzoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEJlZ2luVHJhbnNhY3Rpb25SZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhYmFzZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlRyYW5zYWN0aW9uT3B0aW9uc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0QmVnaW5UcmFuc2FjdGlvblJlc3BvbnNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRDb21taXRSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhYmFzZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0d3JpdGVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJXcml0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdENvbW1pdFJlc3BvbnNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHR3cml0ZVJlc3VsdHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIldyaXRlUmVzdWx0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29tbWl0VGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFJvbGxiYWNrUmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YWJhc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0UnVuUXVlcnlSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRxdWVyeVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInN0cnVjdHVyZWRRdWVyeVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zaXN0ZW5jeVNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ0cmFuc2FjdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwibmV3VHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInJlYWRUaW1lXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0cnVjdHVyZWRRdWVyeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlN0cnVjdHVyZWRRdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdUcmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlRyYW5zYWN0aW9uT3B0aW9uc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogN1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0UnVuUXVlcnlSZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRza2lwcGVkUmVzdWx0czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRSdW5BZ2dyZWdhdGlvblF1ZXJ5UmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cXVlcnlUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJzdHJ1Y3R1cmVkQWdncmVnYXRpb25RdWVyeVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zaXN0ZW5jeVNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ0cmFuc2FjdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwibmV3VHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInJlYWRUaW1lXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0cnVjdHVyZWRBZ2dyZWdhdGlvblF1ZXJ5OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiU3RydWN0dXJlZEFnZ3JlZ2F0aW9uUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bmV3VHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJUcmFuc2FjdGlvbk9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFJ1bkFnZ3JlZ2F0aW9uUXVlcnlSZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVzdWx0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQWdncmVnYXRpb25SZXN1bHRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRQYXJ0aXRpb25RdWVyeVJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHF1ZXJ5VHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwic3RydWN0dXJlZFF1ZXJ5XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0cnVjdHVyZWRRdWVyeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlN0cnVjdHVyZWRRdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHBhcnRpdGlvbkNvdW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50NjRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRwYWdlVG9rZW46IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRwYWdlU2l6ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRQYXJ0aXRpb25RdWVyeVJlc3BvbnNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJ0aXRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJDdXJzb3JcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXh0UGFnZVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRXcml0ZVJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFiYXNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJlYW1JZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHdyaXRlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiV3JpdGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJlYW1Ub2tlbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bGFiZWxzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGtleVR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRXcml0ZVJlc3BvbnNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJlYW1JZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0cmVhbVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR3cml0ZVJlc3VsdHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIldyaXRlUmVzdWx0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29tbWl0VGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdExpc3RlblJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldENoYW5nZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiYWRkVGFyZ2V0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZW1vdmVUYXJnZXRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFiYXNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRhZGRUYXJnZXQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJUYXJnZXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZW1vdmVUYXJnZXQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0TGlzdGVuUmVzcG9uc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidGFyZ2V0Q2hhbmdlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJkb2N1bWVudENoYW5nZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZG9jdW1lbnREZWxldGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImRvY3VtZW50UmVtb3ZlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJmaWx0ZXJcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldENoYW5nZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlRhcmdldENoYW5nZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50Q2hhbmdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRDaGFuZ2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudERlbGV0ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50RGVsZXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnRSZW1vdmU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudFJlbW92ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGZpbHRlcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkV4aXN0ZW5jZUZpbHRlclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0VGFyZ2V0OiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJxdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZG9jdW1lbnRzXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3VtZVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInJlc3VtZVRva2VuXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZWFkVGltZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cXVlcnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJRdWVyeVRhcmdldFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50c1RhcmdldFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3VtZVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDExXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0SWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG9uY2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZXhwZWN0ZWRDb3VudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5JbnQzMlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHREb2N1bWVudHNUYXJnZXQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRRdWVyeVRhcmdldDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRxdWVyeVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwic3RydWN0dXJlZFF1ZXJ5XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBhcmVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdHJ1Y3R1cmVkUXVlcnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiU3RydWN0dXJlZFF1ZXJ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0VGFyZ2V0Q2hhbmdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRDaGFuZ2VUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVGFyZ2V0Q2hhbmdlVHlwZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldElkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRjYXVzZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5ycGMuU3RhdHVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVzdW1lVG9rZW46IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRUYXJnZXRDaGFuZ2VUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdE5PX0NIQU5HRTogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRBREQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0UkVNT1ZFOiAyLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdENVUlJFTlQ6IDMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0UkVTRVQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0TGlzdENvbGxlY3Rpb25JZHNSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHBhZ2VTaXplOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRwYWdlVG9rZW46IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdExpc3RDb2xsZWN0aW9uSWRzUmVzcG9uc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbGxlY3Rpb25JZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG5leHRQYWdlVG9rZW46IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEJhdGNoV3JpdGVSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhYmFzZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0d3JpdGVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJXcml0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0QmF0Y2hXcml0ZVJlc3BvbnNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHR3cml0ZVJlc3VsdHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIldyaXRlUmVzdWx0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdHVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucnBjLlN0YXR1c1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0U3RydWN0dXJlZFF1ZXJ5OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzZWxlY3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJQcm9qZWN0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZnJvbToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQ29sbGVjdGlvblNlbGVjdG9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0d2hlcmU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWx0ZXJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRvcmRlckJ5OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJPcmRlclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXJ0QXQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJDdXJzb3JcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRlbmRBdDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkN1cnNvclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogOFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG9mZnNldDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bGltaXQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuSW50MzJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRDb2xsZWN0aW9uU2VsZWN0b3I6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29sbGVjdGlvbklkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFsbERlc2NlbmRhbnRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0RmlsdGVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpbHRlclR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiY29tcG9zaXRlRmlsdGVyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZmllbGRGaWx0ZXJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ1bmFyeUZpbHRlclwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb21wb3NpdGVGaWx0ZXI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQ29tcG9zaXRlRmlsdGVyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRGaWx0ZXI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGRGaWx0ZXJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmFyeUZpbHRlcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJVbmFyeUZpbHRlclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRDb21wb3NpdGVGaWx0ZXI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3A6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiT3BlcmF0b3JcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWx0ZXJzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpbHRlclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdE9wZXJhdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0T1BFUkFUT1JfVU5TUEVDSUZJRUQ6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdEFORDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0T1I6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRGaWVsZEZpbHRlcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWVsZFJlZmVyZW5jZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9wOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk9wZXJhdG9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRPcGVyYXRvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdE9QRVJBVE9SX1VOU1BFQ0lGSUVEOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRMRVNTX1RIQU46IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdExFU1NfVEhBTl9PUl9FUVVBTDogMixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0R1JFQVRFUl9USEFOOiAzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRHUkVBVEVSX1RIQU5fT1JfRVFVQUw6IDQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdEVRVUFMOiA1LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHROT1RfRVFVQUw6IDYsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdEFSUkFZX0NPTlRBSU5TOiA3LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRJTjogOCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0QVJSQVlfQ09OVEFJTlNfQU5ZOiA5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHROT1RfSU46IDEwXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0VW5hcnlGaWx0ZXI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3BlcmFuZFR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZmllbGRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3A6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiT3BlcmF0b3JcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWVsZFJlZmVyZW5jZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdE9wZXJhdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0T1BFUkFUT1JfVU5TUEVDSUZJRUQ6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdElTX05BTjogMixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0SVNfTlVMTDogMyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0SVNfTk9UX05BTjogNCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0SVNfTk9UX05VTEw6IDVcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRPcmRlcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWVsZFJlZmVyZW5jZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRpcmVjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEaXJlY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0RmllbGRSZWZlcmVuY2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRQYXRoOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRQcm9qZWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWVsZFJlZmVyZW5jZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHREaXJlY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0RElSRUNUSU9OX1VOU1BFQ0lGSUVEOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdEFTQ0VORElORzogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRERVNDRU5ESU5HOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFN0cnVjdHVyZWRBZ2dyZWdhdGlvblF1ZXJ5OiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRxdWVyeVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInN0cnVjdHVyZWRRdWVyeVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RydWN0dXJlZFF1ZXJ5OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiU3RydWN0dXJlZFF1ZXJ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0YWdncmVnYXRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJBZ2dyZWdhdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRBZ2dyZWdhdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvcGVyYXRvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJjb3VudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInN1bVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImF2Z1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb3VudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJDb3VudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHN1bToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJTdW1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhdmc6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQXZnXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YWxpYXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Q291bnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1cFRvOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuSW50NjRWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFN1bToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWVsZFJlZmVyZW5jZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdEF2Zzoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWVsZFJlZmVyZW5jZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEN1cnNvcjoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGJlZm9yZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFdyaXRlOiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvcGVyYXRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInVwZGF0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZGVsZXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ2ZXJpZnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInRyYW5zZm9ybVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0dXBkYXRlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcImRlbGV0ZVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dmVyaWZ5OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRUcmFuc2Zvcm1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR1cGRhdGVNYXNrOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRNYXNrXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dXBkYXRlVHJhbnNmb3Jtczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRUcmFuc2Zvcm0uRmllbGRUcmFuc2Zvcm1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50RG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJQcmVjb25kaXRpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdERvY3VtZW50VHJhbnNmb3JtOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkVHJhbnNmb3Jtczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGRUcmFuc2Zvcm1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0RmllbGRUcmFuc2Zvcm06IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJzZXRUb1NlcnZlclZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiaW5jcmVtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwibWF4aW11bVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIm1pbmltdW1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJhcHBlbmRNaXNzaW5nRWxlbWVudHNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZW1vdmVBbGxGcm9tQXJyYXlcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRQYXRoOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHNldFRvU2VydmVyVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiU2VydmVyVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpbmNyZW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXhpbXVtOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWluaW11bToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFwcGVuZE1pc3NpbmdFbGVtZW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJBcnJheVZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVtb3ZlQWxsRnJvbUFycmF5OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkFycmF5VmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRTZXJ2ZXJWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFNFUlZFUl9WQUxVRV9VTlNQRUNJRklFRDogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0UkVRVUVTVF9USU1FOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRXcml0ZVJlc3VsdDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0dXBkYXRlVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2Zvcm1SZXN1bHRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0RG9jdW1lbnRDaGFuZ2U6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRJZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVtb3ZlZFRhcmdldElkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdERvY3VtZW50RGVsZXRlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlbW92ZWRUYXJnZXRJZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHREb2N1bWVudFJlbW92ZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZW1vdmVkVGFyZ2V0SWRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0RXhpc3RlbmNlRmlsdGVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRJZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y291bnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHVuY2hhbmdlZE5hbWVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQmxvb21GaWx0ZXJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRhcGk6IHtcblx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdGdvX3BhY2thZ2U6IFwiZ29vZ2xlLmdvbGFuZy5vcmcvZ2VucHJvdG8vZ29vZ2xlYXBpcy9hcGkvYW5ub3RhdGlvbnM7YW5ub3RhdGlvbnNcIixcblx0XHRcdFx0XHRqYXZhX211bHRpcGxlX2ZpbGVzOiB0cnVlLFxuXHRcdFx0XHRcdGphdmFfb3V0ZXJfY2xhc3NuYW1lOiBcIkh0dHBQcm90b1wiLFxuXHRcdFx0XHRcdGphdmFfcGFja2FnZTogXCJjb20uZ29vZ2xlLmFwaVwiLFxuXHRcdFx0XHRcdG9iamNfY2xhc3NfcHJlZml4OiBcIkdBUElcIixcblx0XHRcdFx0XHRjY19lbmFibGVfYXJlbmFzOiB0cnVlXG5cdFx0XHRcdH0sXG5cdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdGh0dHA6IHtcblx0XHRcdFx0XHRcdHR5cGU6IFwiSHR0cFJ1bGVcIixcblx0XHRcdFx0XHRcdGlkOiA3MjI5NTcyOCxcblx0XHRcdFx0XHRcdGV4dGVuZDogXCJnb29nbGUucHJvdG9idWYuTWV0aG9kT3B0aW9uc1wiXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRIdHRwOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0cnVsZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJIdHRwUnVsZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEh0dHBSdWxlOiB7XG5cdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0cGF0dGVybjoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcImdldFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XCJwdXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwicG9zdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XCJkZWxldGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwicGF0Y2hcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwiY3VzdG9tXCJcblx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0Z2V0OiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRwdXQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHBvc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFwiZGVsZXRlXCI6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHBhdGNoOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRjdXN0b206IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkN1c3RvbUh0dHBQYXR0ZXJuXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDhcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0c2VsZWN0b3I6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGJvZHk6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGFkZGl0aW9uYWxCaW5kaW5nczoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkh0dHBSdWxlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDExXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEN1c3RvbUh0dHBQYXR0ZXJuOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0a2luZDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0cGF0aDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0bWV0aG9kU2lnbmF0dXJlOiB7XG5cdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0aWQ6IDEwNTEsXG5cdFx0XHRcdFx0XHRleHRlbmQ6IFwiZ29vZ2xlLnByb3RvYnVmLk1ldGhvZE9wdGlvbnNcIlxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0ZGVmYXVsdEhvc3Q6IHtcblx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRpZDogMTA0OSxcblx0XHRcdFx0XHRcdGV4dGVuZDogXCJnb29nbGUucHJvdG9idWYuU2VydmljZU9wdGlvbnNcIlxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0b2F1dGhTY29wZXM6IHtcblx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRpZDogMTA1MCxcblx0XHRcdFx0XHRcdGV4dGVuZDogXCJnb29nbGUucHJvdG9idWYuU2VydmljZU9wdGlvbnNcIlxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0ZmllbGRCZWhhdmlvcjoge1xuXHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUuYXBpLkZpZWxkQmVoYXZpb3JcIixcblx0XHRcdFx0XHRcdGlkOiAxMDUyLFxuXHRcdFx0XHRcdFx0ZXh0ZW5kOiBcImdvb2dsZS5wcm90b2J1Zi5GaWVsZE9wdGlvbnNcIlxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RmllbGRCZWhhdmlvcjoge1xuXHRcdFx0XHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdFx0XHRcdEZJRUxEX0JFSEFWSU9SX1VOU1BFQ0lGSUVEOiAwLFxuXHRcdFx0XHRcdFx0XHRPUFRJT05BTDogMSxcblx0XHRcdFx0XHRcdFx0UkVRVUlSRUQ6IDIsXG5cdFx0XHRcdFx0XHRcdE9VVFBVVF9PTkxZOiAzLFxuXHRcdFx0XHRcdFx0XHRJTlBVVF9PTkxZOiA0LFxuXHRcdFx0XHRcdFx0XHRJTU1VVEFCTEU6IDUsXG5cdFx0XHRcdFx0XHRcdFVOT1JERVJFRF9MSVNUOiA2LFxuXHRcdFx0XHRcdFx0XHROT05fRU1QVFlfREVGQVVMVDogN1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHR5cGU6IHtcblx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdGNjX2VuYWJsZV9hcmVuYXM6IHRydWUsXG5cdFx0XHRcdFx0Z29fcGFja2FnZTogXCJnb29nbGUuZ29sYW5nLm9yZy9nZW5wcm90by9nb29nbGVhcGlzL3R5cGUvbGF0bG5nO2xhdGxuZ1wiLFxuXHRcdFx0XHRcdGphdmFfbXVsdGlwbGVfZmlsZXM6IHRydWUsXG5cdFx0XHRcdFx0amF2YV9vdXRlcl9jbGFzc25hbWU6IFwiTGF0TG5nUHJvdG9cIixcblx0XHRcdFx0XHRqYXZhX3BhY2thZ2U6IFwiY29tLmdvb2dsZS50eXBlXCIsXG5cdFx0XHRcdFx0b2JqY19jbGFzc19wcmVmaXg6IFwiR1RQXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0TGF0TG5nOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bGF0aXR1ZGU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImRvdWJsZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGxvbmdpdHVkZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZG91YmxlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJwYzoge1xuXHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0Y2NfZW5hYmxlX2FyZW5hczogdHJ1ZSxcblx0XHRcdFx0XHRnb19wYWNrYWdlOiBcImdvb2dsZS5nb2xhbmcub3JnL2dlbnByb3RvL2dvb2dsZWFwaXMvcnBjL3N0YXR1cztzdGF0dXNcIixcblx0XHRcdFx0XHRqYXZhX211bHRpcGxlX2ZpbGVzOiB0cnVlLFxuXHRcdFx0XHRcdGphdmFfb3V0ZXJfY2xhc3NuYW1lOiBcIlN0YXR1c1Byb3RvXCIsXG5cdFx0XHRcdFx0amF2YV9wYWNrYWdlOiBcImNvbS5nb29nbGUucnBjXCIsXG5cdFx0XHRcdFx0b2JqY19jbGFzc19wcmVmaXg6IFwiUlBDXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0U3RhdHVzOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0Y29kZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRtZXNzYWdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRkZXRhaWxzOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLkFueVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG52YXIgcHJvdG9zID0ge1xuXHRuZXN0ZWQ6IG5lc3RlZFxufTtcblxudmFyIHByb3RvcyQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIG5lc3RlZDogbmVzdGVkLFxuICAnZGVmYXVsdCc6IHByb3Rvc1xufSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogVXNlZCBieSB0ZXN0cyBzbyB3ZSBjYW4gbWF0Y2ggQGdycGMvcHJvdG8tbG9hZGVyIGJlaGF2aW9yLiAqL1xuY29uc3QgcHJvdG9Mb2FkZXJPcHRpb25zID0ge1xuICAgIGxvbmdzOiBTdHJpbmcsXG4gICAgZW51bXM6IFN0cmluZyxcbiAgICBkZWZhdWx0czogdHJ1ZSxcbiAgICBvbmVvZnM6IGZhbHNlXG59O1xuLyoqXG4gKiBMb2FkcyB0aGUgcHJvdG9jb2wgYnVmZmVyIGRlZmluaXRpb25zIGZvciBGaXJlc3RvcmUuXG4gKlxuICogQHJldHVybnMgVGhlIEdycGNPYmplY3QgcmVwcmVzZW50aW5nIG91ciBwcm90b3MuXG4gKi9cbmZ1bmN0aW9uIGxvYWRQcm90b3MoKSB7XG4gICAgY29uc3QgcGFja2FnZURlZmluaXRpb24gPSBwcm90b0xvYWRlci5mcm9tSlNPTihwcm90b3MkMSwgcHJvdG9Mb2FkZXJPcHRpb25zKTtcbiAgICByZXR1cm4gZ3JwYy5sb2FkUGFja2FnZURlZmluaXRpb24ocGFja2FnZURlZmluaXRpb24pO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqIExvYWRzIHRoZSBHUlBDIHN0YWNrICovXG5mdW5jdGlvbiBuZXdDb25uZWN0aW9uKGRhdGFiYXNlSW5mbykge1xuICAgIGNvbnN0IHByb3RvcyA9IGxvYWRQcm90b3MoKTtcbiAgICByZXR1cm4gbmV3IEdycGNDb25uZWN0aW9uKHByb3RvcywgZGF0YWJhc2VJbmZvKTtcbn1cbi8qKiBSZXR1cm4gdGhlIFBsYXRmb3JtLXNwZWNpZmljIGNvbm5lY3Rpdml0eSBtb25pdG9yLiAqL1xuZnVuY3Rpb24gbmV3Q29ubmVjdGl2aXR5TW9uaXRvcigpIHtcbiAgICByZXR1cm4gbmV3IE5vb3BDb25uZWN0aXZpdHlNb25pdG9yKCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogVGhlIFBsYXRmb3JtJ3MgJ3dpbmRvdycgaW1wbGVtZW50YXRpb24gb3IgbnVsbCBpZiBub3QgYXZhaWxhYmxlLiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5VU0VfTU9DS19QRVJTSVNURU5DRSA9PT0gJ1lFUycpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKiBUaGUgUGxhdGZvcm0ncyAnZG9jdW1lbnQnIGltcGxlbWVudGF0aW9uIG9yIG51bGwgaWYgbm90IGF2YWlsYWJsZS4gKi9cbmZ1bmN0aW9uIGdldERvY3VtZW50KCkge1xuICAgIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gbmV3U2VyaWFsaXplcihkYXRhYmFzZUlkKSB7XG4gICAgcmV0dXJuIG5ldyBKc29uUHJvdG9TZXJpYWxpemVyKGRhdGFiYXNlSWQsIC8qIHVzZVByb3RvM0pzb249ICovIGZhbHNlKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IExPR19UQUckOCA9ICdFeHBvbmVudGlhbEJhY2tvZmYnO1xuLyoqXG4gKiBJbml0aWFsIGJhY2tvZmYgdGltZSBpbiBtaWxsaXNlY29uZHMgYWZ0ZXIgYW4gZXJyb3IuXG4gKiBTZXQgdG8gMXMgYWNjb3JkaW5nIHRvIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9hcGlzL2Rlc2lnbi9lcnJvcnMuXG4gKi9cbmNvbnN0IERFRkFVTFRfQkFDS09GRl9JTklUSUFMX0RFTEFZX01TID0gMTAwMDtcbmNvbnN0IERFRkFVTFRfQkFDS09GRl9GQUNUT1IgPSAxLjU7XG4vKiogTWF4aW11bSBiYWNrb2ZmIHRpbWUgaW4gbWlsbGlzZWNvbmRzICovXG5jb25zdCBERUZBVUxUX0JBQ0tPRkZfTUFYX0RFTEFZX01TID0gNjAgKiAxMDAwO1xuLyoqXG4gKiBBIGhlbHBlciBmb3IgcnVubmluZyBkZWxheWVkIHRhc2tzIGZvbGxvd2luZyBhbiBleHBvbmVudGlhbCBiYWNrb2ZmIGN1cnZlXG4gKiBiZXR3ZWVuIGF0dGVtcHRzLlxuICpcbiAqIEVhY2ggZGVsYXkgaXMgbWFkZSB1cCBvZiBhIFwiYmFzZVwiIGRlbGF5IHdoaWNoIGZvbGxvd3MgdGhlIGV4cG9uZW50aWFsXG4gKiBiYWNrb2ZmIGN1cnZlLCBhbmQgYSArLy0gNTAlIFwiaml0dGVyXCIgdGhhdCBpcyBjYWxjdWxhdGVkIGFuZCBhZGRlZCB0byB0aGVcbiAqIGJhc2UgZGVsYXkuIFRoaXMgcHJldmVudHMgY2xpZW50cyBmcm9tIGFjY2lkZW50YWxseSBzeW5jaHJvbml6aW5nIHRoZWlyXG4gKiBkZWxheXMgY2F1c2luZyBzcGlrZXMgb2YgbG9hZCB0byB0aGUgYmFja2VuZC5cbiAqL1xuY2xhc3MgRXhwb25lbnRpYWxCYWNrb2ZmIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBUaGUgQXN5bmNRdWV1ZSB0byBydW4gYmFja29mZiBvcGVyYXRpb25zIG9uLlxuICAgICAqL1xuICAgIHF1ZXVlLCBcbiAgICAvKipcbiAgICAgKiBUaGUgSUQgdG8gdXNlIHdoZW4gc2NoZWR1bGluZyBiYWNrb2ZmIG9wZXJhdGlvbnMgb24gdGhlIEFzeW5jUXVldWUuXG4gICAgICovXG4gICAgdGltZXJJZCwgXG4gICAgLyoqXG4gICAgICogVGhlIGluaXRpYWwgZGVsYXkgKHVzZWQgYXMgdGhlIGJhc2UgZGVsYXkgb24gdGhlIGZpcnN0IHJldHJ5IGF0dGVtcHQpLlxuICAgICAqIE5vdGUgdGhhdCBqaXR0ZXIgd2lsbCBzdGlsbCBiZSBhcHBsaWVkLCBzbyB0aGUgYWN0dWFsIGRlbGF5IGNvdWxkIGJlIGFzXG4gICAgICogbGl0dGxlIGFzIDAuNSppbml0aWFsRGVsYXlNcy5cbiAgICAgKi9cbiAgICBpbml0aWFsRGVsYXlNcyA9IERFRkFVTFRfQkFDS09GRl9JTklUSUFMX0RFTEFZX01TLCBcbiAgICAvKipcbiAgICAgKiBUaGUgbXVsdGlwbGllciB0byB1c2UgdG8gZGV0ZXJtaW5lIHRoZSBleHRlbmRlZCBiYXNlIGRlbGF5IGFmdGVyIGVhY2hcbiAgICAgKiBhdHRlbXB0LlxuICAgICAqL1xuICAgIGJhY2tvZmZGYWN0b3IgPSBERUZBVUxUX0JBQ0tPRkZfRkFDVE9SLCBcbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSBiYXNlIGRlbGF5IGFmdGVyIHdoaWNoIG5vIGZ1cnRoZXIgYmFja29mZiBpcyBwZXJmb3JtZWQuXG4gICAgICogTm90ZSB0aGF0IGppdHRlciB3aWxsIHN0aWxsIGJlIGFwcGxpZWQsIHNvIHRoZSBhY3R1YWwgZGVsYXkgY291bGQgYmUgYXNcbiAgICAgKiBtdWNoIGFzIDEuNSptYXhEZWxheU1zLlxuICAgICAqL1xuICAgIG1heERlbGF5TXMgPSBERUZBVUxUX0JBQ0tPRkZfTUFYX0RFTEFZX01TKSB7XG4gICAgICAgIHRoaXMucXVldWUgPSBxdWV1ZTtcbiAgICAgICAgdGhpcy50aW1lcklkID0gdGltZXJJZDtcbiAgICAgICAgdGhpcy5pbml0aWFsRGVsYXlNcyA9IGluaXRpYWxEZWxheU1zO1xuICAgICAgICB0aGlzLmJhY2tvZmZGYWN0b3IgPSBiYWNrb2ZmRmFjdG9yO1xuICAgICAgICB0aGlzLm1heERlbGF5TXMgPSBtYXhEZWxheU1zO1xuICAgICAgICB0aGlzLmN1cnJlbnRCYXNlTXMgPSAwO1xuICAgICAgICB0aGlzLnRpbWVyUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIC8qKiBUaGUgbGFzdCBiYWNrb2ZmIGF0dGVtcHQsIGFzIGVwb2NoIG1pbGxpc2Vjb25kcy4gKi9cbiAgICAgICAgdGhpcy5sYXN0QXR0ZW1wdFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgYmFja29mZiBkZWxheS5cbiAgICAgKlxuICAgICAqIFRoZSB2ZXJ5IG5leHQgYmFja29mZkFuZFdhaXQoKSB3aWxsIGhhdmUgbm8gZGVsYXkuIElmIGl0IGlzIGNhbGxlZCBhZ2FpblxuICAgICAqIChpLmUuIGR1ZSB0byBhbiBlcnJvciksIGluaXRpYWxEZWxheU1zIChwbHVzIGppdHRlcikgd2lsbCBiZSB1c2VkLCBhbmRcbiAgICAgKiBzdWJzZXF1ZW50IG9uZXMgd2lsbCBpbmNyZWFzZSBhY2NvcmRpbmcgdG8gdGhlIGJhY2tvZmZGYWN0b3IuXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuY3VycmVudEJhc2VNcyA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgYmFja29mZiBkZWxheSB0byB0aGUgbWF4aW11bSBkZWxheSAoZS5nLiBmb3IgdXNlIGFmdGVyIGFcbiAgICAgKiBSRVNPVVJDRV9FWEhBVVNURUQgZXJyb3IpLlxuICAgICAqL1xuICAgIHJlc2V0VG9NYXgoKSB7XG4gICAgICAgIHRoaXMuY3VycmVudEJhc2VNcyA9IHRoaXMubWF4RGVsYXlNcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciBjdXJyZW50RGVsYXlNcywgYW5kIGluY3JlYXNlcyB0aGVcbiAgICAgKiBkZWxheSBmb3IgYW55IHN1YnNlcXVlbnQgYXR0ZW1wdHMuIElmIHRoZXJlIHdhcyBhIHBlbmRpbmcgYmFja29mZiBvcGVyYXRpb25cbiAgICAgKiBhbHJlYWR5LCBpdCB3aWxsIGJlIGNhbmNlbGVkLlxuICAgICAqL1xuICAgIGJhY2tvZmZBbmRSdW4ob3ApIHtcbiAgICAgICAgLy8gQ2FuY2VsIGFueSBwZW5kaW5nIGJhY2tvZmYgb3BlcmF0aW9uLlxuICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICAvLyBGaXJzdCBzY2hlZHVsZSB1c2luZyB0aGUgY3VycmVudCBiYXNlICh3aGljaCBtYXkgYmUgMCBhbmQgc2hvdWxkIGJlXG4gICAgICAgIC8vIGhvbm9yZWQgYXMgc3VjaCkuXG4gICAgICAgIGNvbnN0IGRlc2lyZWREZWxheVdpdGhKaXR0ZXJNcyA9IE1hdGguZmxvb3IodGhpcy5jdXJyZW50QmFzZU1zICsgdGhpcy5qaXR0ZXJEZWxheU1zKCkpO1xuICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IGxhc3RBdHRlbXB0VGltZSBiZWluZyBpbiB0aGUgZnV0dXJlIGR1ZSB0byBhIGNsb2NrIGNoYW5nZS5cbiAgICAgICAgY29uc3QgZGVsYXlTb0Zhck1zID0gTWF0aC5tYXgoMCwgRGF0ZS5ub3coKSAtIHRoaXMubGFzdEF0dGVtcHRUaW1lKTtcbiAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCB0aGUgYmFja29mZiBkZWxheSBhbHJlYWR5IGJlaW5nIHBhc3QuXG4gICAgICAgIGNvbnN0IHJlbWFpbmluZ0RlbGF5TXMgPSBNYXRoLm1heCgwLCBkZXNpcmVkRGVsYXlXaXRoSml0dGVyTXMgLSBkZWxheVNvRmFyTXMpO1xuICAgICAgICBpZiAocmVtYWluaW5nRGVsYXlNcyA+IDApIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOCwgYEJhY2tpbmcgb2ZmIGZvciAke3JlbWFpbmluZ0RlbGF5TXN9IG1zIGAgK1xuICAgICAgICAgICAgICAgIGAoYmFzZSBkZWxheTogJHt0aGlzLmN1cnJlbnRCYXNlTXN9IG1zLCBgICtcbiAgICAgICAgICAgICAgICBgZGVsYXkgd2l0aCBqaXR0ZXI6ICR7ZGVzaXJlZERlbGF5V2l0aEppdHRlck1zfSBtcywgYCArXG4gICAgICAgICAgICAgICAgYGxhc3QgYXR0ZW1wdDogJHtkZWxheVNvRmFyTXN9IG1zIGFnbylgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVyUHJvbWlzZSA9IHRoaXMucXVldWUuZW5xdWV1ZUFmdGVyRGVsYXkodGhpcy50aW1lcklkLCByZW1haW5pbmdEZWxheU1zLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxhc3RBdHRlbXB0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICByZXR1cm4gb3AoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFwcGx5IGJhY2tvZmYgZmFjdG9yIHRvIGRldGVybWluZSBuZXh0IGRlbGF5IGFuZCBlbnN1cmUgaXQgaXMgd2l0aGluXG4gICAgICAgIC8vIGJvdW5kcy5cbiAgICAgICAgdGhpcy5jdXJyZW50QmFzZU1zICo9IHRoaXMuYmFja29mZkZhY3RvcjtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEJhc2VNcyA8IHRoaXMuaW5pdGlhbERlbGF5TXMpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEJhc2VNcyA9IHRoaXMuaW5pdGlhbERlbGF5TXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEJhc2VNcyA+IHRoaXMubWF4RGVsYXlNcykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50QmFzZU1zID0gdGhpcy5tYXhEZWxheU1zO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNraXBCYWNrb2ZmKCkge1xuICAgICAgICBpZiAodGhpcy50aW1lclByb21pc2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGltZXJQcm9taXNlLnNraXBEZWxheSgpO1xuICAgICAgICAgICAgdGhpcy50aW1lclByb21pc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZXJQcm9taXNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVyUHJvbWlzZS5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMudGltZXJQcm9taXNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIHJhbmRvbSB2YWx1ZSBpbiB0aGUgcmFuZ2UgWy1jdXJyZW50QmFzZU1zLzIsIGN1cnJlbnRCYXNlTXMvMl0gKi9cbiAgICBqaXR0ZXJEZWxheU1zKCkge1xuICAgICAgICByZXR1cm4gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogdGhpcy5jdXJyZW50QmFzZU1zO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IExPR19UQUckNyA9ICdQZXJzaXN0ZW50U3RyZWFtJztcbi8qKiBUaGUgdGltZSBhIHN0cmVhbSBzdGF5cyBvcGVuIGFmdGVyIGl0IGlzIG1hcmtlZCBpZGxlLiAqL1xuY29uc3QgSURMRV9USU1FT1VUX01TID0gNjAgKiAxMDAwO1xuLyoqIFRoZSB0aW1lIGEgc3RyZWFtIHN0YXlzIG9wZW4gdW50aWwgd2UgY29uc2lkZXIgaXQgaGVhbHRoeS4gKi9cbmNvbnN0IEhFQUxUSFlfVElNRU9VVF9NUyA9IDEwICogMTAwMDtcbi8qKlxuICogQSBQZXJzaXN0ZW50U3RyZWFtIGlzIGFuIGFic3RyYWN0IGJhc2UgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgc3RyZWFtaW5nIFJQQ1xuICogdG8gdGhlIEZpcmVzdG9yZSBiYWNrZW5kLiBJdCdzIGJ1aWx0IG9uIHRvcCBvZiB0aGUgY29ubmVjdGlvbnMgb3duIHN1cHBvcnRcbiAqIGZvciBzdHJlYW1pbmcgUlBDcywgYW5kIGFkZHMgc2V2ZXJhbCBjcml0aWNhbCBmZWF0dXJlcyBmb3Igb3VyIGNsaWVudHM6XG4gKlxuICogICAtIEV4cG9uZW50aWFsIGJhY2tvZmYgb24gZmFpbHVyZVxuICogICAtIEF1dGhlbnRpY2F0aW9uIHZpYSBDcmVkZW50aWFsc1Byb3ZpZGVyXG4gKiAgIC0gRGlzcGF0Y2hpbmcgYWxsIGNhbGxiYWNrcyBpbnRvIHRoZSBzaGFyZWQgd29ya2VyIHF1ZXVlXG4gKiAgIC0gQ2xvc2luZyBpZGxlIHN0cmVhbXMgYWZ0ZXIgNjAgc2Vjb25kcyBvZiBpbmFjdGl2aXR5XG4gKlxuICogU3ViY2xhc3NlcyBvZiBQZXJzaXN0ZW50U3RyZWFtIGltcGxlbWVudCBzZXJpYWxpemF0aW9uIG9mIG1vZGVscyB0byBhbmRcbiAqIGZyb20gdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHByb3RvY29sIGJ1ZmZlcnMgZm9yIGEgc3BlY2lmaWNcbiAqIHN0cmVhbWluZyBSUEMuXG4gKlxuICogIyMgU3RhcnRpbmcgYW5kIFN0b3BwaW5nXG4gKlxuICogU3RyZWFtaW5nIFJQQ3MgYXJlIHN0YXRlZnVsIGFuZCBuZWVkIHRvIGJlIHN0YXJ0KCllZCBiZWZvcmUgbWVzc2FnZXMgY2FuXG4gKiBiZSBzZW50IGFuZCByZWNlaXZlZC4gVGhlIFBlcnNpc3RlbnRTdHJlYW0gd2lsbCBjYWxsIHRoZSBvbk9wZW4oKSBmdW5jdGlvblxuICogb2YgdGhlIGxpc3RlbmVyIG9uY2UgdGhlIHN0cmVhbSBpcyByZWFkeSB0byBhY2NlcHQgcmVxdWVzdHMuXG4gKlxuICogU2hvdWxkIGEgc3RhcnQoKSBmYWlsLCBQZXJzaXN0ZW50U3RyZWFtIHdpbGwgY2FsbCB0aGUgcmVnaXN0ZXJlZCBvbkNsb3NlKClcbiAqIGxpc3RlbmVyIHdpdGggYSBGaXJlc3RvcmVFcnJvciBpbmRpY2F0aW5nIHdoYXQgd2VudCB3cm9uZy5cbiAqXG4gKiBBIFBlcnNpc3RlbnRTdHJlYW0gY2FuIGJlIHN0YXJ0ZWQgYW5kIHN0b3BwZWQgcmVwZWF0ZWRseS5cbiAqXG4gKiBHZW5lcmljIHR5cGVzOlxuICogIFNlbmRUeXBlOiBUaGUgdHlwZSBvZiB0aGUgb3V0Z29pbmcgbWVzc2FnZSBvZiB0aGUgdW5kZXJseWluZ1xuICogICAgY29ubmVjdGlvbiBzdHJlYW1cbiAqICBSZWNlaXZlVHlwZTogVGhlIHR5cGUgb2YgdGhlIGluY29taW5nIG1lc3NhZ2Ugb2YgdGhlIHVuZGVybHlpbmdcbiAqICAgIGNvbm5lY3Rpb24gc3RyZWFtXG4gKiAgTGlzdGVuZXJUeXBlOiBUaGUgdHlwZSBvZiB0aGUgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIGNhbGxiYWNrc1xuICovXG5jbGFzcyBQZXJzaXN0ZW50U3RyZWFtIHtcbiAgICBjb25zdHJ1Y3RvcihxdWV1ZSwgY29ubmVjdGlvblRpbWVySWQsIGlkbGVUaW1lcklkLCBoZWFsdGhUaW1lcklkLCBjb25uZWN0aW9uLCBhdXRoQ3JlZGVudGlhbHNQcm92aWRlciwgYXBwQ2hlY2tDcmVkZW50aWFsc1Byb3ZpZGVyLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnF1ZXVlID0gcXVldWU7XG4gICAgICAgIHRoaXMuaWRsZVRpbWVySWQgPSBpZGxlVGltZXJJZDtcbiAgICAgICAgdGhpcy5oZWFsdGhUaW1lcklkID0gaGVhbHRoVGltZXJJZDtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHNQcm92aWRlciA9IGF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyO1xuICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHNQcm92aWRlciA9IGFwcENoZWNrQ3JlZGVudGlhbHNQcm92aWRlcjtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLnN0YXRlID0gMCAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuSW5pdGlhbCAqLztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2xvc2UgY291bnQgdGhhdCdzIGluY3JlbWVudGVkIGV2ZXJ5IHRpbWUgdGhlIHN0cmVhbSBpcyBjbG9zZWQ7IHVzZWQgYnlcbiAgICAgICAgICogZ2V0Q2xvc2VHdWFyZGVkRGlzcGF0Y2hlcigpIHRvIGludmFsaWRhdGUgY2FsbGJhY2tzIHRoYXQgaGFwcGVuIGFmdGVyXG4gICAgICAgICAqIGNsb3NlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5pZGxlVGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmhlYWx0aENoZWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ291bnQgb2YgcmVzcG9uc2UgbWVzc2FnZXMgcmVjZWl2ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc3BvbnNlQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmJhY2tvZmYgPSBuZXcgRXhwb25lbnRpYWxCYWNrb2ZmKHF1ZXVlLCBjb25uZWN0aW9uVGltZXJJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBzdGFydCgpIGhhcyBiZWVuIGNhbGxlZCBhbmQgbm8gZXJyb3IgaGFzIG9jY3VycmVkLiBUcnVlXG4gICAgICogaW5kaWNhdGVzIHRoZSBzdHJlYW0gaXMgb3BlbiBvciBpbiB0aGUgcHJvY2VzcyBvZiBvcGVuaW5nICh3aGljaFxuICAgICAqIGVuY29tcGFzc2VzIHJlc3BlY3RpbmcgYmFja29mZiwgZ2V0dGluZyBhdXRoIHRva2VucywgYW5kIHN0YXJ0aW5nIHRoZVxuICAgICAqIGFjdHVhbCBSUEMpLiBVc2UgaXNPcGVuKCkgdG8gZGV0ZXJtaW5lIGlmIHRoZSBzdHJlYW0gaXMgb3BlbiBhbmQgcmVhZHkgZm9yXG4gICAgICogb3V0Ym91bmQgcmVxdWVzdHMuXG4gICAgICovXG4gICAgaXNTdGFydGVkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuc3RhdGUgPT09IDEgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLlN0YXJ0aW5nICovIHx8XG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSA1IC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5CYWNrb2ZmICovIHx8XG4gICAgICAgICAgICB0aGlzLmlzT3BlbigpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB1bmRlcmx5aW5nIFJQQyBpcyBvcGVuICh0aGUgb25PcGVuKCkgbGlzdGVuZXIgaGFzIGJlZW5cbiAgICAgKiBjYWxsZWQpIGFuZCB0aGUgc3RyZWFtIGlzIHJlYWR5IGZvciBvdXRib3VuZCByZXF1ZXN0cy5cbiAgICAgKi9cbiAgICBpc09wZW4oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zdGF0ZSA9PT0gMiAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuT3BlbiAqLyB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gMyAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuSGVhbHRoeSAqLyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyB0aGUgUlBDLiBPbmx5IGFsbG93ZWQgaWYgaXNTdGFydGVkKCkgcmV0dXJucyBmYWxzZS4gVGhlIHN0cmVhbSBpc1xuICAgICAqIG5vdCBpbW1lZGlhdGVseSByZWFkeSBmb3IgdXNlOiBvbk9wZW4oKSB3aWxsIGJlIGludm9rZWQgd2hlbiB0aGUgUlBDIGlzXG4gICAgICogcmVhZHkgZm9yIG91dGJvdW5kIHJlcXVlc3RzLCBhdCB3aGljaCBwb2ludCBpc09wZW4oKSB3aWxsIHJldHVybiB0cnVlLlxuICAgICAqXG4gICAgICogV2hlbiBzdGFydCByZXR1cm5zLCBpc1N0YXJ0ZWQoKSB3aWxsIHJldHVybiB0cnVlLlxuICAgICAqL1xuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLnJlc3BvbnNlQ291bnQgPSAwO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gNCAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuRXJyb3IgKi8pIHtcbiAgICAgICAgICAgIHRoaXMucGVyZm9ybUJhY2tvZmYoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF1dGgoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgdGhlIFJQQy4gVGhpcyBjYWxsIGlzIGlkZW1wb3RlbnQgYW5kIGFsbG93ZWQgcmVnYXJkbGVzcyBvZiB0aGVcbiAgICAgKiBjdXJyZW50IGlzU3RhcnRlZCgpIHN0YXRlLlxuICAgICAqXG4gICAgICogV2hlbiBzdG9wIHJldHVybnMsIGlzU3RhcnRlZCgpIGFuZCBpc09wZW4oKSB3aWxsIGJvdGggcmV0dXJuIGZhbHNlLlxuICAgICAqL1xuICAgIGFzeW5jIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhcnRlZCgpKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNsb3NlKDAgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLkluaXRpYWwgKi8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFmdGVyIGFuIGVycm9yIHRoZSBzdHJlYW0gd2lsbCB1c3VhbGx5IGJhY2sgb2ZmIG9uIHRoZSBuZXh0IGF0dGVtcHQgdG9cbiAgICAgKiBzdGFydCBpdC4gSWYgdGhlIGVycm9yIHdhcnJhbnRzIGFuIGltbWVkaWF0ZSByZXN0YXJ0IG9mIHRoZSBzdHJlYW0sIHRoZVxuICAgICAqIHNlbmRlciBjYW4gdXNlIHRoaXMgdG8gaW5kaWNhdGUgdGhhdCB0aGUgcmVjZWl2ZXIgc2hvdWxkIG5vdCBiYWNrIG9mZi5cbiAgICAgKlxuICAgICAqIEVhY2ggZXJyb3Igd2lsbCBjYWxsIHRoZSBvbkNsb3NlKCkgbGlzdGVuZXIuIFRoYXQgZnVuY3Rpb24gY2FuIGRlY2lkZSB0b1xuICAgICAqIGluaGliaXQgYmFja29mZiBpZiByZXF1aXJlZC5cbiAgICAgKi9cbiAgICBpbmhpYml0QmFja29mZigpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDAgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLkluaXRpYWwgKi87XG4gICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyB0aGlzIHN0cmVhbSBhcyBpZGxlLiBJZiBubyBmdXJ0aGVyIGFjdGlvbnMgYXJlIHBlcmZvcm1lZCBvbiB0aGVcbiAgICAgKiBzdHJlYW0gZm9yIG9uZSBtaW51dGUsIHRoZSBzdHJlYW0gd2lsbCBhdXRvbWF0aWNhbGx5IGNsb3NlIGl0c2VsZiBhbmRcbiAgICAgKiBub3RpZnkgdGhlIHN0cmVhbSdzIG9uQ2xvc2UoKSBoYW5kbGVyIHdpdGggU3RhdHVzLk9LLiBUaGUgc3RyZWFtIHdpbGwgdGhlblxuICAgICAqIGJlIGluIGEgIWlzU3RhcnRlZCgpIHN0YXRlLCByZXF1aXJpbmcgdGhlIGNhbGxlciB0byBzdGFydCB0aGUgc3RyZWFtIGFnYWluXG4gICAgICogYmVmb3JlIGZ1cnRoZXIgdXNlLlxuICAgICAqXG4gICAgICogT25seSBzdHJlYW1zIHRoYXQgYXJlIGluIHN0YXRlICdPcGVuJyBjYW4gYmUgbWFya2VkIGlkbGUsIGFzIGFsbCBvdGhlclxuICAgICAqIHN0YXRlcyBpbXBseSBwZW5kaW5nIG5ldHdvcmsgb3BlcmF0aW9ucy5cbiAgICAgKi9cbiAgICBtYXJrSWRsZSgpIHtcbiAgICAgICAgLy8gU3RhcnRzIHRoZSBpZGxlIHRpbWUgaWYgd2UgYXJlIGluIHN0YXRlICdPcGVuJyBhbmQgYXJlIG5vdCB5ZXQgYWxyZWFkeVxuICAgICAgICAvLyBydW5uaW5nIGEgdGltZXIgKGluIHdoaWNoIGNhc2UgdGhlIHByZXZpb3VzIGlkbGUgdGltZW91dCBzdGlsbCBhcHBsaWVzKS5cbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKCkgJiYgdGhpcy5pZGxlVGltZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaWRsZVRpbWVyID0gdGhpcy5xdWV1ZS5lbnF1ZXVlQWZ0ZXJEZWxheSh0aGlzLmlkbGVUaW1lcklkLCBJRExFX1RJTUVPVVRfTVMsICgpID0+IHRoaXMuaGFuZGxlSWRsZUNsb3NlVGltZXIoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgdW5kZXJseWluZyBzdHJlYW0uICovXG4gICAgc2VuZFJlcXVlc3QobXNnKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsSWRsZUNoZWNrKCk7XG4gICAgICAgIHRoaXMuc3RyZWFtLnNlbmQobXNnKTtcbiAgICB9XG4gICAgLyoqIENhbGxlZCBieSB0aGUgaWRsZSB0aW1lciB3aGVuIHRoZSBzdHJlYW0gc2hvdWxkIGNsb3NlIGR1ZSB0byBpbmFjdGl2aXR5LiAqL1xuICAgIGFzeW5jIGhhbmRsZUlkbGVDbG9zZVRpbWVyKCkge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4oKSkge1xuICAgICAgICAgICAgLy8gV2hlbiB0aW1pbmcgb3V0IGFuIGlkbGUgc3RyZWFtIHRoZXJlJ3Mgbm8gcmVhc29uIHRvIGZvcmNlIHRoZSBzdHJlYW0gaW50byBiYWNrb2ZmIHdoZW5cbiAgICAgICAgICAgIC8vIGl0IHJlc3RhcnRzIHNvIHNldCB0aGUgc3RyZWFtIHN0YXRlIHRvIEluaXRpYWwgaW5zdGVhZCBvZiBFcnJvci5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb3NlKDAgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLkluaXRpYWwgKi8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBNYXJrcyB0aGUgc3RyZWFtIGFzIGFjdGl2ZSBhZ2Fpbi4gKi9cbiAgICBjYW5jZWxJZGxlQ2hlY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmlkbGVUaW1lcikge1xuICAgICAgICAgICAgdGhpcy5pZGxlVGltZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLmlkbGVUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIENhbmNlbHMgdGhlIGhlYWx0aCBjaGVjayBkZWxheWVkIG9wZXJhdGlvbi4gKi9cbiAgICBjYW5jZWxIZWFsdGhDaGVjaygpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVhbHRoQ2hlY2spIHtcbiAgICAgICAgICAgIHRoaXMuaGVhbHRoQ2hlY2suY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLmhlYWx0aENoZWNrID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIHN0cmVhbSBhbmQgY2xlYW5zIHVwIGFzIG5lY2Vzc2FyeTpcbiAgICAgKlxuICAgICAqICogY2xvc2VzIHRoZSB1bmRlcmx5aW5nIEdSUEMgc3RyZWFtO1xuICAgICAqICogY2FsbHMgdGhlIG9uQ2xvc2UgaGFuZGxlciB3aXRoIHRoZSBnaXZlbiAnZXJyb3InO1xuICAgICAqICogc2V0cyBpbnRlcm5hbCBzdHJlYW0gc3RhdGUgdG8gJ2ZpbmFsU3RhdGUnO1xuICAgICAqICogYWRqdXN0cyB0aGUgYmFja29mZiB0aW1lciBiYXNlZCBvbiB0aGUgZXJyb3JcbiAgICAgKlxuICAgICAqIEEgbmV3IHN0cmVhbSBjYW4gYmUgb3BlbmVkIGJ5IGNhbGxpbmcgc3RhcnQoKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaW5hbFN0YXRlIC0gdGhlIGludGVuZGVkIHN0YXRlIG9mIHRoZSBzdHJlYW0gYWZ0ZXIgY2xvc2luZy5cbiAgICAgKiBAcGFyYW0gZXJyb3IgLSB0aGUgZXJyb3IgdGhlIGNvbm5lY3Rpb24gd2FzIGNsb3NlZCB3aXRoLlxuICAgICAqL1xuICAgIGFzeW5jIGNsb3NlKGZpbmFsU3RhdGUsIGVycm9yKSB7XG4gICAgICAgIC8vIENhbmNlbCBhbnkgb3V0c3RhbmRpbmcgdGltZXJzICh0aGV5J3JlIGd1YXJhbnRlZWQgbm90IHRvIGV4ZWN1dGUpLlxuICAgICAgICB0aGlzLmNhbmNlbElkbGVDaGVjaygpO1xuICAgICAgICB0aGlzLmNhbmNlbEhlYWx0aENoZWNrKCk7XG4gICAgICAgIHRoaXMuYmFja29mZi5jYW5jZWwoKTtcbiAgICAgICAgLy8gSW52YWxpZGF0ZXMgYW55IHN0cmVhbS1yZWxhdGVkIGNhbGxiYWNrcyAoZS5nLiBmcm9tIGF1dGggb3IgdGhlXG4gICAgICAgIC8vIHVuZGVybHlpbmcgc3RyZWFtKSwgZ3VhcmFudGVlaW5nIHRoZXkgd29uJ3QgZXhlY3V0ZS5cbiAgICAgICAgdGhpcy5jbG9zZUNvdW50Kys7XG4gICAgICAgIGlmIChmaW5hbFN0YXRlICE9PSA0IC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5FcnJvciAqLykge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhbiBpbnRlbnRpb25hbCBjbG9zZSBlbnN1cmUgd2UgZG9uJ3QgZGVsYXkgb3VyIG5leHQgY29ubmVjdGlvbiBhdHRlbXB0LlxuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXJyb3IgJiYgZXJyb3IuY29kZSA9PT0gQ29kZS5SRVNPVVJDRV9FWEhBVVNURUQpIHtcbiAgICAgICAgICAgIC8vIExvZyB0aGUgZXJyb3IuIChQcm9iYWJseSBlaXRoZXIgJ3F1b3RhIGV4Y2VlZGVkJyBvciAnbWF4IHF1ZXVlIGxlbmd0aCByZWFjaGVkJy4pXG4gICAgICAgICAgICBsb2dFcnJvcihlcnJvci50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGxvZ0Vycm9yKCdVc2luZyBtYXhpbXVtIGJhY2tvZmYgZGVsYXkgdG8gcHJldmVudCBvdmVybG9hZGluZyB0aGUgYmFja2VuZC4nKTtcbiAgICAgICAgICAgIHRoaXMuYmFja29mZi5yZXNldFRvTWF4KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXJyb3IgJiZcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPT09IENvZGUuVU5BVVRIRU5USUNBVEVEICYmXG4gICAgICAgICAgICB0aGlzLnN0YXRlICE9PSAzIC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5IZWFsdGh5ICovKSB7XG4gICAgICAgICAgICAvLyBcInVuYXV0aGVudGljYXRlZFwiIGVycm9yIG1lYW5zIHRoZSB0b2tlbiB3YXMgcmVqZWN0ZWQuIFRoaXMgc2hvdWxkIHJhcmVseVxuICAgICAgICAgICAgLy8gaGFwcGVuIHNpbmNlIGJvdGggQXV0aCBhbmQgQXBwQ2hlY2sgZW5zdXJlIGEgc3VmZmljaWVudCBUVEwgd2hlbiB3ZVxuICAgICAgICAgICAgLy8gcmVxdWVzdCBhIHRva2VuLiBJZiBhIHVzZXIgbWFudWFsbHkgcmVzZXRzIHRoZWlyIHN5c3RlbSBjbG9jayB0aGlzIGNhblxuICAgICAgICAgICAgLy8gZmFpbCwgaG93ZXZlci4gSW4gdGhpcyBjYXNlLCB3ZSBzaG91bGQgZ2V0IGEgQ29kZS5VTkFVVEhFTlRJQ0FURUQgZXJyb3JcbiAgICAgICAgICAgIC8vIGJlZm9yZSB3ZSByZWNlaXZlZCB0aGUgZmlyc3QgbWVzc2FnZSBhbmQgd2UgbmVlZCB0byBpbnZhbGlkYXRlIHRoZSB0b2tlblxuICAgICAgICAgICAgLy8gdG8gZW5zdXJlIHRoYXQgd2UgZmV0Y2ggYSBuZXcgdG9rZW4uXG4gICAgICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyLmludmFsaWRhdGVUb2tlbigpO1xuICAgICAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzUHJvdmlkZXIuaW52YWxpZGF0ZVRva2VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIHVuZGVybHlpbmcgc3RyZWFtIGJlY2F1c2Ugd2UgYXJlIG5vIGxvbmdlciBpbnRlcmVzdGVkIGluIGV2ZW50cy5cbiAgICAgICAgaWYgKHRoaXMuc3RyZWFtICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRlYXJEb3duKCk7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgc3RhdGUgbXVzdCBiZSBhc3NpZ25lZCBiZWZvcmUgY2FsbGluZyBvbkNsb3NlKCkgdG8gYWxsb3cgdGhlIGNhbGxiYWNrIHRvXG4gICAgICAgIC8vIGluaGliaXQgYmFja29mZiBvciBvdGhlcndpc2UgbWFuaXB1bGF0ZSB0aGUgc3RhdGUgaW4gaXRzIG5vbi1zdGFydGVkIHN0YXRlLlxuICAgICAgICB0aGlzLnN0YXRlID0gZmluYWxTdGF0ZTtcbiAgICAgICAgLy8gTm90aWZ5IHRoZSBsaXN0ZW5lciB0aGF0IHRoZSBzdHJlYW0gY2xvc2VkLlxuICAgICAgICBhd2FpdCB0aGlzLmxpc3RlbmVyLm9uQ2xvc2UoZXJyb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYW4gYmUgb3ZlcnJpZGRlbiB0byBwZXJmb3JtIGFkZGl0aW9uYWwgY2xlYW51cCBiZWZvcmUgdGhlIHN0cmVhbSBpcyBjbG9zZWQuXG4gICAgICogQ2FsbGluZyBzdXBlci50ZWFyRG93bigpIGlzIG5vdCByZXF1aXJlZC5cbiAgICAgKi9cbiAgICB0ZWFyRG93bigpIHsgfVxuICAgIGF1dGgoKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAxIC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5TdGFydGluZyAqLztcbiAgICAgICAgY29uc3QgZGlzcGF0Y2hJZk5vdENsb3NlZCA9IHRoaXMuZ2V0Q2xvc2VHdWFyZGVkRGlzcGF0Y2hlcih0aGlzLmNsb3NlQ291bnQpO1xuICAgICAgICAvLyBUT0RPKG1pa2VsZWhlbik6IEp1c3QgdXNlIGRpc3BhdGNoSWZOb3RDbG9zZWQsIGJ1dCBzZWUgVE9ETyBiZWxvdy5cbiAgICAgICAgY29uc3QgY2xvc2VDb3VudCA9IHRoaXMuY2xvc2VDb3VudDtcbiAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHNQcm92aWRlci5nZXRUb2tlbigpLFxuICAgICAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzUHJvdmlkZXIuZ2V0VG9rZW4oKVxuICAgICAgICBdKS50aGVuKChbYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuXSkgPT4ge1xuICAgICAgICAgICAgLy8gU3RyZWFtIGNhbiBiZSBzdG9wcGVkIHdoaWxlIHdhaXRpbmcgZm9yIGF1dGhlbnRpY2F0aW9uLlxuICAgICAgICAgICAgLy8gVE9ETyhtaWtlbGVoZW4pOiBXZSByZWFsbHkgc2hvdWxkIGp1c3QgdXNlIGRpc3BhdGNoSWZOb3RDbG9zZWRcbiAgICAgICAgICAgIC8vIGFuZCBsZXQgdGhpcyBkaXNwYXRjaCBvbnRvIHRoZSBxdWV1ZSwgYnV0IHRoYXQgb3BlbmVkIGEgc3BlYyB0ZXN0IGNhblxuICAgICAgICAgICAgLy8gb2Ygd29ybXMgdGhhdCBJIGRvbid0IHdhbnQgdG8gZGVhbCB3aXRoIGluIHRoaXMgUFIuXG4gICAgICAgICAgICBpZiAodGhpcy5jbG9zZUNvdW50ID09PSBjbG9zZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgLy8gTm9ybWFsbHkgd2UnZCBoYXZlIHRvIHNjaGVkdWxlIHRoZSBjYWxsYmFjayBvbiB0aGUgQXN5bmNRdWV1ZS5cbiAgICAgICAgICAgICAgICAvLyBIb3dldmVyLCB0aGUgZm9sbG93aW5nIGNhbGxzIGFyZSBzYWZlIHRvIGJlIGNhbGxlZCBvdXRzaWRlIHRoZVxuICAgICAgICAgICAgICAgIC8vIEFzeW5jUXVldWUgc2luY2UgdGhleSBkb24ndCBjaGFpbiBhc3luY2hyb25vdXMgY2FsbHNcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3RyZWFtKGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgZGlzcGF0Y2hJZk5vdENsb3NlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcnBjRXJyb3IgPSBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTktOT1dOLCAnRmV0Y2hpbmcgYXV0aCB0b2tlbiBmYWlsZWQ6ICcgKyBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTdHJlYW1DbG9zZShycGNFcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXJ0U3RyZWFtKGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbikge1xuICAgICAgICBjb25zdCBkaXNwYXRjaElmTm90Q2xvc2VkID0gdGhpcy5nZXRDbG9zZUd1YXJkZWREaXNwYXRjaGVyKHRoaXMuY2xvc2VDb3VudCk7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gdGhpcy5zdGFydFJwYyhhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xuICAgICAgICB0aGlzLnN0cmVhbS5vbkNvbm5lY3RlZCgoKSA9PiB7XG4gICAgICAgICAgICBkaXNwYXRjaElmTm90Q2xvc2VkKCgpID0+IHRoaXMubGlzdGVuZXIub25Db25uZWN0ZWQoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0cmVhbS5vbk9wZW4oKCkgPT4ge1xuICAgICAgICAgICAgZGlzcGF0Y2hJZk5vdENsb3NlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDIgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLk9wZW4gKi87XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFsdGhDaGVjayA9IHRoaXMucXVldWUuZW5xdWV1ZUFmdGVyRGVsYXkodGhpcy5oZWFsdGhUaW1lcklkLCBIRUFMVEhZX1RJTUVPVVRfTVMsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNPcGVuKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzIC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5IZWFsdGh5ICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5vbk9wZW4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHJlYW0ub25DbG9zZSgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoSWZOb3RDbG9zZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVN0cmVhbUNsb3NlKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHJlYW0ub25NZXNzYWdlKChtc2cpID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoSWZOb3RDbG9zZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICgrK3RoaXMucmVzcG9uc2VDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vbkZpcnN0KG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vbk5leHQobXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBlcmZvcm1CYWNrb2ZmKCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gNSAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuQmFja29mZiAqLztcbiAgICAgICAgdGhpcy5iYWNrb2ZmLmJhY2tvZmZBbmRSdW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDAgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLkluaXRpYWwgKi87XG4gICAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBWaXNpYmxlIGZvciB0ZXN0c1xuICAgIGhhbmRsZVN0cmVhbUNsb3NlKGVycm9yKSB7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckNywgYGNsb3NlIHdpdGggZXJyb3I6ICR7ZXJyb3J9YCk7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gbnVsbDtcbiAgICAgICAgLy8gSW4gdGhlb3J5IHRoZSBzdHJlYW0gY291bGQgY2xvc2UgY2xlYW5seSwgaG93ZXZlciwgaW4gb3VyIGN1cnJlbnQgbW9kZWxcbiAgICAgICAgLy8gd2UgbmV2ZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlY2F1c2UgaWYgd2Ugc3RvcCBhIHN0cmVhbSBvdXJzZWx2ZXMsXG4gICAgICAgIC8vIHRoaXMgY2FsbGJhY2sgd2lsbCBuZXZlciBiZSBjYWxsZWQuIFRvIHByZXZlbnQgY2FzZXMgd2hlcmUgd2UgcmV0cnlcbiAgICAgICAgLy8gd2l0aG91dCBhIGJhY2tvZmYgYWNjaWRlbnRhbGx5LCB3ZSBzZXQgdGhlIHN0cmVhbSB0byBlcnJvciBpbiBhbGwgY2FzZXMuXG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlKDQgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLkVycm9yICovLCBlcnJvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBcImRpc3BhdGNoZXJcIiBmdW5jdGlvbiB0aGF0IGRpc3BhdGNoZXMgb3BlcmF0aW9ucyBvbnRvIHRoZVxuICAgICAqIEFzeW5jUXVldWUgYnV0IG9ubHkgcnVucyB0aGVtIGlmIGNsb3NlQ291bnQgcmVtYWlucyB1bmNoYW5nZWQuIFRoaXMgYWxsb3dzXG4gICAgICogdXMgdG8gdHVybiBhdXRoIC8gc3RyZWFtIGNhbGxiYWNrcyBpbnRvIG5vLW9wcyBpZiB0aGUgc3RyZWFtIGlzIGNsb3NlZCAvXG4gICAgICogcmUtb3BlbmVkLCBldGMuXG4gICAgICovXG4gICAgZ2V0Q2xvc2VHdWFyZGVkRGlzcGF0Y2hlcihzdGFydENsb3NlQ291bnQpIHtcbiAgICAgICAgcmV0dXJuIChmbikgPT4ge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jbG9zZUNvdW50ID09PSBzdGFydENsb3NlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDcsICdzdHJlYW0gY2FsbGJhY2sgc2tpcHBlZCBieSBnZXRDbG9zZUd1YXJkZWREaXNwYXRjaGVyLicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiBBIFBlcnNpc3RlbnRTdHJlYW0gdGhhdCBpbXBsZW1lbnRzIHRoZSBMaXN0ZW4gUlBDLlxuICpcbiAqIE9uY2UgdGhlIExpc3RlbiBzdHJlYW0gaGFzIGNhbGxlZCB0aGUgb25PcGVuKCkgbGlzdGVuZXIsIGFueSBudW1iZXIgb2ZcbiAqIGxpc3RlbigpIGFuZCB1bmxpc3RlbigpIGNhbGxzIGNhbiBiZSBtYWRlIHRvIGNvbnRyb2wgd2hhdCBjaGFuZ2VzIHdpbGwgYmVcbiAqIHNlbnQgZnJvbSB0aGUgc2VydmVyIGZvciBMaXN0ZW5SZXNwb25zZXMuXG4gKi9cbmNsYXNzIFBlcnNpc3RlbnRMaXN0ZW5TdHJlYW0gZXh0ZW5kcyBQZXJzaXN0ZW50U3RyZWFtIHtcbiAgICBjb25zdHJ1Y3RvcihxdWV1ZSwgY29ubmVjdGlvbiwgYXV0aENyZWRlbnRpYWxzLCBhcHBDaGVja0NyZWRlbnRpYWxzLCBzZXJpYWxpemVyLCBsaXN0ZW5lcikge1xuICAgICAgICBzdXBlcihxdWV1ZSwgXCJsaXN0ZW5fc3RyZWFtX2Nvbm5lY3Rpb25fYmFja29mZlwiIC8qIFRpbWVySWQuTGlzdGVuU3RyZWFtQ29ubmVjdGlvbkJhY2tvZmYgKi8sIFwibGlzdGVuX3N0cmVhbV9pZGxlXCIgLyogVGltZXJJZC5MaXN0ZW5TdHJlYW1JZGxlICovLCBcImhlYWx0aF9jaGVja190aW1lb3V0XCIgLyogVGltZXJJZC5IZWFsdGhDaGVja1RpbWVvdXQgKi8sIGNvbm5lY3Rpb24sIGF1dGhDcmVkZW50aWFscywgYXBwQ2hlY2tDcmVkZW50aWFscywgbGlzdGVuZXIpO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xuICAgIH1cbiAgICBzdGFydFJwYyhhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5vcGVuU3RyZWFtKCdMaXN0ZW4nLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xuICAgIH1cbiAgICBvbkZpcnN0KHdhdGNoQ2hhbmdlUHJvdG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub25OZXh0KHdhdGNoQ2hhbmdlUHJvdG8pO1xuICAgIH1cbiAgICBvbk5leHQod2F0Y2hDaGFuZ2VQcm90bykge1xuICAgICAgICAvLyBBIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgbWVhbnMgdGhlIHN0cmVhbSBpcyBoZWFsdGh5XG4gICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgICAgICBjb25zdCB3YXRjaENoYW5nZSA9IGZyb21XYXRjaENoYW5nZSh0aGlzLnNlcmlhbGl6ZXIsIHdhdGNoQ2hhbmdlUHJvdG8pO1xuICAgICAgICBjb25zdCBzbmFwc2hvdCA9IHZlcnNpb25Gcm9tTGlzdGVuUmVzcG9uc2Uod2F0Y2hDaGFuZ2VQcm90byk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLm9uV2F0Y2hDaGFuZ2Uod2F0Y2hDaGFuZ2UsIHNuYXBzaG90KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGludGVyZXN0IGluIHRoZSByZXN1bHRzIG9mIHRoZSBnaXZlbiB0YXJnZXQuIElmIHRoZSB0YXJnZXRcbiAgICAgKiBpbmNsdWRlcyBhIHJlc3VtZVRva2VuIGl0IHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHJlcXVlc3QuIFJlc3VsdHMgdGhhdFxuICAgICAqIGFmZmVjdCB0aGUgdGFyZ2V0IHdpbGwgYmUgc3RyZWFtZWQgYmFjayBhcyBXYXRjaENoYW5nZSBtZXNzYWdlcyB0aGF0XG4gICAgICogcmVmZXJlbmNlIHRoZSB0YXJnZXRJZC5cbiAgICAgKi9cbiAgICB3YXRjaCh0YXJnZXREYXRhKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7fTtcbiAgICAgICAgcmVxdWVzdC5kYXRhYmFzZSA9IGdldEVuY29kZWREYXRhYmFzZUlkKHRoaXMuc2VyaWFsaXplcik7XG4gICAgICAgIHJlcXVlc3QuYWRkVGFyZ2V0ID0gdG9UYXJnZXQodGhpcy5zZXJpYWxpemVyLCB0YXJnZXREYXRhKTtcbiAgICAgICAgY29uc3QgbGFiZWxzID0gdG9MaXN0ZW5SZXF1ZXN0TGFiZWxzKHRoaXMuc2VyaWFsaXplciwgdGFyZ2V0RGF0YSk7XG4gICAgICAgIGlmIChsYWJlbHMpIHtcbiAgICAgICAgICAgIHJlcXVlc3QubGFiZWxzID0gbGFiZWxzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VuZFJlcXVlc3QocmVxdWVzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucmVnaXN0ZXJzIGludGVyZXN0IGluIHRoZSByZXN1bHRzIG9mIHRoZSB0YXJnZXQgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgICAqIGdpdmVuIHRhcmdldElkLlxuICAgICAqL1xuICAgIHVud2F0Y2godGFyZ2V0SWQpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHt9O1xuICAgICAgICByZXF1ZXN0LmRhdGFiYXNlID0gZ2V0RW5jb2RlZERhdGFiYXNlSWQodGhpcy5zZXJpYWxpemVyKTtcbiAgICAgICAgcmVxdWVzdC5yZW1vdmVUYXJnZXQgPSB0YXJnZXRJZDtcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChyZXF1ZXN0KTtcbiAgICB9XG59XG4vKipcbiAqIEEgU3RyZWFtIHRoYXQgaW1wbGVtZW50cyB0aGUgV3JpdGUgUlBDLlxuICpcbiAqIFRoZSBXcml0ZSBSUEMgcmVxdWlyZXMgdGhlIGNhbGxlciB0byBtYWludGFpbiBzcGVjaWFsIHN0cmVhbVRva2VuXG4gKiBzdGF0ZSBpbiBiZXR3ZWVuIGNhbGxzLCB0byBoZWxwIHRoZSBzZXJ2ZXIgdW5kZXJzdGFuZCB3aGljaCByZXNwb25zZXMgdGhlXG4gKiBjbGllbnQgaGFzIHByb2Nlc3NlZCBieSB0aGUgdGltZSB0aGUgbmV4dCByZXF1ZXN0IGlzIG1hZGUuIEV2ZXJ5IHJlc3BvbnNlXG4gKiB3aWxsIGNvbnRhaW4gYSBzdHJlYW1Ub2tlbjsgdGhpcyB2YWx1ZSBtdXN0IGJlIHBhc3NlZCB0byB0aGUgbmV4dFxuICogcmVxdWVzdC5cbiAqXG4gKiBBZnRlciBjYWxsaW5nIHN0YXJ0KCkgb24gdGhpcyBzdHJlYW0sIHRoZSBuZXh0IHJlcXVlc3QgbXVzdCBiZSBhIGhhbmRzaGFrZSxcbiAqIGNvbnRhaW5pbmcgd2hhdGV2ZXIgc3RyZWFtVG9rZW4gaXMgb24gaGFuZC4gT25jZSBhIHJlc3BvbnNlIHRvIHRoaXNcbiAqIHJlcXVlc3QgaXMgcmVjZWl2ZWQsIGFsbCBwZW5kaW5nIG11dGF0aW9ucyBtYXkgYmUgc3VibWl0dGVkLiBXaGVuXG4gKiBzdWJtaXR0aW5nIG11bHRpcGxlIGJhdGNoZXMgb2YgbXV0YXRpb25zIGF0IHRoZSBzYW1lIHRpbWUsIGl0J3NcbiAqIG9rYXkgdG8gdXNlIHRoZSBzYW1lIHN0cmVhbVRva2VuIGZvciB0aGUgY2FsbHMgdG8gd3JpdGVNdXRhdGlvbnMuXG4gKlxuICogVE9ETyhiLzMzMjcxMjM1KTogVXNlIHByb3RvIHR5cGVzXG4gKi9cbmNsYXNzIFBlcnNpc3RlbnRXcml0ZVN0cmVhbSBleHRlbmRzIFBlcnNpc3RlbnRTdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKHF1ZXVlLCBjb25uZWN0aW9uLCBhdXRoQ3JlZGVudGlhbHMsIGFwcENoZWNrQ3JlZGVudGlhbHMsIHNlcmlhbGl6ZXIsIGxpc3RlbmVyKSB7XG4gICAgICAgIHN1cGVyKHF1ZXVlLCBcIndyaXRlX3N0cmVhbV9jb25uZWN0aW9uX2JhY2tvZmZcIiAvKiBUaW1lcklkLldyaXRlU3RyZWFtQ29ubmVjdGlvbkJhY2tvZmYgKi8sIFwid3JpdGVfc3RyZWFtX2lkbGVcIiAvKiBUaW1lcklkLldyaXRlU3RyZWFtSWRsZSAqLywgXCJoZWFsdGhfY2hlY2tfdGltZW91dFwiIC8qIFRpbWVySWQuSGVhbHRoQ2hlY2tUaW1lb3V0ICovLCBjb25uZWN0aW9uLCBhdXRoQ3JlZGVudGlhbHMsIGFwcENoZWNrQ3JlZGVudGlhbHMsIGxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhY2tzIHdoZXRoZXIgb3Igbm90IGEgaGFuZHNoYWtlIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBleGNoYW5nZWQgYW5kXG4gICAgICogdGhlIHN0cmVhbSBpcyByZWFkeSB0byBhY2NlcHQgbXV0YXRpb25zLlxuICAgICAqL1xuICAgIGdldCBoYW5kc2hha2VDb21wbGV0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2VDb3VudCA+IDA7XG4gICAgfVxuICAgIC8vIE92ZXJyaWRlIG9mIFBlcnNpc3RlbnRTdHJlYW0uc3RhcnRcbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5sYXN0U3RyZWFtVG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIHN1cGVyLnN0YXJ0KCk7XG4gICAgfVxuICAgIHRlYXJEb3duKCkge1xuICAgICAgICBpZiAodGhpcy5oYW5kc2hha2VDb21wbGV0ZSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZU11dGF0aW9ucyhbXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRScGMoYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24ub3BlblN0cmVhbSgnV3JpdGUnLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xuICAgIH1cbiAgICBvbkZpcnN0KHJlc3BvbnNlUHJvdG8pIHtcbiAgICAgICAgLy8gQWx3YXlzIGNhcHR1cmUgdGhlIGxhc3Qgc3RyZWFtIHRva2VuLlxuICAgICAgICBoYXJkQXNzZXJ0KCEhcmVzcG9uc2VQcm90by5zdHJlYW1Ub2tlbik7XG4gICAgICAgIHRoaXMubGFzdFN0cmVhbVRva2VuID0gcmVzcG9uc2VQcm90by5zdHJlYW1Ub2tlbjtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHJlc3BvbnNlIGlzIGFsd2F5cyB0aGUgaGFuZHNoYWtlIHJlc3BvbnNlXG4gICAgICAgIGhhcmRBc3NlcnQoIXJlc3BvbnNlUHJvdG8ud3JpdGVSZXN1bHRzIHx8IHJlc3BvbnNlUHJvdG8ud3JpdGVSZXN1bHRzLmxlbmd0aCA9PT0gMCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLm9uSGFuZHNoYWtlQ29tcGxldGUoKTtcbiAgICB9XG4gICAgb25OZXh0KHJlc3BvbnNlUHJvdG8pIHtcbiAgICAgICAgLy8gQWx3YXlzIGNhcHR1cmUgdGhlIGxhc3Qgc3RyZWFtIHRva2VuLlxuICAgICAgICBoYXJkQXNzZXJ0KCEhcmVzcG9uc2VQcm90by5zdHJlYW1Ub2tlbik7XG4gICAgICAgIHRoaXMubGFzdFN0cmVhbVRva2VuID0gcmVzcG9uc2VQcm90by5zdHJlYW1Ub2tlbjtcbiAgICAgICAgLy8gQSBzdWNjZXNzZnVsIGZpcnN0IHdyaXRlIHJlc3BvbnNlIG1lYW5zIHRoZSBzdHJlYW0gaXMgaGVhbHRoeSxcbiAgICAgICAgLy8gTm90ZSwgdGhhdCB3ZSBjb3VsZCBjb25zaWRlciBhIHN1Y2Nlc3NmdWwgaGFuZHNoYWtlIGhlYWx0aHksIGhvd2V2ZXIsXG4gICAgICAgIC8vIHRoZSB3cml0ZSBpdHNlbGYgbWlnaHQgYmUgY2F1c2luZyBhbiBlcnJvciB3ZSB3YW50IHRvIGJhY2sgb2ZmIGZyb20uXG4gICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gZnJvbVdyaXRlUmVzdWx0cyhyZXNwb25zZVByb3RvLndyaXRlUmVzdWx0cywgcmVzcG9uc2VQcm90by5jb21taXRUaW1lKTtcbiAgICAgICAgY29uc3QgY29tbWl0VmVyc2lvbiA9IGZyb21WZXJzaW9uKHJlc3BvbnNlUHJvdG8uY29tbWl0VGltZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLm9uTXV0YXRpb25SZXN1bHQoY29tbWl0VmVyc2lvbiwgcmVzdWx0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGFuIGluaXRpYWwgc3RyZWFtVG9rZW4gdG8gdGhlIHNlcnZlciwgcGVyZm9ybWluZyB0aGUgaGFuZHNoYWtlXG4gICAgICogcmVxdWlyZWQgdG8gbWFrZSB0aGUgU3RyZWFtaW5nV3JpdGUgUlBDIHdvcmsuIFN1YnNlcXVlbnRcbiAgICAgKiBjYWxscyBzaG91bGQgd2FpdCB1bnRpbCBvbkhhbmRzaGFrZUNvbXBsZXRlIHdhcyBjYWxsZWQuXG4gICAgICovXG4gICAgd3JpdGVIYW5kc2hha2UoKSB7XG4gICAgICAgIC8vIFRPRE8oZGltb25kKTogU3VwcG9ydCBzdHJlYW0gcmVzdW1wdGlvbi4gV2UgaW50ZW50aW9uYWxseSBkbyBub3Qgc2V0IHRoZVxuICAgICAgICAvLyBzdHJlYW0gdG9rZW4gb24gdGhlIGhhbmRzaGFrZSwgaWdub3JpbmcgYW55IHN0cmVhbSB0b2tlbiB3ZSBtaWdodCBoYXZlLlxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge307XG4gICAgICAgIHJlcXVlc3QuZGF0YWJhc2UgPSBnZXRFbmNvZGVkRGF0YWJhc2VJZCh0aGlzLnNlcmlhbGl6ZXIpO1xuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KHJlcXVlc3QpO1xuICAgIH1cbiAgICAvKiogU2VuZHMgYSBncm91cCBvZiBtdXRhdGlvbnMgdG8gdGhlIEZpcmVzdG9yZSBiYWNrZW5kIHRvIGFwcGx5LiAqL1xuICAgIHdyaXRlTXV0YXRpb25zKG11dGF0aW9ucykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgc3RyZWFtVG9rZW46IHRoaXMubGFzdFN0cmVhbVRva2VuLFxuICAgICAgICAgICAgd3JpdGVzOiBtdXRhdGlvbnMubWFwKG11dGF0aW9uID0+IHRvTXV0YXRpb24odGhpcy5zZXJpYWxpemVyLCBtdXRhdGlvbikpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VuZFJlcXVlc3QocmVxdWVzdCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBEYXRhc3RvcmUgYW5kIGl0cyByZWxhdGVkIG1ldGhvZHMgYXJlIGEgd3JhcHBlciBhcm91bmQgdGhlIGV4dGVybmFsIEdvb2dsZVxuICogQ2xvdWQgRGF0YXN0b3JlIGdycGMgQVBJLCB3aGljaCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgdGhhdCBpcyBtb3JlIGNvbnZlbmllbnRcbiAqIGZvciB0aGUgcmVzdCBvZiB0aGUgY2xpZW50IFNESyBhcmNoaXRlY3R1cmUgdG8gY29uc3VtZS5cbiAqL1xuY2xhc3MgRGF0YXN0b3JlIHtcbn1cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgRGF0YXN0b3JlIHRoYXQgZXhwb3NlcyBhZGRpdGlvbmFsIHN0YXRlIGZvciBpbnRlcm5hbFxuICogY29uc3VtcHRpb24uXG4gKi9cbmNsYXNzIERhdGFzdG9yZUltcGwgZXh0ZW5kcyBEYXRhc3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKGF1dGhDcmVkZW50aWFscywgYXBwQ2hlY2tDcmVkZW50aWFscywgY29ubmVjdGlvbiwgc2VyaWFsaXplcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFscyA9IGF1dGhDcmVkZW50aWFscztcbiAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzID0gYXBwQ2hlY2tDcmVkZW50aWFscztcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcbiAgICAgICAgdGhpcy50ZXJtaW5hdGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHZlcmlmeUluaXRpYWxpemVkKCkge1xuICAgICAgICBpZiAodGhpcy50ZXJtaW5hdGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnVGhlIGNsaWVudCBoYXMgYWxyZWFkeSBiZWVuIHRlcm1pbmF0ZWQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEludm9rZXMgdGhlIHByb3ZpZGVkIFJQQyB3aXRoIGF1dGggYW5kIEFwcENoZWNrIHRva2Vucy4gKi9cbiAgICBpbnZva2VSUEMocnBjTmFtZSwgZGF0YWJhc2VJZCwgcmVzb3VyY2VQYXRoLCByZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMudmVyaWZ5SW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMuYXV0aENyZWRlbnRpYWxzLmdldFRva2VuKCksXG4gICAgICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHMuZ2V0VG9rZW4oKVxuICAgICAgICBdKVxuICAgICAgICAgICAgLnRoZW4oKFthdXRoVG9rZW4sIGFwcENoZWNrVG9rZW5dKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLmludm9rZVJQQyhycGNOYW1lLCB0b1Jlc291cmNlUGF0aChkYXRhYmFzZUlkLCByZXNvdXJjZVBhdGgpLCByZXF1ZXN0LCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdGaXJlYmFzZUVycm9yJykge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBDb2RlLlVOQVVUSEVOVElDQVRFRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFscy5pbnZhbGlkYXRlVG9rZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzLmludmFsaWRhdGVUb2tlbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLlVOS05PV04sIGVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEludm9rZXMgdGhlIHByb3ZpZGVkIFJQQyB3aXRoIHN0cmVhbWVkIHJlc3VsdHMgd2l0aCBhdXRoIGFuZCBBcHBDaGVjayB0b2tlbnMuICovXG4gICAgaW52b2tlU3RyZWFtaW5nUlBDKHJwY05hbWUsIGRhdGFiYXNlSWQsIHJlc291cmNlUGF0aCwgcmVxdWVzdCwgZXhwZWN0ZWRSZXNwb25zZUNvdW50KSB7XG4gICAgICAgIHRoaXMudmVyaWZ5SW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMuYXV0aENyZWRlbnRpYWxzLmdldFRva2VuKCksXG4gICAgICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHMuZ2V0VG9rZW4oKVxuICAgICAgICBdKVxuICAgICAgICAgICAgLnRoZW4oKFthdXRoVG9rZW4sIGFwcENoZWNrVG9rZW5dKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLmludm9rZVN0cmVhbWluZ1JQQyhycGNOYW1lLCB0b1Jlc291cmNlUGF0aChkYXRhYmFzZUlkLCByZXNvdXJjZVBhdGgpLCByZXF1ZXN0LCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4sIGV4cGVjdGVkUmVzcG9uc2VDb3VudCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0ZpcmViYXNlRXJyb3InKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IENvZGUuVU5BVVRIRU5USUNBVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0aENyZWRlbnRpYWxzLmludmFsaWRhdGVUb2tlbigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHMuaW52YWxpZGF0ZVRva2VuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5LTk9XTiwgZXJyb3IudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0ZXJtaW5hdGUoKSB7XG4gICAgICAgIHRoaXMudGVybWluYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi50ZXJtaW5hdGUoKTtcbiAgICB9XG59XG4vLyBUT0RPKGZpcmVzdG9yZXhwKTogTWFrZSBzdXJlIHRoZXJlIGlzIG9ubHkgb25lIERhdGFzdG9yZSBpbnN0YW5jZSBwZXJcbi8vIGZpcmVzdG9yZS1leHAgY2xpZW50LlxuZnVuY3Rpb24gbmV3RGF0YXN0b3JlKGF1dGhDcmVkZW50aWFscywgYXBwQ2hlY2tDcmVkZW50aWFscywgY29ubmVjdGlvbiwgc2VyaWFsaXplcikge1xuICAgIHJldHVybiBuZXcgRGF0YXN0b3JlSW1wbChhdXRoQ3JlZGVudGlhbHMsIGFwcENoZWNrQ3JlZGVudGlhbHMsIGNvbm5lY3Rpb24sIHNlcmlhbGl6ZXIpO1xufVxuYXN5bmMgZnVuY3Rpb24gaW52b2tlQ29tbWl0UnBjKGRhdGFzdG9yZSwgbXV0YXRpb25zKSB7XG4gICAgY29uc3QgZGF0YXN0b3JlSW1wbCA9IGRlYnVnQ2FzdChkYXRhc3RvcmUpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIHdyaXRlczogbXV0YXRpb25zLm1hcChtID0+IHRvTXV0YXRpb24oZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLCBtKSlcbiAgICB9O1xuICAgIGF3YWl0IGRhdGFzdG9yZUltcGwuaW52b2tlUlBDKCdDb21taXQnLCBkYXRhc3RvcmVJbXBsLnNlcmlhbGl6ZXIuZGF0YWJhc2VJZCwgUmVzb3VyY2VQYXRoLmVtcHR5UGF0aCgpLCByZXF1ZXN0KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGludm9rZUJhdGNoR2V0RG9jdW1lbnRzUnBjKGRhdGFzdG9yZSwga2V5cykge1xuICAgIGNvbnN0IGRhdGFzdG9yZUltcGwgPSBkZWJ1Z0Nhc3QoZGF0YXN0b3JlKTtcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICBkb2N1bWVudHM6IGtleXMubWFwKGsgPT4gdG9OYW1lKGRhdGFzdG9yZUltcGwuc2VyaWFsaXplciwgaykpXG4gICAgfTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGRhdGFzdG9yZUltcGwuaW52b2tlU3RyZWFtaW5nUlBDKCdCYXRjaEdldERvY3VtZW50cycsIGRhdGFzdG9yZUltcGwuc2VyaWFsaXplci5kYXRhYmFzZUlkLCBSZXNvdXJjZVBhdGguZW1wdHlQYXRoKCksIHJlcXVlc3QsIGtleXMubGVuZ3RoKTtcbiAgICBjb25zdCBkb2NzID0gbmV3IE1hcCgpO1xuICAgIHJlc3BvbnNlLmZvckVhY2gocHJvdG8gPT4ge1xuICAgICAgICBjb25zdCBkb2MgPSBmcm9tQmF0Y2hHZXREb2N1bWVudHNSZXNwb25zZShkYXRhc3RvcmVJbXBsLnNlcmlhbGl6ZXIsIHByb3RvKTtcbiAgICAgICAgZG9jcy5zZXQoZG9jLmtleS50b1N0cmluZygpLCBkb2MpO1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBjb25zdCBkb2MgPSBkb2NzLmdldChrZXkudG9TdHJpbmcoKSk7XG4gICAgICAgIGhhcmRBc3NlcnQoISFkb2MpO1xuICAgICAgICByZXN1bHQucHVzaChkb2MpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5hc3luYyBmdW5jdGlvbiBpbnZva2VSdW5BZ2dyZWdhdGlvblF1ZXJ5UnBjKGRhdGFzdG9yZSwgcXVlcnksIGFnZ3JlZ2F0ZXMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZGF0YXN0b3JlSW1wbCA9IGRlYnVnQ2FzdChkYXRhc3RvcmUpO1xuICAgIGNvbnN0IHsgcmVxdWVzdCwgYWxpYXNNYXAsIHBhcmVudCB9ID0gdG9SdW5BZ2dyZWdhdGlvblF1ZXJ5UmVxdWVzdChkYXRhc3RvcmVJbXBsLnNlcmlhbGl6ZXIsIHF1ZXJ5VG9BZ2dyZWdhdGVUYXJnZXQocXVlcnkpLCBhZ2dyZWdhdGVzKTtcbiAgICBpZiAoIWRhdGFzdG9yZUltcGwuY29ubmVjdGlvbi5zaG91bGRSZXNvdXJjZVBhdGhCZUluY2x1ZGVkSW5SZXF1ZXN0KSB7XG4gICAgICAgIGRlbGV0ZSByZXF1ZXN0LnBhcmVudDtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBkYXRhc3RvcmVJbXBsLmludm9rZVN0cmVhbWluZ1JQQygnUnVuQWdncmVnYXRpb25RdWVyeScsIGRhdGFzdG9yZUltcGwuc2VyaWFsaXplci5kYXRhYmFzZUlkLCBwYXJlbnQsIHJlcXVlc3QsIFxuICAgIC8qZXhwZWN0ZWRSZXNwb25zZUNvdW50PSovIDEpO1xuICAgIC8vIE9taXQgUnVuQWdncmVnYXRpb25RdWVyeVJlc3BvbnNlIHRoYXQgb25seSBjb250YWluIHJlYWRUaW1lcy5cbiAgICBjb25zdCBmaWx0ZXJlZFJlc3VsdCA9IHJlc3BvbnNlLmZpbHRlcihwcm90byA9PiAhIXByb3RvLnJlc3VsdCk7XG4gICAgaGFyZEFzc2VydChmaWx0ZXJlZFJlc3VsdC5sZW5ndGggPT09IDEpO1xuICAgIC8vIFJlbWFwIHRoZSBzaG9ydC1mb3JtIGFsaWFzZXMgdGhhdCB3ZXJlIHNlbnQgdG8gdGhlIHNlcnZlclxuICAgIC8vIHRvIHRoZSBjbGllbnQtc2lkZSBhbGlhc2VzLiBVc2VycyB3aWxsIGFjY2VzcyB0aGUgcmVzdWx0c1xuICAgIC8vIHVzaW5nIHRoZSBjbGllbnQtc2lkZSBhbGlhcy5cbiAgICBjb25zdCB1bm1hcHBlZEFnZ3JlZ2F0ZUZpZWxkcyA9IChfYSA9IGZpbHRlcmVkUmVzdWx0WzBdLnJlc3VsdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFnZ3JlZ2F0ZUZpZWxkcztcbiAgICBjb25zdCByZW1hcHBlZEZpZWxkcyA9IE9iamVjdC5rZXlzKHVubWFwcGVkQWdncmVnYXRlRmllbGRzKS5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBrZXkpID0+IHtcbiAgICAgICAgYWNjdW11bGF0b3JbYWxpYXNNYXBba2V5XV0gPSB1bm1hcHBlZEFnZ3JlZ2F0ZUZpZWxkc1trZXldO1xuICAgICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfSwge30pO1xuICAgIHJldHVybiByZW1hcHBlZEZpZWxkcztcbn1cbmZ1bmN0aW9uIG5ld1BlcnNpc3RlbnRXcml0ZVN0cmVhbShkYXRhc3RvcmUsIHF1ZXVlLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IGRhdGFzdG9yZUltcGwgPSBkZWJ1Z0Nhc3QoZGF0YXN0b3JlKTtcbiAgICBkYXRhc3RvcmVJbXBsLnZlcmlmeUluaXRpYWxpemVkKCk7XG4gICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW50V3JpdGVTdHJlYW0ocXVldWUsIGRhdGFzdG9yZUltcGwuY29ubmVjdGlvbiwgZGF0YXN0b3JlSW1wbC5hdXRoQ3JlZGVudGlhbHMsIGRhdGFzdG9yZUltcGwuYXBwQ2hlY2tDcmVkZW50aWFscywgZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLCBsaXN0ZW5lcik7XG59XG5mdW5jdGlvbiBuZXdQZXJzaXN0ZW50V2F0Y2hTdHJlYW0oZGF0YXN0b3JlLCBxdWV1ZSwgbGlzdGVuZXIpIHtcbiAgICBjb25zdCBkYXRhc3RvcmVJbXBsID0gZGVidWdDYXN0KGRhdGFzdG9yZSk7XG4gICAgZGF0YXN0b3JlSW1wbC52ZXJpZnlJbml0aWFsaXplZCgpO1xuICAgIHJldHVybiBuZXcgUGVyc2lzdGVudExpc3RlblN0cmVhbShxdWV1ZSwgZGF0YXN0b3JlSW1wbC5jb25uZWN0aW9uLCBkYXRhc3RvcmVJbXBsLmF1dGhDcmVkZW50aWFscywgZGF0YXN0b3JlSW1wbC5hcHBDaGVja0NyZWRlbnRpYWxzLCBkYXRhc3RvcmVJbXBsLnNlcmlhbGl6ZXIsIGxpc3RlbmVyKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IExPR19UQUckNiA9ICdPbmxpbmVTdGF0ZVRyYWNrZXInO1xuLy8gVG8gZGVhbCB3aXRoIHRyYW5zaWVudCBmYWlsdXJlcywgd2UgYWxsb3cgbXVsdGlwbGUgc3RyZWFtIGF0dGVtcHRzIGJlZm9yZVxuLy8gZ2l2aW5nIHVwIGFuZCB0cmFuc2l0aW9uaW5nIGZyb20gT25saW5lU3RhdGUuVW5rbm93biB0byBPZmZsaW5lLlxuLy8gVE9ETyhtaWtlbGVoZW4pOiBUaGlzIHVzZWQgdG8gYmUgc2V0IHRvIDIgYXMgYSBtaXRpZ2F0aW9uIGZvciBiLzY2MjI4Mzk0LlxuLy8gQGpkaW1vbmQgdGhpbmtzIHRoYXQgYnVnIGlzIHN1ZmZpY2llbnRseSBmaXhlZCBzbyB0aGF0IHdlIGNhbiBzZXQgdGhpcyBiYWNrXG4vLyB0byAxLiBJZiB0aGF0IHdvcmtzIG9rYXksIHdlIGNvdWxkIHBvdGVudGlhbGx5IHJlbW92ZSB0aGlzIGxvZ2ljIGVudGlyZWx5LlxuY29uc3QgTUFYX1dBVENIX1NUUkVBTV9GQUlMVVJFUyA9IDE7XG4vLyBUbyBkZWFsIHdpdGggc3RyZWFtIGF0dGVtcHRzIHRoYXQgZG9uJ3Qgc3VjY2VlZCBvciBmYWlsIGluIGEgdGltZWx5IG1hbm5lcixcbi8vIHdlIGhhdmUgYSB0aW1lb3V0IGZvciBPbmxpbmVTdGF0ZSB0byByZWFjaCBPbmxpbmUgb3IgT2ZmbGluZS5cbi8vIElmIHRoZSB0aW1lb3V0IGlzIHJlYWNoZWQsIHdlIHRyYW5zaXRpb24gdG8gT2ZmbGluZSByYXRoZXIgdGhhbiB3YWl0aW5nXG4vLyBpbmRlZmluaXRlbHkuXG5jb25zdCBPTkxJTkVfU1RBVEVfVElNRU9VVF9NUyA9IDEwICogMTAwMDtcbi8qKlxuICogQSBjb21wb25lbnQgdXNlZCBieSB0aGUgUmVtb3RlU3RvcmUgdG8gdHJhY2sgdGhlIE9ubGluZVN0YXRlICh0aGF0IGlzLFxuICogd2hldGhlciBvciBub3QgdGhlIGNsaWVudCBhcyBhIHdob2xlIHNob3VsZCBiZSBjb25zaWRlcmVkIHRvIGJlIG9ubGluZSBvclxuICogb2ZmbGluZSksIGltcGxlbWVudGluZyB0aGUgYXBwcm9wcmlhdGUgaGV1cmlzdGljcy5cbiAqXG4gKiBJbiBwYXJ0aWN1bGFyLCB3aGVuIHRoZSBjbGllbnQgaXMgdHJ5aW5nIHRvIGNvbm5lY3QgdG8gdGhlIGJhY2tlbmQsIHdlXG4gKiBhbGxvdyB1cCB0byBNQVhfV0FUQ0hfU1RSRUFNX0ZBSUxVUkVTIHdpdGhpbiBPTkxJTkVfU1RBVEVfVElNRU9VVF9NUyBmb3JcbiAqIGEgY29ubmVjdGlvbiB0byBzdWNjZWVkLiBJZiB3ZSBoYXZlIHRvbyBtYW55IGZhaWx1cmVzIG9yIHRoZSB0aW1lb3V0IGVsYXBzZXMsXG4gKiB0aGVuIHdlIHNldCB0aGUgT25saW5lU3RhdGUgdG8gT2ZmbGluZSwgYW5kIHRoZSBjbGllbnQgd2lsbCBiZWhhdmUgYXMgaWZcbiAqIGl0IGlzIG9mZmxpbmUgKGdldCgpcyB3aWxsIHJldHVybiBjYWNoZWQgZGF0YSwgZXRjLikuXG4gKi9cbmNsYXNzIE9ubGluZVN0YXRlVHJhY2tlciB7XG4gICAgY29uc3RydWN0b3IoYXN5bmNRdWV1ZSwgb25saW5lU3RhdGVIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuYXN5bmNRdWV1ZSA9IGFzeW5jUXVldWU7XG4gICAgICAgIHRoaXMub25saW5lU3RhdGVIYW5kbGVyID0gb25saW5lU3RhdGVIYW5kbGVyO1xuICAgICAgICAvKiogVGhlIGN1cnJlbnQgT25saW5lU3RhdGUuICovXG4gICAgICAgIHRoaXMuc3RhdGUgPSBcIlVua25vd25cIiAvKiBPbmxpbmVTdGF0ZS5Vbmtub3duICovO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBjb3VudCBvZiBjb25zZWN1dGl2ZSBmYWlsdXJlcyB0byBvcGVuIHRoZSBzdHJlYW0uIElmIGl0IHJlYWNoZXMgdGhlXG4gICAgICAgICAqIG1heGltdW0gZGVmaW5lZCBieSBNQVhfV0FUQ0hfU1RSRUFNX0ZBSUxVUkVTLCB3ZSdsbCBzZXQgdGhlIE9ubGluZVN0YXRlIHRvXG4gICAgICAgICAqIE9mZmxpbmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndhdGNoU3RyZWFtRmFpbHVyZXMgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSB0aW1lciB0aGF0IGVsYXBzZXMgYWZ0ZXIgT05MSU5FX1NUQVRFX1RJTUVPVVRfTVMsIGF0IHdoaWNoIHBvaW50IHdlXG4gICAgICAgICAqIHRyYW5zaXRpb24gZnJvbSBPbmxpbmVTdGF0ZS5Vbmtub3duIHRvIE9ubGluZVN0YXRlLk9mZmxpbmUgd2l0aG91dCB3YWl0aW5nXG4gICAgICAgICAqIGZvciB0aGUgc3RyZWFtIHRvIGFjdHVhbGx5IGZhaWwgKE1BWF9XQVRDSF9TVFJFQU1fRkFJTFVSRVMgdGltZXMpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZVRpbWVyID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGNsaWVudCBzaG91bGQgbG9nIGEgd2FybmluZyBtZXNzYWdlIGlmIGl0IGZhaWxzIHRvIGNvbm5lY3QgdG9cbiAgICAgICAgICogdGhlIGJhY2tlbmQgKGluaXRpYWxseSB0cnVlLCBjbGVhcmVkIGFmdGVyIGEgc3VjY2Vzc2Z1bCBzdHJlYW0sIG9yIGlmIHdlJ3ZlXG4gICAgICAgICAqIGxvZ2dlZCB0aGUgbWVzc2FnZSBhbHJlYWR5KS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2hvdWxkV2FybkNsaWVudElzT2ZmbGluZSA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCBieSBSZW1vdGVTdG9yZSB3aGVuIGEgd2F0Y2ggc3RyZWFtIGlzIHN0YXJ0ZWQgKGluY2x1ZGluZyBvbiBlYWNoXG4gICAgICogYmFja29mZiBhdHRlbXB0KS5cbiAgICAgKlxuICAgICAqIElmIHRoaXMgaXMgdGhlIGZpcnN0IGF0dGVtcHQsIGl0IHNldHMgdGhlIE9ubGluZVN0YXRlIHRvIFVua25vd24gYW5kIHN0YXJ0c1xuICAgICAqIHRoZSBvbmxpbmVTdGF0ZVRpbWVyLlxuICAgICAqL1xuICAgIGhhbmRsZVdhdGNoU3RyZWFtU3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLndhdGNoU3RyZWFtRmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QW5kQnJvYWRjYXN0KFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi8pO1xuICAgICAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZVRpbWVyID0gdGhpcy5hc3luY1F1ZXVlLmVucXVldWVBZnRlckRlbGF5KFwib25saW5lX3N0YXRlX3RpbWVvdXRcIiAvKiBUaW1lcklkLk9ubGluZVN0YXRlVGltZW91dCAqLywgT05MSU5FX1NUQVRFX1RJTUVPVVRfTVMsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9ubGluZVN0YXRlVGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nQ2xpZW50T2ZmbGluZVdhcm5pbmdJZk5lY2Vzc2FyeShgQmFja2VuZCBkaWRuJ3QgcmVzcG9uZCB3aXRoaW4gJHtPTkxJTkVfU1RBVEVfVElNRU9VVF9NUyAvIDEwMDB9IGAgK1xuICAgICAgICAgICAgICAgICAgICBgc2Vjb25kcy5gKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEFuZEJyb2FkY2FzdChcIk9mZmxpbmVcIiAvKiBPbmxpbmVTdGF0ZS5PZmZsaW5lICovKTtcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBoYW5kbGVXYXRjaFN0cmVhbUZhaWx1cmUoKSB3aWxsIGNvbnRpbnVlIHRvIGluY3JlbWVudFxuICAgICAgICAgICAgICAgIC8vIHdhdGNoU3RyZWFtRmFpbHVyZXMgZXZlbiB0aG91Z2ggd2UgYXJlIGFscmVhZHkgbWFya2VkIE9mZmxpbmUsXG4gICAgICAgICAgICAgICAgLy8gYnV0IHRoaXMgaXMgbm9uLWhhcm1mdWwuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBvdXIgT25saW5lU3RhdGUgYXMgYXBwcm9wcmlhdGUgYWZ0ZXIgdGhlIHdhdGNoIHN0cmVhbSByZXBvcnRzIGFcbiAgICAgKiBmYWlsdXJlLiBUaGUgZmlyc3QgZmFpbHVyZSBtb3ZlcyB1cyB0byB0aGUgJ1Vua25vd24nIHN0YXRlLiBXZSB0aGVuIG1heVxuICAgICAqIGFsbG93IG11bHRpcGxlIGZhaWx1cmVzIChiYXNlZCBvbiBNQVhfV0FUQ0hfU1RSRUFNX0ZBSUxVUkVTKSBiZWZvcmUgd2VcbiAgICAgKiBhY3R1YWxseSB0cmFuc2l0aW9uIHRvIHRoZSAnT2ZmbGluZScgc3RhdGUuXG4gICAgICovXG4gICAgaGFuZGxlV2F0Y2hTdHJlYW1GYWlsdXJlKGVycm9yKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBcIk9ubGluZVwiIC8qIE9ubGluZVN0YXRlLk9ubGluZSAqLykge1xuICAgICAgICAgICAgdGhpcy5zZXRBbmRCcm9hZGNhc3QoXCJVbmtub3duXCIgLyogT25saW5lU3RhdGUuVW5rbm93biAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndhdGNoU3RyZWFtRmFpbHVyZXMrKztcbiAgICAgICAgICAgIGlmICh0aGlzLndhdGNoU3RyZWFtRmFpbHVyZXMgPj0gTUFYX1dBVENIX1NUUkVBTV9GQUlMVVJFUykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJPbmxpbmVTdGF0ZVRpbWVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dDbGllbnRPZmZsaW5lV2FybmluZ0lmTmVjZXNzYXJ5KGBDb25uZWN0aW9uIGZhaWxlZCAke01BWF9XQVRDSF9TVFJFQU1fRkFJTFVSRVN9IGAgK1xuICAgICAgICAgICAgICAgICAgICBgdGltZXMuIE1vc3QgcmVjZW50IGVycm9yOiAke2Vycm9yLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBbmRCcm9hZGNhc3QoXCJPZmZsaW5lXCIgLyogT25saW5lU3RhdGUuT2ZmbGluZSAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwbGljaXRseSBzZXRzIHRoZSBPbmxpbmVTdGF0ZSB0byB0aGUgc3BlY2lmaWVkIHN0YXRlLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgcmVzZXRzIG91ciB0aW1lcnMgLyBmYWlsdXJlIGNvdW50ZXJzLCBldGMuIHVzZWQgYnkgb3VyXG4gICAgICogT2ZmbGluZSBoZXVyaXN0aWNzLCBzbyBtdXN0IG5vdCBiZSB1c2VkIGluIHBsYWNlIG9mXG4gICAgICogaGFuZGxlV2F0Y2hTdHJlYW1TdGFydCgpIGFuZCBoYW5kbGVXYXRjaFN0cmVhbUZhaWx1cmUoKS5cbiAgICAgKi9cbiAgICBzZXQobmV3U3RhdGUpIHtcbiAgICAgICAgdGhpcy5jbGVhck9ubGluZVN0YXRlVGltZXIoKTtcbiAgICAgICAgdGhpcy53YXRjaFN0cmVhbUZhaWx1cmVzID0gMDtcbiAgICAgICAgaWYgKG5ld1N0YXRlID09PSBcIk9ubGluZVwiIC8qIE9ubGluZVN0YXRlLk9ubGluZSAqLykge1xuICAgICAgICAgICAgLy8gV2UndmUgY29ubmVjdGVkIHRvIHdhdGNoIGF0IGxlYXN0IG9uY2UuIERvbid0IHdhcm4gdGhlIGRldmVsb3BlclxuICAgICAgICAgICAgLy8gYWJvdXQgYmVpbmcgb2ZmbGluZSBnb2luZyBmb3J3YXJkLlxuICAgICAgICAgICAgdGhpcy5zaG91bGRXYXJuQ2xpZW50SXNPZmZsaW5lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRBbmRCcm9hZGNhc3QobmV3U3RhdGUpO1xuICAgIH1cbiAgICBzZXRBbmRCcm9hZGNhc3QobmV3U3RhdGUpIHtcbiAgICAgICAgaWYgKG5ld1N0YXRlICE9PSB0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgICAgICB0aGlzLm9ubGluZVN0YXRlSGFuZGxlcihuZXdTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9nQ2xpZW50T2ZmbGluZVdhcm5pbmdJZk5lY2Vzc2FyeShkZXRhaWxzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgQ291bGQgbm90IHJlYWNoIENsb3VkIEZpcmVzdG9yZSBiYWNrZW5kLiAke2RldGFpbHN9XFxuYCArXG4gICAgICAgICAgICBgVGhpcyB0eXBpY2FsbHkgaW5kaWNhdGVzIHRoYXQgeW91ciBkZXZpY2UgZG9lcyBub3QgaGF2ZSBhIGhlYWx0aHkgYCArXG4gICAgICAgICAgICBgSW50ZXJuZXQgY29ubmVjdGlvbiBhdCB0aGUgbW9tZW50LiBUaGUgY2xpZW50IHdpbGwgb3BlcmF0ZSBpbiBvZmZsaW5lIGAgK1xuICAgICAgICAgICAgYG1vZGUgdW50aWwgaXQgaXMgYWJsZSB0byBzdWNjZXNzZnVsbHkgY29ubmVjdCB0byB0aGUgYmFja2VuZC5gO1xuICAgICAgICBpZiAodGhpcy5zaG91bGRXYXJuQ2xpZW50SXNPZmZsaW5lKSB7XG4gICAgICAgICAgICBsb2dFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkV2FybkNsaWVudElzT2ZmbGluZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ2LCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhck9ubGluZVN0YXRlVGltZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLm9ubGluZVN0YXRlVGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMub25saW5lU3RhdGVUaW1lci5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMub25saW5lU3RhdGVUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBMT0dfVEFHJDUgPSAnUmVtb3RlU3RvcmUnO1xuLy8gVE9ETyhiLzM1ODUzNDAyKTogTmVnb3RpYXRlIHRoaXMgd2l0aCB0aGUgc3RyZWFtLlxuY29uc3QgTUFYX1BFTkRJTkdfV1JJVEVTID0gMTA7XG5jbGFzcyBSZW1vdGVTdG9yZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIFRoZSBsb2NhbCBzdG9yZSwgdXNlZCB0byBmaWxsIHRoZSB3cml0ZSBwaXBlbGluZSB3aXRoIG91dGJvdW5kIG11dGF0aW9ucy5cbiAgICAgKi9cbiAgICBsb2NhbFN0b3JlLCBcbiAgICAvKiogVGhlIGNsaWVudC1zaWRlIHByb3h5IGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBiYWNrZW5kLiAqL1xuICAgIGRhdGFzdG9yZSwgYXN5bmNRdWV1ZSwgb25saW5lU3RhdGVIYW5kbGVyLCBjb25uZWN0aXZpdHlNb25pdG9yKSB7XG4gICAgICAgIHRoaXMubG9jYWxTdG9yZSA9IGxvY2FsU3RvcmU7XG4gICAgICAgIHRoaXMuZGF0YXN0b3JlID0gZGF0YXN0b3JlO1xuICAgICAgICB0aGlzLmFzeW5jUXVldWUgPSBhc3luY1F1ZXVlO1xuICAgICAgICB0aGlzLnJlbW90ZVN5bmNlciA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIHVwIHRvIE1BWF9QRU5ESU5HX1dSSVRFUyB3cml0ZXMgdGhhdCB3ZSBoYXZlIGZldGNoZWQgZnJvbSB0aGVcbiAgICAgICAgICogTG9jYWxTdG9yZSB2aWEgZmlsbFdyaXRlUGlwZWxpbmUoKSBhbmQgaGF2ZSBvciB3aWxsIHNlbmQgdG8gdGhlIHdyaXRlXG4gICAgICAgICAqIHN0cmVhbS5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbmV2ZXIgd3JpdGVQaXBlbGluZS5sZW5ndGggPiAwIHRoZSBSZW1vdGVTdG9yZSB3aWxsIGF0dGVtcHQgdG8gc3RhcnQgb3JcbiAgICAgICAgICogcmVzdGFydCB0aGUgd3JpdGUgc3RyZWFtLiBXaGVuIHRoZSBzdHJlYW0gaXMgZXN0YWJsaXNoZWQgdGhlIHdyaXRlcyBpbiB0aGVcbiAgICAgICAgICogcGlwZWxpbmUgd2lsbCBiZSBzZW50IGluIG9yZGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXcml0ZXMgcmVtYWluIGluIHdyaXRlUGlwZWxpbmUgdW50aWwgdGhleSBhcmUgYWNrbm93bGVkZ2VkIGJ5IHRoZSBiYWNrZW5kXG4gICAgICAgICAqIGFuZCB0aHVzIHdpbGwgYXV0b21hdGljYWxseSBiZSByZS1zZW50IGlmIHRoZSBzdHJlYW0gaXMgaW50ZXJydXB0ZWQgL1xuICAgICAgICAgKiByZXN0YXJ0ZWQgYmVmb3JlIHRoZXkncmUgYWNrbm93bGVkZ2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXcml0ZSByZXNwb25zZXMgZnJvbSB0aGUgYmFja2VuZCBhcmUgbGlua2VkIHRvIHRoZWlyIG9yaWdpbmF0aW5nIHJlcXVlc3RcbiAgICAgICAgICogcHVyZWx5IGJhc2VkIG9uIG9yZGVyLCBhbmQgc28gd2UgY2FuIGp1c3Qgc2hpZnQoKSB3cml0ZXMgZnJvbSB0aGUgZnJvbnQgb2ZcbiAgICAgICAgICogdGhlIHdyaXRlUGlwZWxpbmUgYXMgd2UgcmVjZWl2ZSByZXNwb25zZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndyaXRlUGlwZWxpbmUgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWFwcGluZyBvZiB3YXRjaGVkIHRhcmdldHMgdGhhdCB0aGUgY2xpZW50IGNhcmVzIGFib3V0IHRyYWNraW5nIGFuZCB0aGVcbiAgICAgICAgICogdXNlciBoYXMgZXhwbGljaXRseSBjYWxsZWQgYSAnbGlzdGVuJyBmb3IgdGhpcyB0YXJnZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZXNlIHRhcmdldHMgbWF5IG9yIG1heSBub3QgaGF2ZSBiZWVuIHNlbnQgdG8gb3IgYWNrbm93bGVkZ2VkIGJ5IHRoZVxuICAgICAgICAgKiBzZXJ2ZXIuIE9uIHJlLWVzdGFibGlzaGluZyB0aGUgbGlzdGVuIHN0cmVhbSwgdGhlc2UgdGFyZ2V0cyBzaG91bGQgYmUgc2VudFxuICAgICAgICAgKiB0byB0aGUgc2VydmVyLiBUaGUgdGFyZ2V0cyByZW1vdmVkIHdpdGggdW5saXN0ZW5zIGFyZSByZW1vdmVkIGVhZ2VybHlcbiAgICAgICAgICogd2l0aG91dCB3YWl0aW5nIGZvciBjb25maXJtYXRpb24gZnJvbSB0aGUgbGlzdGVuIHN0cmVhbS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGlzdGVuVGFyZ2V0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2V0IG9mIHJlYXNvbnMgZm9yIHdoeSB0aGUgUmVtb3RlU3RvcmUgbWF5IGJlIG9mZmxpbmUuIElmIGVtcHR5LCB0aGVcbiAgICAgICAgICogUmVtb3RlU3RvcmUgbWF5IHN0YXJ0IGl0cyBuZXR3b3JrIGNvbm5lY3Rpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vZmZsaW5lQ2F1c2VzID0gbmV3IFNldCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgaGFuZGxlcnMgdGhhdCBnZXQgY2FsbGVkIHdoZW4gdGhlIG5ldHdvcmsgaXMgZGlzYWJsZWQgb3IgZW5hYmxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogUE9SVElORyBOT1RFOiBUaGVzZSBmdW5jdGlvbnMgYXJlIHVzZWQgb24gdGhlIFdlYiBjbGllbnQgdG8gY3JlYXRlIHRoZVxuICAgICAgICAgKiB1bmRlcmx5aW5nIHN0cmVhbXMgKHRvIHN1cHBvcnQgdHJlZS1zaGFrZWFibGUgc3RyZWFtcykuIE9uIEFuZHJvaWQgYW5kIGlPUyxcbiAgICAgICAgICogdGhlIHN0cmVhbXMgYXJlIGNyZWF0ZWQgZHVyaW5nIGNvbnN0cnVjdGlvbiBvZiBSZW1vdGVTdG9yZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25OZXR3b3JrU3RhdHVzQ2hhbmdlID0gW107XG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5TW9uaXRvciA9IGNvbm5lY3Rpdml0eU1vbml0b3I7XG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5TW9uaXRvci5hZGRDYWxsYmFjaygoXykgPT4ge1xuICAgICAgICAgICAgYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBQb3J0aW5nIE5vdGU6IFVubGlrZSBpT1MsIGByZXN0YXJ0TmV0d29yaygpYCBpcyBjYWxsZWQgZXZlbiB3aGVuIHRoZVxuICAgICAgICAgICAgICAgIC8vIG5ldHdvcmsgYmVjb21lcyB1bnJlYWNoYWJsZSBhcyB3ZSBkb24ndCBoYXZlIGFueSBvdGhlciB3YXkgdG8gdGVhclxuICAgICAgICAgICAgICAgIC8vIGRvd24gb3VyIHN0cmVhbXMuXG4gICAgICAgICAgICAgICAgaWYgKGNhblVzZU5ldHdvcmsodGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ1LCAnUmVzdGFydGluZyBzdHJlYW1zIGZvciBuZXR3b3JrIHJlYWNoYWJpbGl0eSBjaGFuZ2UuJyk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlc3RhcnROZXR3b3JrKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZVRyYWNrZXIgPSBuZXcgT25saW5lU3RhdGVUcmFja2VyKGFzeW5jUXVldWUsIG9ubGluZVN0YXRlSGFuZGxlcik7XG4gICAgfVxufVxuZnVuY3Rpb24gbmV3UmVtb3RlU3RvcmUobG9jYWxTdG9yZSwgZGF0YXN0b3JlLCBhc3luY1F1ZXVlLCBvbmxpbmVTdGF0ZUhhbmRsZXIsIGNvbm5lY3Rpdml0eU1vbml0b3IpIHtcbiAgICByZXR1cm4gbmV3IFJlbW90ZVN0b3JlSW1wbChsb2NhbFN0b3JlLCBkYXRhc3RvcmUsIGFzeW5jUXVldWUsIG9ubGluZVN0YXRlSGFuZGxlciwgY29ubmVjdGl2aXR5TW9uaXRvcik7XG59XG4vKiogUmUtZW5hYmxlcyB0aGUgbmV0d29yay4gSWRlbXBvdGVudC4gKi9cbmZ1bmN0aW9uIHJlbW90ZVN0b3JlRW5hYmxlTmV0d29yayhyZW1vdGVTdG9yZSkge1xuICAgIGNvbnN0IHJlbW90ZVN0b3JlSW1wbCA9IGRlYnVnQ2FzdChyZW1vdGVTdG9yZSk7XG4gICAgcmVtb3RlU3RvcmVJbXBsLm9mZmxpbmVDYXVzZXMuZGVsZXRlKDAgLyogT2ZmbGluZUNhdXNlLlVzZXJEaXNhYmxlZCAqLyk7XG4gICAgcmV0dXJuIGVuYWJsZU5ldHdvcmtJbnRlcm5hbChyZW1vdGVTdG9yZUltcGwpO1xufVxuYXN5bmMgZnVuY3Rpb24gZW5hYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCkge1xuICAgIGlmIChjYW5Vc2VOZXR3b3JrKHJlbW90ZVN0b3JlSW1wbCkpIHtcbiAgICAgICAgZm9yIChjb25zdCBuZXR3b3JrU3RhdHVzSGFuZGxlciBvZiByZW1vdGVTdG9yZUltcGwub25OZXR3b3JrU3RhdHVzQ2hhbmdlKSB7XG4gICAgICAgICAgICBhd2FpdCBuZXR3b3JrU3RhdHVzSGFuZGxlcigvKiBlbmFibGVkPSAqLyB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogVGVtcG9yYXJpbHkgZGlzYWJsZXMgdGhlIG5ldHdvcmsuIFRoZSBuZXR3b3JrIGNhbiBiZSByZS1lbmFibGVkIHVzaW5nXG4gKiBlbmFibGVOZXR3b3JrKCkuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlbW90ZVN0b3JlRGlzYWJsZU5ldHdvcmsocmVtb3RlU3RvcmUpIHtcbiAgICBjb25zdCByZW1vdGVTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlU3RvcmUpO1xuICAgIHJlbW90ZVN0b3JlSW1wbC5vZmZsaW5lQ2F1c2VzLmFkZCgwIC8qIE9mZmxpbmVDYXVzZS5Vc2VyRGlzYWJsZWQgKi8pO1xuICAgIGF3YWl0IGRpc2FibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAvLyBTZXQgdGhlIE9ubGluZVN0YXRlIHRvIE9mZmxpbmUgc28gZ2V0KClzIHJldHVybiBmcm9tIGNhY2hlLCBldGMuXG4gICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5zZXQoXCJPZmZsaW5lXCIgLyogT25saW5lU3RhdGUuT2ZmbGluZSAqLyk7XG59XG5hc3luYyBmdW5jdGlvbiBkaXNhYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCkge1xuICAgIGZvciAoY29uc3QgbmV0d29ya1N0YXR1c0hhbmRsZXIgb2YgcmVtb3RlU3RvcmVJbXBsLm9uTmV0d29ya1N0YXR1c0NoYW5nZSkge1xuICAgICAgICBhd2FpdCBuZXR3b3JrU3RhdHVzSGFuZGxlcigvKiBlbmFibGVkPSAqLyBmYWxzZSk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcmVtb3RlU3RvcmVTaHV0ZG93bihyZW1vdGVTdG9yZSkge1xuICAgIGNvbnN0IHJlbW90ZVN0b3JlSW1wbCA9IGRlYnVnQ2FzdChyZW1vdGVTdG9yZSk7XG4gICAgbG9nRGVidWcoTE9HX1RBRyQ1LCAnUmVtb3RlU3RvcmUgc2h1dHRpbmcgZG93bi4nKTtcbiAgICByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5hZGQoNSAvKiBPZmZsaW5lQ2F1c2UuU2h1dGRvd24gKi8pO1xuICAgIGF3YWl0IGRpc2FibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcbiAgICByZW1vdGVTdG9yZUltcGwuY29ubmVjdGl2aXR5TW9uaXRvci5zaHV0ZG93bigpO1xuICAgIC8vIFNldCB0aGUgT25saW5lU3RhdGUgdG8gVW5rbm93biAocmF0aGVyIHRoYW4gT2ZmbGluZSkgdG8gYXZvaWQgcG90ZW50aWFsbHlcbiAgICAvLyB0cmlnZ2VyaW5nIHNwdXJpb3VzIGxpc3RlbmVyIGV2ZW50cyB3aXRoIGNhY2hlZCBkYXRhLCBldGMuXG4gICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5zZXQoXCJVbmtub3duXCIgLyogT25saW5lU3RhdGUuVW5rbm93biAqLyk7XG59XG4vKipcbiAqIFN0YXJ0cyBuZXcgbGlzdGVuIGZvciB0aGUgZ2l2ZW4gdGFyZ2V0LiBVc2VzIHJlc3VtZSB0b2tlbiBpZiBwcm92aWRlZC4gSXRcbiAqIGlzIGEgbm8tb3AgaWYgdGhlIHRhcmdldCBvZiBnaXZlbiBgVGFyZ2V0RGF0YWAgaXMgYWxyZWFkeSBiZWluZyBsaXN0ZW5lZCB0by5cbiAqL1xuZnVuY3Rpb24gcmVtb3RlU3RvcmVMaXN0ZW4ocmVtb3RlU3RvcmUsIHRhcmdldERhdGEpIHtcbiAgICBjb25zdCByZW1vdGVTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlU3RvcmUpO1xuICAgIGlmIChyZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5oYXModGFyZ2V0RGF0YS50YXJnZXRJZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBNYXJrIHRoaXMgYXMgc29tZXRoaW5nIHRoZSBjbGllbnQgaXMgY3VycmVudGx5IGxpc3RlbmluZyBmb3IuXG4gICAgcmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuc2V0KHRhcmdldERhdGEudGFyZ2V0SWQsIHRhcmdldERhdGEpO1xuICAgIGlmIChzaG91bGRTdGFydFdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkpIHtcbiAgICAgICAgLy8gVGhlIGxpc3RlbiB3aWxsIGJlIHNlbnQgaW4gb25XYXRjaFN0cmVhbU9wZW5cbiAgICAgICAgc3RhcnRXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpO1xuICAgIH1cbiAgICBlbHNlIGlmIChlbnN1cmVXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpLmlzT3BlbigpKSB7XG4gICAgICAgIHNlbmRXYXRjaFJlcXVlc3QocmVtb3RlU3RvcmVJbXBsLCB0YXJnZXREYXRhKTtcbiAgICB9XG59XG4vKipcbiAqIFJlbW92ZXMgdGhlIGxpc3RlbiBmcm9tIHNlcnZlci4gSXQgaXMgYSBuby1vcCBpZiB0aGUgZ2l2ZW4gdGFyZ2V0IGlkIGlzXG4gKiBub3QgYmVpbmcgbGlzdGVuZWQgdG8uXG4gKi9cbmZ1bmN0aW9uIHJlbW90ZVN0b3JlVW5saXN0ZW4ocmVtb3RlU3RvcmUsIHRhcmdldElkKSB7XG4gICAgY29uc3QgcmVtb3RlU3RvcmVJbXBsID0gZGVidWdDYXN0KHJlbW90ZVN0b3JlKTtcbiAgICBjb25zdCB3YXRjaFN0cmVhbSA9IGVuc3VyZVdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCk7XG4gICAgcmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuZGVsZXRlKHRhcmdldElkKTtcbiAgICBpZiAod2F0Y2hTdHJlYW0uaXNPcGVuKCkpIHtcbiAgICAgICAgc2VuZFVud2F0Y2hSZXF1ZXN0KHJlbW90ZVN0b3JlSW1wbCwgdGFyZ2V0SWQpO1xuICAgIH1cbiAgICBpZiAocmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBpZiAod2F0Y2hTdHJlYW0uaXNPcGVuKCkpIHtcbiAgICAgICAgICAgIHdhdGNoU3RyZWFtLm1hcmtJZGxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2FuVXNlTmV0d29yayhyZW1vdGVTdG9yZUltcGwpKSB7XG4gICAgICAgICAgICAvLyBSZXZlcnQgdG8gT25saW5lU3RhdGUuVW5rbm93biBpZiB0aGUgd2F0Y2ggc3RyZWFtIGlzIG5vdCBvcGVuIGFuZCB3ZVxuICAgICAgICAgICAgLy8gaGF2ZSBubyBsaXN0ZW5lcnMsIHNpbmNlIHdpdGhvdXQgYW55IGxpc3RlbnMgdG8gc2VuZCB3ZSBjYW5ub3RcbiAgICAgICAgICAgIC8vIGNvbmZpcm0gaWYgdGhlIHN0cmVhbSBpcyBoZWFsdGh5IGFuZCB1cGdyYWRlIHRvIE9ubGluZVN0YXRlLk9ubGluZS5cbiAgICAgICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi8pO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBXZSBuZWVkIHRvIGluY3JlbWVudCB0aGUgZXhwZWN0ZWQgbnVtYmVyIG9mIHBlbmRpbmcgcmVzcG9uc2VzIHdlJ3JlIGR1ZVxuICogZnJvbSB3YXRjaCBzbyB3ZSB3YWl0IGZvciB0aGUgYWNrIHRvIHByb2Nlc3MgYW55IG1lc3NhZ2VzIGZyb20gdGhpcyB0YXJnZXQuXG4gKi9cbmZ1bmN0aW9uIHNlbmRXYXRjaFJlcXVlc3QocmVtb3RlU3RvcmVJbXBsLCB0YXJnZXREYXRhKSB7XG4gICAgcmVtb3RlU3RvcmVJbXBsLndhdGNoQ2hhbmdlQWdncmVnYXRvci5yZWNvcmRQZW5kaW5nVGFyZ2V0UmVxdWVzdCh0YXJnZXREYXRhLnRhcmdldElkKTtcbiAgICBpZiAodGFyZ2V0RGF0YS5yZXN1bWVUb2tlbi5hcHByb3hpbWF0ZUJ5dGVTaXplKCkgPiAwIHx8XG4gICAgICAgIHRhcmdldERhdGEuc25hcHNob3RWZXJzaW9uLmNvbXBhcmVUbyhTbmFwc2hvdFZlcnNpb24ubWluKCkpID4gMCkge1xuICAgICAgICBjb25zdCBleHBlY3RlZENvdW50ID0gcmVtb3RlU3RvcmVJbXBsLnJlbW90ZVN5bmNlci5nZXRSZW1vdGVLZXlzRm9yVGFyZ2V0KHRhcmdldERhdGEudGFyZ2V0SWQpLnNpemU7XG4gICAgICAgIHRhcmdldERhdGEgPSB0YXJnZXREYXRhLndpdGhFeHBlY3RlZENvdW50KGV4cGVjdGVkQ291bnQpO1xuICAgIH1cbiAgICBlbnN1cmVXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpLndhdGNoKHRhcmdldERhdGEpO1xufVxuLyoqXG4gKiBXZSBuZWVkIHRvIGluY3JlbWVudCB0aGUgZXhwZWN0ZWQgbnVtYmVyIG9mIHBlbmRpbmcgcmVzcG9uc2VzIHdlJ3JlIGR1ZVxuICogZnJvbSB3YXRjaCBzbyB3ZSB3YWl0IGZvciB0aGUgcmVtb3ZhbCBvbiB0aGUgc2VydmVyIGJlZm9yZSB3ZSBwcm9jZXNzIGFueVxuICogbWVzc2FnZXMgZnJvbSB0aGlzIHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gc2VuZFVud2F0Y2hSZXF1ZXN0KHJlbW90ZVN0b3JlSW1wbCwgdGFyZ2V0SWQpIHtcbiAgICByZW1vdGVTdG9yZUltcGwud2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yLnJlY29yZFBlbmRpbmdUYXJnZXRSZXF1ZXN0KHRhcmdldElkKTtcbiAgICBlbnN1cmVXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpLnVud2F0Y2godGFyZ2V0SWQpO1xufVxuZnVuY3Rpb24gc3RhcnRXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpIHtcbiAgICByZW1vdGVTdG9yZUltcGwud2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yID0gbmV3IFdhdGNoQ2hhbmdlQWdncmVnYXRvcih7XG4gICAgICAgIGdldFJlbW90ZUtleXNGb3JUYXJnZXQ6IHRhcmdldElkID0+IHJlbW90ZVN0b3JlSW1wbC5yZW1vdGVTeW5jZXIuZ2V0UmVtb3RlS2V5c0ZvclRhcmdldCh0YXJnZXRJZCksXG4gICAgICAgIGdldFRhcmdldERhdGFGb3JUYXJnZXQ6IHRhcmdldElkID0+IHJlbW90ZVN0b3JlSW1wbC5saXN0ZW5UYXJnZXRzLmdldCh0YXJnZXRJZCkgfHwgbnVsbCxcbiAgICAgICAgZ2V0RGF0YWJhc2VJZDogKCkgPT4gcmVtb3RlU3RvcmVJbXBsLmRhdGFzdG9yZS5zZXJpYWxpemVyLmRhdGFiYXNlSWRcbiAgICB9KTtcbiAgICBlbnN1cmVXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpLnN0YXJ0KCk7XG4gICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5oYW5kbGVXYXRjaFN0cmVhbVN0YXJ0KCk7XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgd2F0Y2ggc3RyZWFtIHNob3VsZCBiZSBzdGFydGVkIGJlY2F1c2UgaXQncyBuZWNlc3NhcnlcbiAqIGFuZCBoYXMgbm90IHlldCBiZWVuIHN0YXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFN0YXJ0V2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKSB7XG4gICAgcmV0dXJuIChjYW5Vc2VOZXR3b3JrKHJlbW90ZVN0b3JlSW1wbCkgJiZcbiAgICAgICAgIWVuc3VyZVdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkuaXNTdGFydGVkKCkgJiZcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuc2l6ZSA+IDApO1xufVxuZnVuY3Rpb24gY2FuVXNlTmV0d29yayhyZW1vdGVTdG9yZSkge1xuICAgIGNvbnN0IHJlbW90ZVN0b3JlSW1wbCA9IGRlYnVnQ2FzdChyZW1vdGVTdG9yZSk7XG4gICAgcmV0dXJuIHJlbW90ZVN0b3JlSW1wbC5vZmZsaW5lQ2F1c2VzLnNpemUgPT09IDA7XG59XG5mdW5jdGlvbiBjbGVhblVwV2F0Y2hTdHJlYW1TdGF0ZShyZW1vdGVTdG9yZUltcGwpIHtcbiAgICByZW1vdGVTdG9yZUltcGwud2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yID0gdW5kZWZpbmVkO1xufVxuYXN5bmMgZnVuY3Rpb24gb25XYXRjaFN0cmVhbUNvbm5lY3RlZChyZW1vdGVTdG9yZUltcGwpIHtcbiAgICAvLyBNYXJrIHRoZSBjbGllbnQgYXMgb25saW5lIHNpbmNlIHdlIGdvdCBhIFwiY29ubmVjdGVkXCIgbm90aWZpY2F0aW9uLlxuICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiT25saW5lXCIgLyogT25saW5lU3RhdGUuT25saW5lICovKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG9uV2F0Y2hTdHJlYW1PcGVuKHJlbW90ZVN0b3JlSW1wbCkge1xuICAgIHJlbW90ZVN0b3JlSW1wbC5saXN0ZW5UYXJnZXRzLmZvckVhY2goKHRhcmdldERhdGEsIHRhcmdldElkKSA9PiB7XG4gICAgICAgIHNlbmRXYXRjaFJlcXVlc3QocmVtb3RlU3RvcmVJbXBsLCB0YXJnZXREYXRhKTtcbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG9uV2F0Y2hTdHJlYW1DbG9zZShyZW1vdGVTdG9yZUltcGwsIGVycm9yKSB7XG4gICAgY2xlYW5VcFdhdGNoU3RyZWFtU3RhdGUocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAvLyBJZiB3ZSBzdGlsbCBuZWVkIHRoZSB3YXRjaCBzdHJlYW0sIHJldHJ5IHRoZSBjb25uZWN0aW9uLlxuICAgIGlmIChzaG91bGRTdGFydFdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkpIHtcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5oYW5kbGVXYXRjaFN0cmVhbUZhaWx1cmUoZXJyb3IpO1xuICAgICAgICBzdGFydFdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBObyBuZWVkIHRvIHJlc3RhcnQgd2F0Y2ggc3RyZWFtIGJlY2F1c2UgdGhlcmUgYXJlIG5vIGFjdGl2ZSB0YXJnZXRzLlxuICAgICAgICAvLyBUaGUgb25saW5lIHN0YXRlIGlzIHNldCB0byB1bmtub3duIGJlY2F1c2UgdGhlcmUgaXMgbm8gYWN0aXZlIGF0dGVtcHRcbiAgICAgICAgLy8gYXQgZXN0YWJsaXNoaW5nIGEgY29ubmVjdGlvblxuICAgICAgICByZW1vdGVTdG9yZUltcGwub25saW5lU3RhdGVUcmFja2VyLnNldChcIlVua25vd25cIiAvKiBPbmxpbmVTdGF0ZS5Vbmtub3duICovKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBvbldhdGNoU3RyZWFtQ2hhbmdlKHJlbW90ZVN0b3JlSW1wbCwgd2F0Y2hDaGFuZ2UsIHNuYXBzaG90VmVyc2lvbikge1xuICAgIC8vIE1hcmsgdGhlIGNsaWVudCBhcyBvbmxpbmUgc2luY2Ugd2UgZ290IGEgbWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXJcbiAgICByZW1vdGVTdG9yZUltcGwub25saW5lU3RhdGVUcmFja2VyLnNldChcIk9ubGluZVwiIC8qIE9ubGluZVN0YXRlLk9ubGluZSAqLyk7XG4gICAgaWYgKHdhdGNoQ2hhbmdlIGluc3RhbmNlb2YgV2F0Y2hUYXJnZXRDaGFuZ2UgJiZcbiAgICAgICAgd2F0Y2hDaGFuZ2Uuc3RhdGUgPT09IDIgLyogV2F0Y2hUYXJnZXRDaGFuZ2VTdGF0ZS5SZW1vdmVkICovICYmXG4gICAgICAgIHdhdGNoQ2hhbmdlLmNhdXNlKSB7XG4gICAgICAgIC8vIFRoZXJlIHdhcyBhbiBlcnJvciBvbiBhIHRhcmdldCwgZG9uJ3Qgd2FpdCBmb3IgYSBjb25zaXN0ZW50IHNuYXBzaG90XG4gICAgICAgIC8vIHRvIHJhaXNlIGV2ZW50c1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlVGFyZ2V0RXJyb3IocmVtb3RlU3RvcmVJbXBsLCB3YXRjaENoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckNSwgJ0ZhaWxlZCB0byByZW1vdmUgdGFyZ2V0cyAlczogJXMgJywgd2F0Y2hDaGFuZ2UudGFyZ2V0SWRzLmpvaW4oJywnKSwgZSk7XG4gICAgICAgICAgICBhd2FpdCBkaXNhYmxlTmV0d29ya1VudGlsUmVjb3ZlcnkocmVtb3RlU3RvcmVJbXBsLCBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh3YXRjaENoYW5nZSBpbnN0YW5jZW9mIERvY3VtZW50V2F0Y2hDaGFuZ2UpIHtcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLndhdGNoQ2hhbmdlQWdncmVnYXRvci5oYW5kbGVEb2N1bWVudENoYW5nZSh3YXRjaENoYW5nZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHdhdGNoQ2hhbmdlIGluc3RhbmNlb2YgRXhpc3RlbmNlRmlsdGVyQ2hhbmdlKSB7XG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC53YXRjaENoYW5nZUFnZ3JlZ2F0b3IuaGFuZGxlRXhpc3RlbmNlRmlsdGVyKHdhdGNoQ2hhbmdlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC53YXRjaENoYW5nZUFnZ3JlZ2F0b3IuaGFuZGxlVGFyZ2V0Q2hhbmdlKHdhdGNoQ2hhbmdlKTtcbiAgICB9XG4gICAgaWYgKCFzbmFwc2hvdFZlcnNpb24uaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uID0gYXdhaXQgbG9jYWxTdG9yZUdldExhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24ocmVtb3RlU3RvcmVJbXBsLmxvY2FsU3RvcmUpO1xuICAgICAgICAgICAgaWYgKHNuYXBzaG90VmVyc2lvbi5jb21wYXJlVG8obGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbikgPj0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgcmVjZWl2ZWQgYSB0YXJnZXQgY2hhbmdlIHdpdGggYSBnbG9iYWwgc25hcHNob3QgaWYgdGhlIHNuYXBzaG90XG4gICAgICAgICAgICAgICAgLy8gdmVyc2lvbiBpcyBub3QgZXF1YWwgdG8gU25hcHNob3RWZXJzaW9uLm1pbigpLlxuICAgICAgICAgICAgICAgIGF3YWl0IHJhaXNlV2F0Y2hTbmFwc2hvdChyZW1vdGVTdG9yZUltcGwsIHNuYXBzaG90VmVyc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckNSwgJ0ZhaWxlZCB0byByYWlzZSBzbmFwc2hvdDonLCBlKTtcbiAgICAgICAgICAgIGF3YWl0IGRpc2FibGVOZXR3b3JrVW50aWxSZWNvdmVyeShyZW1vdGVTdG9yZUltcGwsIGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBSZWNvdmVyeSBsb2dpYyBmb3IgSW5kZXhlZERCIGVycm9ycyB0aGF0IHRha2VzIHRoZSBuZXR3b3JrIG9mZmxpbmUgdW50aWxcbiAqIGBvcGAgc3VjY2VlZHMuIFJldHJpZXMgYXJlIHNjaGVkdWxlZCB3aXRoIGJhY2tvZmYgdXNpbmdcbiAqIGBlbnF1ZXVlUmV0cnlhYmxlKClgLiBJZiBgb3AoKWAgaXMgbm90IHByb3ZpZGVkLCBJbmRleGVkREIgYWNjZXNzIGlzXG4gKiB2YWxpZGF0ZWQgdmlhIGEgZ2VuZXJpYyBvcGVyYXRpb24uXG4gKlxuICogVGhlIHJldHVybmVkIFByb21pc2UgaXMgcmVzb2x2ZWQgb25jZSB0aGUgbmV0d29yayBpcyBkaXNhYmxlZCBhbmQgYmVmb3JlXG4gKiBhbnkgcmV0cnkgYXR0ZW1wdC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGlzYWJsZU5ldHdvcmtVbnRpbFJlY292ZXJ5KHJlbW90ZVN0b3JlSW1wbCwgZSwgb3ApIHtcbiAgICBpZiAoaXNJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGUpKSB7XG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vZmZsaW5lQ2F1c2VzLmFkZCgxIC8qIE9mZmxpbmVDYXVzZS5JbmRleGVkRGJGYWlsZWQgKi8pO1xuICAgICAgICAvLyBEaXNhYmxlIG5ldHdvcmsgYW5kIHJhaXNlIG9mZmxpbmUgc25hcHNob3RzXG4gICAgICAgIGF3YWl0IGRpc2FibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5zZXQoXCJPZmZsaW5lXCIgLyogT25saW5lU3RhdGUuT2ZmbGluZSAqLyk7XG4gICAgICAgIGlmICghb3ApIHtcbiAgICAgICAgICAgIC8vIFVzZSBhIHNpbXBsZSByZWFkIG9wZXJhdGlvbiB0byBkZXRlcm1pbmUgaWYgSW5kZXhlZERCIHJlY292ZXJlZC5cbiAgICAgICAgICAgIC8vIElkZWFsbHksIHdlIHdvdWxkIGV4cG9zZSBhIGhlYWx0aCBjaGVjayBkaXJlY3RseSBvbiBTaW1wbGVEYiwgYnV0XG4gICAgICAgICAgICAvLyBSZW1vdGVTdG9yZSBvbmx5IGhhcyBhY2Nlc3MgdG8gcGVyc2lzdGVuY2UgdGhyb3VnaCBMb2NhbFN0b3JlLlxuICAgICAgICAgICAgb3AgPSAoKSA9PiBsb2NhbFN0b3JlR2V0TGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbihyZW1vdGVTdG9yZUltcGwubG9jYWxTdG9yZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJvYmUgSW5kZXhlZERCIHBlcmlvZGljYWxseSBhbmQgcmUtZW5hYmxlIG5ldHdvcmtcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLmFzeW5jUXVldWUuZW5xdWV1ZVJldHJ5YWJsZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDUsICdSZXRyeWluZyBJbmRleGVkREIgYWNjZXNzJyk7XG4gICAgICAgICAgICBhd2FpdCBvcCgpO1xuICAgICAgICAgICAgcmVtb3RlU3RvcmVJbXBsLm9mZmxpbmVDYXVzZXMuZGVsZXRlKDEgLyogT2ZmbGluZUNhdXNlLkluZGV4ZWREYkZhaWxlZCAqLyk7XG4gICAgICAgICAgICBhd2FpdCBlbmFibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbn1cbi8qKlxuICogRXhlY3V0ZXMgYG9wYC4gSWYgYG9wYCBmYWlscywgdGFrZXMgdGhlIG5ldHdvcmsgb2ZmbGluZSB1bnRpbCBgb3BgXG4gKiBzdWNjZWVkcy4gUmV0dXJucyBhZnRlciB0aGUgZmlyc3QgYXR0ZW1wdC5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZVdpdGhSZWNvdmVyeShyZW1vdGVTdG9yZUltcGwsIG9wKSB7XG4gICAgcmV0dXJuIG9wKCkuY2F0Y2goZSA9PiBkaXNhYmxlTmV0d29ya1VudGlsUmVjb3ZlcnkocmVtb3RlU3RvcmVJbXBsLCBlLCBvcCkpO1xufVxuLyoqXG4gKiBUYWtlcyBhIGJhdGNoIG9mIGNoYW5nZXMgZnJvbSB0aGUgRGF0YXN0b3JlLCByZXBhY2thZ2VzIHRoZW0gYXMgYVxuICogUmVtb3RlRXZlbnQsIGFuZCBwYXNzZXMgdGhhdCBvbiB0byB0aGUgbGlzdGVuZXIsIHdoaWNoIGlzIHR5cGljYWxseSB0aGVcbiAqIFN5bmNFbmdpbmUuXG4gKi9cbmZ1bmN0aW9uIHJhaXNlV2F0Y2hTbmFwc2hvdChyZW1vdGVTdG9yZUltcGwsIHNuYXBzaG90VmVyc2lvbikge1xuICAgIGNvbnN0IHJlbW90ZUV2ZW50ID0gcmVtb3RlU3RvcmVJbXBsLndhdGNoQ2hhbmdlQWdncmVnYXRvci5jcmVhdGVSZW1vdGVFdmVudChzbmFwc2hvdFZlcnNpb24pO1xuICAgIC8vIFVwZGF0ZSBpbi1tZW1vcnkgcmVzdW1lIHRva2Vucy4gTG9jYWxTdG9yZSB3aWxsIHVwZGF0ZSB0aGVcbiAgICAvLyBwZXJzaXN0ZW50IHZpZXcgb2YgdGhlc2Ugd2hlbiBhcHBseWluZyB0aGUgY29tcGxldGVkIFJlbW90ZUV2ZW50LlxuICAgIHJlbW90ZUV2ZW50LnRhcmdldENoYW5nZXMuZm9yRWFjaCgoY2hhbmdlLCB0YXJnZXRJZCkgPT4ge1xuICAgICAgICBpZiAoY2hhbmdlLnJlc3VtZVRva2VuLmFwcHJveGltYXRlQnl0ZVNpemUoKSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldERhdGEgPSByZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5nZXQodGFyZ2V0SWQpO1xuICAgICAgICAgICAgLy8gQSB3YXRjaGVkIHRhcmdldCBtaWdodCBoYXZlIGJlZW4gcmVtb3ZlZCBhbHJlYWR5LlxuICAgICAgICAgICAgaWYgKHRhcmdldERhdGEpIHtcbiAgICAgICAgICAgICAgICByZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5zZXQodGFyZ2V0SWQsIHRhcmdldERhdGEud2l0aFJlc3VtZVRva2VuKGNoYW5nZS5yZXN1bWVUb2tlbiwgc25hcHNob3RWZXJzaW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBSZS1lc3RhYmxpc2ggbGlzdGVucyBmb3IgdGhlIHRhcmdldHMgdGhhdCBoYXZlIGJlZW4gaW52YWxpZGF0ZWQgYnlcbiAgICAvLyBleGlzdGVuY2UgZmlsdGVyIG1pc21hdGNoZXMuXG4gICAgcmVtb3RlRXZlbnQudGFyZ2V0TWlzbWF0Y2hlcy5mb3JFYWNoKCh0YXJnZXRJZCwgdGFyZ2V0UHVycG9zZSkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXREYXRhID0gcmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuZ2V0KHRhcmdldElkKTtcbiAgICAgICAgaWYgKCF0YXJnZXREYXRhKSB7XG4gICAgICAgICAgICAvLyBBIHdhdGNoZWQgdGFyZ2V0IG1pZ2h0IGhhdmUgYmVlbiByZW1vdmVkIGFscmVhZHkuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgdGhlIHJlc3VtZSB0b2tlbiBmb3IgdGhlIHRhcmdldCwgc2luY2Ugd2UncmUgaW4gYSBrbm93biBtaXNtYXRjaFxuICAgICAgICAvLyBzdGF0ZS5cbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuc2V0KHRhcmdldElkLCB0YXJnZXREYXRhLndpdGhSZXN1bWVUb2tlbihCeXRlU3RyaW5nLkVNUFRZX0JZVEVfU1RSSU5HLCB0YXJnZXREYXRhLnNuYXBzaG90VmVyc2lvbikpO1xuICAgICAgICAvLyBDYXVzZSBhIGhhcmQgcmVzZXQgYnkgdW53YXRjaGluZyBhbmQgcmV3YXRjaGluZyBpbW1lZGlhdGVseSwgYnV0XG4gICAgICAgIC8vIGRlbGliZXJhdGVseSBkb24ndCBzZW5kIGEgcmVzdW1lIHRva2VuIHNvIHRoYXQgd2UgZ2V0IGEgZnVsbCB1cGRhdGUuXG4gICAgICAgIHNlbmRVbndhdGNoUmVxdWVzdChyZW1vdGVTdG9yZUltcGwsIHRhcmdldElkKTtcbiAgICAgICAgLy8gTWFyayB0aGUgdGFyZ2V0IHdlIHNlbmQgYXMgYmVpbmcgb24gYmVoYWxmIG9mIGFuIGV4aXN0ZW5jZSBmaWx0ZXJcbiAgICAgICAgLy8gbWlzbWF0Y2gsIGJ1dCBkb24ndCBhY3R1YWxseSByZXRhaW4gdGhhdCBpbiBsaXN0ZW5UYXJnZXRzLiBUaGlzIGVuc3VyZXNcbiAgICAgICAgLy8gdGhhdCB3ZSBmbGFnIHRoZSBmaXJzdCByZS1saXN0ZW4gdGhpcyB3YXkgd2l0aG91dCBpbXBhY3RpbmcgZnV0dXJlXG4gICAgICAgIC8vIGxpc3RlbnMgb2YgdGhpcyB0YXJnZXQgKHRoYXQgbWlnaHQgaGFwcGVuIGUuZy4gb24gcmVjb25uZWN0KS5cbiAgICAgICAgY29uc3QgcmVxdWVzdFRhcmdldERhdGEgPSBuZXcgVGFyZ2V0RGF0YSh0YXJnZXREYXRhLnRhcmdldCwgdGFyZ2V0SWQsIHRhcmdldFB1cnBvc2UsIHRhcmdldERhdGEuc2VxdWVuY2VOdW1iZXIpO1xuICAgICAgICBzZW5kV2F0Y2hSZXF1ZXN0KHJlbW90ZVN0b3JlSW1wbCwgcmVxdWVzdFRhcmdldERhdGEpO1xuICAgIH0pO1xuICAgIHJldHVybiByZW1vdGVTdG9yZUltcGwucmVtb3RlU3luY2VyLmFwcGx5UmVtb3RlRXZlbnQocmVtb3RlRXZlbnQpO1xufVxuLyoqIEhhbmRsZXMgYW4gZXJyb3Igb24gYSB0YXJnZXQgKi9cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVRhcmdldEVycm9yKHJlbW90ZVN0b3JlSW1wbCwgd2F0Y2hDaGFuZ2UpIHtcbiAgICBjb25zdCBlcnJvciA9IHdhdGNoQ2hhbmdlLmNhdXNlO1xuICAgIGZvciAoY29uc3QgdGFyZ2V0SWQgb2Ygd2F0Y2hDaGFuZ2UudGFyZ2V0SWRzKSB7XG4gICAgICAgIC8vIEEgd2F0Y2hlZCB0YXJnZXQgbWlnaHQgaGF2ZSBiZWVuIHJlbW92ZWQgYWxyZWFkeS5cbiAgICAgICAgaWYgKHJlbW90ZVN0b3JlSW1wbC5saXN0ZW5UYXJnZXRzLmhhcyh0YXJnZXRJZCkpIHtcbiAgICAgICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlSW1wbC5yZW1vdGVTeW5jZXIucmVqZWN0TGlzdGVuKHRhcmdldElkLCBlcnJvcik7XG4gICAgICAgICAgICByZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5kZWxldGUodGFyZ2V0SWQpO1xuICAgICAgICAgICAgcmVtb3RlU3RvcmVJbXBsLndhdGNoQ2hhbmdlQWdncmVnYXRvci5yZW1vdmVUYXJnZXQodGFyZ2V0SWQpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBdHRlbXB0cyB0byBmaWxsIG91ciB3cml0ZSBwaXBlbGluZSB3aXRoIHdyaXRlcyBmcm9tIHRoZSBMb2NhbFN0b3JlLlxuICpcbiAqIENhbGxlZCBpbnRlcm5hbGx5IHRvIGJvb3RzdHJhcCBvciByZWZpbGwgdGhlIHdyaXRlIHBpcGVsaW5lIGFuZCBieVxuICogU3luY0VuZ2luZSB3aGVuZXZlciB0aGVyZSBhcmUgbmV3IG11dGF0aW9ucyB0byBwcm9jZXNzLlxuICpcbiAqIFN0YXJ0cyB0aGUgd3JpdGUgc3RyZWFtIGlmIG5lY2Vzc2FyeS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmlsbFdyaXRlUGlwZWxpbmUocmVtb3RlU3RvcmUpIHtcbiAgICBjb25zdCByZW1vdGVTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlU3RvcmUpO1xuICAgIGNvbnN0IHdyaXRlU3RyZWFtID0gZW5zdXJlV3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKTtcbiAgICBsZXQgbGFzdEJhdGNoSWRSZXRyaWV2ZWQgPSByZW1vdGVTdG9yZUltcGwud3JpdGVQaXBlbGluZS5sZW5ndGggPiAwXG4gICAgICAgID8gcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmVbcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgIC5iYXRjaElkXG4gICAgICAgIDogQkFUQ0hJRF9VTktOT1dOO1xuICAgIHdoaWxlIChjYW5BZGRUb1dyaXRlUGlwZWxpbmUocmVtb3RlU3RvcmVJbXBsKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSBhd2FpdCBsb2NhbFN0b3JlR2V0TmV4dE11dGF0aW9uQmF0Y2gocmVtb3RlU3RvcmVJbXBsLmxvY2FsU3RvcmUsIGxhc3RCYXRjaElkUmV0cmlldmVkKTtcbiAgICAgICAgICAgIGlmIChiYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdGVTdG9yZUltcGwud3JpdGVQaXBlbGluZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVTdHJlYW0ubWFya0lkbGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYXN0QmF0Y2hJZFJldHJpZXZlZCA9IGJhdGNoLmJhdGNoSWQ7XG4gICAgICAgICAgICAgICAgYWRkVG9Xcml0ZVBpcGVsaW5lKHJlbW90ZVN0b3JlSW1wbCwgYmF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhd2FpdCBkaXNhYmxlTmV0d29ya1VudGlsUmVjb3ZlcnkocmVtb3RlU3RvcmVJbXBsLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2hvdWxkU3RhcnRXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpKSB7XG4gICAgICAgIHN0YXJ0V3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB3ZSBjYW4gYWRkIHRvIHRoZSB3cml0ZSBwaXBlbGluZSAoaS5lLiB0aGUgbmV0d29yayBpc1xuICogZW5hYmxlZCBhbmQgdGhlIHdyaXRlIHBpcGVsaW5lIGlzIG5vdCBmdWxsKS5cbiAqL1xuZnVuY3Rpb24gY2FuQWRkVG9Xcml0ZVBpcGVsaW5lKHJlbW90ZVN0b3JlSW1wbCkge1xuICAgIHJldHVybiAoY2FuVXNlTmV0d29yayhyZW1vdGVTdG9yZUltcGwpICYmXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC53cml0ZVBpcGVsaW5lLmxlbmd0aCA8IE1BWF9QRU5ESU5HX1dSSVRFUyk7XG59XG4vKipcbiAqIFF1ZXVlcyBhZGRpdGlvbmFsIHdyaXRlcyB0byBiZSBzZW50IHRvIHRoZSB3cml0ZSBzdHJlYW0sIHNlbmRpbmcgdGhlbVxuICogaW1tZWRpYXRlbHkgaWYgdGhlIHdyaXRlIHN0cmVhbSBpcyBlc3RhYmxpc2hlZC5cbiAqL1xuZnVuY3Rpb24gYWRkVG9Xcml0ZVBpcGVsaW5lKHJlbW90ZVN0b3JlSW1wbCwgYmF0Y2gpIHtcbiAgICByZW1vdGVTdG9yZUltcGwud3JpdGVQaXBlbGluZS5wdXNoKGJhdGNoKTtcbiAgICBjb25zdCB3cml0ZVN0cmVhbSA9IGVuc3VyZVdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCk7XG4gICAgaWYgKHdyaXRlU3RyZWFtLmlzT3BlbigpICYmIHdyaXRlU3RyZWFtLmhhbmRzaGFrZUNvbXBsZXRlKSB7XG4gICAgICAgIHdyaXRlU3RyZWFtLndyaXRlTXV0YXRpb25zKGJhdGNoLm11dGF0aW9ucyk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2hvdWxkU3RhcnRXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpIHtcbiAgICByZXR1cm4gKGNhblVzZU5ldHdvcmsocmVtb3RlU3RvcmVJbXBsKSAmJlxuICAgICAgICAhZW5zdXJlV3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKS5pc1N0YXJ0ZWQoKSAmJlxuICAgICAgICByZW1vdGVTdG9yZUltcGwud3JpdGVQaXBlbGluZS5sZW5ndGggPiAwKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0V3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKSB7XG4gICAgZW5zdXJlV3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKS5zdGFydCgpO1xufVxuYXN5bmMgZnVuY3Rpb24gb25Xcml0ZVN0cmVhbU9wZW4ocmVtb3RlU3RvcmVJbXBsKSB7XG4gICAgZW5zdXJlV3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKS53cml0ZUhhbmRzaGFrZSgpO1xufVxuYXN5bmMgZnVuY3Rpb24gb25Xcml0ZUhhbmRzaGFrZUNvbXBsZXRlKHJlbW90ZVN0b3JlSW1wbCkge1xuICAgIGNvbnN0IHdyaXRlU3RyZWFtID0gZW5zdXJlV3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAvLyBTZW5kIHRoZSB3cml0ZSBwaXBlbGluZSBub3cgdGhhdCB0aGUgc3RyZWFtIGlzIGVzdGFibGlzaGVkLlxuICAgIGZvciAoY29uc3QgYmF0Y2ggb2YgcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUpIHtcbiAgICAgICAgd3JpdGVTdHJlYW0ud3JpdGVNdXRhdGlvbnMoYmF0Y2gubXV0YXRpb25zKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBvbk11dGF0aW9uUmVzdWx0KHJlbW90ZVN0b3JlSW1wbCwgY29tbWl0VmVyc2lvbiwgcmVzdWx0cykge1xuICAgIGNvbnN0IGJhdGNoID0gcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUuc2hpZnQoKTtcbiAgICBjb25zdCBzdWNjZXNzID0gTXV0YXRpb25CYXRjaFJlc3VsdC5mcm9tKGJhdGNoLCBjb21taXRWZXJzaW9uLCByZXN1bHRzKTtcbiAgICBhd2FpdCBleGVjdXRlV2l0aFJlY292ZXJ5KHJlbW90ZVN0b3JlSW1wbCwgKCkgPT4gcmVtb3RlU3RvcmVJbXBsLnJlbW90ZVN5bmNlci5hcHBseVN1Y2Nlc3NmdWxXcml0ZShzdWNjZXNzKSk7XG4gICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IHdpdGggdGhlIGNvbXBsZXRpb24gb2YgdGhpcyBtdXRhdGlvbiBhbm90aGVyXG4gICAgLy8gc2xvdCBoYXMgZnJlZWQgdXAuXG4gICAgYXdhaXQgZmlsbFdyaXRlUGlwZWxpbmUocmVtb3RlU3RvcmVJbXBsKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG9uV3JpdGVTdHJlYW1DbG9zZShyZW1vdGVTdG9yZUltcGwsIGVycm9yKSB7XG4gICAgLy8gSWYgdGhlIHdyaXRlIHN0cmVhbSBjbG9zZWQgYWZ0ZXIgdGhlIHdyaXRlIGhhbmRzaGFrZSBjb21wbGV0ZXMsIGEgd3JpdGVcbiAgICAvLyBvcGVyYXRpb24gZmFpbGVkIGFuZCB3ZSBmYWlsIHRoZSBwZW5kaW5nIG9wZXJhdGlvbi5cbiAgICBpZiAoZXJyb3IgJiYgZW5zdXJlV3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKS5oYW5kc2hha2VDb21wbGV0ZSkge1xuICAgICAgICAvLyBUaGlzIGVycm9yIGFmZmVjdHMgdGhlIGFjdHVhbCB3cml0ZS5cbiAgICAgICAgYXdhaXQgaGFuZGxlV3JpdGVFcnJvcihyZW1vdGVTdG9yZUltcGwsIGVycm9yKTtcbiAgICB9XG4gICAgLy8gVGhlIHdyaXRlIHN0cmVhbSBtaWdodCBoYXZlIGJlZW4gc3RhcnRlZCBieSByZWZpbGxpbmcgdGhlIHdyaXRlXG4gICAgLy8gcGlwZWxpbmUgZm9yIGZhaWxlZCB3cml0ZXNcbiAgICBpZiAoc2hvdWxkU3RhcnRXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpKSB7XG4gICAgICAgIHN0YXJ0V3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVXcml0ZUVycm9yKHJlbW90ZVN0b3JlSW1wbCwgZXJyb3IpIHtcbiAgICAvLyBPbmx5IGhhbmRsZSBwZXJtYW5lbnQgZXJyb3JzIGhlcmUuIElmIGl0J3MgdHJhbnNpZW50LCBqdXN0IGxldCB0aGUgcmV0cnlcbiAgICAvLyBsb2dpYyBraWNrIGluLlxuICAgIGlmIChpc1Blcm1hbmVudFdyaXRlRXJyb3IoZXJyb3IuY29kZSkpIHtcbiAgICAgICAgLy8gVGhpcyB3YXMgYSBwZXJtYW5lbnQgZXJyb3IsIHRoZSByZXF1ZXN0IGl0c2VsZiB3YXMgdGhlIHByb2JsZW1cbiAgICAgICAgLy8gc28gaXQncyBub3QgZ29pbmcgdG8gc3VjY2VlZCBpZiB3ZSByZXNlbmQgaXQuXG4gICAgICAgIGNvbnN0IGJhdGNoID0gcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUuc2hpZnQoKTtcbiAgICAgICAgLy8gSW4gdGhpcyBjYXNlIGl0J3MgYWxzbyB1bmxpa2VseSB0aGF0IHRoZSBzZXJ2ZXIgaXRzZWxmIGlzIG1lbHRpbmdcbiAgICAgICAgLy8gZG93biAtLSB0aGlzIHdhcyBqdXN0IGEgYmFkIHJlcXVlc3Qgc28gaW5oaWJpdCBiYWNrb2ZmIG9uIHRoZSBuZXh0XG4gICAgICAgIC8vIHJlc3RhcnQuXG4gICAgICAgIGVuc3VyZVdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkuaW5oaWJpdEJhY2tvZmYoKTtcbiAgICAgICAgYXdhaXQgZXhlY3V0ZVdpdGhSZWNvdmVyeShyZW1vdGVTdG9yZUltcGwsICgpID0+IHJlbW90ZVN0b3JlSW1wbC5yZW1vdGVTeW5jZXIucmVqZWN0RmFpbGVkV3JpdGUoYmF0Y2guYmF0Y2hJZCwgZXJyb3IpKTtcbiAgICAgICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IHdpdGggdGhlIGNvbXBsZXRpb24gb2YgdGhpcyBtdXRhdGlvblxuICAgICAgICAvLyBhbm90aGVyIHNsb3QgaGFzIGZyZWVkIHVwLlxuICAgICAgICBhd2FpdCBmaWxsV3JpdGVQaXBlbGluZShyZW1vdGVTdG9yZUltcGwpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHJlc3RhcnROZXR3b3JrKHJlbW90ZVN0b3JlKSB7XG4gICAgY29uc3QgcmVtb3RlU3RvcmVJbXBsID0gZGVidWdDYXN0KHJlbW90ZVN0b3JlKTtcbiAgICByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5hZGQoNCAvKiBPZmZsaW5lQ2F1c2UuQ29ubmVjdGl2aXR5Q2hhbmdlICovKTtcbiAgICBhd2FpdCBkaXNhYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCk7XG4gICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5zZXQoXCJVbmtub3duXCIgLyogT25saW5lU3RhdGUuVW5rbm93biAqLyk7XG4gICAgcmVtb3RlU3RvcmVJbXBsLm9mZmxpbmVDYXVzZXMuZGVsZXRlKDQgLyogT2ZmbGluZUNhdXNlLkNvbm5lY3Rpdml0eUNoYW5nZSAqLyk7XG4gICAgYXdhaXQgZW5hYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCk7XG59XG5hc3luYyBmdW5jdGlvbiByZW1vdGVTdG9yZUhhbmRsZUNyZWRlbnRpYWxDaGFuZ2UocmVtb3RlU3RvcmUsIHVzZXIpIHtcbiAgICBjb25zdCByZW1vdGVTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlU3RvcmUpO1xuICAgIHJlbW90ZVN0b3JlSW1wbC5hc3luY1F1ZXVlLnZlcmlmeU9wZXJhdGlvbkluUHJvZ3Jlc3MoKTtcbiAgICBsb2dEZWJ1ZyhMT0dfVEFHJDUsICdSZW1vdGVTdG9yZSByZWNlaXZlZCBuZXcgY3JlZGVudGlhbHMnKTtcbiAgICBjb25zdCB1c2VzTmV0d29yayA9IGNhblVzZU5ldHdvcmsocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAvLyBUZWFyIGRvd24gYW5kIHJlLWNyZWF0ZSBvdXIgbmV0d29yayBzdHJlYW1zLiBUaGlzIHdpbGwgZW5zdXJlIHdlIGdldCBhXG4gICAgLy8gZnJlc2ggYXV0aCB0b2tlbiBmb3IgdGhlIG5ldyB1c2VyIGFuZCByZS1maWxsIHRoZSB3cml0ZSBwaXBlbGluZSB3aXRoXG4gICAgLy8gbmV3IG11dGF0aW9ucyBmcm9tIHRoZSBMb2NhbFN0b3JlIChzaW5jZSBtdXRhdGlvbnMgYXJlIHBlci11c2VyKS5cbiAgICByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5hZGQoMyAvKiBPZmZsaW5lQ2F1c2UuQ3JlZGVudGlhbENoYW5nZSAqLyk7XG4gICAgYXdhaXQgZGlzYWJsZU5ldHdvcmtJbnRlcm5hbChyZW1vdGVTdG9yZUltcGwpO1xuICAgIGlmICh1c2VzTmV0d29yaykge1xuICAgICAgICAvLyBEb24ndCBzZXQgdGhlIG5ldHdvcmsgc3RhdHVzIHRvIFVua25vd24gaWYgd2UgYXJlIG9mZmxpbmUuXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi8pO1xuICAgIH1cbiAgICBhd2FpdCByZW1vdGVTdG9yZUltcGwucmVtb3RlU3luY2VyLmhhbmRsZUNyZWRlbnRpYWxDaGFuZ2UodXNlcik7XG4gICAgcmVtb3RlU3RvcmVJbXBsLm9mZmxpbmVDYXVzZXMuZGVsZXRlKDMgLyogT2ZmbGluZUNhdXNlLkNyZWRlbnRpYWxDaGFuZ2UgKi8pO1xuICAgIGF3YWl0IGVuYWJsZU5ldHdvcmtJbnRlcm5hbChyZW1vdGVTdG9yZUltcGwpO1xufVxuLyoqXG4gKiBUb2dnbGVzIHRoZSBuZXR3b3JrIHN0YXRlIHdoZW4gdGhlIGNsaWVudCBnYWlucyBvciBsb3NlcyBpdHMgcHJpbWFyeSBsZWFzZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVtb3RlU3RvcmVBcHBseVByaW1hcnlTdGF0ZShyZW1vdGVTdG9yZSwgaXNQcmltYXJ5KSB7XG4gICAgY29uc3QgcmVtb3RlU3RvcmVJbXBsID0gZGVidWdDYXN0KHJlbW90ZVN0b3JlKTtcbiAgICBpZiAoaXNQcmltYXJ5KSB7XG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vZmZsaW5lQ2F1c2VzLmRlbGV0ZSgyIC8qIE9mZmxpbmVDYXVzZS5Jc1NlY29uZGFyeSAqLyk7XG4gICAgICAgIGF3YWl0IGVuYWJsZU5ldHdvcmtJbnRlcm5hbChyZW1vdGVTdG9yZUltcGwpO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXNQcmltYXJ5KSB7XG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vZmZsaW5lQ2F1c2VzLmFkZCgyIC8qIE9mZmxpbmVDYXVzZS5Jc1NlY29uZGFyeSAqLyk7XG4gICAgICAgIGF3YWl0IGRpc2FibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5zZXQoXCJVbmtub3duXCIgLyogT25saW5lU3RhdGUuVW5rbm93biAqLyk7XG4gICAgfVxufVxuLyoqXG4gKiBJZiBub3QgeWV0IGluaXRpYWxpemVkLCByZWdpc3RlcnMgdGhlIFdhdGNoU3RyZWFtIGFuZCBpdHMgbmV0d29yayBzdGF0ZVxuICogY2FsbGJhY2sgd2l0aCBgcmVtb3RlU3RvcmVJbXBsYC4gUmV0dXJucyB0aGUgZXhpc3Rpbmcgc3RyZWFtIGlmIG9uZSBpc1xuICogYWxyZWFkeSBhdmFpbGFibGUuXG4gKlxuICogUE9SVElORyBOT1RFOiBPbiBpT1MgYW5kIEFuZHJvaWQsIHRoZSBXYXRjaFN0cmVhbSBnZXRzIHJlZ2lzdGVyZWQgb24gc3RhcnR1cC5cbiAqIFRoaXMgaXMgbm90IGRvbmUgb24gV2ViIHRvIGFsbG93IGl0IHRvIGJlIHRyZWUtc2hha2VuLlxuICovXG5mdW5jdGlvbiBlbnN1cmVXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpIHtcbiAgICBpZiAoIXJlbW90ZVN0b3JlSW1wbC53YXRjaFN0cmVhbSkge1xuICAgICAgICAvLyBDcmVhdGUgc3RyZWFtIChidXQgbm90ZSB0aGF0IGl0IGlzIG5vdCBzdGFydGVkIHlldCkuXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC53YXRjaFN0cmVhbSA9IG5ld1BlcnNpc3RlbnRXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwuZGF0YXN0b3JlLCByZW1vdGVTdG9yZUltcGwuYXN5bmNRdWV1ZSwge1xuICAgICAgICAgICAgb25Db25uZWN0ZWQ6IG9uV2F0Y2hTdHJlYW1Db25uZWN0ZWQuYmluZChudWxsLCByZW1vdGVTdG9yZUltcGwpLFxuICAgICAgICAgICAgb25PcGVuOiBvbldhdGNoU3RyZWFtT3Blbi5iaW5kKG51bGwsIHJlbW90ZVN0b3JlSW1wbCksXG4gICAgICAgICAgICBvbkNsb3NlOiBvbldhdGNoU3RyZWFtQ2xvc2UuYmluZChudWxsLCByZW1vdGVTdG9yZUltcGwpLFxuICAgICAgICAgICAgb25XYXRjaENoYW5nZTogb25XYXRjaFN0cmVhbUNoYW5nZS5iaW5kKG51bGwsIHJlbW90ZVN0b3JlSW1wbClcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbk5ldHdvcmtTdGF0dXNDaGFuZ2UucHVzaChhc3luYyAoZW5hYmxlZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByZW1vdGVTdG9yZUltcGwud2F0Y2hTdHJlYW0uaW5oaWJpdEJhY2tvZmYoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnRXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0V2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlSW1wbC53YXRjaFN0cmVhbS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgY2xlYW5VcFdhdGNoU3RyZWFtU3RhdGUocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZW1vdGVTdG9yZUltcGwud2F0Y2hTdHJlYW07XG59XG4vKipcbiAqIElmIG5vdCB5ZXQgaW5pdGlhbGl6ZWQsIHJlZ2lzdGVycyB0aGUgV3JpdGVTdHJlYW0gYW5kIGl0cyBuZXR3b3JrIHN0YXRlXG4gKiBjYWxsYmFjayB3aXRoIGByZW1vdGVTdG9yZUltcGxgLiBSZXR1cm5zIHRoZSBleGlzdGluZyBzdHJlYW0gaWYgb25lIGlzXG4gKiBhbHJlYWR5IGF2YWlsYWJsZS5cbiAqXG4gKiBQT1JUSU5HIE5PVEU6IE9uIGlPUyBhbmQgQW5kcm9pZCwgdGhlIFdyaXRlU3RyZWFtIGdldHMgcmVnaXN0ZXJlZCBvbiBzdGFydHVwLlxuICogVGhpcyBpcyBub3QgZG9uZSBvbiBXZWIgdG8gYWxsb3cgaXQgdG8gYmUgdHJlZS1zaGFrZW4uXG4gKi9cbmZ1bmN0aW9uIGVuc3VyZVdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkge1xuICAgIGlmICghcmVtb3RlU3RvcmVJbXBsLndyaXRlU3RyZWFtKSB7XG4gICAgICAgIC8vIENyZWF0ZSBzdHJlYW0gKGJ1dCBub3RlIHRoYXQgaXQgaXMgbm90IHN0YXJ0ZWQgeWV0KS5cbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLndyaXRlU3RyZWFtID0gbmV3UGVyc2lzdGVudFdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbC5kYXRhc3RvcmUsIHJlbW90ZVN0b3JlSW1wbC5hc3luY1F1ZXVlLCB7XG4gICAgICAgICAgICBvbkNvbm5lY3RlZDogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCksXG4gICAgICAgICAgICBvbk9wZW46IG9uV3JpdGVTdHJlYW1PcGVuLmJpbmQobnVsbCwgcmVtb3RlU3RvcmVJbXBsKSxcbiAgICAgICAgICAgIG9uQ2xvc2U6IG9uV3JpdGVTdHJlYW1DbG9zZS5iaW5kKG51bGwsIHJlbW90ZVN0b3JlSW1wbCksXG4gICAgICAgICAgICBvbkhhbmRzaGFrZUNvbXBsZXRlOiBvbldyaXRlSGFuZHNoYWtlQ29tcGxldGUuYmluZChudWxsLCByZW1vdGVTdG9yZUltcGwpLFxuICAgICAgICAgICAgb25NdXRhdGlvblJlc3VsdDogb25NdXRhdGlvblJlc3VsdC5iaW5kKG51bGwsIHJlbW90ZVN0b3JlSW1wbClcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbk5ldHdvcmtTdGF0dXNDaGFuZ2UucHVzaChhc3luYyAoZW5hYmxlZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByZW1vdGVTdG9yZUltcGwud3JpdGVTdHJlYW0uaW5oaWJpdEJhY2tvZmYoKTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgc3RhcnQgdGhlIHdyaXRlIHN0cmVhbSBpZiBuZWNlc3NhcnkuXG4gICAgICAgICAgICAgICAgYXdhaXQgZmlsbFdyaXRlUGlwZWxpbmUocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlSW1wbC53cml0ZVN0cmVhbS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW90ZVN0b3JlSW1wbC53cml0ZVBpcGVsaW5lLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ1LCBgU3RvcHBpbmcgd3JpdGUgc3RyZWFtIHdpdGggJHtyZW1vdGVTdG9yZUltcGwud3JpdGVQaXBlbGluZS5sZW5ndGh9IHBlbmRpbmcgd3JpdGVzYCk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVN0b3JlSW1wbC53cml0ZVBpcGVsaW5lID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlbW90ZVN0b3JlSW1wbC53cml0ZVN0cmVhbTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IExPR19UQUckNCA9ICdBc3luY1F1ZXVlJztcbi8qKlxuICogUmVwcmVzZW50cyBhbiBvcGVyYXRpb24gc2NoZWR1bGVkIHRvIGJlIHJ1biBpbiB0aGUgZnV0dXJlIG9uIGFuIEFzeW5jUXVldWUuXG4gKlxuICogSXQgaXMgY3JlYXRlZCB2aWEgRGVsYXllZE9wZXJhdGlvbi5jcmVhdGVBbmRTY2hlZHVsZSgpLlxuICpcbiAqIFN1cHBvcnRzIGNhbmNlbGxhdGlvbiAodmlhIGNhbmNlbCgpKSBhbmQgZWFybHkgZXhlY3V0aW9uICh2aWEgc2tpcERlbGF5KCkpLlxuICpcbiAqIE5vdGU6IFdlIGltcGxlbWVudCBgUHJvbWlzZUxpa2VgIGluc3RlYWQgb2YgYFByb21pc2VgLCBhcyB0aGUgYFByb21pc2VgIHR5cGVcbiAqIGluIG5ld2VyIHZlcnNpb25zIG9mIFR5cGVTY3JpcHQgZGVmaW5lcyBgZmluYWxseWAsIHdoaWNoIGlzIG5vdCBhdmFpbGFibGUgaW5cbiAqIElFLlxuICovXG5jbGFzcyBEZWxheWVkT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihhc3luY1F1ZXVlLCB0aW1lcklkLCB0YXJnZXRUaW1lTXMsIG9wLCByZW1vdmFsQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5hc3luY1F1ZXVlID0gYXN5bmNRdWV1ZTtcbiAgICAgICAgdGhpcy50aW1lcklkID0gdGltZXJJZDtcbiAgICAgICAgdGhpcy50YXJnZXRUaW1lTXMgPSB0YXJnZXRUaW1lTXM7XG4gICAgICAgIHRoaXMub3AgPSBvcDtcbiAgICAgICAgdGhpcy5yZW1vdmFsQ2FsbGJhY2sgPSByZW1vdmFsQ2FsbGJhY2s7XG4gICAgICAgIHRoaXMuZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy50aGVuID0gdGhpcy5kZWZlcnJlZC5wcm9taXNlLnRoZW4uYmluZCh0aGlzLmRlZmVycmVkLnByb21pc2UpO1xuICAgICAgICAvLyBJdCdzIG5vcm1hbCBmb3IgdGhlIGRlZmVycmVkIHByb21pc2UgdG8gYmUgY2FuY2VsZWQgKGR1ZSB0byBjYW5jZWxsYXRpb24pXG4gICAgICAgIC8vIGFuZCBzbyB3ZSBhdHRhY2ggYSBkdW1teSBjYXRjaCBjYWxsYmFjayB0byBhdm9pZFxuICAgICAgICAvLyAnVW5oYW5kbGVkUHJvbWlzZVJlamVjdGlvbldhcm5pbmcnIGxvZyBzcGFtLlxuICAgICAgICB0aGlzLmRlZmVycmVkLnByb21pc2UuY2F0Y2goZXJyID0+IHsgfSk7XG4gICAgfVxuICAgIGdldCBwcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWZlcnJlZC5wcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgRGVsYXllZE9wZXJhdGlvbiB0aGF0IGhhcyBiZWVuIHNjaGVkdWxlZCB0byBiZVxuICAgICAqIGV4ZWN1dGVkIG9uIHRoZSBwcm92aWRlZCBhc3luY1F1ZXVlIGFmdGVyIHRoZSBwcm92aWRlZCBkZWxheU1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzeW5jUXVldWUgLSBUaGUgcXVldWUgdG8gc2NoZWR1bGUgdGhlIG9wZXJhdGlvbiBvbi5cbiAgICAgKiBAcGFyYW0gaWQgLSBBIFRpbWVyIElEIGlkZW50aWZ5aW5nIHRoZSB0eXBlIG9mIG9wZXJhdGlvbiB0aGlzIGlzLlxuICAgICAqIEBwYXJhbSBkZWxheU1zIC0gVGhlIGRlbGF5IChtcykgYmVmb3JlIHRoZSBvcGVyYXRpb24gc2hvdWxkIGJlIHNjaGVkdWxlZC5cbiAgICAgKiBAcGFyYW0gb3AgLSBUaGUgb3BlcmF0aW9uIHRvIHJ1bi5cbiAgICAgKiBAcGFyYW0gcmVtb3ZhbENhbGxiYWNrIC0gQSBjYWxsYmFjayB0byBiZSBjYWxsZWQgc3luY2hyb25vdXNseSBvbmNlIHRoZVxuICAgICAqICAgb3BlcmF0aW9uIGlzIGV4ZWN1dGVkIG9yIGNhbmNlbGVkLCBub3RpZnlpbmcgdGhlIEFzeW5jUXVldWUgdG8gcmVtb3ZlIGl0XG4gICAgICogICBmcm9tIGl0cyBkZWxheWVkT3BlcmF0aW9ucyBsaXN0LlxuICAgICAqICAgUE9SVElORyBOT1RFOiBUaGlzIGV4aXN0cyB0byBwcmV2ZW50IG1ha2luZyByZW1vdmVEZWxheWVkT3BlcmF0aW9uKCkgYW5kXG4gICAgICogICB0aGUgRGVsYXllZE9wZXJhdGlvbiBjbGFzcyBwdWJsaWMuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUFuZFNjaGVkdWxlKGFzeW5jUXVldWUsIHRpbWVySWQsIGRlbGF5TXMsIG9wLCByZW1vdmFsQ2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0VGltZSA9IERhdGUubm93KCkgKyBkZWxheU1zO1xuICAgICAgICBjb25zdCBkZWxheWVkT3AgPSBuZXcgRGVsYXllZE9wZXJhdGlvbihhc3luY1F1ZXVlLCB0aW1lcklkLCB0YXJnZXRUaW1lLCBvcCwgcmVtb3ZhbENhbGxiYWNrKTtcbiAgICAgICAgZGVsYXllZE9wLnN0YXJ0KGRlbGF5TXMpO1xuICAgICAgICByZXR1cm4gZGVsYXllZE9wO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdGhlIHRpbWVyLiBUaGlzIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBjb25zdHJ1Y3Rpb24gYnlcbiAgICAgKiBjcmVhdGVBbmRTY2hlZHVsZSgpLlxuICAgICAqL1xuICAgIHN0YXJ0KGRlbGF5TXMpIHtcbiAgICAgICAgdGhpcy50aW1lckhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5oYW5kbGVEZWxheUVsYXBzZWQoKSwgZGVsYXlNcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXVlcyB0aGUgb3BlcmF0aW9uIHRvIHJ1biBpbW1lZGlhdGVseSAoaWYgaXQgaGFzbid0IGFscmVhZHkgYmVlbiBydW4gb3JcbiAgICAgKiBjYW5jZWxlZCkuXG4gICAgICovXG4gICAgc2tpcERlbGF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVEZWxheUVsYXBzZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VscyB0aGUgb3BlcmF0aW9uIGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gZXhlY3V0ZWQgb3IgY2FuY2VsZWQuIFRoZVxuICAgICAqIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZC5cbiAgICAgKlxuICAgICAqIEFzIGxvbmcgYXMgdGhlIG9wZXJhdGlvbiBoYXMgbm90IHlldCBiZWVuIHJ1biwgY2FsbGluZyBjYW5jZWwoKSBwcm92aWRlcyBhXG4gICAgICogZ3VhcmFudGVlIHRoYXQgdGhlIG9wZXJhdGlvbiB3aWxsIG5vdCBiZSBydW4uXG4gICAgICovXG4gICAgY2FuY2VsKHJlYXNvbikge1xuICAgICAgICBpZiAodGhpcy50aW1lckhhbmRsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQucmVqZWN0KG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkNBTkNFTExFRCwgJ09wZXJhdGlvbiBjYW5jZWxsZWQnICsgKHJlYXNvbiA/ICc6ICcgKyByZWFzb24gOiAnJykpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVEZWxheUVsYXBzZWQoKSB7XG4gICAgICAgIHRoaXMuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVySGFuZGxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcCgpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xlYXJUaW1lb3V0KCkge1xuICAgICAgICBpZiAodGhpcy50aW1lckhhbmRsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmFsQ2FsbGJhY2sodGhpcyk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lckhhbmRsZSk7XG4gICAgICAgICAgICB0aGlzLnRpbWVySGFuZGxlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyBhIEZpcmVzdG9yZUVycm9yIHRoYXQgY2FuIGJlIHN1cmZhY2VkIHRvIHRoZSB1c2VyIGlmIHRoZSBwcm92aWRlZFxuICogZXJyb3IgaXMgYW4gSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvci4gUmUtdGhyb3dzIHRoZSBlcnJvciBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIHdyYXBJblVzZXJFcnJvcklmUmVjb3ZlcmFibGUoZSwgbXNnKSB7XG4gICAgbG9nRXJyb3IoTE9HX1RBRyQ0LCBgJHttc2d9OiAke2V9YCk7XG4gICAgaWYgKGlzSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihlKSkge1xuICAgICAgICByZXR1cm4gbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5BVkFJTEFCTEUsIGAke21zZ306ICR7ZX1gKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBEb2N1bWVudFNldCBpcyBhbiBpbW11dGFibGUgKGNvcHktb24td3JpdGUpIGNvbGxlY3Rpb24gdGhhdCBob2xkcyBkb2N1bWVudHNcbiAqIGluIG9yZGVyIHNwZWNpZmllZCBieSB0aGUgcHJvdmlkZWQgY29tcGFyYXRvci4gV2UgYWx3YXlzIGFkZCBhIGRvY3VtZW50IGtleVxuICogY29tcGFyYXRvciBvbiB0b3Agb2Ygd2hhdCBpcyBwcm92aWRlZCB0byBndWFyYW50ZWUgZG9jdW1lbnQgZXF1YWxpdHkgYmFzZWQgb25cbiAqIHRoZSBrZXkuXG4gKi9cbmNsYXNzIERvY3VtZW50U2V0IHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGVtcHR5IGNvcHkgb2YgdGhlIGV4aXN0aW5nIERvY3VtZW50U2V0LCB1c2luZyB0aGUgc2FtZVxuICAgICAqIGNvbXBhcmF0b3IuXG4gICAgICovXG4gICAgc3RhdGljIGVtcHR5U2V0KG9sZFNldCkge1xuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50U2V0KG9sZFNldC5jb21wYXJhdG9yKTtcbiAgICB9XG4gICAgLyoqIFRoZSBkZWZhdWx0IG9yZGVyaW5nIGlzIGJ5IGtleSBpZiB0aGUgY29tcGFyYXRvciBpcyBvbWl0dGVkICovXG4gICAgY29uc3RydWN0b3IoY29tcCkge1xuICAgICAgICAvLyBXZSBhcmUgYWRkaW5nIGRvY3VtZW50IGtleSBjb21wYXJhdG9yIHRvIHRoZSBlbmQgYXMgaXQncyB0aGUgb25seVxuICAgICAgICAvLyBndWFyYW50ZWVkIHVuaXF1ZSBwcm9wZXJ0eSBvZiBhIGRvY3VtZW50LlxuICAgICAgICBpZiAoY29tcCkge1xuICAgICAgICAgICAgdGhpcy5jb21wYXJhdG9yID0gKGQxLCBkMikgPT4gY29tcChkMSwgZDIpIHx8IERvY3VtZW50S2V5LmNvbXBhcmF0b3IoZDEua2V5LCBkMi5rZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb21wYXJhdG9yID0gKGQxLCBkMikgPT4gRG9jdW1lbnRLZXkuY29tcGFyYXRvcihkMS5rZXksIGQyLmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZXllZE1hcCA9IGRvY3VtZW50TWFwKCk7XG4gICAgICAgIHRoaXMuc29ydGVkU2V0ID0gbmV3IFNvcnRlZE1hcCh0aGlzLmNvbXBhcmF0b3IpO1xuICAgIH1cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleWVkTWFwLmdldChrZXkpICE9IG51bGw7XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5ZWRNYXAuZ2V0KGtleSk7XG4gICAgfVxuICAgIGZpcnN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3J0ZWRTZXQubWluS2V5KCk7XG4gICAgfVxuICAgIGxhc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvcnRlZFNldC5tYXhLZXkoKTtcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ydGVkU2V0LmlzRW1wdHkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIHByb3ZpZGVkIGtleSBpbiB0aGUgZG9jdW1lbnQgc2V0LCBvciAtMSBpZiB0aGVcbiAgICAgKiBkb2N1bWVudCBrZXkgaXMgbm90IHByZXNlbnQgaW4gdGhlIHNldDtcbiAgICAgKi9cbiAgICBpbmRleE9mKGtleSkge1xuICAgICAgICBjb25zdCBkb2MgPSB0aGlzLmtleWVkTWFwLmdldChrZXkpO1xuICAgICAgICByZXR1cm4gZG9jID8gdGhpcy5zb3J0ZWRTZXQuaW5kZXhPZihkb2MpIDogLTE7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3J0ZWRTZXQuc2l6ZTtcbiAgICB9XG4gICAgLyoqIEl0ZXJhdGVzIGRvY3VtZW50cyBpbiBvcmRlciBkZWZpbmVkIGJ5IFwiY29tcGFyYXRvclwiICovXG4gICAgZm9yRWFjaChjYikge1xuICAgICAgICB0aGlzLnNvcnRlZFNldC5pbm9yZGVyVHJhdmVyc2FsKChrLCB2KSA9PiB7XG4gICAgICAgICAgICBjYihrKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBJbnNlcnRzIG9yIHVwZGF0ZXMgYSBkb2N1bWVudCB3aXRoIHRoZSBzYW1lIGtleSAqL1xuICAgIGFkZChkb2MpIHtcbiAgICAgICAgLy8gRmlyc3QgcmVtb3ZlIHRoZSBlbGVtZW50IGlmIHdlIGhhdmUgaXQuXG4gICAgICAgIGNvbnN0IHNldCA9IHRoaXMuZGVsZXRlKGRvYy5rZXkpO1xuICAgICAgICByZXR1cm4gc2V0LmNvcHkoc2V0LmtleWVkTWFwLmluc2VydChkb2Mua2V5LCBkb2MpLCBzZXQuc29ydGVkU2V0Lmluc2VydChkb2MsIG51bGwpKTtcbiAgICB9XG4gICAgLyoqIERlbGV0ZXMgYSBkb2N1bWVudCB3aXRoIGEgZ2l2ZW4ga2V5ICovXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCBkb2MgPSB0aGlzLmdldChrZXkpO1xuICAgICAgICBpZiAoIWRvYykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29weSh0aGlzLmtleWVkTWFwLnJlbW92ZShrZXkpLCB0aGlzLnNvcnRlZFNldC5yZW1vdmUoZG9jKSk7XG4gICAgfVxuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBEb2N1bWVudFNldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaXplICE9PSBvdGhlci5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGhpc0l0ID0gdGhpcy5zb3J0ZWRTZXQuZ2V0SXRlcmF0b3IoKTtcbiAgICAgICAgY29uc3Qgb3RoZXJJdCA9IG90aGVyLnNvcnRlZFNldC5nZXRJdGVyYXRvcigpO1xuICAgICAgICB3aGlsZSAodGhpc0l0Lmhhc05leHQoKSkge1xuICAgICAgICAgICAgY29uc3QgdGhpc0RvYyA9IHRoaXNJdC5nZXROZXh0KCkua2V5O1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJEb2MgPSBvdGhlckl0LmdldE5leHQoKS5rZXk7XG4gICAgICAgICAgICBpZiAoIXRoaXNEb2MuaXNFcXVhbChvdGhlckRvYykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBkb2NTdHJpbmdzID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaChkb2MgPT4ge1xuICAgICAgICAgICAgZG9jU3RyaW5ncy5wdXNoKGRvYy50b1N0cmluZygpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkb2NTdHJpbmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICdEb2N1bWVudFNldCAoKSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ0RvY3VtZW50U2V0IChcXG4gICcgKyBkb2NTdHJpbmdzLmpvaW4oJyAgXFxuJykgKyAnXFxuKSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29weShrZXllZE1hcCwgc29ydGVkU2V0KSB7XG4gICAgICAgIGNvbnN0IG5ld1NldCA9IG5ldyBEb2N1bWVudFNldCgpO1xuICAgICAgICBuZXdTZXQuY29tcGFyYXRvciA9IHRoaXMuY29tcGFyYXRvcjtcbiAgICAgICAgbmV3U2V0LmtleWVkTWFwID0ga2V5ZWRNYXA7XG4gICAgICAgIG5ld1NldC5zb3J0ZWRTZXQgPSBzb3J0ZWRTZXQ7XG4gICAgICAgIHJldHVybiBuZXdTZXQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBEb2N1bWVudENoYW5nZVNldCBrZWVwcyB0cmFjayBvZiBhIHNldCBvZiBjaGFuZ2VzIHRvIGRvY3MgaW4gYSBxdWVyeSwgbWVyZ2luZ1xuICogZHVwbGljYXRlIGV2ZW50cyBmb3IgdGhlIHNhbWUgZG9jLlxuICovXG5jbGFzcyBEb2N1bWVudENoYW5nZVNldCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlTWFwID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcbiAgICB9XG4gICAgdHJhY2soY2hhbmdlKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGNoYW5nZS5kb2Mua2V5O1xuICAgICAgICBjb25zdCBvbGRDaGFuZ2UgPSB0aGlzLmNoYW5nZU1hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFvbGRDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwID0gdGhpcy5jaGFuZ2VNYXAuaW5zZXJ0KGtleSwgY2hhbmdlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBNZXJnZSB0aGUgbmV3IGNoYW5nZSB3aXRoIHRoZSBleGlzdGluZyBjaGFuZ2UuXG4gICAgICAgIGlmIChjaGFuZ2UudHlwZSAhPT0gMCAvKiBDaGFuZ2VUeXBlLkFkZGVkICovICYmXG4gICAgICAgICAgICBvbGRDaGFuZ2UudHlwZSA9PT0gMyAvKiBDaGFuZ2VUeXBlLk1ldGFkYXRhICovKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZU1hcCA9IHRoaXMuY2hhbmdlTWFwLmluc2VydChrZXksIGNoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnR5cGUgPT09IDMgLyogQ2hhbmdlVHlwZS5NZXRhZGF0YSAqLyAmJlxuICAgICAgICAgICAgb2xkQ2hhbmdlLnR5cGUgIT09IDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZU1hcCA9IHRoaXMuY2hhbmdlTWFwLmluc2VydChrZXksIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBvbGRDaGFuZ2UudHlwZSxcbiAgICAgICAgICAgICAgICBkb2M6IGNoYW5nZS5kb2NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi8gJiZcbiAgICAgICAgICAgIG9sZENoYW5nZS50eXBlID09PSAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwID0gdGhpcy5jaGFuZ2VNYXAuaW5zZXJ0KGtleSwge1xuICAgICAgICAgICAgICAgIHR5cGU6IDIgLyogQ2hhbmdlVHlwZS5Nb2RpZmllZCAqLyxcbiAgICAgICAgICAgICAgICBkb2M6IGNoYW5nZS5kb2NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi8gJiZcbiAgICAgICAgICAgIG9sZENoYW5nZS50eXBlID09PSAwIC8qIENoYW5nZVR5cGUuQWRkZWQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwID0gdGhpcy5jaGFuZ2VNYXAuaW5zZXJ0KGtleSwge1xuICAgICAgICAgICAgICAgIHR5cGU6IDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLyxcbiAgICAgICAgICAgICAgICBkb2M6IGNoYW5nZS5kb2NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSAxIC8qIENoYW5nZVR5cGUuUmVtb3ZlZCAqLyAmJlxuICAgICAgICAgICAgb2xkQ2hhbmdlLnR5cGUgPT09IDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLykge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VNYXAgPSB0aGlzLmNoYW5nZU1hcC5yZW1vdmUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PT0gMSAvKiBDaGFuZ2VUeXBlLlJlbW92ZWQgKi8gJiZcbiAgICAgICAgICAgIG9sZENoYW5nZS50eXBlID09PSAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwID0gdGhpcy5jaGFuZ2VNYXAuaW5zZXJ0KGtleSwge1xuICAgICAgICAgICAgICAgIHR5cGU6IDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovLFxuICAgICAgICAgICAgICAgIGRvYzogb2xkQ2hhbmdlLmRvY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnR5cGUgPT09IDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLyAmJlxuICAgICAgICAgICAgb2xkQ2hhbmdlLnR5cGUgPT09IDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZU1hcCA9IHRoaXMuY2hhbmdlTWFwLmluc2VydChrZXksIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi8sXG4gICAgICAgICAgICAgICAgZG9jOiBjaGFuZ2UuZG9jXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaW5jbHVkZXMgdGhlc2UgY2FzZXMsIHdoaWNoIGRvbid0IG1ha2Ugc2Vuc2U6XG4gICAgICAgICAgICAvLyBBZGRlZC0+QWRkZWRcbiAgICAgICAgICAgIC8vIFJlbW92ZWQtPlJlbW92ZWRcbiAgICAgICAgICAgIC8vIE1vZGlmaWVkLT5BZGRlZFxuICAgICAgICAgICAgLy8gUmVtb3ZlZC0+TW9kaWZpZWRcbiAgICAgICAgICAgIC8vIE1ldGFkYXRhLT5BZGRlZFxuICAgICAgICAgICAgLy8gUmVtb3ZlZC0+TWV0YWRhdGFcbiAgICAgICAgICAgIGZhaWwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDaGFuZ2VzKCkge1xuICAgICAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgICAgIHRoaXMuY2hhbmdlTWFwLmlub3JkZXJUcmF2ZXJzYWwoKGtleSwgY2hhbmdlKSA9PiB7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjaGFuZ2VzO1xuICAgIH1cbn1cbmNsYXNzIFZpZXdTbmFwc2hvdCB7XG4gICAgY29uc3RydWN0b3IocXVlcnksIGRvY3MsIG9sZERvY3MsIGRvY0NoYW5nZXMsIG11dGF0ZWRLZXlzLCBmcm9tQ2FjaGUsIHN5bmNTdGF0ZUNoYW5nZWQsIGV4Y2x1ZGVzTWV0YWRhdGFDaGFuZ2VzLCBoYXNDYWNoZWRSZXN1bHRzKSB7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgdGhpcy5kb2NzID0gZG9jcztcbiAgICAgICAgdGhpcy5vbGREb2NzID0gb2xkRG9jcztcbiAgICAgICAgdGhpcy5kb2NDaGFuZ2VzID0gZG9jQ2hhbmdlcztcbiAgICAgICAgdGhpcy5tdXRhdGVkS2V5cyA9IG11dGF0ZWRLZXlzO1xuICAgICAgICB0aGlzLmZyb21DYWNoZSA9IGZyb21DYWNoZTtcbiAgICAgICAgdGhpcy5zeW5jU3RhdGVDaGFuZ2VkID0gc3luY1N0YXRlQ2hhbmdlZDtcbiAgICAgICAgdGhpcy5leGNsdWRlc01ldGFkYXRhQ2hhbmdlcyA9IGV4Y2x1ZGVzTWV0YWRhdGFDaGFuZ2VzO1xuICAgICAgICB0aGlzLmhhc0NhY2hlZFJlc3VsdHMgPSBoYXNDYWNoZWRSZXN1bHRzO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIHZpZXcgc25hcHNob3QgYXMgaWYgYWxsIGRvY3VtZW50cyBpbiB0aGUgc25hcHNob3Qgd2VyZSBhZGRlZC4gKi9cbiAgICBzdGF0aWMgZnJvbUluaXRpYWxEb2N1bWVudHMocXVlcnksIGRvY3VtZW50cywgbXV0YXRlZEtleXMsIGZyb21DYWNoZSwgaGFzQ2FjaGVkUmVzdWx0cykge1xuICAgICAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgICAgIGRvY3VtZW50cy5mb3JFYWNoKGRvYyA9PiB7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyB0eXBlOiAwIC8qIENoYW5nZVR5cGUuQWRkZWQgKi8sIGRvYyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgVmlld1NuYXBzaG90KHF1ZXJ5LCBkb2N1bWVudHMsIERvY3VtZW50U2V0LmVtcHR5U2V0KGRvY3VtZW50cyksIGNoYW5nZXMsIG11dGF0ZWRLZXlzLCBmcm9tQ2FjaGUsIFxuICAgICAgICAvKiBzeW5jU3RhdGVDaGFuZ2VkPSAqLyB0cnVlLCBcbiAgICAgICAgLyogZXhjbHVkZXNNZXRhZGF0YUNoYW5nZXM9ICovIGZhbHNlLCBoYXNDYWNoZWRSZXN1bHRzKTtcbiAgICB9XG4gICAgZ2V0IGhhc1BlbmRpbmdXcml0ZXMoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5tdXRhdGVkS2V5cy5pc0VtcHR5KCk7XG4gICAgfVxuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuZnJvbUNhY2hlICE9PSBvdGhlci5mcm9tQ2FjaGUgfHxcbiAgICAgICAgICAgIHRoaXMuaGFzQ2FjaGVkUmVzdWx0cyAhPT0gb3RoZXIuaGFzQ2FjaGVkUmVzdWx0cyB8fFxuICAgICAgICAgICAgdGhpcy5zeW5jU3RhdGVDaGFuZ2VkICE9PSBvdGhlci5zeW5jU3RhdGVDaGFuZ2VkIHx8XG4gICAgICAgICAgICAhdGhpcy5tdXRhdGVkS2V5cy5pc0VxdWFsKG90aGVyLm11dGF0ZWRLZXlzKSB8fFxuICAgICAgICAgICAgIXF1ZXJ5RXF1YWxzKHRoaXMucXVlcnksIG90aGVyLnF1ZXJ5KSB8fFxuICAgICAgICAgICAgIXRoaXMuZG9jcy5pc0VxdWFsKG90aGVyLmRvY3MpIHx8XG4gICAgICAgICAgICAhdGhpcy5vbGREb2NzLmlzRXF1YWwob3RoZXIub2xkRG9jcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5kb2NDaGFuZ2VzO1xuICAgICAgICBjb25zdCBvdGhlckNoYW5nZXMgPSBvdGhlci5kb2NDaGFuZ2VzO1xuICAgICAgICBpZiAoY2hhbmdlcy5sZW5ndGggIT09IG90aGVyQ2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzW2ldLnR5cGUgIT09IG90aGVyQ2hhbmdlc1tpXS50eXBlIHx8XG4gICAgICAgICAgICAgICAgIWNoYW5nZXNbaV0uZG9jLmlzRXF1YWwob3RoZXJDaGFuZ2VzW2ldLmRvYykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBIb2xkcyB0aGUgbGlzdGVuZXJzIGFuZCB0aGUgbGFzdCByZWNlaXZlZCBWaWV3U25hcHNob3QgZm9yIGEgcXVlcnkgYmVpbmdcbiAqIHRyYWNrZWQgYnkgRXZlbnRNYW5hZ2VyLlxuICovXG5jbGFzcyBRdWVyeUxpc3RlbmVyc0luZm8ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZpZXdTbmFwID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgIH1cbiAgICAvLyBIZWxwZXIgbWV0aG9kcyB0aGF0IGNoZWNrcyBpZiB0aGUgcXVlcnkgaGFzIGxpc3RlbmVycyB0aGF0IGxpc3RlbmluZyB0byByZW1vdGUgc3RvcmVcbiAgICBoYXNSZW1vdGVMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVycy5zb21lKGxpc3RlbmVyID0+IGxpc3RlbmVyLmxpc3RlbnNUb1JlbW90ZVN0b3JlKCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5ld0V2ZW50TWFuYWdlcigpIHtcbiAgICByZXR1cm4gbmV3IEV2ZW50TWFuYWdlckltcGwoKTtcbn1cbmNsYXNzIEV2ZW50TWFuYWdlckltcGwge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnF1ZXJpZXMgPSBuZXdRdWVyaWVzT2JqZWN0TWFwKCk7XG4gICAgICAgIHRoaXMub25saW5lU3RhdGUgPSBcIlVua25vd25cIiAvKiBPbmxpbmVTdGF0ZS5Vbmtub3duICovO1xuICAgICAgICB0aGlzLnNuYXBzaG90c0luU3luY0xpc3RlbmVycyA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgdGVybWluYXRlKCkge1xuICAgICAgICBlcnJvckFsbFRhcmdldHModGhpcywgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuQUJPUlRFRCwgJ0ZpcmVzdG9yZSBzaHV0dGluZyBkb3duJykpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5ld1F1ZXJpZXNPYmplY3RNYXAoKSB7XG4gICAgcmV0dXJuIG5ldyBPYmplY3RNYXAocSA9PiBjYW5vbmlmeVF1ZXJ5KHEpLCBxdWVyeUVxdWFscyk7XG59XG5hc3luYyBmdW5jdGlvbiBldmVudE1hbmFnZXJMaXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IGV2ZW50TWFuYWdlckltcGwgPSBkZWJ1Z0Nhc3QoZXZlbnRNYW5hZ2VyKTtcbiAgICBsZXQgbGlzdGVuZXJBY3Rpb24gPSAzIC8qIExpc3RlbmVyU2V0dXBBY3Rpb24uTm9BY3Rpb25SZXF1aXJlZCAqLztcbiAgICBjb25zdCBxdWVyeSA9IGxpc3RlbmVyLnF1ZXJ5O1xuICAgIGxldCBxdWVyeUluZm8gPSBldmVudE1hbmFnZXJJbXBsLnF1ZXJpZXMuZ2V0KHF1ZXJ5KTtcbiAgICBpZiAoIXF1ZXJ5SW5mbykge1xuICAgICAgICBxdWVyeUluZm8gPSBuZXcgUXVlcnlMaXN0ZW5lcnNJbmZvKCk7XG4gICAgICAgIGxpc3RlbmVyQWN0aW9uID0gbGlzdGVuZXIubGlzdGVuc1RvUmVtb3RlU3RvcmUoKVxuICAgICAgICAgICAgPyAwIC8qIExpc3RlbmVyU2V0dXBBY3Rpb24uSW5pdGlhbGl6ZUxvY2FsTGlzdGVuQW5kUmVxdWlyZVdhdGNoQ29ubmVjdGlvbiAqL1xuICAgICAgICAgICAgOiAxIC8qIExpc3RlbmVyU2V0dXBBY3Rpb24uSW5pdGlhbGl6ZUxvY2FsTGlzdGVuT25seSAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoIXF1ZXJ5SW5mby5oYXNSZW1vdGVMaXN0ZW5lcnMoKSAmJlxuICAgICAgICBsaXN0ZW5lci5saXN0ZW5zVG9SZW1vdGVTdG9yZSgpKSB7XG4gICAgICAgIC8vIFF1ZXJ5IGhhcyBiZWVuIGxpc3RlbmluZyB0byBsb2NhbCBjYWNoZSwgYW5kIHRyaWVzIHRvIGFkZCBhIG5ldyBsaXN0ZW5lciBzb3VyY2VkIGZyb20gd2F0Y2guXG4gICAgICAgIGxpc3RlbmVyQWN0aW9uID0gMiAvKiBMaXN0ZW5lclNldHVwQWN0aW9uLlJlcXVpcmVXYXRjaENvbm5lY3Rpb25Pbmx5ICovO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBzd2l0Y2ggKGxpc3RlbmVyQWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIDAgLyogTGlzdGVuZXJTZXR1cEFjdGlvbi5Jbml0aWFsaXplTG9jYWxMaXN0ZW5BbmRSZXF1aXJlV2F0Y2hDb25uZWN0aW9uICovOlxuICAgICAgICAgICAgICAgIHF1ZXJ5SW5mby52aWV3U25hcCA9IGF3YWl0IGV2ZW50TWFuYWdlckltcGwub25MaXN0ZW4ocXVlcnksIFxuICAgICAgICAgICAgICAgIC8qKiBlbmFibGVSZW1vdGVMaXN0ZW49ICovIHRydWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxIC8qIExpc3RlbmVyU2V0dXBBY3Rpb24uSW5pdGlhbGl6ZUxvY2FsTGlzdGVuT25seSAqLzpcbiAgICAgICAgICAgICAgICBxdWVyeUluZm8udmlld1NuYXAgPSBhd2FpdCBldmVudE1hbmFnZXJJbXBsLm9uTGlzdGVuKHF1ZXJ5LCBcbiAgICAgICAgICAgICAgICAvKiogZW5hYmxlUmVtb3RlTGlzdGVuPSAqLyBmYWxzZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIgLyogTGlzdGVuZXJTZXR1cEFjdGlvbi5SZXF1aXJlV2F0Y2hDb25uZWN0aW9uT25seSAqLzpcbiAgICAgICAgICAgICAgICBhd2FpdCBldmVudE1hbmFnZXJJbXBsLm9uRmlyc3RSZW1vdGVTdG9yZUxpc3RlbihxdWVyeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IGZpcmVzdG9yZUVycm9yID0gd3JhcEluVXNlckVycm9ySWZSZWNvdmVyYWJsZShlLCBgSW5pdGlhbGl6YXRpb24gb2YgcXVlcnkgJyR7c3RyaW5naWZ5UXVlcnkobGlzdGVuZXIucXVlcnkpfScgZmFpbGVkYCk7XG4gICAgICAgIGxpc3RlbmVyLm9uRXJyb3IoZmlyZXN0b3JlRXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50TWFuYWdlckltcGwucXVlcmllcy5zZXQocXVlcnksIHF1ZXJ5SW5mbyk7XG4gICAgcXVlcnlJbmZvLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAvLyBSdW4gZ2xvYmFsIHNuYXBzaG90IGxpc3RlbmVycyBpZiBhIGNvbnNpc3RlbnQgc25hcHNob3QgaGFzIGJlZW4gZW1pdHRlZC5cbiAgICBsaXN0ZW5lci5hcHBseU9ubGluZVN0YXRlQ2hhbmdlKGV2ZW50TWFuYWdlckltcGwub25saW5lU3RhdGUpO1xuICAgIGlmIChxdWVyeUluZm8udmlld1NuYXApIHtcbiAgICAgICAgY29uc3QgcmFpc2VkRXZlbnQgPSBsaXN0ZW5lci5vblZpZXdTbmFwc2hvdChxdWVyeUluZm8udmlld1NuYXApO1xuICAgICAgICBpZiAocmFpc2VkRXZlbnQpIHtcbiAgICAgICAgICAgIHJhaXNlU25hcHNob3RzSW5TeW5jRXZlbnQoZXZlbnRNYW5hZ2VySW1wbCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBldmVudE1hbmFnZXJVbmxpc3RlbihldmVudE1hbmFnZXIsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgZXZlbnRNYW5hZ2VySW1wbCA9IGRlYnVnQ2FzdChldmVudE1hbmFnZXIpO1xuICAgIGNvbnN0IHF1ZXJ5ID0gbGlzdGVuZXIucXVlcnk7XG4gICAgbGV0IGxpc3RlbmVyQWN0aW9uID0gMyAvKiBMaXN0ZW5lclJlbW92YWxBY3Rpb24uTm9BY3Rpb25SZXF1aXJlZCAqLztcbiAgICBjb25zdCBxdWVyeUluZm8gPSBldmVudE1hbmFnZXJJbXBsLnF1ZXJpZXMuZ2V0KHF1ZXJ5KTtcbiAgICBpZiAocXVlcnlJbmZvKSB7XG4gICAgICAgIGNvbnN0IGkgPSBxdWVyeUluZm8ubGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgICAgICBxdWVyeUluZm8ubGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGlmIChxdWVyeUluZm8ubGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyQWN0aW9uID0gbGlzdGVuZXIubGlzdGVuc1RvUmVtb3RlU3RvcmUoKVxuICAgICAgICAgICAgICAgICAgICA/IDAgLyogTGlzdGVuZXJSZW1vdmFsQWN0aW9uLlRlcm1pbmF0ZUxvY2FsTGlzdGVuQW5kUmVxdWlyZVdhdGNoRGlzY29ubmVjdGlvbiAqL1xuICAgICAgICAgICAgICAgICAgICA6IDEgLyogTGlzdGVuZXJSZW1vdmFsQWN0aW9uLlRlcm1pbmF0ZUxvY2FsTGlzdGVuT25seSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFxdWVyeUluZm8uaGFzUmVtb3RlTGlzdGVuZXJzKCkgJiZcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5zVG9SZW1vdGVTdG9yZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlbW92ZWQgbGlzdGVuZXIgaXMgdGhlIGxhc3Qgb25lIHRoYXQgc291cmNlZCBmcm9tIHdhdGNoLlxuICAgICAgICAgICAgICAgIGxpc3RlbmVyQWN0aW9uID0gMiAvKiBMaXN0ZW5lclJlbW92YWxBY3Rpb24uUmVxdWlyZVdhdGNoRGlzY29ubmVjdGlvbk9ubHkgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoIChsaXN0ZW5lckFjdGlvbikge1xuICAgICAgICBjYXNlIDAgLyogTGlzdGVuZXJSZW1vdmFsQWN0aW9uLlRlcm1pbmF0ZUxvY2FsTGlzdGVuQW5kUmVxdWlyZVdhdGNoRGlzY29ubmVjdGlvbiAqLzpcbiAgICAgICAgICAgIGV2ZW50TWFuYWdlckltcGwucXVlcmllcy5kZWxldGUocXVlcnkpO1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50TWFuYWdlckltcGwub25Vbmxpc3RlbihxdWVyeSwgXG4gICAgICAgICAgICAvKiogZGlzYWJsZVJlbW90ZUxpc3Rlbj0gKi8gdHJ1ZSk7XG4gICAgICAgIGNhc2UgMSAvKiBMaXN0ZW5lclJlbW92YWxBY3Rpb24uVGVybWluYXRlTG9jYWxMaXN0ZW5Pbmx5ICovOlxuICAgICAgICAgICAgZXZlbnRNYW5hZ2VySW1wbC5xdWVyaWVzLmRlbGV0ZShxdWVyeSk7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRNYW5hZ2VySW1wbC5vblVubGlzdGVuKHF1ZXJ5LCBcbiAgICAgICAgICAgIC8qKiBkaXNhYmxlUmVtb3RlTGlzdGVuPSAqLyBmYWxzZSk7XG4gICAgICAgIGNhc2UgMiAvKiBMaXN0ZW5lclJlbW92YWxBY3Rpb24uUmVxdWlyZVdhdGNoRGlzY29ubmVjdGlvbk9ubHkgKi86XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRNYW5hZ2VySW1wbC5vbkxhc3RSZW1vdGVTdG9yZVVubGlzdGVuKHF1ZXJ5KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybjtcbiAgICB9XG59XG5mdW5jdGlvbiBldmVudE1hbmFnZXJPbldhdGNoQ2hhbmdlKGV2ZW50TWFuYWdlciwgdmlld1NuYXBzKSB7XG4gICAgY29uc3QgZXZlbnRNYW5hZ2VySW1wbCA9IGRlYnVnQ2FzdChldmVudE1hbmFnZXIpO1xuICAgIGxldCByYWlzZWRFdmVudCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3Qgdmlld1NuYXAgb2Ygdmlld1NuYXBzKSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gdmlld1NuYXAucXVlcnk7XG4gICAgICAgIGNvbnN0IHF1ZXJ5SW5mbyA9IGV2ZW50TWFuYWdlckltcGwucXVlcmllcy5nZXQocXVlcnkpO1xuICAgICAgICBpZiAocXVlcnlJbmZvKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHF1ZXJ5SW5mby5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIub25WaWV3U25hcHNob3Qodmlld1NuYXApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhaXNlZEV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWVyeUluZm8udmlld1NuYXAgPSB2aWV3U25hcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocmFpc2VkRXZlbnQpIHtcbiAgICAgICAgcmFpc2VTbmFwc2hvdHNJblN5bmNFdmVudChldmVudE1hbmFnZXJJbXBsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBldmVudE1hbmFnZXJPbldhdGNoRXJyb3IoZXZlbnRNYW5hZ2VyLCBxdWVyeSwgZXJyb3IpIHtcbiAgICBjb25zdCBldmVudE1hbmFnZXJJbXBsID0gZGVidWdDYXN0KGV2ZW50TWFuYWdlcik7XG4gICAgY29uc3QgcXVlcnlJbmZvID0gZXZlbnRNYW5hZ2VySW1wbC5xdWVyaWVzLmdldChxdWVyeSk7XG4gICAgaWYgKHF1ZXJ5SW5mbykge1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHF1ZXJ5SW5mby5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzLiBOT1RFOiBXZSBkb24ndCBuZWVkIHRvIGNhbGwgc3luY0VuZ2luZS51bmxpc3RlbigpXG4gICAgLy8gYWZ0ZXIgYW4gZXJyb3IuXG4gICAgZXZlbnRNYW5hZ2VySW1wbC5xdWVyaWVzLmRlbGV0ZShxdWVyeSk7XG59XG5mdW5jdGlvbiBldmVudE1hbmFnZXJPbk9ubGluZVN0YXRlQ2hhbmdlKGV2ZW50TWFuYWdlciwgb25saW5lU3RhdGUpIHtcbiAgICBjb25zdCBldmVudE1hbmFnZXJJbXBsID0gZGVidWdDYXN0KGV2ZW50TWFuYWdlcik7XG4gICAgZXZlbnRNYW5hZ2VySW1wbC5vbmxpbmVTdGF0ZSA9IG9ubGluZVN0YXRlO1xuICAgIGxldCByYWlzZWRFdmVudCA9IGZhbHNlO1xuICAgIGV2ZW50TWFuYWdlckltcGwucXVlcmllcy5mb3JFYWNoKChfLCBxdWVyeUluZm8pID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBxdWVyeUluZm8ubGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAvLyBSdW4gZ2xvYmFsIHNuYXBzaG90IGxpc3RlbmVycyBpZiBhIGNvbnNpc3RlbnQgc25hcHNob3QgaGFzIGJlZW4gZW1pdHRlZC5cbiAgICAgICAgICAgIGlmIChsaXN0ZW5lci5hcHBseU9ubGluZVN0YXRlQ2hhbmdlKG9ubGluZVN0YXRlKSkge1xuICAgICAgICAgICAgICAgIHJhaXNlZEV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChyYWlzZWRFdmVudCkge1xuICAgICAgICByYWlzZVNuYXBzaG90c0luU3luY0V2ZW50KGV2ZW50TWFuYWdlckltcGwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZFNuYXBzaG90c0luU3luY0xpc3RlbmVyKGV2ZW50TWFuYWdlciwgb2JzZXJ2ZXIpIHtcbiAgICBjb25zdCBldmVudE1hbmFnZXJJbXBsID0gZGVidWdDYXN0KGV2ZW50TWFuYWdlcik7XG4gICAgZXZlbnRNYW5hZ2VySW1wbC5zbmFwc2hvdHNJblN5bmNMaXN0ZW5lcnMuYWRkKG9ic2VydmVyKTtcbiAgICAvLyBJbW1lZGlhdGVseSBmaXJlIGFuIGluaXRpYWwgZXZlbnQsIGluZGljYXRpbmcgYWxsIGV4aXN0aW5nIGxpc3RlbmVyc1xuICAgIC8vIGFyZSBpbi1zeW5jLlxuICAgIG9ic2VydmVyLm5leHQoKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVNuYXBzaG90c0luU3luY0xpc3RlbmVyKGV2ZW50TWFuYWdlciwgb2JzZXJ2ZXIpIHtcbiAgICBjb25zdCBldmVudE1hbmFnZXJJbXBsID0gZGVidWdDYXN0KGV2ZW50TWFuYWdlcik7XG4gICAgZXZlbnRNYW5hZ2VySW1wbC5zbmFwc2hvdHNJblN5bmNMaXN0ZW5lcnMuZGVsZXRlKG9ic2VydmVyKTtcbn1cbmZ1bmN0aW9uIGVycm9yQWxsVGFyZ2V0cyhldmVudE1hbmFnZXIsIGVycm9yKSB7XG4gICAgY29uc3QgZXZlbnRNYW5hZ2VySW1wbCA9IGRlYnVnQ2FzdChldmVudE1hbmFnZXIpO1xuICAgIGNvbnN0IHF1ZXJpZXMgPSBldmVudE1hbmFnZXJJbXBsLnF1ZXJpZXM7XG4gICAgLy8gUHJldmVudCBmdXJ0aGVyIGFjY2VzcyBieSBjbGVhcmluZyBPYmplY3RNYXAuXG4gICAgZXZlbnRNYW5hZ2VySW1wbC5xdWVyaWVzID0gbmV3UXVlcmllc09iamVjdE1hcCgpO1xuICAgIHF1ZXJpZXMuZm9yRWFjaCgoXywgcXVlcnlJbmZvKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgcXVlcnlJbmZvLmxpc3RlbmVycykge1xuICAgICAgICAgICAgbGlzdGVuZXIub25FcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8vIENhbGwgYWxsIGdsb2JhbCBzbmFwc2hvdCBsaXN0ZW5lcnMgdGhhdCBoYXZlIGJlZW4gc2V0LlxuZnVuY3Rpb24gcmFpc2VTbmFwc2hvdHNJblN5bmNFdmVudChldmVudE1hbmFnZXJJbXBsKSB7XG4gICAgZXZlbnRNYW5hZ2VySW1wbC5zbmFwc2hvdHNJblN5bmNMaXN0ZW5lcnMuZm9yRWFjaChvYnNlcnZlciA9PiB7XG4gICAgICAgIG9ic2VydmVyLm5leHQoKTtcbiAgICB9KTtcbn1cbnZhciBMaXN0ZW5lckRhdGFTb3VyY2U7XG4oZnVuY3Rpb24gKExpc3RlbmVyRGF0YVNvdXJjZSkge1xuICAgIC8qKiBMaXN0ZW4gdG8gYm90aCBjYWNoZSBhbmQgc2VydmVyIGNoYW5nZXMgKi9cbiAgICBMaXN0ZW5lckRhdGFTb3VyY2VbXCJEZWZhdWx0XCJdID0gXCJkZWZhdWx0XCI7XG4gICAgLyoqIExpc3RlbiB0byBjaGFuZ2VzIGluIGNhY2hlIG9ubHkgKi9cbiAgICBMaXN0ZW5lckRhdGFTb3VyY2VbXCJDYWNoZVwiXSA9IFwiY2FjaGVcIjtcbn0pKExpc3RlbmVyRGF0YVNvdXJjZSB8fCAoTGlzdGVuZXJEYXRhU291cmNlID0ge30pKTtcbi8qKlxuICogUXVlcnlMaXN0ZW5lciB0YWtlcyBhIHNlcmllcyBvZiBpbnRlcm5hbCB2aWV3IHNuYXBzaG90cyBhbmQgZGV0ZXJtaW5lc1xuICogd2hlbiB0byByYWlzZSB0aGUgZXZlbnQuXG4gKlxuICogSXQgdXNlcyBhbiBPYnNlcnZlciB0byBkaXNwYXRjaCBldmVudHMuXG4gKi9cbmNsYXNzIFF1ZXJ5TGlzdGVuZXIge1xuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5LCBxdWVyeU9ic2VydmVyLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgdGhpcy5xdWVyeU9ic2VydmVyID0gcXVlcnlPYnNlcnZlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWwgc25hcHNob3RzIChlLmcuIGZyb20gY2FjaGUpIG1heSBub3QgYmUgcHJvcGFnYXRlZCB0byB0aGUgd3JhcHBlZFxuICAgICAgICAgKiBvYnNlcnZlci4gVGhpcyBmbGFnIGlzIHNldCB0byB0cnVlIG9uY2Ugd2UndmUgYWN0dWFsbHkgcmFpc2VkIGFuIGV2ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYWlzZWRJbml0aWFsRXZlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zbmFwID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZSA9IFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi87XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIG5ldyBWaWV3U25hcHNob3QgdG8gdGhpcyBsaXN0ZW5lciwgcmFpc2luZyBhIHVzZXItZmFjaW5nIGV2ZW50XG4gICAgICogaWYgYXBwbGljYWJsZSAoZGVwZW5kaW5nIG9uIHdoYXQgY2hhbmdlZCwgd2hldGhlciB0aGUgdXNlciBoYXMgb3B0ZWQgaW50b1xuICAgICAqIG1ldGFkYXRhLW9ubHkgY2hhbmdlcywgZXRjLikuIFJldHVybnMgdHJ1ZSBpZiBhIHVzZXItZmFjaW5nIGV2ZW50IHdhc1xuICAgICAqIGluZGVlZCByYWlzZWQuXG4gICAgICovXG4gICAgb25WaWV3U25hcHNob3Qoc25hcCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pbmNsdWRlTWV0YWRhdGFDaGFuZ2VzKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG1ldGFkYXRhIG9ubHkgY2hhbmdlcy5cbiAgICAgICAgICAgIGNvbnN0IGRvY0NoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZG9jQ2hhbmdlIG9mIHNuYXAuZG9jQ2hhbmdlcykge1xuICAgICAgICAgICAgICAgIGlmIChkb2NDaGFuZ2UudHlwZSAhPT0gMyAvKiBDaGFuZ2VUeXBlLk1ldGFkYXRhICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY0NoYW5nZXMucHVzaChkb2NDaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNuYXAgPSBuZXcgVmlld1NuYXBzaG90KHNuYXAucXVlcnksIHNuYXAuZG9jcywgc25hcC5vbGREb2NzLCBkb2NDaGFuZ2VzLCBzbmFwLm11dGF0ZWRLZXlzLCBzbmFwLmZyb21DYWNoZSwgc25hcC5zeW5jU3RhdGVDaGFuZ2VkLCBcbiAgICAgICAgICAgIC8qIGV4Y2x1ZGVzTWV0YWRhdGFDaGFuZ2VzPSAqLyB0cnVlLCBzbmFwLmhhc0NhY2hlZFJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByYWlzZWRFdmVudCA9IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMucmFpc2VkSW5pdGlhbEV2ZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zaG91bGRSYWlzZUluaXRpYWxFdmVudChzbmFwLCB0aGlzLm9ubGluZVN0YXRlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmFpc2VJbml0aWFsRXZlbnQoc25hcCk7XG4gICAgICAgICAgICAgICAgcmFpc2VkRXZlbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2hvdWxkUmFpc2VFdmVudChzbmFwKSkge1xuICAgICAgICAgICAgdGhpcy5xdWVyeU9ic2VydmVyLm5leHQoc25hcCk7XG4gICAgICAgICAgICByYWlzZWRFdmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zbmFwID0gc25hcDtcbiAgICAgICAgcmV0dXJuIHJhaXNlZEV2ZW50O1xuICAgIH1cbiAgICBvbkVycm9yKGVycm9yKSB7XG4gICAgICAgIHRoaXMucXVlcnlPYnNlcnZlci5lcnJvcihlcnJvcik7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHdoZXRoZXIgYSBzbmFwc2hvdCB3YXMgcmFpc2VkLiAqL1xuICAgIGFwcGx5T25saW5lU3RhdGVDaGFuZ2Uob25saW5lU3RhdGUpIHtcbiAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZSA9IG9ubGluZVN0YXRlO1xuICAgICAgICBsZXQgcmFpc2VkRXZlbnQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuc25hcCAmJlxuICAgICAgICAgICAgIXRoaXMucmFpc2VkSW5pdGlhbEV2ZW50ICYmXG4gICAgICAgICAgICB0aGlzLnNob3VsZFJhaXNlSW5pdGlhbEV2ZW50KHRoaXMuc25hcCwgb25saW5lU3RhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlSW5pdGlhbEV2ZW50KHRoaXMuc25hcCk7XG4gICAgICAgICAgICByYWlzZWRFdmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhaXNlZEV2ZW50O1xuICAgIH1cbiAgICBzaG91bGRSYWlzZUluaXRpYWxFdmVudChzbmFwLCBvbmxpbmVTdGF0ZSkge1xuICAgICAgICAvLyBBbHdheXMgcmFpc2UgdGhlIGZpcnN0IGV2ZW50IHdoZW4gd2UncmUgc3luY2VkXG4gICAgICAgIGlmICghc25hcC5mcm9tQ2FjaGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsd2F5cyByYWlzZSBldmVudCBpZiBsaXN0ZW5pbmcgdG8gY2FjaGVcbiAgICAgICAgaWYgKCF0aGlzLmxpc3RlbnNUb1JlbW90ZVN0b3JlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5PVEU6IFdlIGNvbnNpZGVyIE9ubGluZVN0YXRlLlVua25vd24gYXMgb25saW5lIChpdCBzaG91bGQgYmVjb21lIE9mZmxpbmVcbiAgICAgICAgLy8gb3IgT25saW5lIGlmIHdlIHdhaXQgbG9uZyBlbm91Z2gpLlxuICAgICAgICBjb25zdCBtYXliZU9ubGluZSA9IG9ubGluZVN0YXRlICE9PSBcIk9mZmxpbmVcIiAvKiBPbmxpbmVTdGF0ZS5PZmZsaW5lICovO1xuICAgICAgICAvLyBEb24ndCByYWlzZSB0aGUgZXZlbnQgaWYgd2UncmUgb25saW5lLCBhcmVuJ3Qgc3luY2VkIHlldCAoY2hlY2tlZFxuICAgICAgICAvLyBhYm92ZSkgYW5kIGFyZSB3YWl0aW5nIGZvciBhIHN5bmMuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMud2FpdEZvclN5bmNXaGVuT25saW5lICYmIG1heWJlT25saW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmFpc2UgZGF0YSBmcm9tIGNhY2hlIGlmIHdlIGhhdmUgYW55IGRvY3VtZW50cywgaGF2ZSBjYWNoZWQgcmVzdWx0cyBiZWZvcmUsXG4gICAgICAgIC8vIG9yIHdlIGFyZSBvZmZsaW5lLlxuICAgICAgICByZXR1cm4gKCFzbmFwLmRvY3MuaXNFbXB0eSgpIHx8XG4gICAgICAgICAgICBzbmFwLmhhc0NhY2hlZFJlc3VsdHMgfHxcbiAgICAgICAgICAgIG9ubGluZVN0YXRlID09PSBcIk9mZmxpbmVcIiAvKiBPbmxpbmVTdGF0ZS5PZmZsaW5lICovKTtcbiAgICB9XG4gICAgc2hvdWxkUmFpc2VFdmVudChzbmFwKSB7XG4gICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gaGFuZGxlIGluY2x1ZGVEb2N1bWVudE1ldGFkYXRhQ2hhbmdlcyBoZXJlIGJlY2F1c2VcbiAgICAgICAgLy8gdGhlIE1ldGFkYXRhIG9ubHkgY2hhbmdlcyBoYXZlIGFscmVhZHkgYmVlbiBzdHJpcHBlZCBvdXQgaWYgbmVlZGVkLlxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBvbmx5IGNoYW5nZXMgd2Ugd2lsbCBzZWUgYXJlIHRoZSBvbmVzIHdlIHNob3VsZFxuICAgICAgICAvLyBwcm9wYWdhdGUuXG4gICAgICAgIGlmIChzbmFwLmRvY0NoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzUGVuZGluZ1dyaXRlc0NoYW5nZWQgPSB0aGlzLnNuYXAgJiYgdGhpcy5zbmFwLmhhc1BlbmRpbmdXcml0ZXMgIT09IHNuYXAuaGFzUGVuZGluZ1dyaXRlcztcbiAgICAgICAgaWYgKHNuYXAuc3luY1N0YXRlQ2hhbmdlZCB8fCBoYXNQZW5kaW5nV3JpdGVzQ2hhbmdlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pbmNsdWRlTWV0YWRhdGFDaGFuZ2VzID09PSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdlbmVyYWxseSB3ZSBzaG91bGQgaGF2ZSBoaXQgb25lIG9mIHRoZSBjYXNlcyBhYm92ZSwgYnV0IGl0J3MgcG9zc2libGVcbiAgICAgICAgLy8gdG8gZ2V0IGhlcmUgaWYgdGhlcmUgd2VyZSBvbmx5IG1ldGFkYXRhIGRvY0NoYW5nZXMgYW5kIHRoZXkgZ290XG4gICAgICAgIC8vIHN0cmlwcGVkIG91dC5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByYWlzZUluaXRpYWxFdmVudChzbmFwKSB7XG4gICAgICAgIHNuYXAgPSBWaWV3U25hcHNob3QuZnJvbUluaXRpYWxEb2N1bWVudHMoc25hcC5xdWVyeSwgc25hcC5kb2NzLCBzbmFwLm11dGF0ZWRLZXlzLCBzbmFwLmZyb21DYWNoZSwgc25hcC5oYXNDYWNoZWRSZXN1bHRzKTtcbiAgICAgICAgdGhpcy5yYWlzZWRJbml0aWFsRXZlbnQgPSB0cnVlO1xuICAgICAgICB0aGlzLnF1ZXJ5T2JzZXJ2ZXIubmV4dChzbmFwKTtcbiAgICB9XG4gICAgbGlzdGVuc1RvUmVtb3RlU3RvcmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc291cmNlICE9PSBMaXN0ZW5lckRhdGFTb3VyY2UuQ2FjaGU7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIHNldCBvZiBjaGFuZ2VzIHRvIHdoYXQgZG9jdW1lbnRzIGFyZSBjdXJyZW50bHkgaW4gdmlldyBhbmQgb3V0IG9mIHZpZXcgZm9yXG4gKiBhIGdpdmVuIHF1ZXJ5LiBUaGVzZSBjaGFuZ2VzIGFyZSBzZW50IHRvIHRoZSBMb2NhbFN0b3JlIGJ5IHRoZSBWaWV3ICh2aWFcbiAqIHRoZSBTeW5jRW5naW5lKSBhbmQgYXJlIHVzZWQgdG8gcGluIC8gdW5waW4gZG9jdW1lbnRzIGFzIGFwcHJvcHJpYXRlLlxuICovXG5jbGFzcyBMb2NhbFZpZXdDaGFuZ2VzIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXRJZCwgZnJvbUNhY2hlLCBhZGRlZEtleXMsIHJlbW92ZWRLZXlzKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0SWQgPSB0YXJnZXRJZDtcbiAgICAgICAgdGhpcy5mcm9tQ2FjaGUgPSBmcm9tQ2FjaGU7XG4gICAgICAgIHRoaXMuYWRkZWRLZXlzID0gYWRkZWRLZXlzO1xuICAgICAgICB0aGlzLnJlbW92ZWRLZXlzID0gcmVtb3ZlZEtleXM7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU25hcHNob3QodGFyZ2V0SWQsIHZpZXdTbmFwc2hvdCkge1xuICAgICAgICBsZXQgYWRkZWRLZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgbGV0IHJlbW92ZWRLZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCBkb2NDaGFuZ2Ugb2Ygdmlld1NuYXBzaG90LmRvY0NoYW5nZXMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZG9jQ2hhbmdlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLzpcbiAgICAgICAgICAgICAgICAgICAgYWRkZWRLZXlzID0gYWRkZWRLZXlzLmFkZChkb2NDaGFuZ2UuZG9jLmtleSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBDaGFuZ2VUeXBlLlJlbW92ZWQgKi86XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWRLZXlzID0gcmVtb3ZlZEtleXMuYWRkKGRvY0NoYW5nZS5kb2Mua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTG9jYWxWaWV3Q2hhbmdlcyh0YXJnZXRJZCwgdmlld1NuYXBzaG90LmZyb21DYWNoZSwgYWRkZWRLZXlzLCByZW1vdmVkS2V5cyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBIZWxwZXIgdG8gY29udmVydCBvYmplY3RzIGZyb20gYnVuZGxlcyB0byBtb2RlbCBvYmplY3RzIGluIHRoZSBTREsuXG4gKi9cbmNsYXNzIEJ1bmRsZUNvbnZlcnRlckltcGwge1xuICAgIGNvbnN0cnVjdG9yKHNlcmlhbGl6ZXIpIHtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcbiAgICB9XG4gICAgdG9Eb2N1bWVudEtleShuYW1lKSB7XG4gICAgICAgIHJldHVybiBmcm9tTmFtZSh0aGlzLnNlcmlhbGl6ZXIsIG5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIEJ1bmRsZURvY3VtZW50IHRvIGEgTXV0YWJsZURvY3VtZW50LlxuICAgICAqL1xuICAgIHRvTXV0YWJsZURvY3VtZW50KGJ1bmRsZWREb2MpIHtcbiAgICAgICAgaWYgKGJ1bmRsZWREb2MubWV0YWRhdGEuZXhpc3RzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbURvY3VtZW50KHRoaXMuc2VyaWFsaXplciwgYnVuZGxlZERvYy5kb2N1bWVudCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE11dGFibGVEb2N1bWVudC5uZXdOb0RvY3VtZW50KHRoaXMudG9Eb2N1bWVudEtleShidW5kbGVkRG9jLm1ldGFkYXRhLm5hbWUpLCB0aGlzLnRvU25hcHNob3RWZXJzaW9uKGJ1bmRsZWREb2MubWV0YWRhdGEucmVhZFRpbWUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1NuYXBzaG90VmVyc2lvbih0aW1lKSB7XG4gICAgICAgIHJldHVybiBmcm9tVmVyc2lvbih0aW1lKTtcbiAgICB9XG59XG4vKipcbiAqIEEgY2xhc3MgdG8gcHJvY2VzcyB0aGUgZWxlbWVudHMgZnJvbSBhIGJ1bmRsZSwgbG9hZCB0aGVtIGludG8gbG9jYWxcbiAqIHN0b3JhZ2UgYW5kIHByb3ZpZGUgcHJvZ3Jlc3MgdXBkYXRlIHdoaWxlIGxvYWRpbmcuXG4gKi9cbmNsYXNzIEJ1bmRsZUxvYWRlciB7XG4gICAgY29uc3RydWN0b3IoYnVuZGxlTWV0YWRhdGEsIGxvY2FsU3RvcmUsIHNlcmlhbGl6ZXIpIHtcbiAgICAgICAgdGhpcy5idW5kbGVNZXRhZGF0YSA9IGJ1bmRsZU1ldGFkYXRhO1xuICAgICAgICB0aGlzLmxvY2FsU3RvcmUgPSBsb2NhbFN0b3JlO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xuICAgICAgICAvKiogQmF0Y2hlZCBxdWVyaWVzIHRvIGJlIHNhdmVkIGludG8gc3RvcmFnZSAqL1xuICAgICAgICB0aGlzLnF1ZXJpZXMgPSBbXTtcbiAgICAgICAgLyoqIEJhdGNoZWQgZG9jdW1lbnRzIHRvIGJlIHNhdmVkIGludG8gc3RvcmFnZSAqL1xuICAgICAgICB0aGlzLmRvY3VtZW50cyA9IFtdO1xuICAgICAgICAvKiogVGhlIGNvbGxlY3Rpb24gZ3JvdXBzIGFmZmVjdGVkIGJ5IHRoaXMgYnVuZGxlLiAqL1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25Hcm91cHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3MgPSBidW5kbGVJbml0aWFsUHJvZ3Jlc3MoYnVuZGxlTWV0YWRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGVsZW1lbnQgZnJvbSB0aGUgYnVuZGxlIHRvIHRoZSBsb2FkZXIuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHByb2dyZXNzIGlmIGFkZGluZyB0aGUgZWxlbWVudCBsZWFkcyB0byBhIG5ldyBwcm9ncmVzcyxcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJucyBudWxsLlxuICAgICAqL1xuICAgIGFkZFNpemVkRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3MuYnl0ZXNMb2FkZWQgKz0gZWxlbWVudC5ieXRlTGVuZ3RoO1xuICAgICAgICBsZXQgZG9jdW1lbnRzTG9hZGVkID0gdGhpcy5wcm9ncmVzcy5kb2N1bWVudHNMb2FkZWQ7XG4gICAgICAgIGlmIChlbGVtZW50LnBheWxvYWQubmFtZWRRdWVyeSkge1xuICAgICAgICAgICAgdGhpcy5xdWVyaWVzLnB1c2goZWxlbWVudC5wYXlsb2FkLm5hbWVkUXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnQucGF5bG9hZC5kb2N1bWVudE1ldGFkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50cy5wdXNoKHsgbWV0YWRhdGE6IGVsZW1lbnQucGF5bG9hZC5kb2N1bWVudE1ldGFkYXRhIH0pO1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50LnBheWxvYWQuZG9jdW1lbnRNZXRhZGF0YS5leGlzdHMpIHtcbiAgICAgICAgICAgICAgICArK2RvY3VtZW50c0xvYWRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhlbGVtZW50LnBheWxvYWQuZG9jdW1lbnRNZXRhZGF0YS5uYW1lKTtcbiAgICAgICAgICAgIHRoaXMuY29sbGVjdGlvbkdyb3Vwcy5hZGQocGF0aC5nZXQocGF0aC5sZW5ndGggLSAyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudC5wYXlsb2FkLmRvY3VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50c1t0aGlzLmRvY3VtZW50cy5sZW5ndGggLSAxXS5kb2N1bWVudCA9XG4gICAgICAgICAgICAgICAgZWxlbWVudC5wYXlsb2FkLmRvY3VtZW50O1xuICAgICAgICAgICAgKytkb2N1bWVudHNMb2FkZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvY3VtZW50c0xvYWRlZCAhPT0gdGhpcy5wcm9ncmVzcy5kb2N1bWVudHNMb2FkZWQpIHtcbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3MuZG9jdW1lbnRzTG9hZGVkID0gZG9jdW1lbnRzTG9hZGVkO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXRRdWVyeURvY3VtZW50TWFwcGluZyhkb2N1bWVudHMpIHtcbiAgICAgICAgY29uc3QgcXVlcnlEb2N1bWVudE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgYnVuZGxlQ29udmVydGVyID0gbmV3IEJ1bmRsZUNvbnZlcnRlckltcGwodGhpcy5zZXJpYWxpemVyKTtcbiAgICAgICAgZm9yIChjb25zdCBidW5kbGVEb2Mgb2YgZG9jdW1lbnRzKSB7XG4gICAgICAgICAgICBpZiAoYnVuZGxlRG9jLm1ldGFkYXRhLnF1ZXJpZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudEtleSA9IGJ1bmRsZUNvbnZlcnRlci50b0RvY3VtZW50S2V5KGJ1bmRsZURvYy5tZXRhZGF0YS5uYW1lKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHF1ZXJ5TmFtZSBvZiBidW5kbGVEb2MubWV0YWRhdGEucXVlcmllcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudEtleXMgPSAocXVlcnlEb2N1bWVudE1hcC5nZXQocXVlcnlOYW1lKSB8fCBkb2N1bWVudEtleVNldCgpKS5hZGQoZG9jdW1lbnRLZXkpO1xuICAgICAgICAgICAgICAgICAgICBxdWVyeURvY3VtZW50TWFwLnNldChxdWVyeU5hbWUsIGRvY3VtZW50S2V5cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxdWVyeURvY3VtZW50TWFwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHByb2dyZXNzIHRvICdTdWNjZXNzJyBhbmQgcmV0dXJuIHRoZSB1cGRhdGVkIHByb2dyZXNzLlxuICAgICAqL1xuICAgIGFzeW5jIGNvbXBsZXRlKCkge1xuICAgICAgICBjb25zdCBjaGFuZ2VkRG9jcyA9IGF3YWl0IGxvY2FsU3RvcmVBcHBseUJ1bmRsZWREb2N1bWVudHModGhpcy5sb2NhbFN0b3JlLCBuZXcgQnVuZGxlQ29udmVydGVySW1wbCh0aGlzLnNlcmlhbGl6ZXIpLCB0aGlzLmRvY3VtZW50cywgdGhpcy5idW5kbGVNZXRhZGF0YS5pZCk7XG4gICAgICAgIGNvbnN0IHF1ZXJ5RG9jdW1lbnRNYXAgPSB0aGlzLmdldFF1ZXJ5RG9jdW1lbnRNYXBwaW5nKHRoaXMuZG9jdW1lbnRzKTtcbiAgICAgICAgZm9yIChjb25zdCBxIG9mIHRoaXMucXVlcmllcykge1xuICAgICAgICAgICAgYXdhaXQgbG9jYWxTdG9yZVNhdmVOYW1lZFF1ZXJ5KHRoaXMubG9jYWxTdG9yZSwgcSwgcXVlcnlEb2N1bWVudE1hcC5nZXQocS5uYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9ncmVzcy50YXNrU3RhdGUgPSAnU3VjY2Vzcyc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm9ncmVzczogdGhpcy5wcm9ncmVzcyxcbiAgICAgICAgICAgIGNoYW5nZWRDb2xsZWN0aW9uR3JvdXBzOiB0aGlzLmNvbGxlY3Rpb25Hcm91cHMsXG4gICAgICAgICAgICBjaGFuZ2VkRG9jc1xuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyBhIGBMb2FkQnVuZGxlVGFza1Byb2dyZXNzYCByZXByZXNlbnRpbmcgdGhlIGluaXRpYWwgcHJvZ3Jlc3Mgb2ZcbiAqIGxvYWRpbmcgYSBidW5kbGUuXG4gKi9cbmZ1bmN0aW9uIGJ1bmRsZUluaXRpYWxQcm9ncmVzcyhtZXRhZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRhc2tTdGF0ZTogJ1J1bm5pbmcnLFxuICAgICAgICBkb2N1bWVudHNMb2FkZWQ6IDAsXG4gICAgICAgIGJ5dGVzTG9hZGVkOiAwLFxuICAgICAgICB0b3RhbERvY3VtZW50czogbWV0YWRhdGEudG90YWxEb2N1bWVudHMsXG4gICAgICAgIHRvdGFsQnl0ZXM6IG1ldGFkYXRhLnRvdGFsQnl0ZXNcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgYExvYWRCdW5kbGVUYXNrUHJvZ3Jlc3NgIHJlcHJlc2VudGluZyB0aGUgcHJvZ3Jlc3MgdGhhdCB0aGUgbG9hZGluZ1xuICogaGFzIHN1Y2NlZWRlZC5cbiAqL1xuZnVuY3Rpb24gYnVuZGxlU3VjY2Vzc1Byb2dyZXNzKG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFza1N0YXRlOiAnU3VjY2VzcycsXG4gICAgICAgIGRvY3VtZW50c0xvYWRlZDogbWV0YWRhdGEudG90YWxEb2N1bWVudHMsXG4gICAgICAgIGJ5dGVzTG9hZGVkOiBtZXRhZGF0YS50b3RhbEJ5dGVzLFxuICAgICAgICB0b3RhbERvY3VtZW50czogbWV0YWRhdGEudG90YWxEb2N1bWVudHMsXG4gICAgICAgIHRvdGFsQnl0ZXM6IG1ldGFkYXRhLnRvdGFsQnl0ZXNcbiAgICB9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgQWRkZWRMaW1ib0RvY3VtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgfVxufVxuY2xhc3MgUmVtb3ZlZExpbWJvRG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKGtleSkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICB9XG59XG4vKipcbiAqIFZpZXcgaXMgcmVzcG9uc2libGUgZm9yIGNvbXB1dGluZyB0aGUgZmluYWwgbWVyZ2VkIHRydXRoIG9mIHdoYXQgZG9jcyBhcmUgaW5cbiAqIGEgcXVlcnkuIEl0IGdldHMgbm90aWZpZWQgb2YgbG9jYWwgYW5kIHJlbW90ZSBjaGFuZ2VzIHRvIGRvY3MsIGFuZCBhcHBsaWVzXG4gKiB0aGUgcXVlcnkgZmlsdGVycyBhbmQgbGltaXRzIHRvIGRldGVybWluZSB0aGUgbW9zdCBjb3JyZWN0IHBvc3NpYmxlIHJlc3VsdHMuXG4gKi9cbmNsYXNzIFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5LCBcbiAgICAvKiogRG9jdW1lbnRzIGluY2x1ZGVkIGluIHRoZSByZW1vdGUgdGFyZ2V0ICovXG4gICAgX3N5bmNlZERvY3VtZW50cykge1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIHRoaXMuX3N5bmNlZERvY3VtZW50cyA9IF9zeW5jZWREb2N1bWVudHM7XG4gICAgICAgIHRoaXMuc3luY1N0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYXNDYWNoZWRSZXN1bHRzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZsYWcgd2hldGhlciB0aGUgdmlldyBpcyBjdXJyZW50IHdpdGggdGhlIGJhY2tlbmQuIEEgdmlldyBpcyBjb25zaWRlcmVkXG4gICAgICAgICAqIGN1cnJlbnQgYWZ0ZXIgaXQgaGFzIHNlZW4gdGhlIGN1cnJlbnQgZmxhZyBmcm9tIHRoZSBiYWNrZW5kIGFuZCBkaWQgbm90XG4gICAgICAgICAqIGxvc2UgY29uc2lzdGVuY3kgd2l0aGluIHRoZSB3YXRjaCBzdHJlYW0gKGUuZy4gYmVjYXVzZSBvZiBhbiBleGlzdGVuY2VcbiAgICAgICAgICogZmlsdGVyIG1pc21hdGNoKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAvKiogRG9jdW1lbnRzIGluIHRoZSB2aWV3IGJ1dCBub3QgaW4gdGhlIHJlbW90ZSB0YXJnZXQgKi9cbiAgICAgICAgdGhpcy5saW1ib0RvY3VtZW50cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgIC8qKiBEb2N1bWVudCBLZXlzIHRoYXQgaGF2ZSBsb2NhbCBjaGFuZ2VzICovXG4gICAgICAgIHRoaXMubXV0YXRlZEtleXMgPSBkb2N1bWVudEtleVNldCgpO1xuICAgICAgICB0aGlzLmRvY0NvbXBhcmF0b3IgPSBuZXdRdWVyeUNvbXBhcmF0b3IocXVlcnkpO1xuICAgICAgICB0aGlzLmRvY3VtZW50U2V0ID0gbmV3IERvY3VtZW50U2V0KHRoaXMuZG9jQ29tcGFyYXRvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBzZXQgb2YgcmVtb3RlIGRvY3VtZW50cyB0aGF0IHRoZSBzZXJ2ZXIgaGFzIHRvbGQgdXMgYmVsb25ncyB0byB0aGUgdGFyZ2V0IGFzc29jaWF0ZWQgd2l0aFxuICAgICAqIHRoaXMgdmlldy5cbiAgICAgKi9cbiAgICBnZXQgc3luY2VkRG9jdW1lbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3luY2VkRG9jdW1lbnRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGEgc2V0IG9mIGRvYyBjaGFuZ2VzLCBhcHBsaWVzIHRoZSBxdWVyeSBsaW1pdCwgYW5kIGNvbXB1dGVzXG4gICAgICogd2hhdCB0aGUgbmV3IHJlc3VsdHMgc2hvdWxkIGJlLCB3aGF0IHRoZSBjaGFuZ2VzIHdlcmUsIGFuZCB3aGV0aGVyIHdlIG1heVxuICAgICAqIG5lZWQgdG8gZ28gYmFjayB0byB0aGUgbG9jYWwgY2FjaGUgZm9yIG1vcmUgcmVzdWx0cy4gRG9lcyBub3QgbWFrZSBhbnlcbiAgICAgKiBjaGFuZ2VzIHRvIHRoZSB2aWV3LlxuICAgICAqIEBwYXJhbSBkb2NDaGFuZ2VzIC0gVGhlIGRvYyBjaGFuZ2VzIHRvIGFwcGx5IHRvIHRoaXMgdmlldy5cbiAgICAgKiBAcGFyYW0gcHJldmlvdXNDaGFuZ2VzIC0gSWYgdGhpcyBpcyBiZWluZyBjYWxsZWQgd2l0aCBhIHJlZmlsbCwgdGhlbiBzdGFydFxuICAgICAqICAgICAgICB3aXRoIHRoaXMgc2V0IG9mIGRvY3MgYW5kIGNoYW5nZXMgaW5zdGVhZCBvZiB0aGUgY3VycmVudCB2aWV3LlxuICAgICAqIEByZXR1cm5zIGEgbmV3IHNldCBvZiBkb2NzLCBjaGFuZ2VzLCBhbmQgcmVmaWxsIGZsYWcuXG4gICAgICovXG4gICAgY29tcHV0ZURvY0NoYW5nZXMoZG9jQ2hhbmdlcywgcHJldmlvdXNDaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZVNldCA9IHByZXZpb3VzQ2hhbmdlc1xuICAgICAgICAgICAgPyBwcmV2aW91c0NoYW5nZXMuY2hhbmdlU2V0XG4gICAgICAgICAgICA6IG5ldyBEb2N1bWVudENoYW5nZVNldCgpO1xuICAgICAgICBjb25zdCBvbGREb2N1bWVudFNldCA9IHByZXZpb3VzQ2hhbmdlc1xuICAgICAgICAgICAgPyBwcmV2aW91c0NoYW5nZXMuZG9jdW1lbnRTZXRcbiAgICAgICAgICAgIDogdGhpcy5kb2N1bWVudFNldDtcbiAgICAgICAgbGV0IG5ld011dGF0ZWRLZXlzID0gcHJldmlvdXNDaGFuZ2VzXG4gICAgICAgICAgICA/IHByZXZpb3VzQ2hhbmdlcy5tdXRhdGVkS2V5c1xuICAgICAgICAgICAgOiB0aGlzLm11dGF0ZWRLZXlzO1xuICAgICAgICBsZXQgbmV3RG9jdW1lbnRTZXQgPSBvbGREb2N1bWVudFNldDtcbiAgICAgICAgbGV0IG5lZWRzUmVmaWxsID0gZmFsc2U7XG4gICAgICAgIC8vIFRyYWNrIHRoZSBsYXN0IGRvYyBpbiBhIChmdWxsKSBsaW1pdC4gVGhpcyBpcyBuZWNlc3NhcnksIGJlY2F1c2Ugc29tZVxuICAgICAgICAvLyB1cGRhdGUgKGEgZGVsZXRlLCBvciBhbiB1cGRhdGUgbW92aW5nIGEgZG9jIHBhc3QgdGhlIG9sZCBsaW1pdCkgbWlnaHRcbiAgICAgICAgLy8gbWVhbiB0aGVyZSBpcyBzb21lIG90aGVyIGRvY3VtZW50IGluIHRoZSBsb2NhbCBjYWNoZSB0aGF0IGVpdGhlciBzaG91bGRcbiAgICAgICAgLy8gY29tZSAoMSkgYmV0d2VlbiB0aGUgb2xkIGxhc3QgbGltaXQgZG9jIGFuZCB0aGUgbmV3IGxhc3QgZG9jdW1lbnQsIGluIHRoZVxuICAgICAgICAvLyBjYXNlIG9mIHVwZGF0ZXMsIG9yICgyKSBhZnRlciB0aGUgbmV3IGxhc3QgZG9jdW1lbnQsIGluIHRoZSBjYXNlIG9mXG4gICAgICAgIC8vIGRlbGV0ZXMuIFNvIHdlIGtlZXAgdGhpcyBkb2MgYXQgdGhlIG9sZCBsaW1pdCB0byBjb21wYXJlIHRoZSB1cGRhdGVzIHRvLlxuICAgICAgICAvL1xuICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBzaG91bGQgbmV2ZXIgZ2V0IHVzZWQgaW4gYSByZWZpbGwgKHdoZW4gcHJldmlvdXNDaGFuZ2VzIGlzXG4gICAgICAgIC8vIHNldCksIGJlY2F1c2UgdGhlcmUgd2lsbCBvbmx5IGJlIGFkZHMgLS0gbm8gZGVsZXRlcyBvciB1cGRhdGVzLlxuICAgICAgICBjb25zdCBsYXN0RG9jSW5MaW1pdCA9IHRoaXMucXVlcnkubGltaXRUeXBlID09PSBcIkZcIiAvKiBMaW1pdFR5cGUuRmlyc3QgKi8gJiZcbiAgICAgICAgICAgIG9sZERvY3VtZW50U2V0LnNpemUgPT09IHRoaXMucXVlcnkubGltaXRcbiAgICAgICAgICAgID8gb2xkRG9jdW1lbnRTZXQubGFzdCgpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGNvbnN0IGZpcnN0RG9jSW5MaW1pdCA9IHRoaXMucXVlcnkubGltaXRUeXBlID09PSBcIkxcIiAvKiBMaW1pdFR5cGUuTGFzdCAqLyAmJlxuICAgICAgICAgICAgb2xkRG9jdW1lbnRTZXQuc2l6ZSA9PT0gdGhpcy5xdWVyeS5saW1pdFxuICAgICAgICAgICAgPyBvbGREb2N1bWVudFNldC5maXJzdCgpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGRvY0NoYW5nZXMuaW5vcmRlclRyYXZlcnNhbCgoa2V5LCBlbnRyeSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2xkRG9jID0gb2xkRG9jdW1lbnRTZXQuZ2V0KGtleSk7XG4gICAgICAgICAgICBjb25zdCBuZXdEb2MgPSBxdWVyeU1hdGNoZXModGhpcy5xdWVyeSwgZW50cnkpID8gZW50cnkgOiBudWxsO1xuICAgICAgICAgICAgY29uc3Qgb2xkRG9jSGFkUGVuZGluZ011dGF0aW9ucyA9IG9sZERvY1xuICAgICAgICAgICAgICAgID8gdGhpcy5tdXRhdGVkS2V5cy5oYXMob2xkRG9jLmtleSlcbiAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgbmV3RG9jSGFzUGVuZGluZ011dGF0aW9ucyA9IG5ld0RvY1xuICAgICAgICAgICAgICAgID8gbmV3RG9jLmhhc0xvY2FsTXV0YXRpb25zIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgY29uc2lkZXIgY29tbWl0dGVkIG11dGF0aW9ucyBmb3IgZG9jdW1lbnRzIHRoYXQgd2VyZVxuICAgICAgICAgICAgICAgICAgICAvLyBtdXRhdGVkIGR1cmluZyB0aGUgbGlmZXRpbWUgb2YgdGhlIHZpZXcuXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLm11dGF0ZWRLZXlzLmhhcyhuZXdEb2Mua2V5KSAmJiBuZXdEb2MuaGFzQ29tbWl0dGVkTXV0YXRpb25zKVxuICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgICAgICBsZXQgY2hhbmdlQXBwbGllZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGNoYW5nZVxuICAgICAgICAgICAgaWYgKG9sZERvYyAmJiBuZXdEb2MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkb2NzRXF1YWwgPSBvbGREb2MuZGF0YS5pc0VxdWFsKG5ld0RvYy5kYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRvY3NFcXVhbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2hvdWxkV2FpdEZvclN5bmNlZERvY3VtZW50KG9sZERvYywgbmV3RG9jKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlU2V0LnRyYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jOiBuZXdEb2NcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlQXBwbGllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGxhc3REb2NJbkxpbWl0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NDb21wYXJhdG9yKG5ld0RvYywgbGFzdERvY0luTGltaXQpID4gMCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmlyc3REb2NJbkxpbWl0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jQ29tcGFyYXRvcihuZXdEb2MsIGZpcnN0RG9jSW5MaW1pdCkgPCAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZG9jIG1vdmVkIGZyb20gaW5zaWRlIHRoZSBsaW1pdCB0byBvdXRzaWRlIHRoZSBsaW1pdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGF0IG1lYW5zIHRoZXJlIG1heSBiZSBzb21lIG90aGVyIGRvYyBpbiB0aGUgbG9jYWwgY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IHNob3VsZCBiZSBpbmNsdWRlZCBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRzUmVmaWxsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvbGREb2NIYWRQZW5kaW5nTXV0YXRpb25zICE9PSBuZXdEb2NIYXNQZW5kaW5nTXV0YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZVNldC50cmFjayh7IHR5cGU6IDMgLyogQ2hhbmdlVHlwZS5NZXRhZGF0YSAqLywgZG9jOiBuZXdEb2MgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUFwcGxpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFvbGREb2MgJiYgbmV3RG9jKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlU2V0LnRyYWNrKHsgdHlwZTogMCAvKiBDaGFuZ2VUeXBlLkFkZGVkICovLCBkb2M6IG5ld0RvYyB9KTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VBcHBsaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9sZERvYyAmJiAhbmV3RG9jKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlU2V0LnRyYWNrKHsgdHlwZTogMSAvKiBDaGFuZ2VUeXBlLlJlbW92ZWQgKi8sIGRvYzogb2xkRG9jIH0pO1xuICAgICAgICAgICAgICAgIGNoYW5nZUFwcGxpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0RG9jSW5MaW1pdCB8fCBmaXJzdERvY0luTGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBkb2Mgd2FzIHJlbW92ZWQgZnJvbSBhIGZ1bGwgbGltaXQgcXVlcnkuIFdlJ2xsIG5lZWQgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVxdWVyeSBmcm9tIHRoZSBsb2NhbCBjYWNoZSB0byBzZWUgaWYgd2Uga25vdyBhYm91dCBzb21lIG90aGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvYyB0aGF0IHNob3VsZCBiZSBpbiB0aGUgcmVzdWx0cy5cbiAgICAgICAgICAgICAgICAgICAgbmVlZHNSZWZpbGwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFuZ2VBcHBsaWVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0RvYykge1xuICAgICAgICAgICAgICAgICAgICBuZXdEb2N1bWVudFNldCA9IG5ld0RvY3VtZW50U2V0LmFkZChuZXdEb2MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3RG9jSGFzUGVuZGluZ011dGF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TXV0YXRlZEtleXMgPSBuZXdNdXRhdGVkS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld011dGF0ZWRLZXlzID0gbmV3TXV0YXRlZEtleXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0RvY3VtZW50U2V0ID0gbmV3RG9jdW1lbnRTZXQuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIG5ld011dGF0ZWRLZXlzID0gbmV3TXV0YXRlZEtleXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gRHJvcCBkb2N1bWVudHMgb3V0IHRvIG1lZXQgbGltaXQvbGltaXRUb0xhc3QgcmVxdWlyZW1lbnQuXG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5LmxpbWl0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB3aGlsZSAobmV3RG9jdW1lbnRTZXQuc2l6ZSA+IHRoaXMucXVlcnkubGltaXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbGREb2MgPSB0aGlzLnF1ZXJ5LmxpbWl0VHlwZSA9PT0gXCJGXCIgLyogTGltaXRUeXBlLkZpcnN0ICovXG4gICAgICAgICAgICAgICAgICAgID8gbmV3RG9jdW1lbnRTZXQubGFzdCgpXG4gICAgICAgICAgICAgICAgICAgIDogbmV3RG9jdW1lbnRTZXQuZmlyc3QoKTtcbiAgICAgICAgICAgICAgICBuZXdEb2N1bWVudFNldCA9IG5ld0RvY3VtZW50U2V0LmRlbGV0ZShvbGREb2Mua2V5KTtcbiAgICAgICAgICAgICAgICBuZXdNdXRhdGVkS2V5cyA9IG5ld011dGF0ZWRLZXlzLmRlbGV0ZShvbGREb2Mua2V5KTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VTZXQudHJhY2soeyB0eXBlOiAxIC8qIENoYW5nZVR5cGUuUmVtb3ZlZCAqLywgZG9jOiBvbGREb2MgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvY3VtZW50U2V0OiBuZXdEb2N1bWVudFNldCxcbiAgICAgICAgICAgIGNoYW5nZVNldCxcbiAgICAgICAgICAgIG5lZWRzUmVmaWxsLFxuICAgICAgICAgICAgbXV0YXRlZEtleXM6IG5ld011dGF0ZWRLZXlzXG4gICAgICAgIH07XG4gICAgfVxuICAgIHNob3VsZFdhaXRGb3JTeW5jZWREb2N1bWVudChvbGREb2MsIG5ld0RvYykge1xuICAgICAgICAvLyBXZSBzdXBwcmVzcyB0aGUgaW5pdGlhbCBjaGFuZ2UgZXZlbnQgZm9yIGRvY3VtZW50cyB0aGF0IHdlcmUgbW9kaWZpZWQgYXNcbiAgICAgICAgLy8gcGFydCBvZiBhIHdyaXRlIGFja25vd2xlZGdtZW50IChlLmcuIHdoZW4gdGhlIHZhbHVlIG9mIGEgc2VydmVyIHRyYW5zZm9ybVxuICAgICAgICAvLyBpcyBhcHBsaWVkKSBhcyBXYXRjaCB3aWxsIHNlbmQgdXMgdGhlIHNhbWUgZG9jdW1lbnQgYWdhaW4uXG4gICAgICAgIC8vIEJ5IHN1cHByZXNzaW5nIHRoZSBldmVudCwgd2Ugb25seSByYWlzZSB0d28gdXNlciB2aXNpYmxlIGV2ZW50cyAob25lIHdpdGhcbiAgICAgICAgLy8gYGhhc1BlbmRpbmdXcml0ZXNgIGFuZCB0aGUgZmluYWwgc3RhdGUgb2YgdGhlIGRvY3VtZW50KSBpbnN0ZWFkIG9mIHRocmVlXG4gICAgICAgIC8vIChvbmUgd2l0aCBgaGFzUGVuZGluZ1dyaXRlc2AsIHRoZSBtb2RpZmllZCBkb2N1bWVudCB3aXRoXG4gICAgICAgIC8vIGBoYXNQZW5kaW5nV3JpdGVzYCBhbmQgdGhlIGZpbmFsIHN0YXRlIG9mIHRoZSBkb2N1bWVudCkuXG4gICAgICAgIHJldHVybiAob2xkRG9jLmhhc0xvY2FsTXV0YXRpb25zICYmXG4gICAgICAgICAgICBuZXdEb2MuaGFzQ29tbWl0dGVkTXV0YXRpb25zICYmXG4gICAgICAgICAgICAhbmV3RG9jLmhhc0xvY2FsTXV0YXRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdmlldyB3aXRoIHRoZSBnaXZlbiBWaWV3RG9jdW1lbnRDaGFuZ2VzIGFuZCBvcHRpb25hbGx5IHVwZGF0ZXNcbiAgICAgKiBsaW1ibyBkb2NzIGFuZCBzeW5jIHN0YXRlIGZyb20gdGhlIHByb3ZpZGVkIHRhcmdldCBjaGFuZ2UuXG4gICAgICogQHBhcmFtIGRvY0NoYW5nZXMgLSBUaGUgc2V0IG9mIGNoYW5nZXMgdG8gbWFrZSB0byB0aGUgdmlldydzIGRvY3MuXG4gICAgICogQHBhcmFtIGxpbWJvUmVzb2x1dGlvbkVuYWJsZWQgLSBXaGV0aGVyIHRvIHVwZGF0ZSBsaW1ibyBkb2N1bWVudHMgYmFzZWQgb25cbiAgICAgKiAgICAgICAgdGhpcyBjaGFuZ2UuXG4gICAgICogQHBhcmFtIHRhcmdldENoYW5nZSAtIEEgdGFyZ2V0IGNoYW5nZSB0byBhcHBseSBmb3IgY29tcHV0aW5nIGxpbWJvIGRvY3MgYW5kXG4gICAgICogICAgICAgIHN5bmMgc3RhdGUuXG4gICAgICogQHBhcmFtIHRhcmdldElzUGVuZGluZ1Jlc2V0IC0gV2hldGhlciB0aGUgdGFyZ2V0IGlzIHBlbmRpbmcgdG8gcmVzZXQgZHVlIHRvXG4gICAgICogICAgICAgIGV4aXN0ZW5jZSBmaWx0ZXIgbWlzbWF0Y2guIElmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZCwgaXQgaXMgdHJlYXRlZFxuICAgICAqICAgICAgICBlcXVpdmFsZW50bHkgdG8gYGZhbHNlYC5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBWaWV3Q2hhbmdlIHdpdGggdGhlIGdpdmVuIGRvY3MsIGNoYW5nZXMsIGFuZCBzeW5jIHN0YXRlLlxuICAgICAqL1xuICAgIC8vIFBPUlRJTkcgTk9URTogVGhlIGlPUy9BbmRyb2lkIGNsaWVudHMgYWx3YXlzIGNvbXB1dGUgbGltYm8gZG9jdW1lbnQgY2hhbmdlcy5cbiAgICBhcHBseUNoYW5nZXMoZG9jQ2hhbmdlcywgbGltYm9SZXNvbHV0aW9uRW5hYmxlZCwgdGFyZ2V0Q2hhbmdlLCB0YXJnZXRJc1BlbmRpbmdSZXNldCkge1xuICAgICAgICBjb25zdCBvbGREb2NzID0gdGhpcy5kb2N1bWVudFNldDtcbiAgICAgICAgdGhpcy5kb2N1bWVudFNldCA9IGRvY0NoYW5nZXMuZG9jdW1lbnRTZXQ7XG4gICAgICAgIHRoaXMubXV0YXRlZEtleXMgPSBkb2NDaGFuZ2VzLm11dGF0ZWRLZXlzO1xuICAgICAgICAvLyBTb3J0IGNoYW5nZXMgYmFzZWQgb24gdHlwZSBhbmQgcXVlcnkgY29tcGFyYXRvclxuICAgICAgICBjb25zdCBjaGFuZ2VzID0gZG9jQ2hhbmdlcy5jaGFuZ2VTZXQuZ2V0Q2hhbmdlcygpO1xuICAgICAgICBjaGFuZ2VzLnNvcnQoKGMxLCBjMikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChjb21wYXJlQ2hhbmdlVHlwZShjMS50eXBlLCBjMi50eXBlKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuZG9jQ29tcGFyYXRvcihjMS5kb2MsIGMyLmRvYykpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hcHBseVRhcmdldENoYW5nZSh0YXJnZXRDaGFuZ2UpO1xuICAgICAgICB0YXJnZXRJc1BlbmRpbmdSZXNldCA9IHRhcmdldElzUGVuZGluZ1Jlc2V0ICE9PSBudWxsICYmIHRhcmdldElzUGVuZGluZ1Jlc2V0ICE9PSB2b2lkIDAgPyB0YXJnZXRJc1BlbmRpbmdSZXNldCA6IGZhbHNlO1xuICAgICAgICBjb25zdCBsaW1ib0NoYW5nZXMgPSBsaW1ib1Jlc29sdXRpb25FbmFibGVkICYmICF0YXJnZXRJc1BlbmRpbmdSZXNldFxuICAgICAgICAgICAgPyB0aGlzLnVwZGF0ZUxpbWJvRG9jdW1lbnRzKClcbiAgICAgICAgICAgIDogW107XG4gICAgICAgIC8vIFdlIGFyZSBhdCBzeW5jZWQgc3RhdGUgaWYgdGhlcmUgaXMgbm8gbGltYm8gZG9jcyBhcmUgd2FpdGluZyB0byBiZSByZXNvbHZlZCwgdmlldyBpcyBjdXJyZW50XG4gICAgICAgIC8vIHdpdGggdGhlIGJhY2tlbmQsIGFuZCB0aGUgcXVlcnkgaXMgbm90IHBlbmRpbmcgdG8gcmVzZXQgZHVlIHRvIGV4aXN0ZW5jZSBmaWx0ZXIgbWlzbWF0Y2guXG4gICAgICAgIGNvbnN0IHN5bmNlZCA9IHRoaXMubGltYm9Eb2N1bWVudHMuc2l6ZSA9PT0gMCAmJiB0aGlzLmN1cnJlbnQgJiYgIXRhcmdldElzUGVuZGluZ1Jlc2V0O1xuICAgICAgICBjb25zdCBuZXdTeW5jU3RhdGUgPSBzeW5jZWQgPyAxIC8qIFN5bmNTdGF0ZS5TeW5jZWQgKi8gOiAwIC8qIFN5bmNTdGF0ZS5Mb2NhbCAqLztcbiAgICAgICAgY29uc3Qgc3luY1N0YXRlQ2hhbmdlZCA9IG5ld1N5bmNTdGF0ZSAhPT0gdGhpcy5zeW5jU3RhdGU7XG4gICAgICAgIHRoaXMuc3luY1N0YXRlID0gbmV3U3luY1N0YXRlO1xuICAgICAgICBpZiAoY2hhbmdlcy5sZW5ndGggPT09IDAgJiYgIXN5bmNTdGF0ZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIC8vIG5vIGNoYW5nZXNcbiAgICAgICAgICAgIHJldHVybiB7IGxpbWJvQ2hhbmdlcyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc25hcCA9IG5ldyBWaWV3U25hcHNob3QodGhpcy5xdWVyeSwgZG9jQ2hhbmdlcy5kb2N1bWVudFNldCwgb2xkRG9jcywgY2hhbmdlcywgZG9jQ2hhbmdlcy5tdXRhdGVkS2V5cywgbmV3U3luY1N0YXRlID09PSAwIC8qIFN5bmNTdGF0ZS5Mb2NhbCAqLywgc3luY1N0YXRlQ2hhbmdlZCwgXG4gICAgICAgICAgICAvKiBleGNsdWRlc01ldGFkYXRhQ2hhbmdlcz0gKi8gZmFsc2UsIHRhcmdldENoYW5nZVxuICAgICAgICAgICAgICAgID8gdGFyZ2V0Q2hhbmdlLnJlc3VtZVRva2VuLmFwcHJveGltYXRlQnl0ZVNpemUoKSA+IDBcbiAgICAgICAgICAgICAgICA6IGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc25hcHNob3Q6IHNuYXAsXG4gICAgICAgICAgICAgICAgbGltYm9DaGFuZ2VzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYW4gT25saW5lU3RhdGUgY2hhbmdlIHRvIHRoZSB2aWV3LCBwb3RlbnRpYWxseSBnZW5lcmF0aW5nIGFcbiAgICAgKiBWaWV3Q2hhbmdlIGlmIHRoZSB2aWV3J3Mgc3luY1N0YXRlIGNoYW5nZXMgYXMgYSByZXN1bHQuXG4gICAgICovXG4gICAgYXBwbHlPbmxpbmVTdGF0ZUNoYW5nZShvbmxpbmVTdGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50ICYmIG9ubGluZVN0YXRlID09PSBcIk9mZmxpbmVcIiAvKiBPbmxpbmVTdGF0ZS5PZmZsaW5lICovKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBvZmZsaW5lLCBzZXQgYGN1cnJlbnRgIHRvIGZhbHNlIGFuZCB0aGVuIGNhbGwgYXBwbHlDaGFuZ2VzKClcbiAgICAgICAgICAgIC8vIHRvIHJlZnJlc2ggb3VyIHN5bmNTdGF0ZSBhbmQgZ2VuZXJhdGUgYSBWaWV3Q2hhbmdlIGFzIGFwcHJvcHJpYXRlLiBXZVxuICAgICAgICAgICAgLy8gYXJlIGd1YXJhbnRlZWQgdG8gZ2V0IGEgbmV3IFRhcmdldENoYW5nZSB0aGF0IHNldHMgYGN1cnJlbnRgIGJhY2sgdG9cbiAgICAgICAgICAgIC8vIHRydWUgb25jZSB0aGUgY2xpZW50IGlzIGJhY2sgb25saW5lLlxuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBseUNoYW5nZXMoe1xuICAgICAgICAgICAgICAgIGRvY3VtZW50U2V0OiB0aGlzLmRvY3VtZW50U2V0LFxuICAgICAgICAgICAgICAgIGNoYW5nZVNldDogbmV3IERvY3VtZW50Q2hhbmdlU2V0KCksXG4gICAgICAgICAgICAgICAgbXV0YXRlZEtleXM6IHRoaXMubXV0YXRlZEtleXMsXG4gICAgICAgICAgICAgICAgbmVlZHNSZWZpbGw6IGZhbHNlXG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8qIGxpbWJvUmVzb2x1dGlvbkVuYWJsZWQ9ICovIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIGVmZmVjdCwganVzdCByZXR1cm4gYSBuby1vcCBWaWV3Q2hhbmdlLlxuICAgICAgICAgICAgcmV0dXJuIHsgbGltYm9DaGFuZ2VzOiBbXSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZG9jIGZvciB0aGUgZ2l2ZW4ga2V5IHNob3VsZCBiZSBpbiBsaW1iby5cbiAgICAgKi9cbiAgICBzaG91bGRCZUluTGltYm8oa2V5KSB7XG4gICAgICAgIC8vIElmIHRoZSByZW1vdGUgZW5kIHNheXMgaXQncyBwYXJ0IG9mIHRoaXMgcXVlcnksIGl0J3Mgbm90IGluIGxpbWJvLlxuICAgICAgICBpZiAodGhpcy5fc3luY2VkRG9jdW1lbnRzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGxvY2FsIHN0b3JlIGRvZXNuJ3QgdGhpbmsgaXQncyBhIHJlc3VsdCwgc28gaXQgc2hvdWxkbid0IGJlIGluIGxpbWJvLlxuICAgICAgICBpZiAoIXRoaXMuZG9jdW1lbnRTZXQuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbG9jYWwgY2hhbmdlcyB0byB0aGUgZG9jLCB0aGV5IG1pZ2h0IGV4cGxhaW4gd2h5IHRoZSBzZXJ2ZXJcbiAgICAgICAgLy8gZG9lc24ndCBrbm93IHRoYXQgaXQncyBwYXJ0IG9mIHRoZSBxdWVyeS4gU28gZG9uJ3QgcHV0IGl0IGluIGxpbWJvLlxuICAgICAgICAvLyBUT0RPKGtsaW10KTogSWRlYWxseSwgd2Ugd291bGQgb25seSBjb25zaWRlciBjaGFuZ2VzIHRoYXQgbWlnaHQgYWN0dWFsbHlcbiAgICAgICAgLy8gYWZmZWN0IHRoaXMgc3BlY2lmaWMgcXVlcnkuXG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50U2V0LmdldChrZXkpLmhhc0xvY2FsTXV0YXRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXZlcnl0aGluZyBlbHNlIGlzIGluIGxpbWJvLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBzeW5jZWREb2N1bWVudHMsIGN1cnJlbnQsIGFuZCBsaW1ibyBkb2NzIGJhc2VkIG9uIHRoZSBnaXZlbiBjaGFuZ2UuXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBjaGFuZ2VzIHRvIHdoaWNoIGRvY3MgYXJlIGluIGxpbWJvLlxuICAgICAqL1xuICAgIGFwcGx5VGFyZ2V0Q2hhbmdlKHRhcmdldENoYW5nZSkge1xuICAgICAgICBpZiAodGFyZ2V0Q2hhbmdlKSB7XG4gICAgICAgICAgICB0YXJnZXRDaGFuZ2UuYWRkZWREb2N1bWVudHMuZm9yRWFjaChrZXkgPT4gKHRoaXMuX3N5bmNlZERvY3VtZW50cyA9IHRoaXMuX3N5bmNlZERvY3VtZW50cy5hZGQoa2V5KSkpO1xuICAgICAgICAgICAgdGFyZ2V0Q2hhbmdlLm1vZGlmaWVkRG9jdW1lbnRzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGFyZ2V0Q2hhbmdlLnJlbW92ZWREb2N1bWVudHMuZm9yRWFjaChrZXkgPT4gKHRoaXMuX3N5bmNlZERvY3VtZW50cyA9IHRoaXMuX3N5bmNlZERvY3VtZW50cy5kZWxldGUoa2V5KSkpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gdGFyZ2V0Q2hhbmdlLmN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlTGltYm9Eb2N1bWVudHMoKSB7XG4gICAgICAgIC8vIFdlIGNhbiBvbmx5IGRldGVybWluZSBsaW1ibyBkb2N1bWVudHMgd2hlbiB3ZSdyZSBpbi1zeW5jIHdpdGggdGhlIHNlcnZlci5cbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPKGtsaW10KTogRG8gdGhpcyBpbmNyZW1lbnRhbGx5IHNvIHRoYXQgaXQncyBub3QgcXVhZHJhdGljIHdoZW5cbiAgICAgICAgLy8gdXBkYXRpbmcgbWFueSBkb2N1bWVudHMuXG4gICAgICAgIGNvbnN0IG9sZExpbWJvRG9jdW1lbnRzID0gdGhpcy5saW1ib0RvY3VtZW50cztcbiAgICAgICAgdGhpcy5saW1ib0RvY3VtZW50cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRTZXQuZm9yRWFjaChkb2MgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkQmVJbkxpbWJvKGRvYy5rZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saW1ib0RvY3VtZW50cyA9IHRoaXMubGltYm9Eb2N1bWVudHMuYWRkKGRvYy5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gRGlmZiB0aGUgbmV3IGxpbWJvIGRvY3Mgd2l0aCB0aGUgb2xkIGxpbWJvIGRvY3MuXG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgb2xkTGltYm9Eb2N1bWVudHMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmxpbWJvRG9jdW1lbnRzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKG5ldyBSZW1vdmVkTGltYm9Eb2N1bWVudChrZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGltYm9Eb2N1bWVudHMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKCFvbGRMaW1ib0RvY3VtZW50cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChuZXcgQWRkZWRMaW1ib0RvY3VtZW50KGtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNoYW5nZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgaW4tbWVtb3J5IHN0YXRlIG9mIHRoZSBjdXJyZW50IHZpZXcgd2l0aCB0aGUgc3RhdGUgcmVhZCBmcm9tXG4gICAgICogcGVyc2lzdGVuY2UuXG4gICAgICpcbiAgICAgKiBXZSB1cGRhdGUgdGhlIHF1ZXJ5IHZpZXcgd2hlbmV2ZXIgYSBjbGllbnQncyBwcmltYXJ5IHN0YXR1cyBjaGFuZ2VzOlxuICAgICAqIC0gV2hlbiBhIGNsaWVudCB0cmFuc2l0aW9ucyBmcm9tIHByaW1hcnkgdG8gc2Vjb25kYXJ5LCBpdCBjYW4gbWlzc1xuICAgICAqICAgTG9jYWxTdG9yYWdlIHVwZGF0ZXMgYW5kIGl0cyBxdWVyeSB2aWV3cyBtYXkgdGVtcG9yYXJpbHkgbm90IGJlXG4gICAgICogICBzeW5jaHJvbml6ZWQgd2l0aCB0aGUgc3RhdGUgb24gZGlzay5cbiAgICAgKiAtIEZvciBzZWNvbmRhcnkgdG8gcHJpbWFyeSB0cmFuc2l0aW9ucywgdGhlIGNsaWVudCBuZWVkcyB0byB1cGRhdGUgdGhlIGxpc3RcbiAgICAgKiAgIG9mIGBzeW5jZWREb2N1bWVudHNgIHNpbmNlIHNlY29uZGFyeSBjbGllbnRzIHVwZGF0ZSB0aGVpciBxdWVyeSB2aWV3c1xuICAgICAqICAgYmFzZWQgcHVyZWx5IG9uIHN5bnRoZXNpemVkIFJlbW90ZUV2ZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBxdWVyeVJlc3VsdC5kb2N1bWVudHMgLSBUaGUgZG9jdW1lbnRzIHRoYXQgbWF0Y2ggdGhlIHF1ZXJ5IGFjY29yZGluZ1xuICAgICAqIHRvIHRoZSBMb2NhbFN0b3JlLlxuICAgICAqIEBwYXJhbSBxdWVyeVJlc3VsdC5yZW1vdGVLZXlzIC0gVGhlIGtleXMgb2YgdGhlIGRvY3VtZW50cyB0aGF0IG1hdGNoIHRoZVxuICAgICAqIHF1ZXJ5IGFjY29yZGluZyB0byB0aGUgYmFja2VuZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBWaWV3Q2hhbmdlIHRoYXQgcmVzdWx0ZWQgZnJvbSB0aGlzIHN5bmNocm9uaXphdGlvbi5cbiAgICAgKi9cbiAgICAvLyBQT1JUSU5HIE5PVEU6IE11bHRpLXRhYiBvbmx5LlxuICAgIHN5bmNocm9uaXplV2l0aFBlcnNpc3RlZFN0YXRlKHF1ZXJ5UmVzdWx0KSB7XG4gICAgICAgIHRoaXMuX3N5bmNlZERvY3VtZW50cyA9IHF1ZXJ5UmVzdWx0LnJlbW90ZUtleXM7XG4gICAgICAgIHRoaXMubGltYm9Eb2N1bWVudHMgPSBkb2N1bWVudEtleVNldCgpO1xuICAgICAgICBjb25zdCBkb2NDaGFuZ2VzID0gdGhpcy5jb21wdXRlRG9jQ2hhbmdlcyhxdWVyeVJlc3VsdC5kb2N1bWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseUNoYW5nZXMoZG9jQ2hhbmdlcywgLyogbGltYm9SZXNvbHV0aW9uRW5hYmxlZD0gKi8gdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB2aWV3IHNuYXBzaG90IGFzIGlmIHRoaXMgcXVlcnkgd2FzIGp1c3QgbGlzdGVuZWQgdG8uIENvbnRhaW5zXG4gICAgICogYSBkb2N1bWVudCBhZGQgZm9yIGV2ZXJ5IGV4aXN0aW5nIGRvY3VtZW50IGFuZCB0aGUgYGZyb21DYWNoZWAgYW5kXG4gICAgICogYGhhc1BlbmRpbmdXcml0ZXNgIHN0YXR1cyBvZiB0aGUgYWxyZWFkeSBlc3RhYmxpc2hlZCB2aWV3LlxuICAgICAqL1xuICAgIC8vIFBPUlRJTkcgTk9URTogTXVsdGktdGFiIG9ubHkuXG4gICAgY29tcHV0ZUluaXRpYWxTbmFwc2hvdCgpIHtcbiAgICAgICAgcmV0dXJuIFZpZXdTbmFwc2hvdC5mcm9tSW5pdGlhbERvY3VtZW50cyh0aGlzLnF1ZXJ5LCB0aGlzLmRvY3VtZW50U2V0LCB0aGlzLm11dGF0ZWRLZXlzLCB0aGlzLnN5bmNTdGF0ZSA9PT0gMCAvKiBTeW5jU3RhdGUuTG9jYWwgKi8sIHRoaXMuaGFzQ2FjaGVkUmVzdWx0cyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGFyZUNoYW5nZVR5cGUoYzEsIGMyKSB7XG4gICAgY29uc3Qgb3JkZXIgPSAoY2hhbmdlKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoY2hhbmdlKSB7XG4gICAgICAgICAgICBjYXNlIDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGNhc2UgMiAvKiBDaGFuZ2VUeXBlLk1vZGlmaWVkICovOlxuICAgICAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgICAgY2FzZSAzIC8qIENoYW5nZVR5cGUuTWV0YWRhdGEgKi86XG4gICAgICAgICAgICAgICAgLy8gQSBtZXRhZGF0YSBjaGFuZ2UgaXMgY29udmVydGVkIHRvIGEgbW9kaWZpZWQgY2hhbmdlIGF0IHRoZSBwdWJsaWNcbiAgICAgICAgICAgICAgICAvLyBhcGkgbGF5ZXIuICBTaW5jZSB3ZSBzb3J0IGJ5IGRvY3VtZW50IGtleSBhbmQgdGhlbiBjaGFuZ2UgdHlwZSxcbiAgICAgICAgICAgICAgICAvLyBtZXRhZGF0YSBhbmQgbW9kaWZpZWQgY2hhbmdlcyBtdXN0IGJlIHNvcnRlZCBlcXVpdmFsZW50bHkuXG4gICAgICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgICBjYXNlIDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovOlxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gb3JkZXIoYzEpIC0gb3JkZXIoYzIpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgTE9HX1RBRyQzID0gJ1N5bmNFbmdpbmUnO1xuLyoqXG4gKiBRdWVyeVZpZXcgY29udGFpbnMgYWxsIG9mIHRoZSBkYXRhIHRoYXQgU3luY0VuZ2luZSBuZWVkcyB0byBrZWVwIHRyYWNrIG9mIGZvclxuICogYSBwYXJ0aWN1bGFyIHF1ZXJ5LlxuICovXG5jbGFzcyBRdWVyeVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIFRoZSBxdWVyeSBpdHNlbGYuXG4gICAgICovXG4gICAgcXVlcnksIFxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgbnVtYmVyIGNyZWF0ZWQgYnkgdGhlIGNsaWVudCB0aGF0IGlzIHVzZWQgaW4gdGhlIHdhdGNoXG4gICAgICogc3RyZWFtIHRvIGlkZW50aWZ5IHRoaXMgcXVlcnkuXG4gICAgICovXG4gICAgdGFyZ2V0SWQsIFxuICAgIC8qKlxuICAgICAqIFRoZSB2aWV3IGlzIHJlc3BvbnNpYmxlIGZvciBjb21wdXRpbmcgdGhlIGZpbmFsIG1lcmdlZCB0cnV0aCBvZiB3aGF0XG4gICAgICogZG9jcyBhcmUgaW4gdGhlIHF1ZXJ5LiBJdCBnZXRzIG5vdGlmaWVkIG9mIGxvY2FsIGFuZCByZW1vdGUgY2hhbmdlcyxcbiAgICAgKiBhbmQgYXBwbGllcyB0aGUgcXVlcnkgZmlsdGVycyBhbmQgbGltaXRzIHRvIGRldGVybWluZSB0aGUgbW9zdCBjb3JyZWN0XG4gICAgICogcG9zc2libGUgcmVzdWx0cy5cbiAgICAgKi9cbiAgICB2aWV3KSB7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgdGhpcy50YXJnZXRJZCA9IHRhcmdldElkO1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgIH1cbn1cbi8qKiBUcmFja3MgYSBsaW1ibyByZXNvbHV0aW9uLiAqL1xuY2xhc3MgTGltYm9SZXNvbHV0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdG8gdHJ1ZSBvbmNlIHdlJ3ZlIHJlY2VpdmVkIGEgZG9jdW1lbnQuIFRoaXMgaXMgdXNlZCBpblxuICAgICAgICAgKiBnZXRSZW1vdGVLZXlzRm9yVGFyZ2V0KCkgYW5kIHVsdGltYXRlbHkgdXNlZCBieSBXYXRjaENoYW5nZUFnZ3JlZ2F0b3IgdG9cbiAgICAgICAgICogZGVjaWRlIHdoZXRoZXIgaXQgbmVlZHMgdG8gbWFudWZhY3R1cmUgYSBkZWxldGUgZXZlbnQgZm9yIHRoZSB0YXJnZXQgb25jZVxuICAgICAgICAgKiB0aGUgdGFyZ2V0IGlzIENVUlJFTlQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlY2VpdmVkRG9jdW1lbnQgPSBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGBTeW5jRW5naW5lYCBjb29yZGluYXRpbmcgd2l0aCBvdGhlciBwYXJ0cyBvZiBTREsuXG4gKlxuICogVGhlIHBhcnRzIG9mIFN5bmNFbmdpbmUgdGhhdCBhY3QgYXMgYSBjYWxsYmFjayB0byBSZW1vdGVTdG9yZSBuZWVkIHRvIGJlXG4gKiByZWdpc3RlcmVkIGluZGl2aWR1YWxseS4gVGhpcyBpcyBkb25lIGluIGBzeW5jRW5naW5lV3JpdGUoKWAgYW5kXG4gKiBgc3luY0VuZ2luZUxpc3RlbigpYCAoYXMgd2VsbCBhcyBgYXBwbHlQcmltYXJ5U3RhdGUoKWApIGFzIHRoZXNlIG1ldGhvZHNcbiAqIHNlcnZlIGFzIGVudHJ5IHBvaW50cyB0byBSZW1vdGVTdG9yZSdzIGZ1bmN0aW9uYWxpdHkuXG4gKlxuICogTm90ZTogc29tZSBmaWVsZCBkZWZpbmVkIGluIHRoaXMgY2xhc3MgbWlnaHQgaGF2ZSBwdWJsaWMgYWNjZXNzIGxldmVsLCBidXRcbiAqIHRoZSBjbGFzcyBpcyBub3QgZXhwb3J0ZWQgc28gdGhleSBhcmUgb25seSBhY2Nlc3NpYmxlIGZyb20gdGhpcyBtb2R1bGUuXG4gKiBUaGlzIGlzIHVzZWZ1bCB0byBpbXBsZW1lbnQgb3B0aW9uYWwgZmVhdHVyZXMgKGxpa2UgYnVuZGxlcykgaW4gZnJlZVxuICogZnVuY3Rpb25zLCBzdWNoIHRoYXQgdGhleSBhcmUgdHJlZS1zaGFrZWFibGUuXG4gKi9cbmNsYXNzIFN5bmNFbmdpbmVJbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbFN0b3JlLCByZW1vdGVTdG9yZSwgZXZlbnRNYW5hZ2VyLCBcbiAgICAvLyBQT1JUSU5HIE5PVEU6IE1hbmFnZXMgc3RhdGUgc3luY2hyb25pemF0aW9uIGluIG11bHRpLXRhYiBlbnZpcm9ubWVudHMuXG4gICAgc2hhcmVkQ2xpZW50U3RhdGUsIGN1cnJlbnRVc2VyLCBtYXhDb25jdXJyZW50TGltYm9SZXNvbHV0aW9ucykge1xuICAgICAgICB0aGlzLmxvY2FsU3RvcmUgPSBsb2NhbFN0b3JlO1xuICAgICAgICB0aGlzLnJlbW90ZVN0b3JlID0gcmVtb3RlU3RvcmU7XG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xuICAgICAgICB0aGlzLnNoYXJlZENsaWVudFN0YXRlID0gc2hhcmVkQ2xpZW50U3RhdGU7XG4gICAgICAgIHRoaXMuY3VycmVudFVzZXIgPSBjdXJyZW50VXNlcjtcbiAgICAgICAgdGhpcy5tYXhDb25jdXJyZW50TGltYm9SZXNvbHV0aW9ucyA9IG1heENvbmN1cnJlbnRMaW1ib1Jlc29sdXRpb25zO1xuICAgICAgICB0aGlzLnN5bmNFbmdpbmVMaXN0ZW5lciA9IHt9O1xuICAgICAgICB0aGlzLnF1ZXJ5Vmlld3NCeVF1ZXJ5ID0gbmV3IE9iamVjdE1hcChxID0+IGNhbm9uaWZ5UXVlcnkocSksIHF1ZXJ5RXF1YWxzKTtcbiAgICAgICAgdGhpcy5xdWVyaWVzQnlUYXJnZXQgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUga2V5cyBvZiBkb2N1bWVudHMgdGhhdCBhcmUgaW4gbGltYm8gZm9yIHdoaWNoIHdlIGhhdmVuJ3QgeWV0IHN0YXJ0ZWQgYVxuICAgICAgICAgKiBsaW1ibyByZXNvbHV0aW9uIHF1ZXJ5LiBUaGUgc3RyaW5ncyBpbiB0aGlzIHNldCBhcmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nXG4gICAgICAgICAqIGBrZXkucGF0aC5jYW5vbmljYWxTdHJpbmcoKWAgd2hlcmUgYGtleWAgaXMgYSBgRG9jdW1lbnRLZXlgIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGBTZXRgIHR5cGUgd2FzIGNob3NlbiBiZWNhdXNlIGl0IHByb3ZpZGVzIGVmZmljaWVudCBsb29rdXAgYW5kIHJlbW92YWxcbiAgICAgICAgICogb2YgYXJiaXRyYXJ5IGVsZW1lbnRzIGFuZCBpdCBhbHNvIG1haW50YWlucyBpbnNlcnRpb24gb3JkZXIsIHByb3ZpZGluZyB0aGVcbiAgICAgICAgICogZGVzaXJlZCBxdWV1ZS1saWtlIEZJRk8gc2VtYW50aWNzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgdGFyZ2V0IElEIGZvciBlYWNoIGRvY3VtZW50IHRoYXQgaXMgaW4gbGltYm8gd2l0aCBhblxuICAgICAgICAgKiBhY3RpdmUgdGFyZ2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmVMaW1ib1RhcmdldHNCeUtleSA9IG5ldyBTb3J0ZWRNYXAoRG9jdW1lbnRLZXkuY29tcGFyYXRvcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgaW5mb3JtYXRpb24gYWJvdXQgYW4gYWN0aXZlIGxpbWJvIHJlc29sdXRpb24gZm9yIGVhY2hcbiAgICAgICAgICogYWN0aXZlIHRhcmdldCBJRCB0aGF0IHdhcyBzdGFydGVkIGZvciB0aGUgcHVycG9zZSBvZiBsaW1ibyByZXNvbHV0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmVMaW1ib1Jlc29sdXRpb25zQnlUYXJnZXQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubGltYm9Eb2N1bWVudFJlZnMgPSBuZXcgUmVmZXJlbmNlU2V0KCk7XG4gICAgICAgIC8qKiBTdG9yZXMgdXNlciBjb21wbGV0aW9uIGhhbmRsZXJzLCBpbmRleGVkIGJ5IFVzZXIgYW5kIEJhdGNoSWQuICovXG4gICAgICAgIHRoaXMubXV0YXRpb25Vc2VyQ2FsbGJhY2tzID0ge307XG4gICAgICAgIC8qKiBTdG9yZXMgdXNlciBjYWxsYmFja3Mgd2FpdGluZyBmb3IgYWxsIHBlbmRpbmcgd3JpdGVzIHRvIGJlIGFja25vd2xlZGdlZC4gKi9cbiAgICAgICAgdGhpcy5wZW5kaW5nV3JpdGVzQ2FsbGJhY2tzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmxpbWJvVGFyZ2V0SWRHZW5lcmF0b3IgPSBUYXJnZXRJZEdlbmVyYXRvci5mb3JTeW5jRW5naW5lKCk7XG4gICAgICAgIHRoaXMub25saW5lU3RhdGUgPSBcIlVua25vd25cIiAvKiBPbmxpbmVTdGF0ZS5Vbmtub3duICovO1xuICAgICAgICAvLyBUaGUgcHJpbWFyeSBzdGF0ZSBpcyBzZXQgdG8gYHRydWVgIG9yIGBmYWxzZWAgaW1tZWRpYXRlbHkgYWZ0ZXIgRmlyZXN0b3JlXG4gICAgICAgIC8vIHN0YXJ0dXAuIEluIHRoZSBpbnRlcmltLCBhIGNsaWVudCBzaG91bGQgb25seSBiZSBjb25zaWRlcmVkIHByaW1hcnkgaWZcbiAgICAgICAgLy8gYGlzUHJpbWFyeWAgaXMgdHJ1ZS5cbiAgICAgICAgdGhpcy5faXNQcmltYXJ5Q2xpZW50ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgaXNQcmltYXJ5Q2xpZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNQcmltYXJ5Q2xpZW50ID09PSB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5ld1N5bmNFbmdpbmUobG9jYWxTdG9yZSwgcmVtb3RlU3RvcmUsIGV2ZW50TWFuYWdlciwgXG4vLyBQT1JUSU5HIE5PVEU6IE1hbmFnZXMgc3RhdGUgc3luY2hyb25pemF0aW9uIGluIG11bHRpLXRhYiBlbnZpcm9ubWVudHMuXG5zaGFyZWRDbGllbnRTdGF0ZSwgY3VycmVudFVzZXIsIG1heENvbmN1cnJlbnRMaW1ib1Jlc29sdXRpb25zLCBpc1ByaW1hcnkpIHtcbiAgICBjb25zdCBzeW5jRW5naW5lID0gbmV3IFN5bmNFbmdpbmVJbXBsKGxvY2FsU3RvcmUsIHJlbW90ZVN0b3JlLCBldmVudE1hbmFnZXIsIHNoYXJlZENsaWVudFN0YXRlLCBjdXJyZW50VXNlciwgbWF4Q29uY3VycmVudExpbWJvUmVzb2x1dGlvbnMpO1xuICAgIGlmIChpc1ByaW1hcnkpIHtcbiAgICAgICAgc3luY0VuZ2luZS5faXNQcmltYXJ5Q2xpZW50ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHN5bmNFbmdpbmU7XG59XG4vKipcbiAqIEluaXRpYXRlcyB0aGUgbmV3IGxpc3RlbiwgcmVzb2x2ZXMgcHJvbWlzZSB3aGVuIGxpc3RlbiBlbnF1ZXVlZCB0byB0aGVcbiAqIHNlcnZlci4gQWxsIHRoZSBzdWJzZXF1ZW50IHZpZXcgc25hcHNob3RzIG9yIGVycm9ycyBhcmUgc2VudCB0byB0aGVcbiAqIHN1YnNjcmliZWQgaGFuZGxlcnMuIFJldHVybnMgdGhlIGluaXRpYWwgc25hcHNob3QuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVMaXN0ZW4oc3luY0VuZ2luZSwgcXVlcnksIHNob3VsZExpc3RlblRvUmVtb3RlID0gdHJ1ZSkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZW5zdXJlV2F0Y2hDYWxsYmFja3Moc3luY0VuZ2luZSk7XG4gICAgbGV0IHZpZXdTbmFwc2hvdDtcbiAgICBjb25zdCBxdWVyeVZpZXcgPSBzeW5jRW5naW5lSW1wbC5xdWVyeVZpZXdzQnlRdWVyeS5nZXQocXVlcnkpO1xuICAgIGlmIChxdWVyeVZpZXcpIHtcbiAgICAgICAgLy8gUE9SVElORyBOT1RFOiBXaXRoIE11bHRpLVRhYiBXZWIsIGl0IGlzIHBvc3NpYmxlIHRoYXQgYSBxdWVyeSB2aWV3XG4gICAgICAgIC8vIGFscmVhZHkgZXhpc3RzIHdoZW4gRXZlbnRNYW5hZ2VyIGNhbGxzIHVzIGZvciB0aGUgZmlyc3QgdGltZS4gVGhpc1xuICAgICAgICAvLyBoYXBwZW5zIHdoZW4gdGhlIHByaW1hcnkgdGFiIGlzIGFscmVhZHkgbGlzdGVuaW5nIHRvIHRoaXMgcXVlcnkgb25cbiAgICAgICAgLy8gYmVoYWxmIG9mIGFub3RoZXIgdGFiIGFuZCB0aGUgdXNlciBvZiB0aGUgcHJpbWFyeSBhbHNvIHN0YXJ0cyBsaXN0ZW5pbmdcbiAgICAgICAgLy8gdG8gdGhlIHF1ZXJ5LiBFdmVudE1hbmFnZXIgd2lsbCBub3QgaGF2ZSBhbiBhc3NpZ25lZCB0YXJnZXQgSUQgaW4gdGhpc1xuICAgICAgICAvLyBjYXNlIGFuZCBjYWxscyBgbGlzdGVuYCB0byBvYnRhaW4gdGhpcyBJRC5cbiAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUuYWRkTG9jYWxRdWVyeVRhcmdldChxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgICAgICB2aWV3U25hcHNob3QgPSBxdWVyeVZpZXcudmlldy5jb21wdXRlSW5pdGlhbFNuYXBzaG90KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3U25hcHNob3QgPSBhd2FpdCBhbGxvY2F0ZVRhcmdldEFuZE1heWJlTGlzdGVuKHN5bmNFbmdpbmVJbXBsLCBxdWVyeSwgc2hvdWxkTGlzdGVuVG9SZW1vdGUsIFxuICAgICAgICAvKiogc2hvdWxkSW5pdGlhbGl6ZVZpZXc9ICovIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmlld1NuYXBzaG90O1xufVxuLyoqIFF1ZXJ5IGhhcyBiZWVuIGxpc3RlbmluZyB0byB0aGUgY2FjaGUsIGFuZCB0cmllcyB0byBpbml0aWF0ZSB0aGUgcmVtb3RlIHN0b3JlIGxpc3RlbiAqL1xuYXN5bmMgZnVuY3Rpb24gdHJpZ2dlclJlbW90ZVN0b3JlTGlzdGVuKHN5bmNFbmdpbmUsIHF1ZXJ5KSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBlbnN1cmVXYXRjaENhbGxiYWNrcyhzeW5jRW5naW5lKTtcbiAgICBhd2FpdCBhbGxvY2F0ZVRhcmdldEFuZE1heWJlTGlzdGVuKHN5bmNFbmdpbmVJbXBsLCBxdWVyeSwgXG4gICAgLyoqIHNob3VsZExpc3RlblRvUmVtb3RlPSAqLyB0cnVlLCBcbiAgICAvKiogc2hvdWxkSW5pdGlhbGl6ZVZpZXc9ICovIGZhbHNlKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFsbG9jYXRlVGFyZ2V0QW5kTWF5YmVMaXN0ZW4oc3luY0VuZ2luZUltcGwsIHF1ZXJ5LCBzaG91bGRMaXN0ZW5Ub1JlbW90ZSwgc2hvdWxkSW5pdGlhbGl6ZVZpZXcpIHtcbiAgICBjb25zdCB0YXJnZXREYXRhID0gYXdhaXQgbG9jYWxTdG9yZUFsbG9jYXRlVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHF1ZXJ5VG9UYXJnZXQocXVlcnkpKTtcbiAgICBjb25zdCB0YXJnZXRJZCA9IHRhcmdldERhdGEudGFyZ2V0SWQ7XG4gICAgLy8gUE9SVElORyBOT1RFOiBXaGVuIHRoZSBxdWVyeSBpcyBsaXN0ZW5pbmcgdG8gY2FjaGUgb25seSwgd2Ugc2tpcCBzZW5kaW5nIGl0IG92ZXIgdG8gV2F0Y2ggYnlcbiAgICAvLyBub3QgcmVnaXN0ZXJpbmcgaXQgaW4gc2hhcmVkIGNsaWVudCBzdGF0ZSwgYW5kIGRpcmVjdGx5IGNhbGN1bGF0ZSBpbml0aWFsIHNuYXBzaG90cyBhbmRcbiAgICAvLyBzdWJzZXF1ZW50IHVwZGF0ZXMgZnJvbSBjYWNoZS4gT3RoZXJ3aXNlLCByZWdpc3RlciB0aGUgdGFyZ2V0IElEIHdpdGggbG9jYWwgRmlyZXN0b3JlIGNsaWVudFxuICAgIC8vIGFzIGFjdGl2ZSB3YXRjaCB0YXJnZXQuXG4gICAgY29uc3Qgc3RhdHVzID0gc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUuYWRkTG9jYWxRdWVyeVRhcmdldCh0YXJnZXRJZCwgXG4gICAgLyogYWRkVG9BY3RpdmVUYXJnZXRJZHM9ICovIHNob3VsZExpc3RlblRvUmVtb3RlKTtcbiAgICBsZXQgdmlld1NuYXBzaG90O1xuICAgIGlmIChzaG91bGRJbml0aWFsaXplVmlldykge1xuICAgICAgICB2aWV3U25hcHNob3QgPSBhd2FpdCBpbml0aWFsaXplVmlld0FuZENvbXB1dGVTbmFwc2hvdChzeW5jRW5naW5lSW1wbCwgcXVlcnksIHRhcmdldElkLCBzdGF0dXMgPT09ICdjdXJyZW50JywgdGFyZ2V0RGF0YS5yZXN1bWVUb2tlbik7XG4gICAgfVxuICAgIGlmIChzeW5jRW5naW5lSW1wbC5pc1ByaW1hcnlDbGllbnQgJiYgc2hvdWxkTGlzdGVuVG9SZW1vdGUpIHtcbiAgICAgICAgcmVtb3RlU3RvcmVMaXN0ZW4oc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIHRhcmdldERhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdmlld1NuYXBzaG90O1xufVxuLyoqXG4gKiBSZWdpc3RlcnMgYSB2aWV3IGZvciBhIHByZXZpb3VzbHkgdW5rbm93biBxdWVyeSBhbmQgY29tcHV0ZXMgaXRzIGluaXRpYWxcbiAqIHNuYXBzaG90LlxuICovXG5hc3luYyBmdW5jdGlvbiBpbml0aWFsaXplVmlld0FuZENvbXB1dGVTbmFwc2hvdChzeW5jRW5naW5lSW1wbCwgcXVlcnksIHRhcmdldElkLCBjdXJyZW50LCByZXN1bWVUb2tlbikge1xuICAgIC8vIFBPUlRJTkcgTk9URTogT24gV2ViIG9ubHksIHdlIGluamVjdCB0aGUgY29kZSB0aGF0IHJlZ2lzdGVycyBuZXcgTGltYm9cbiAgICAvLyB0YXJnZXRzIGJhc2VkIG9uIHZpZXcgY2hhbmdlcy4gVGhpcyBhbGxvd3MgdXMgdG8gb25seSBkZXBlbmQgb24gTGltYm9cbiAgICAvLyBjaGFuZ2VzIHdoZW4gdXNlciBjb2RlIGluY2x1ZGVzIHF1ZXJpZXMuXG4gICAgc3luY0VuZ2luZUltcGwuYXBwbHlEb2NDaGFuZ2VzID0gKHF1ZXJ5VmlldywgY2hhbmdlcywgcmVtb3RlRXZlbnQpID0+IGFwcGx5RG9jQ2hhbmdlcyhzeW5jRW5naW5lSW1wbCwgcXVlcnlWaWV3LCBjaGFuZ2VzLCByZW1vdGVFdmVudCk7XG4gICAgY29uc3QgcXVlcnlSZXN1bHQgPSBhd2FpdCBsb2NhbFN0b3JlRXhlY3V0ZVF1ZXJ5KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHF1ZXJ5LCBcbiAgICAvKiB1c2VQcmV2aW91c1Jlc3VsdHM9ICovIHRydWUpO1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgVmlldyhxdWVyeSwgcXVlcnlSZXN1bHQucmVtb3RlS2V5cyk7XG4gICAgY29uc3Qgdmlld0RvY0NoYW5nZXMgPSB2aWV3LmNvbXB1dGVEb2NDaGFuZ2VzKHF1ZXJ5UmVzdWx0LmRvY3VtZW50cyk7XG4gICAgY29uc3Qgc3ludGhlc2l6ZWRUYXJnZXRDaGFuZ2UgPSBUYXJnZXRDaGFuZ2UuY3JlYXRlU3ludGhlc2l6ZWRUYXJnZXRDaGFuZ2VGb3JDdXJyZW50Q2hhbmdlKHRhcmdldElkLCBjdXJyZW50ICYmIHN5bmNFbmdpbmVJbXBsLm9ubGluZVN0YXRlICE9PSBcIk9mZmxpbmVcIiAvKiBPbmxpbmVTdGF0ZS5PZmZsaW5lICovLCByZXN1bWVUb2tlbik7XG4gICAgY29uc3Qgdmlld0NoYW5nZSA9IHZpZXcuYXBwbHlDaGFuZ2VzKHZpZXdEb2NDaGFuZ2VzLCBcbiAgICAvKiBsaW1ib1Jlc29sdXRpb25FbmFibGVkPSAqLyBzeW5jRW5naW5lSW1wbC5pc1ByaW1hcnlDbGllbnQsIHN5bnRoZXNpemVkVGFyZ2V0Q2hhbmdlKTtcbiAgICB1cGRhdGVUcmFja2VkTGltYm9zKHN5bmNFbmdpbmVJbXBsLCB0YXJnZXRJZCwgdmlld0NoYW5nZS5saW1ib0NoYW5nZXMpO1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgUXVlcnlWaWV3KHF1ZXJ5LCB0YXJnZXRJZCwgdmlldyk7XG4gICAgc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuc2V0KHF1ZXJ5LCBkYXRhKTtcbiAgICBpZiAoc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0Lmhhcyh0YXJnZXRJZCkpIHtcbiAgICAgICAgc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LmdldCh0YXJnZXRJZCkucHVzaChxdWVyeSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5xdWVyaWVzQnlUYXJnZXQuc2V0KHRhcmdldElkLCBbcXVlcnldKTtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXdDaGFuZ2Uuc25hcHNob3Q7XG59XG4vKiogU3RvcHMgbGlzdGVuaW5nIHRvIHRoZSBxdWVyeS4gKi9cbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVVbmxpc3RlbihzeW5jRW5naW5lLCBxdWVyeSwgc2hvdWxkVW5saXN0ZW5Ub1JlbW90ZSkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIGNvbnN0IHF1ZXJ5VmlldyA9IHN5bmNFbmdpbmVJbXBsLnF1ZXJ5Vmlld3NCeVF1ZXJ5LmdldChxdWVyeSk7XG4gICAgLy8gT25seSBjbGVhbiB1cCB0aGUgcXVlcnkgdmlldyBhbmQgdGFyZ2V0IGlmIHRoaXMgaXMgdGhlIG9ubHkgcXVlcnkgbWFwcGVkXG4gICAgLy8gdG8gdGhlIHRhcmdldC5cbiAgICBjb25zdCBxdWVyaWVzID0gc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LmdldChxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgIGlmIChxdWVyaWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LnNldChxdWVyeVZpZXcudGFyZ2V0SWQsIHF1ZXJpZXMuZmlsdGVyKHEgPT4gIXF1ZXJ5RXF1YWxzKHEsIHF1ZXJ5KSkpO1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5xdWVyeVZpZXdzQnlRdWVyeS5kZWxldGUocXVlcnkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIE5vIG90aGVyIHF1ZXJpZXMgYXJlIG1hcHBlZCB0byB0aGUgdGFyZ2V0LCBjbGVhbiB1cCB0aGUgcXVlcnkgYW5kIHRoZSB0YXJnZXQuXG4gICAgaWYgKHN5bmNFbmdpbmVJbXBsLmlzUHJpbWFyeUNsaWVudCkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHJlbW92ZSB0aGUgbG9jYWwgcXVlcnkgdGFyZ2V0IGZpcnN0IHRvIGFsbG93IHVzIHRvIHZlcmlmeVxuICAgICAgICAvLyB3aGV0aGVyIGFueSBvdGhlciBjbGllbnQgaXMgc3RpbGwgaW50ZXJlc3RlZCBpbiB0aGlzIHRhcmdldC5cbiAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUucmVtb3ZlTG9jYWxRdWVyeVRhcmdldChxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgICAgICBjb25zdCB0YXJnZXRSZW1haW5zQWN0aXZlID0gc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUuaXNBY3RpdmVRdWVyeVRhcmdldChxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgICAgICBpZiAoIXRhcmdldFJlbWFpbnNBY3RpdmUpIHtcbiAgICAgICAgICAgIGF3YWl0IGxvY2FsU3RvcmVSZWxlYXNlVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHF1ZXJ5Vmlldy50YXJnZXRJZCwgXG4gICAgICAgICAgICAvKmtlZXBQZXJzaXN0ZWRUYXJnZXREYXRhPSovIGZhbHNlKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5jbGVhclF1ZXJ5U3RhdGUocXVlcnlWaWV3LnRhcmdldElkKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkVW5saXN0ZW5Ub1JlbW90ZSkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVTdG9yZVVubGlzdGVuKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCBxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZW1vdmVBbmRDbGVhbnVwVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLCBxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goaWdub3JlSWZQcmltYXJ5TGVhc2VMb3NzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVtb3ZlQW5kQ2xlYW51cFRhcmdldChzeW5jRW5naW5lSW1wbCwgcXVlcnlWaWV3LnRhcmdldElkKTtcbiAgICAgICAgYXdhaXQgbG9jYWxTdG9yZVJlbGVhc2VUYXJnZXQoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgcXVlcnlWaWV3LnRhcmdldElkLCBcbiAgICAgICAgLyprZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YT0qLyB0cnVlKTtcbiAgICB9XG59XG4vKiogVW5saXN0ZW5zIHRvIHRoZSByZW1vdGUgc3RvcmUgd2hpbGUgc3RpbGwgbGlzdGVuaW5nIHRvIHRoZSBjYWNoZS4gKi9cbmFzeW5jIGZ1bmN0aW9uIHRyaWdnZXJSZW1vdGVTdG9yZVVubGlzdGVuKHN5bmNFbmdpbmUsIHF1ZXJ5KSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgY29uc3QgcXVlcnlWaWV3ID0gc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZ2V0KHF1ZXJ5KTtcbiAgICBjb25zdCBxdWVyaWVzID0gc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LmdldChxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgIGlmIChzeW5jRW5naW5lSW1wbC5pc1ByaW1hcnlDbGllbnQgJiYgcXVlcmllcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gUE9SVElORyBOT1RFOiBVbnJlZ2lzdGVyIHRoZSB0YXJnZXQgSUQgd2l0aCBsb2NhbCBGaXJlc3RvcmUgY2xpZW50IGFzXG4gICAgICAgIC8vIHdhdGNoIHRhcmdldC5cbiAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUucmVtb3ZlTG9jYWxRdWVyeVRhcmdldChxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgICAgICByZW1vdGVTdG9yZVVubGlzdGVuKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCBxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgIH1cbn1cbi8qKlxuICogSW5pdGlhdGVzIHRoZSB3cml0ZSBvZiBsb2NhbCBtdXRhdGlvbiBiYXRjaCB3aGljaCBpbnZvbHZlcyBhZGRpbmcgdGhlXG4gKiB3cml0ZXMgdG8gdGhlIG11dGF0aW9uIHF1ZXVlLCBub3RpZnlpbmcgdGhlIHJlbW90ZSBzdG9yZSBhYm91dCBuZXdcbiAqIG11dGF0aW9ucyBhbmQgcmFpc2luZyBldmVudHMgZm9yIGFueSBjaGFuZ2VzIHRoaXMgd3JpdGUgY2F1c2VkLlxuICpcbiAqIFRoZSBwcm9taXNlIHJldHVybmVkIGJ5IHRoaXMgY2FsbCBpcyByZXNvbHZlZCB3aGVuIHRoZSBhYm92ZSBzdGVwc1xuICogaGF2ZSBjb21wbGV0ZWQsICpub3QqIHdoZW4gdGhlIHdyaXRlIHdhcyBhY2tlZCBieSB0aGUgYmFja2VuZC4gVGhlXG4gKiB1c2VyQ2FsbGJhY2sgaXMgcmVzb2x2ZWQgb25jZSB0aGUgd3JpdGUgd2FzIGFja2VkL3JlamVjdGVkIGJ5IHRoZVxuICogYmFja2VuZCAob3IgZmFpbGVkIGxvY2FsbHkgZm9yIGFueSBvdGhlciByZWFzb24pLlxuICovXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lV3JpdGUoc3luY0VuZ2luZSwgYmF0Y2gsIHVzZXJDYWxsYmFjaykge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gc3luY0VuZ2luZUVuc3VyZVdyaXRlQ2FsbGJhY2tzKHN5bmNFbmdpbmUpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxvY2FsU3RvcmVXcml0ZUxvY2FsbHkoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgYmF0Y2gpO1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5hZGRQZW5kaW5nTXV0YXRpb24ocmVzdWx0LmJhdGNoSWQpO1xuICAgICAgICBhZGRNdXRhdGlvbkNhbGxiYWNrKHN5bmNFbmdpbmVJbXBsLCByZXN1bHQuYmF0Y2hJZCwgdXNlckNhbGxiYWNrKTtcbiAgICAgICAgYXdhaXQgc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZUltcGwsIHJlc3VsdC5jaGFuZ2VzKTtcbiAgICAgICAgYXdhaXQgZmlsbFdyaXRlUGlwZWxpbmUoc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBJZiB3ZSBjYW4ndCBwZXJzaXN0IHRoZSBtdXRhdGlvbiwgd2UgcmVqZWN0IHRoZSB1c2VyIGNhbGxiYWNrIGFuZFxuICAgICAgICAvLyBkb24ndCBzZW5kIHRoZSBtdXRhdGlvbi4gVGhlIHVzZXIgY2FuIHRoZW4gcmV0cnkgdGhlIHdyaXRlLlxuICAgICAgICBjb25zdCBlcnJvciA9IHdyYXBJblVzZXJFcnJvcklmUmVjb3ZlcmFibGUoZSwgYEZhaWxlZCB0byBwZXJzaXN0IHdyaXRlYCk7XG4gICAgICAgIHVzZXJDYWxsYmFjay5yZWplY3QoZXJyb3IpO1xuICAgIH1cbn1cbi8qKlxuICogQXBwbGllcyBvbmUgcmVtb3RlIGV2ZW50IHRvIHRoZSBzeW5jIGVuZ2luZSwgbm90aWZ5aW5nIGFueSB2aWV3cyBvZiB0aGVcbiAqIGNoYW5nZXMsIGFuZCByZWxlYXNpbmcgYW55IHBlbmRpbmcgbXV0YXRpb24gYmF0Y2hlcyB0aGF0IHdvdWxkIGJlY29tZVxuICogdmlzaWJsZSBiZWNhdXNlIG9mIHRoZSBzbmFwc2hvdCB2ZXJzaW9uIHRoZSByZW1vdGUgZXZlbnQgY29udGFpbnMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVBcHBseVJlbW90ZUV2ZW50KHN5bmNFbmdpbmUsIHJlbW90ZUV2ZW50KSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IGF3YWl0IGxvY2FsU3RvcmVBcHBseVJlbW90ZUV2ZW50VG9Mb2NhbENhY2hlKHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHJlbW90ZUV2ZW50KTtcbiAgICAgICAgLy8gVXBkYXRlIGByZWNlaXZlZERvY3VtZW50YCBhcyBhcHByb3ByaWF0ZSBmb3IgYW55IGxpbWJvIHRhcmdldHMuXG4gICAgICAgIHJlbW90ZUV2ZW50LnRhcmdldENoYW5nZXMuZm9yRWFjaCgodGFyZ2V0Q2hhbmdlLCB0YXJnZXRJZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGltYm9SZXNvbHV0aW9uID0gc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9SZXNvbHV0aW9uc0J5VGFyZ2V0LmdldCh0YXJnZXRJZCk7XG4gICAgICAgICAgICBpZiAobGltYm9SZXNvbHV0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gU2luY2UgdGhpcyBpcyBhIGxpbWJvIHJlc29sdXRpb24gbG9va3VwLCBpdCdzIGZvciBhIHNpbmdsZSBkb2N1bWVudFxuICAgICAgICAgICAgICAgIC8vIGFuZCBpdCBjb3VsZCBiZSBhZGRlZCwgbW9kaWZpZWQsIG9yIHJlbW92ZWQsIGJ1dCBub3QgYSBjb21iaW5hdGlvbi5cbiAgICAgICAgICAgICAgICBoYXJkQXNzZXJ0KHRhcmdldENoYW5nZS5hZGRlZERvY3VtZW50cy5zaXplICtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q2hhbmdlLm1vZGlmaWVkRG9jdW1lbnRzLnNpemUgK1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRDaGFuZ2UucmVtb3ZlZERvY3VtZW50cy5zaXplIDw9XG4gICAgICAgICAgICAgICAgICAgIDEpO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRDaGFuZ2UuYWRkZWREb2N1bWVudHMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGltYm9SZXNvbHV0aW9uLnJlY2VpdmVkRG9jdW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0YXJnZXRDaGFuZ2UubW9kaWZpZWREb2N1bWVudHMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaGFyZEFzc2VydChsaW1ib1Jlc29sdXRpb24ucmVjZWl2ZWREb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldENoYW5nZS5yZW1vdmVkRG9jdW1lbnRzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQobGltYm9SZXNvbHV0aW9uLnJlY2VpdmVkRG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBsaW1ib1Jlc29sdXRpb24ucmVjZWl2ZWREb2N1bWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3YXMgcHJvYmFibHkganVzdCBhIENVUlJFTlQgdGFyZ2V0Q2hhbmdlIG9yIHNpbWlsYXIuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZUltcGwsIGNoYW5nZXMsIHJlbW90ZUV2ZW50KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGF3YWl0IGlnbm9yZUlmUHJpbWFyeUxlYXNlTG9zcyhlcnJvcik7XG4gICAgfVxufVxuLyoqXG4gKiBBcHBsaWVzIGFuIE9ubGluZVN0YXRlIGNoYW5nZSB0byB0aGUgc3luYyBlbmdpbmUgYW5kIG5vdGlmaWVzIGFueSB2aWV3cyBvZlxuICogdGhlIGNoYW5nZS5cbiAqL1xuZnVuY3Rpb24gc3luY0VuZ2luZUFwcGx5T25saW5lU3RhdGVDaGFuZ2Uoc3luY0VuZ2luZSwgb25saW5lU3RhdGUsIHNvdXJjZSkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIC8vIElmIHdlIGFyZSB0aGUgc2Vjb25kYXJ5IGNsaWVudCwgd2UgZXhwbGljaXRseSBpZ25vcmUgdGhlIHJlbW90ZSBzdG9yZSdzXG4gICAgLy8gb25saW5lIHN0YXRlICh0aGUgbG9jYWwgY2xpZW50IG1heSBnbyBvZmZsaW5lLCBldmVuIHRob3VnaCB0aGUgcHJpbWFyeVxuICAgIC8vIHRhYiByZW1haW5zIG9ubGluZSkgYW5kIG9ubHkgYXBwbHkgdGhlIHByaW1hcnkgdGFiJ3Mgb25saW5lIHN0YXRlIGZyb21cbiAgICAvLyBTaGFyZWRDbGllbnRTdGF0ZS5cbiAgICBpZiAoKHN5bmNFbmdpbmVJbXBsLmlzUHJpbWFyeUNsaWVudCAmJlxuICAgICAgICBzb3VyY2UgPT09IDAgLyogT25saW5lU3RhdGVTb3VyY2UuUmVtb3RlU3RvcmUgKi8pIHx8XG4gICAgICAgICghc3luY0VuZ2luZUltcGwuaXNQcmltYXJ5Q2xpZW50ICYmXG4gICAgICAgICAgICBzb3VyY2UgPT09IDEgLyogT25saW5lU3RhdGVTb3VyY2UuU2hhcmVkQ2xpZW50U3RhdGUgKi8pKSB7XG4gICAgICAgIGNvbnN0IG5ld1ZpZXdTbmFwc2hvdHMgPSBbXTtcbiAgICAgICAgc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZm9yRWFjaCgocXVlcnksIHF1ZXJ5VmlldykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgdmlld0NoYW5nZSA9IHF1ZXJ5Vmlldy52aWV3LmFwcGx5T25saW5lU3RhdGVDaGFuZ2Uob25saW5lU3RhdGUpO1xuICAgICAgICAgICAgaWYgKHZpZXdDaGFuZ2Uuc25hcHNob3QpIHtcbiAgICAgICAgICAgICAgICBuZXdWaWV3U25hcHNob3RzLnB1c2godmlld0NoYW5nZS5zbmFwc2hvdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBldmVudE1hbmFnZXJPbk9ubGluZVN0YXRlQ2hhbmdlKHN5bmNFbmdpbmVJbXBsLmV2ZW50TWFuYWdlciwgb25saW5lU3RhdGUpO1xuICAgICAgICBpZiAobmV3Vmlld1NuYXBzaG90cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN5bmNFbmdpbmVJbXBsLnN5bmNFbmdpbmVMaXN0ZW5lci5vbldhdGNoQ2hhbmdlKG5ld1ZpZXdTbmFwc2hvdHMpO1xuICAgICAgICB9XG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLm9ubGluZVN0YXRlID0gb25saW5lU3RhdGU7XG4gICAgICAgIGlmIChzeW5jRW5naW5lSW1wbC5pc1ByaW1hcnlDbGllbnQpIHtcbiAgICAgICAgICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLnNldE9ubGluZVN0YXRlKG9ubGluZVN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogUmVqZWN0cyB0aGUgbGlzdGVuIGZvciB0aGUgZ2l2ZW4gdGFyZ2V0SUQuIFRoaXMgY2FuIGJlIHRyaWdnZXJlZCBieSB0aGVcbiAqIGJhY2tlbmQgZm9yIGFueSBhY3RpdmUgdGFyZ2V0LlxuICpcbiAqIEBwYXJhbSBzeW5jRW5naW5lIC0gVGhlIHN5bmMgZW5naW5lIGltcGxlbWVudGF0aW9uLlxuICogQHBhcmFtIHRhcmdldElkIC0gVGhlIHRhcmdldElEIGNvcnJlc3BvbmRzIHRvIG9uZSBwcmV2aW91c2x5IGluaXRpYXRlZCBieSB0aGVcbiAqIHVzZXIgYXMgcGFydCBvZiBUYXJnZXREYXRhIHBhc3NlZCB0byBsaXN0ZW4oKSBvbiBSZW1vdGVTdG9yZS5cbiAqIEBwYXJhbSBlcnIgLSBBIGRlc2NyaXB0aW9uIG9mIHRoZSBjb25kaXRpb24gdGhhdCBoYXMgZm9yY2VkIHRoZSByZWplY3Rpb24uXG4gKiBOZWFybHkgYWx3YXlzIHRoaXMgd2lsbCBiZSBhbiBpbmRpY2F0aW9uIHRoYXQgdGhlIHVzZXIgaXMgbm8gbG9uZ2VyXG4gKiBhdXRob3JpemVkIHRvIHNlZSB0aGUgZGF0YSBtYXRjaGluZyB0aGUgdGFyZ2V0LlxuICovXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lUmVqZWN0TGlzdGVuKHN5bmNFbmdpbmUsIHRhcmdldElkLCBlcnIpIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcbiAgICAvLyBQT1JUSU5HIE5PVEU6IE11bHRpLXRhYiBvbmx5LlxuICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLnVwZGF0ZVF1ZXJ5U3RhdGUodGFyZ2V0SWQsICdyZWplY3RlZCcsIGVycik7XG4gICAgY29uc3QgbGltYm9SZXNvbHV0aW9uID0gc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9SZXNvbHV0aW9uc0J5VGFyZ2V0LmdldCh0YXJnZXRJZCk7XG4gICAgY29uc3QgbGltYm9LZXkgPSBsaW1ib1Jlc29sdXRpb24gJiYgbGltYm9SZXNvbHV0aW9uLmtleTtcbiAgICBpZiAobGltYm9LZXkpIHtcbiAgICAgICAgLy8gVE9ETyhrbGltdCk6IFdlIHJlYWxseSBvbmx5IHNob3VsZCBkbyB0aGUgZm9sbG93aW5nIG9uIHBlcm1pc3Npb25cbiAgICAgICAgLy8gZGVuaWVkIGVycm9ycywgYnV0IHdlIGRvbid0IGhhdmUgdGhlIGNhdXNlIGNvZGUgaGVyZS5cbiAgICAgICAgLy8gSXQncyBhIGxpbWJvIGRvYy4gQ3JlYXRlIGEgc3ludGhldGljIGV2ZW50IHNheWluZyBpdCB3YXMgZGVsZXRlZC5cbiAgICAgICAgLy8gVGhpcyBpcyBraW5kIG9mIGEgaGFjay4gSWRlYWxseSwgd2Ugd291bGQgaGF2ZSBhIG1ldGhvZCBpbiB0aGUgbG9jYWxcbiAgICAgICAgLy8gc3RvcmUgdG8gcHVyZ2UgYSBkb2N1bWVudC4gSG93ZXZlciwgaXQgd291bGQgYmUgdHJpY2t5IHRvIGtlZXAgYWxsIG9mXG4gICAgICAgIC8vIHRoZSBsb2NhbCBzdG9yZSdzIGludmFyaWFudHMgd2l0aCBhbm90aGVyIG1ldGhvZC5cbiAgICAgICAgbGV0IGRvY3VtZW50VXBkYXRlcyA9IG5ldyBTb3J0ZWRNYXAoRG9jdW1lbnRLZXkuY29tcGFyYXRvcik7XG4gICAgICAgIC8vIFRPRE8oYi8yMTcxODkyMTYpOiBUaGlzIGxpbWJvIGRvY3VtZW50IHNob3VsZCBpZGVhbGx5IGhhdmUgYSByZWFkIHRpbWUsXG4gICAgICAgIC8vIHNvIHRoYXQgaXQgaXMgcGlja2VkIHVwIGJ5IGFueSByZWFkLXRpbWUgYmFzZWQgc2NhbnMuIFRoZSBiYWNrZW5kLFxuICAgICAgICAvLyBob3dldmVyLCBkb2VzIG5vdCBzZW5kIGEgcmVhZCB0aW1lIGZvciB0YXJnZXQgcmVtb3ZhbHMuXG4gICAgICAgIGRvY3VtZW50VXBkYXRlcyA9IGRvY3VtZW50VXBkYXRlcy5pbnNlcnQobGltYm9LZXksIE11dGFibGVEb2N1bWVudC5uZXdOb0RvY3VtZW50KGxpbWJvS2V5LCBTbmFwc2hvdFZlcnNpb24ubWluKCkpKTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRMaW1ib0RvY3VtZW50cyA9IGRvY3VtZW50S2V5U2V0KCkuYWRkKGxpbWJvS2V5KTtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgUmVtb3RlRXZlbnQoU25hcHNob3RWZXJzaW9uLm1pbigpLCBcbiAgICAgICAgLyogdGFyZ2V0Q2hhbmdlcz0gKi8gbmV3IE1hcCgpLCBcbiAgICAgICAgLyogdGFyZ2V0TWlzbWF0Y2hlcz0gKi8gbmV3IFNvcnRlZE1hcChwcmltaXRpdmVDb21wYXJhdG9yKSwgZG9jdW1lbnRVcGRhdGVzLCByZXNvbHZlZExpbWJvRG9jdW1lbnRzKTtcbiAgICAgICAgYXdhaXQgc3luY0VuZ2luZUFwcGx5UmVtb3RlRXZlbnQoc3luY0VuZ2luZUltcGwsIGV2ZW50KTtcbiAgICAgICAgLy8gU2luY2UgdGhpcyBxdWVyeSBmYWlsZWQsIHdlIHdvbid0IHdhbnQgdG8gbWFudWFsbHkgdW5saXN0ZW4gdG8gaXQuXG4gICAgICAgIC8vIFdlIG9ubHkgcmVtb3ZlIGl0IGZyb20gYm9va2tlZXBpbmcgYWZ0ZXIgd2Ugc3VjY2Vzc2Z1bGx5IGFwcGxpZWQgdGhlXG4gICAgICAgIC8vIFJlbW90ZUV2ZW50LiBJZiBgYXBwbHlSZW1vdGVFdmVudCgpYCB0aHJvd3MsIHdlIHdhbnQgdG8gcmUtbGlzdGVuIHRvXG4gICAgICAgIC8vIHRoaXMgcXVlcnkgd2hlbiB0aGUgUmVtb3RlU3RvcmUgcmVzdGFydHMgdGhlIFdhdGNoIHN0cmVhbSwgd2hpY2ggc2hvdWxkXG4gICAgICAgIC8vIHJlLXRyaWdnZXIgdGhlIHRhcmdldCBmYWlsdXJlLlxuICAgICAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1RhcmdldHNCeUtleSA9XG4gICAgICAgICAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1RhcmdldHNCeUtleS5yZW1vdmUobGltYm9LZXkpO1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1Jlc29sdXRpb25zQnlUYXJnZXQuZGVsZXRlKHRhcmdldElkKTtcbiAgICAgICAgcHVtcEVucXVldWVkTGltYm9SZXNvbHV0aW9ucyhzeW5jRW5naW5lSW1wbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhd2FpdCBsb2NhbFN0b3JlUmVsZWFzZVRhcmdldChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCB0YXJnZXRJZCwgXG4gICAgICAgIC8qIGtlZXBQZXJzaXN0ZWRUYXJnZXREYXRhICovIGZhbHNlKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gcmVtb3ZlQW5kQ2xlYW51cFRhcmdldChzeW5jRW5naW5lSW1wbCwgdGFyZ2V0SWQsIGVycikpXG4gICAgICAgICAgICAuY2F0Y2goaWdub3JlSWZQcmltYXJ5TGVhc2VMb3NzKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lQXBwbHlTdWNjZXNzZnVsV3JpdGUoc3luY0VuZ2luZSwgbXV0YXRpb25CYXRjaFJlc3VsdCkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIGNvbnN0IGJhdGNoSWQgPSBtdXRhdGlvbkJhdGNoUmVzdWx0LmJhdGNoLmJhdGNoSWQ7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IGF3YWl0IGxvY2FsU3RvcmVBY2tub3dsZWRnZUJhdGNoKHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIG11dGF0aW9uQmF0Y2hSZXN1bHQpO1xuICAgICAgICAvLyBUaGUgbG9jYWwgc3RvcmUgbWF5IG9yIG1heSBub3QgYmUgYWJsZSB0byBhcHBseSB0aGUgd3JpdGUgcmVzdWx0IGFuZFxuICAgICAgICAvLyByYWlzZSBldmVudHMgaW1tZWRpYXRlbHkgKGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSB3YXRjaGVyIGlzIGNhdWdodFxuICAgICAgICAvLyB1cCksIHNvIHdlIHJhaXNlIHVzZXIgY2FsbGJhY2tzIGZpcnN0IHNvIHRoYXQgdGhleSBjb25zaXN0ZW50bHkgaGFwcGVuXG4gICAgICAgIC8vIGJlZm9yZSBsaXN0ZW4gZXZlbnRzLlxuICAgICAgICBwcm9jZXNzVXNlckNhbGxiYWNrKHN5bmNFbmdpbmVJbXBsLCBiYXRjaElkLCAvKmVycm9yPSovIG51bGwpO1xuICAgICAgICB0cmlnZ2VyUGVuZGluZ1dyaXRlc0NhbGxiYWNrcyhzeW5jRW5naW5lSW1wbCwgYmF0Y2hJZCk7XG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLnVwZGF0ZU11dGF0aW9uU3RhdGUoYmF0Y2hJZCwgJ2Fja25vd2xlZGdlZCcpO1xuICAgICAgICBhd2FpdCBzeW5jRW5naW5lRW1pdE5ld1NuYXBzQW5kTm90aWZ5TG9jYWxTdG9yZShzeW5jRW5naW5lSW1wbCwgY2hhbmdlcyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBhd2FpdCBpZ25vcmVJZlByaW1hcnlMZWFzZUxvc3MoZXJyb3IpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVSZWplY3RGYWlsZWRXcml0ZShzeW5jRW5naW5lLCBiYXRjaElkLCBlcnJvcikge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBhd2FpdCBsb2NhbFN0b3JlUmVqZWN0QmF0Y2goc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgYmF0Y2hJZCk7XG4gICAgICAgIC8vIFRoZSBsb2NhbCBzdG9yZSBtYXkgb3IgbWF5IG5vdCBiZSBhYmxlIHRvIGFwcGx5IHRoZSB3cml0ZSByZXN1bHQgYW5kXG4gICAgICAgIC8vIHJhaXNlIGV2ZW50cyBpbW1lZGlhdGVseSAoZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIHdhdGNoZXIgaXMgY2F1Z2h0IHVwKSxcbiAgICAgICAgLy8gc28gd2UgcmFpc2UgdXNlciBjYWxsYmFja3MgZmlyc3Qgc28gdGhhdCB0aGV5IGNvbnNpc3RlbnRseSBoYXBwZW4gYmVmb3JlXG4gICAgICAgIC8vIGxpc3RlbiBldmVudHMuXG4gICAgICAgIHByb2Nlc3NVc2VyQ2FsbGJhY2soc3luY0VuZ2luZUltcGwsIGJhdGNoSWQsIGVycm9yKTtcbiAgICAgICAgdHJpZ2dlclBlbmRpbmdXcml0ZXNDYWxsYmFja3Moc3luY0VuZ2luZUltcGwsIGJhdGNoSWQpO1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS51cGRhdGVNdXRhdGlvblN0YXRlKGJhdGNoSWQsICdyZWplY3RlZCcsIGVycm9yKTtcbiAgICAgICAgYXdhaXQgc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZUltcGwsIGNoYW5nZXMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXdhaXQgaWdub3JlSWZQcmltYXJ5TGVhc2VMb3NzKGVycm9yKTtcbiAgICB9XG59XG4vKipcbiAqIFJlZ2lzdGVycyBhIHVzZXIgY2FsbGJhY2sgdGhhdCByZXNvbHZlcyB3aGVuIGFsbCBwZW5kaW5nIG11dGF0aW9ucyBhdCB0aGUgbW9tZW50IG9mIGNhbGxpbmdcbiAqIGFyZSBhY2tub3dsZWRnZWQgLlxuICovXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lUmVnaXN0ZXJQZW5kaW5nV3JpdGVzQ2FsbGJhY2soc3luY0VuZ2luZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcbiAgICBpZiAoIWNhblVzZU5ldHdvcmsoc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUpKSB7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckMywgJ1RoZSBuZXR3b3JrIGlzIGRpc2FibGVkLiBUaGUgdGFzayByZXR1cm5lZCBieSAnICtcbiAgICAgICAgICAgIFwiJ2F3YWl0UGVuZGluZ1dyaXRlcygpJyB3aWxsIG5vdCBjb21wbGV0ZSB1bnRpbCB0aGUgbmV0d29yayBpcyBlbmFibGVkLlwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaGlnaGVzdEJhdGNoSWQgPSBhd2FpdCBsb2NhbFN0b3JlR2V0SGlnaGVzdFVuYWNrbm93bGVkZ2VkQmF0Y2hJZChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlKTtcbiAgICAgICAgaWYgKGhpZ2hlc3RCYXRjaElkID09PSBCQVRDSElEX1VOS05PV04pIHtcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgdGhlIGNhbGxiYWNrIHJpZ2h0IGF3YXkgaWYgdGhlcmUgaXMgbm8gcGVuZGluZyB3cml0ZXMgYXQgdGhlIG1vbWVudC5cbiAgICAgICAgICAgIGNhbGxiYWNrLnJlc29sdmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBzeW5jRW5naW5lSW1wbC5wZW5kaW5nV3JpdGVzQ2FsbGJhY2tzLmdldChoaWdoZXN0QmF0Y2hJZCkgfHwgW107XG4gICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgc3luY0VuZ2luZUltcGwucGVuZGluZ1dyaXRlc0NhbGxiYWNrcy5zZXQoaGlnaGVzdEJhdGNoSWQsIGNhbGxiYWNrcyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IGZpcmVzdG9yZUVycm9yID0gd3JhcEluVXNlckVycm9ySWZSZWNvdmVyYWJsZShlLCAnSW5pdGlhbGl6YXRpb24gb2Ygd2FpdEZvclBlbmRpbmdXcml0ZXMoKSBvcGVyYXRpb24gZmFpbGVkJyk7XG4gICAgICAgIGNhbGxiYWNrLnJlamVjdChmaXJlc3RvcmVFcnJvcik7XG4gICAgfVxufVxuLyoqXG4gKiBUcmlnZ2VycyB0aGUgY2FsbGJhY2tzIHRoYXQgYXJlIHdhaXRpbmcgZm9yIHRoaXMgYmF0Y2ggaWQgdG8gZ2V0IGFja25vd2xlZGdlZCBieSBzZXJ2ZXIsXG4gKiBpZiB0aGVyZSBhcmUgYW55LlxuICovXG5mdW5jdGlvbiB0cmlnZ2VyUGVuZGluZ1dyaXRlc0NhbGxiYWNrcyhzeW5jRW5naW5lSW1wbCwgYmF0Y2hJZCkge1xuICAgIChzeW5jRW5naW5lSW1wbC5wZW5kaW5nV3JpdGVzQ2FsbGJhY2tzLmdldChiYXRjaElkKSB8fCBbXSkuZm9yRWFjaChjYWxsYmFjayA9PiB7XG4gICAgICAgIGNhbGxiYWNrLnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICBzeW5jRW5naW5lSW1wbC5wZW5kaW5nV3JpdGVzQ2FsbGJhY2tzLmRlbGV0ZShiYXRjaElkKTtcbn1cbi8qKiBSZWplY3QgYWxsIG91dHN0YW5kaW5nIGNhbGxiYWNrcyB3YWl0aW5nIGZvciBwZW5kaW5nIHdyaXRlcyB0byBjb21wbGV0ZS4gKi9cbmZ1bmN0aW9uIHJlamVjdE91dHN0YW5kaW5nUGVuZGluZ1dyaXRlc0NhbGxiYWNrcyhzeW5jRW5naW5lSW1wbCwgZXJyb3JNZXNzYWdlKSB7XG4gICAgc3luY0VuZ2luZUltcGwucGVuZGluZ1dyaXRlc0NhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrcyA9PiB7XG4gICAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrLnJlamVjdChuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5DQU5DRUxMRUQsIGVycm9yTWVzc2FnZSkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBzeW5jRW5naW5lSW1wbC5wZW5kaW5nV3JpdGVzQ2FsbGJhY2tzLmNsZWFyKCk7XG59XG5mdW5jdGlvbiBhZGRNdXRhdGlvbkNhbGxiYWNrKHN5bmNFbmdpbmVJbXBsLCBiYXRjaElkLCBjYWxsYmFjaykge1xuICAgIGxldCBuZXdDYWxsYmFja3MgPSBzeW5jRW5naW5lSW1wbC5tdXRhdGlvblVzZXJDYWxsYmFja3Nbc3luY0VuZ2luZUltcGwuY3VycmVudFVzZXIudG9LZXkoKV07XG4gICAgaWYgKCFuZXdDYWxsYmFja3MpIHtcbiAgICAgICAgbmV3Q2FsbGJhY2tzID0gbmV3IFNvcnRlZE1hcChwcmltaXRpdmVDb21wYXJhdG9yKTtcbiAgICB9XG4gICAgbmV3Q2FsbGJhY2tzID0gbmV3Q2FsbGJhY2tzLmluc2VydChiYXRjaElkLCBjYWxsYmFjayk7XG4gICAgc3luY0VuZ2luZUltcGwubXV0YXRpb25Vc2VyQ2FsbGJhY2tzW3N5bmNFbmdpbmVJbXBsLmN1cnJlbnRVc2VyLnRvS2V5KCldID1cbiAgICAgICAgbmV3Q2FsbGJhY2tzO1xufVxuLyoqXG4gKiBSZXNvbHZlcyBvciByZWplY3RzIHRoZSB1c2VyIGNhbGxiYWNrIGZvciB0aGUgZ2l2ZW4gYmF0Y2ggYW5kIHRoZW4gZGlzY2FyZHNcbiAqIGl0LlxuICovXG5mdW5jdGlvbiBwcm9jZXNzVXNlckNhbGxiYWNrKHN5bmNFbmdpbmUsIGJhdGNoSWQsIGVycm9yKSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgbGV0IG5ld0NhbGxiYWNrcyA9IHN5bmNFbmdpbmVJbXBsLm11dGF0aW9uVXNlckNhbGxiYWNrc1tzeW5jRW5naW5lSW1wbC5jdXJyZW50VXNlci50b0tleSgpXTtcbiAgICAvLyBOT1RFOiBNdXRhdGlvbnMgcmVzdG9yZWQgZnJvbSBwZXJzaXN0ZW5jZSB3b24ndCBoYXZlIGNhbGxiYWNrcywgc28gaXQnc1xuICAgIC8vIG9rYXkgZm9yIHRoZXJlIHRvIGJlIG5vIGNhbGxiYWNrIGZvciB0aGlzIElELlxuICAgIGlmIChuZXdDYWxsYmFja3MpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBuZXdDYWxsYmFja3MuZ2V0KGJhdGNoSWQpO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdDYWxsYmFja3MgPSBuZXdDYWxsYmFja3MucmVtb3ZlKGJhdGNoSWQpO1xuICAgICAgICB9XG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLm11dGF0aW9uVXNlckNhbGxiYWNrc1tzeW5jRW5naW5lSW1wbC5jdXJyZW50VXNlci50b0tleSgpXSA9XG4gICAgICAgICAgICBuZXdDYWxsYmFja3M7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlQW5kQ2xlYW51cFRhcmdldChzeW5jRW5naW5lSW1wbCwgdGFyZ2V0SWQsIGVycm9yID0gbnVsbCkge1xuICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLnJlbW92ZUxvY2FsUXVlcnlUYXJnZXQodGFyZ2V0SWQpO1xuICAgIGZvciAoY29uc3QgcXVlcnkgb2Ygc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LmdldCh0YXJnZXRJZCkpIHtcbiAgICAgICAgc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZGVsZXRlKHF1ZXJ5KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBzeW5jRW5naW5lSW1wbC5zeW5jRW5naW5lTGlzdGVuZXIub25XYXRjaEVycm9yKHF1ZXJ5LCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LmRlbGV0ZSh0YXJnZXRJZCk7XG4gICAgaWYgKHN5bmNFbmdpbmVJbXBsLmlzUHJpbWFyeUNsaWVudCkge1xuICAgICAgICBjb25zdCBsaW1ib0tleXMgPSBzeW5jRW5naW5lSW1wbC5saW1ib0RvY3VtZW50UmVmcy5yZW1vdmVSZWZlcmVuY2VzRm9ySWQodGFyZ2V0SWQpO1xuICAgICAgICBsaW1ib0tleXMuZm9yRWFjaChsaW1ib0tleSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc1JlZmVyZW5jZWQgPSBzeW5jRW5naW5lSW1wbC5saW1ib0RvY3VtZW50UmVmcy5jb250YWluc0tleShsaW1ib0tleSk7XG4gICAgICAgICAgICBpZiAoIWlzUmVmZXJlbmNlZCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHJlbW92ZWQgdGhlIGxhc3QgcmVmZXJlbmNlIGZvciB0aGlzIGtleVxuICAgICAgICAgICAgICAgIHJlbW92ZUxpbWJvVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLCBsaW1ib0tleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUxpbWJvVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLCBrZXkpIHtcbiAgICBzeW5jRW5naW5lSW1wbC5lbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnMuZGVsZXRlKGtleS5wYXRoLmNhbm9uaWNhbFN0cmluZygpKTtcbiAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHRhcmdldCBhbHJlYWR5IGdvdCByZW1vdmVkIGJlY2F1c2UgdGhlIHF1ZXJ5IGZhaWxlZC4gSW4gdGhhdCBjYXNlLFxuICAgIC8vIHRoZSBrZXkgd29uJ3QgZXhpc3QgaW4gYGxpbWJvVGFyZ2V0c0J5S2V5YC4gT25seSBkbyB0aGUgY2xlYW51cCBpZiB3ZSBzdGlsbCBoYXZlIHRoZSB0YXJnZXQuXG4gICAgY29uc3QgbGltYm9UYXJnZXRJZCA9IHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvVGFyZ2V0c0J5S2V5LmdldChrZXkpO1xuICAgIGlmIChsaW1ib1RhcmdldElkID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgdGFyZ2V0IGFscmVhZHkgZ290IHJlbW92ZWQsIGJlY2F1c2UgdGhlIHF1ZXJ5IGZhaWxlZC5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZW1vdGVTdG9yZVVubGlzdGVuKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCBsaW1ib1RhcmdldElkKTtcbiAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1RhcmdldHNCeUtleSA9XG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvVGFyZ2V0c0J5S2V5LnJlbW92ZShrZXkpO1xuICAgIHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvUmVzb2x1dGlvbnNCeVRhcmdldC5kZWxldGUobGltYm9UYXJnZXRJZCk7XG4gICAgcHVtcEVucXVldWVkTGltYm9SZXNvbHV0aW9ucyhzeW5jRW5naW5lSW1wbCk7XG59XG5mdW5jdGlvbiB1cGRhdGVUcmFja2VkTGltYm9zKHN5bmNFbmdpbmVJbXBsLCB0YXJnZXRJZCwgbGltYm9DaGFuZ2VzKSB7XG4gICAgZm9yIChjb25zdCBsaW1ib0NoYW5nZSBvZiBsaW1ib0NoYW5nZXMpIHtcbiAgICAgICAgaWYgKGxpbWJvQ2hhbmdlIGluc3RhbmNlb2YgQWRkZWRMaW1ib0RvY3VtZW50KSB7XG4gICAgICAgICAgICBzeW5jRW5naW5lSW1wbC5saW1ib0RvY3VtZW50UmVmcy5hZGRSZWZlcmVuY2UobGltYm9DaGFuZ2Uua2V5LCB0YXJnZXRJZCk7XG4gICAgICAgICAgICB0cmFja0xpbWJvQ2hhbmdlKHN5bmNFbmdpbmVJbXBsLCBsaW1ib0NoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGltYm9DaGFuZ2UgaW5zdGFuY2VvZiBSZW1vdmVkTGltYm9Eb2N1bWVudCkge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQzLCAnRG9jdW1lbnQgbm8gbG9uZ2VyIGluIGxpbWJvOiAnICsgbGltYm9DaGFuZ2Uua2V5KTtcbiAgICAgICAgICAgIHN5bmNFbmdpbmVJbXBsLmxpbWJvRG9jdW1lbnRSZWZzLnJlbW92ZVJlZmVyZW5jZShsaW1ib0NoYW5nZS5rZXksIHRhcmdldElkKTtcbiAgICAgICAgICAgIGNvbnN0IGlzUmVmZXJlbmNlZCA9IHN5bmNFbmdpbmVJbXBsLmxpbWJvRG9jdW1lbnRSZWZzLmNvbnRhaW5zS2V5KGxpbWJvQ2hhbmdlLmtleSk7XG4gICAgICAgICAgICBpZiAoIWlzUmVmZXJlbmNlZCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHJlbW92ZWQgdGhlIGxhc3QgcmVmZXJlbmNlIGZvciB0aGlzIGtleVxuICAgICAgICAgICAgICAgIHJlbW92ZUxpbWJvVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLCBsaW1ib0NoYW5nZS5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmFpbCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdHJhY2tMaW1ib0NoYW5nZShzeW5jRW5naW5lSW1wbCwgbGltYm9DaGFuZ2UpIHtcbiAgICBjb25zdCBrZXkgPSBsaW1ib0NoYW5nZS5rZXk7XG4gICAgY29uc3Qga2V5U3RyaW5nID0ga2V5LnBhdGguY2Fub25pY2FsU3RyaW5nKCk7XG4gICAgaWYgKCFzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1RhcmdldHNCeUtleS5nZXQoa2V5KSAmJlxuICAgICAgICAhc3luY0VuZ2luZUltcGwuZW5xdWV1ZWRMaW1ib1Jlc29sdXRpb25zLmhhcyhrZXlTdHJpbmcpKSB7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckMywgJ05ldyBkb2N1bWVudCBpbiBsaW1ibzogJyArIGtleSk7XG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLmVucXVldWVkTGltYm9SZXNvbHV0aW9ucy5hZGQoa2V5U3RyaW5nKTtcbiAgICAgICAgcHVtcEVucXVldWVkTGltYm9SZXNvbHV0aW9ucyhzeW5jRW5naW5lSW1wbCk7XG4gICAgfVxufVxuLyoqXG4gKiBTdGFydHMgbGlzdGVucyBmb3IgZG9jdW1lbnRzIGluIGxpbWJvIHRoYXQgYXJlIGVucXVldWVkIGZvciByZXNvbHV0aW9uLFxuICogc3ViamVjdCB0byBhIG1heGltdW0gbnVtYmVyIG9mIGNvbmN1cnJlbnQgcmVzb2x1dGlvbnMuXG4gKlxuICogV2l0aG91dCBib3VuZGluZyB0aGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgcmVzb2x1dGlvbnMsIHRoZSBzZXJ2ZXIgY2FuIGZhaWxcbiAqIHdpdGggXCJyZXNvdXJjZSBleGhhdXN0ZWRcIiBlcnJvcnMgd2hpY2ggY2FuIGxlYWQgdG8gcGF0aG9sb2dpY2FsIGNsaWVudFxuICogYmVoYXZpb3IgYXMgc2VlbiBpbiBodHRwczovL2dpdGh1Yi5jb20vZmlyZWJhc2UvZmlyZWJhc2UtanMtc2RrL2lzc3Vlcy8yNjgzLlxuICovXG5mdW5jdGlvbiBwdW1wRW5xdWV1ZWRMaW1ib1Jlc29sdXRpb25zKHN5bmNFbmdpbmVJbXBsKSB7XG4gICAgd2hpbGUgKHN5bmNFbmdpbmVJbXBsLmVucXVldWVkTGltYm9SZXNvbHV0aW9ucy5zaXplID4gMCAmJlxuICAgICAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1RhcmdldHNCeUtleS5zaXplIDxcbiAgICAgICAgICAgIHN5bmNFbmdpbmVJbXBsLm1heENvbmN1cnJlbnRMaW1ib1Jlc29sdXRpb25zKSB7XG4gICAgICAgIGNvbnN0IGtleVN0cmluZyA9IHN5bmNFbmdpbmVJbXBsLmVucXVldWVkTGltYm9SZXNvbHV0aW9uc1xuICAgICAgICAgICAgLnZhbHVlcygpXG4gICAgICAgICAgICAubmV4dCgpLnZhbHVlO1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5lbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnMuZGVsZXRlKGtleVN0cmluZyk7XG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBEb2N1bWVudEtleShSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhrZXlTdHJpbmcpKTtcbiAgICAgICAgY29uc3QgbGltYm9UYXJnZXRJZCA9IHN5bmNFbmdpbmVJbXBsLmxpbWJvVGFyZ2V0SWRHZW5lcmF0b3IubmV4dCgpO1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1Jlc29sdXRpb25zQnlUYXJnZXQuc2V0KGxpbWJvVGFyZ2V0SWQsIG5ldyBMaW1ib1Jlc29sdXRpb24oa2V5KSk7XG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvVGFyZ2V0c0J5S2V5ID1cbiAgICAgICAgICAgIHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvVGFyZ2V0c0J5S2V5Lmluc2VydChrZXksIGxpbWJvVGFyZ2V0SWQpO1xuICAgICAgICByZW1vdGVTdG9yZUxpc3RlbihzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZSwgbmV3IFRhcmdldERhdGEocXVlcnlUb1RhcmdldChuZXdRdWVyeUZvclBhdGgoa2V5LnBhdGgpKSwgbGltYm9UYXJnZXRJZCwgXCJUYXJnZXRQdXJwb3NlTGltYm9SZXNvbHV0aW9uXCIgLyogVGFyZ2V0UHVycG9zZS5MaW1ib1Jlc29sdXRpb24gKi8sIExpc3RlblNlcXVlbmNlLklOVkFMSUQpKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lRW1pdE5ld1NuYXBzQW5kTm90aWZ5TG9jYWxTdG9yZShzeW5jRW5naW5lLCBjaGFuZ2VzLCByZW1vdGVFdmVudCkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIGNvbnN0IG5ld1NuYXBzID0gW107XG4gICAgY29uc3QgZG9jQ2hhbmdlc0luQWxsVmlld3MgPSBbXTtcbiAgICBjb25zdCBxdWVyaWVzUHJvY2Vzc2VkID0gW107XG4gICAgaWYgKHN5bmNFbmdpbmVJbXBsLnF1ZXJ5Vmlld3NCeVF1ZXJ5LmlzRW1wdHkoKSkge1xuICAgICAgICAvLyBSZXR1cm4gZWFybHkgc2luY2UgYG9uV2F0Y2hDaGFuZ2UoKWAgbWlnaHQgbm90IGhhdmUgYmVlbiBhc3NpZ25lZCB5ZXQuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZm9yRWFjaCgoXywgcXVlcnlWaWV3KSA9PiB7XG4gICAgICAgIHF1ZXJpZXNQcm9jZXNzZWQucHVzaChzeW5jRW5naW5lSW1wbFxuICAgICAgICAgICAgLmFwcGx5RG9jQ2hhbmdlcyhxdWVyeVZpZXcsIGNoYW5nZXMsIHJlbW90ZUV2ZW50KVxuICAgICAgICAgICAgLnRoZW4odmlld1NuYXBzaG90ID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBjaGFuZ2VzLCBvciB3ZSBhcmUgaGFuZGxpbmcgYSBnbG9iYWwgc25hcHNob3QsIG5vdGlmeVxuICAgICAgICAgICAgLy8gc2Vjb25kYXJ5IGNsaWVudHMgdG8gdXBkYXRlIHF1ZXJ5IHN0YXRlLlxuICAgICAgICAgICAgaWYgKHZpZXdTbmFwc2hvdCB8fCByZW1vdGVFdmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChzeW5jRW5naW5lSW1wbC5pc1ByaW1hcnlDbGllbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUXVlcnkgc3RhdGUgaXMgc2V0IHRvIGBjdXJyZW50YCBpZjpcbiAgICAgICAgICAgICAgICAgICAgLy8gLSBUaGVyZSBpcyBhIHZpZXcgY2hhbmdlIGFuZCBpdCBpcyB1cC10by1kYXRlLCBvcixcbiAgICAgICAgICAgICAgICAgICAgLy8gLSBUaGVyZSBpcyBhIGdsb2JhbCBzbmFwc2hvdCwgdGhlIFRhcmdldCBpcyBjdXJyZW50LCBhbmQgbm8gY2hhbmdlcyB0byBiZSByZXNvbHZlZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0N1cnJlbnQgPSB2aWV3U25hcHNob3RcbiAgICAgICAgICAgICAgICAgICAgICAgID8gIXZpZXdTbmFwc2hvdC5mcm9tQ2FjaGVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKF9hID0gcmVtb3RlRXZlbnQgPT09IG51bGwgfHwgcmVtb3RlRXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbW90ZUV2ZW50LnRhcmdldENoYW5nZXMuZ2V0KHF1ZXJ5Vmlldy50YXJnZXRJZCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS51cGRhdGVRdWVyeVN0YXRlKHF1ZXJ5Vmlldy50YXJnZXRJZCwgaXNDdXJyZW50ID8gJ2N1cnJlbnQnIDogJ25vdC1jdXJyZW50Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHZpZXdzIGlmIHRoZXJlIGFyZSBhY3R1YWwgY2hhbmdlcy5cbiAgICAgICAgICAgIGlmICghIXZpZXdTbmFwc2hvdCkge1xuICAgICAgICAgICAgICAgIG5ld1NuYXBzLnB1c2godmlld1NuYXBzaG90KTtcbiAgICAgICAgICAgICAgICBjb25zdCBkb2NDaGFuZ2VzID0gTG9jYWxWaWV3Q2hhbmdlcy5mcm9tU25hcHNob3QocXVlcnlWaWV3LnRhcmdldElkLCB2aWV3U25hcHNob3QpO1xuICAgICAgICAgICAgICAgIGRvY0NoYW5nZXNJbkFsbFZpZXdzLnB1c2goZG9jQ2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9KTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChxdWVyaWVzUHJvY2Vzc2VkKTtcbiAgICBzeW5jRW5naW5lSW1wbC5zeW5jRW5naW5lTGlzdGVuZXIub25XYXRjaENoYW5nZShuZXdTbmFwcyk7XG4gICAgYXdhaXQgbG9jYWxTdG9yZU5vdGlmeUxvY2FsVmlld0NoYW5nZXMoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgZG9jQ2hhbmdlc0luQWxsVmlld3MpO1xufVxuYXN5bmMgZnVuY3Rpb24gYXBwbHlEb2NDaGFuZ2VzKHN5bmNFbmdpbmVJbXBsLCBxdWVyeVZpZXcsIGNoYW5nZXMsIHJlbW90ZUV2ZW50KSB7XG4gICAgbGV0IHZpZXdEb2NDaGFuZ2VzID0gcXVlcnlWaWV3LnZpZXcuY29tcHV0ZURvY0NoYW5nZXMoY2hhbmdlcyk7XG4gICAgaWYgKHZpZXdEb2NDaGFuZ2VzLm5lZWRzUmVmaWxsKSB7XG4gICAgICAgIC8vIFRoZSBxdWVyeSBoYXMgYSBsaW1pdCBhbmQgc29tZSBkb2NzIHdlcmUgcmVtb3ZlZCwgc28gd2UgbmVlZFxuICAgICAgICAvLyB0byByZS1ydW4gdGhlIHF1ZXJ5IGFnYWluc3QgdGhlIGxvY2FsIHN0b3JlIHRvIG1ha2Ugc3VyZSB3ZVxuICAgICAgICAvLyBkaWRuJ3QgbG9zZSBhbnkgZ29vZCBkb2NzIHRoYXQgaGFkIGJlZW4gcGFzdCB0aGUgbGltaXQuXG4gICAgICAgIHZpZXdEb2NDaGFuZ2VzID0gYXdhaXQgbG9jYWxTdG9yZUV4ZWN1dGVRdWVyeShzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCBxdWVyeVZpZXcucXVlcnksIFxuICAgICAgICAvKiB1c2VQcmV2aW91c1Jlc3VsdHM9ICovIGZhbHNlKS50aGVuKCh7IGRvY3VtZW50cyB9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcXVlcnlWaWV3LnZpZXcuY29tcHV0ZURvY0NoYW5nZXMoZG9jdW1lbnRzLCB2aWV3RG9jQ2hhbmdlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRDaGFuZ2UgPSByZW1vdGVFdmVudCAmJiByZW1vdGVFdmVudC50YXJnZXRDaGFuZ2VzLmdldChxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgIGNvbnN0IHRhcmdldElzUGVuZGluZ1Jlc2V0ID0gcmVtb3RlRXZlbnQgJiYgcmVtb3RlRXZlbnQudGFyZ2V0TWlzbWF0Y2hlcy5nZXQocXVlcnlWaWV3LnRhcmdldElkKSAhPSBudWxsO1xuICAgIGNvbnN0IHZpZXdDaGFuZ2UgPSBxdWVyeVZpZXcudmlldy5hcHBseUNoYW5nZXModmlld0RvY0NoYW5nZXMsIFxuICAgIC8qIGxpbWJvUmVzb2x1dGlvbkVuYWJsZWQ9ICovIHN5bmNFbmdpbmVJbXBsLmlzUHJpbWFyeUNsaWVudCwgdGFyZ2V0Q2hhbmdlLCB0YXJnZXRJc1BlbmRpbmdSZXNldCk7XG4gICAgdXBkYXRlVHJhY2tlZExpbWJvcyhzeW5jRW5naW5lSW1wbCwgcXVlcnlWaWV3LnRhcmdldElkLCB2aWV3Q2hhbmdlLmxpbWJvQ2hhbmdlcyk7XG4gICAgcmV0dXJuIHZpZXdDaGFuZ2Uuc25hcHNob3Q7XG59XG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lSGFuZGxlQ3JlZGVudGlhbENoYW5nZShzeW5jRW5naW5lLCB1c2VyKSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgY29uc3QgdXNlckNoYW5nZWQgPSAhc3luY0VuZ2luZUltcGwuY3VycmVudFVzZXIuaXNFcXVhbCh1c2VyKTtcbiAgICBpZiAodXNlckNoYW5nZWQpIHtcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQzLCAnVXNlciBjaGFuZ2UuIE5ldyB1c2VyOicsIHVzZXIudG9LZXkoKSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxvY2FsU3RvcmVIYW5kbGVVc2VyQ2hhbmdlKHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHVzZXIpO1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5jdXJyZW50VXNlciA9IHVzZXI7XG4gICAgICAgIC8vIEZhaWxzIHRhc2tzIHdhaXRpbmcgZm9yIHBlbmRpbmcgd3JpdGVzIHJlcXVlc3RlZCBieSBwcmV2aW91cyB1c2VyLlxuICAgICAgICByZWplY3RPdXRzdGFuZGluZ1BlbmRpbmdXcml0ZXNDYWxsYmFja3Moc3luY0VuZ2luZUltcGwsIFwiJ3dhaXRGb3JQZW5kaW5nV3JpdGVzJyBwcm9taXNlIGlzIHJlamVjdGVkIGR1ZSB0byBhIHVzZXIgY2hhbmdlLlwiKTtcbiAgICAgICAgLy8gVE9ETyhiLzExNDIyNjQxNyk6IENvbnNpZGVyIGNhbGxpbmcgdGhpcyBvbmx5IGluIHRoZSBwcmltYXJ5IHRhYi5cbiAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUuaGFuZGxlVXNlckNoYW5nZSh1c2VyLCByZXN1bHQucmVtb3ZlZEJhdGNoSWRzLCByZXN1bHQuYWRkZWRCYXRjaElkcyk7XG4gICAgICAgIGF3YWl0IHN5bmNFbmdpbmVFbWl0TmV3U25hcHNBbmROb3RpZnlMb2NhbFN0b3JlKHN5bmNFbmdpbmVJbXBsLCByZXN1bHQuYWZmZWN0ZWREb2N1bWVudHMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN5bmNFbmdpbmVHZXRSZW1vdGVLZXlzRm9yVGFyZ2V0KHN5bmNFbmdpbmUsIHRhcmdldElkKSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgY29uc3QgbGltYm9SZXNvbHV0aW9uID0gc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9SZXNvbHV0aW9uc0J5VGFyZ2V0LmdldCh0YXJnZXRJZCk7XG4gICAgaWYgKGxpbWJvUmVzb2x1dGlvbiAmJiBsaW1ib1Jlc29sdXRpb24ucmVjZWl2ZWREb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnRLZXlTZXQoKS5hZGQobGltYm9SZXNvbHV0aW9uLmtleSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQga2V5U2V0ID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgY29uc3QgcXVlcmllcyA9IHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5nZXQodGFyZ2V0SWQpO1xuICAgICAgICBpZiAoIXF1ZXJpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXlTZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBxdWVyeSBvZiBxdWVyaWVzKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVZpZXcgPSBzeW5jRW5naW5lSW1wbC5xdWVyeVZpZXdzQnlRdWVyeS5nZXQocXVlcnkpO1xuICAgICAgICAgICAga2V5U2V0ID0ga2V5U2V0LnVuaW9uV2l0aChxdWVyeVZpZXcudmlldy5zeW5jZWREb2N1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlTZXQ7XG4gICAgfVxufVxuLyoqXG4gKiBSZWNvbmNpbGUgdGhlIGxpc3Qgb2Ygc3luY2VkIGRvY3VtZW50cyBpbiBhbiBleGlzdGluZyB2aWV3IHdpdGggdGhvc2VcbiAqIGZyb20gcGVyc2lzdGVuY2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHN5bmNocm9uaXplVmlld0FuZENvbXB1dGVTbmFwc2hvdChzeW5jRW5naW5lLCBxdWVyeVZpZXcpIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcbiAgICBjb25zdCBxdWVyeVJlc3VsdCA9IGF3YWl0IGxvY2FsU3RvcmVFeGVjdXRlUXVlcnkoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgcXVlcnlWaWV3LnF1ZXJ5LCBcbiAgICAvKiB1c2VQcmV2aW91c1Jlc3VsdHM9ICovIHRydWUpO1xuICAgIGNvbnN0IHZpZXdTbmFwc2hvdCA9IHF1ZXJ5Vmlldy52aWV3LnN5bmNocm9uaXplV2l0aFBlcnNpc3RlZFN0YXRlKHF1ZXJ5UmVzdWx0KTtcbiAgICBpZiAoc3luY0VuZ2luZUltcGwuaXNQcmltYXJ5Q2xpZW50KSB7XG4gICAgICAgIHVwZGF0ZVRyYWNrZWRMaW1ib3Moc3luY0VuZ2luZUltcGwsIHF1ZXJ5Vmlldy50YXJnZXRJZCwgdmlld1NuYXBzaG90LmxpbWJvQ2hhbmdlcyk7XG4gICAgfVxuICAgIHJldHVybiB2aWV3U25hcHNob3Q7XG59XG4vKipcbiAqIFJldHJpZXZlcyBuZXdseSBjaGFuZ2VkIGRvY3VtZW50cyBmcm9tIHJlbW90ZSBkb2N1bWVudCBjYWNoZSBhbmQgcmFpc2VzXG4gKiBzbmFwc2hvdHMgaWYgbmVlZGVkLlxuICovXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZVN5bmNocm9uaXplV2l0aENoYW5nZWREb2N1bWVudHMoc3luY0VuZ2luZSwgY29sbGVjdGlvbkdyb3VwKSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmVHZXROZXdEb2N1bWVudENoYW5nZXMoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgY29sbGVjdGlvbkdyb3VwKS50aGVuKGNoYW5nZXMgPT4gc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZUltcGwsIGNoYW5nZXMpKTtcbn1cbi8qKiBBcHBsaWVzIGEgbXV0YXRpb24gc3RhdGUgdG8gYW4gZXhpc3RpbmcgYmF0Y2guICAqL1xuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVBcHBseUJhdGNoU3RhdGUoc3luY0VuZ2luZSwgYmF0Y2hJZCwgYmF0Y2hTdGF0ZSwgZXJyb3IpIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcbiAgICBjb25zdCBkb2N1bWVudHMgPSBhd2FpdCBsb2NhbFN0b3JlTG9va3VwTXV0YXRpb25Eb2N1bWVudHMoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgYmF0Y2hJZCk7XG4gICAgaWYgKGRvY3VtZW50cyA9PT0gbnVsbCkge1xuICAgICAgICAvLyBBIHRocm90dGxlZCB0YWIgbWF5IG5vdCBoYXZlIHNlZW4gdGhlIG11dGF0aW9uIGJlZm9yZSBpdCB3YXMgY29tcGxldGVkXG4gICAgICAgIC8vIGFuZCByZW1vdmVkIGZyb20gdGhlIG11dGF0aW9uIHF1ZXVlLCBpbiB3aGljaCBjYXNlIHdlIHdvbid0IGhhdmUgY2FjaGVkXG4gICAgICAgIC8vIHRoZSBhZmZlY3RlZCBkb2N1bWVudHMuIEluIHRoaXMgY2FzZSB3ZSBjYW4gc2FmZWx5IGlnbm9yZSB0aGUgdXBkYXRlXG4gICAgICAgIC8vIHNpbmNlIHRoYXQgbWVhbnMgd2UgZGlkbid0IGFwcGx5IHRoZSBtdXRhdGlvbiBsb2NhbGx5IGF0IGFsbCAoaWYgd2VcbiAgICAgICAgLy8gaGFkLCB3ZSB3b3VsZCBoYXZlIGNhY2hlZCB0aGUgYWZmZWN0ZWQgZG9jdW1lbnRzKSwgYW5kIHNvIHdlIHdpbGwganVzdFxuICAgICAgICAvLyBzZWUgYW55IHJlc3VsdGluZyBkb2N1bWVudCBjaGFuZ2VzIHZpYSBub3JtYWwgcmVtb3RlIGRvY3VtZW50IHVwZGF0ZXNcbiAgICAgICAgLy8gYXMgYXBwbGljYWJsZS5cbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQzLCAnQ2Fubm90IGFwcGx5IG11dGF0aW9uIGJhdGNoIHdpdGggaWQ6ICcgKyBiYXRjaElkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYmF0Y2hTdGF0ZSA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgIC8vIElmIHdlIGFyZSB0aGUgcHJpbWFyeSBjbGllbnQsIHdlIG5lZWQgdG8gc2VuZCB0aGlzIHdyaXRlIHRvIHRoZVxuICAgICAgICAvLyBiYWNrZW5kLiBTZWNvbmRhcnkgY2xpZW50cyB3aWxsIGlnbm9yZSB0aGVzZSB3cml0ZXMgc2luY2UgdGhlaXIgcmVtb3RlXG4gICAgICAgIC8vIGNvbm5lY3Rpb24gaXMgZGlzYWJsZWQuXG4gICAgICAgIGF3YWl0IGZpbGxXcml0ZVBpcGVsaW5lKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYmF0Y2hTdGF0ZSA9PT0gJ2Fja25vd2xlZGdlZCcgfHwgYmF0Y2hTdGF0ZSA9PT0gJ3JlamVjdGVkJykge1xuICAgICAgICAvLyBOT1RFOiBCb3RoIHRoZXNlIG1ldGhvZHMgYXJlIG5vLW9wcyBmb3IgYmF0Y2hlcyB0aGF0IG9yaWdpbmF0ZWQgZnJvbVxuICAgICAgICAvLyBvdGhlciBjbGllbnRzLlxuICAgICAgICBwcm9jZXNzVXNlckNhbGxiYWNrKHN5bmNFbmdpbmVJbXBsLCBiYXRjaElkLCBlcnJvciA/IGVycm9yIDogbnVsbCk7XG4gICAgICAgIHRyaWdnZXJQZW5kaW5nV3JpdGVzQ2FsbGJhY2tzKHN5bmNFbmdpbmVJbXBsLCBiYXRjaElkKTtcbiAgICAgICAgbG9jYWxTdG9yZVJlbW92ZUNhY2hlZE11dGF0aW9uQmF0Y2hNZXRhZGF0YShzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCBiYXRjaElkKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZhaWwoKTtcbiAgICB9XG4gICAgYXdhaXQgc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZUltcGwsIGRvY3VtZW50cyk7XG59XG4vKiogQXBwbGllcyBhIHF1ZXJ5IHRhcmdldCBjaGFuZ2UgZnJvbSBhIGRpZmZlcmVudCB0YWIuICovXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZUFwcGx5UHJpbWFyeVN0YXRlKHN5bmNFbmdpbmUsIGlzUHJpbWFyeSkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIGVuc3VyZVdhdGNoQ2FsbGJhY2tzKHN5bmNFbmdpbmVJbXBsKTtcbiAgICBzeW5jRW5naW5lRW5zdXJlV3JpdGVDYWxsYmFja3Moc3luY0VuZ2luZUltcGwpO1xuICAgIGlmIChpc1ByaW1hcnkgPT09IHRydWUgJiYgc3luY0VuZ2luZUltcGwuX2lzUHJpbWFyeUNsaWVudCAhPT0gdHJ1ZSkge1xuICAgICAgICAvLyBTZWNvbmRhcnkgdGFicyBvbmx5IG1haW50YWluIFZpZXdzIGZvciB0aGVpciBsb2NhbCBsaXN0ZW5lcnMgYW5kIHRoZVxuICAgICAgICAvLyBWaWV3cyBpbnRlcm5hbCBzdGF0ZSBtYXkgbm90IGJlIDEwMCUgcG9wdWxhdGVkIChpbiBwYXJ0aWN1bGFyXG4gICAgICAgIC8vIHNlY29uZGFyeSB0YWJzIGRvbid0IHRyYWNrIHN5bmNlZERvY3VtZW50cywgdGhlIHNldCBvZiBkb2N1bWVudHMgdGhlXG4gICAgICAgIC8vIHNlcnZlciBjb25zaWRlcnMgdG8gYmUgaW4gdGhlIHRhcmdldCkuIFNvIHdoZW4gYSBzZWNvbmRhcnkgYmVjb21lc1xuICAgICAgICAvLyBwcmltYXJ5LCB3ZSBuZWVkIHRvIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYWxsIHZpZXdzIGZvciBhbGwgdGFyZ2V0c1xuICAgICAgICAvLyBtYXRjaCB0aGUgc3RhdGUgb24gZGlzay5cbiAgICAgICAgY29uc3QgYWN0aXZlVGFyZ2V0cyA9IHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLmdldEFsbEFjdGl2ZVF1ZXJ5VGFyZ2V0cygpO1xuICAgICAgICBjb25zdCBhY3RpdmVRdWVyaWVzID0gYXdhaXQgc3luY2hyb25pemVRdWVyeVZpZXdzQW5kUmFpc2VTbmFwc2hvdHMoc3luY0VuZ2luZUltcGwsIGFjdGl2ZVRhcmdldHMudG9BcnJheSgpKTtcbiAgICAgICAgc3luY0VuZ2luZUltcGwuX2lzUHJpbWFyeUNsaWVudCA9IHRydWU7XG4gICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlQXBwbHlQcmltYXJ5U3RhdGUoc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIHRydWUpO1xuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldERhdGEgb2YgYWN0aXZlUXVlcmllcykge1xuICAgICAgICAgICAgcmVtb3RlU3RvcmVMaXN0ZW4oc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIHRhcmdldERhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUHJpbWFyeSA9PT0gZmFsc2UgJiYgc3luY0VuZ2luZUltcGwuX2lzUHJpbWFyeUNsaWVudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgYWN0aXZlVGFyZ2V0cyA9IFtdO1xuICAgICAgICBsZXQgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5xdWVyaWVzQnlUYXJnZXQuZm9yRWFjaCgoXywgdGFyZ2V0SWQpID0+IHtcbiAgICAgICAgICAgIGlmIChzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5pc0xvY2FsUXVlcnlUYXJnZXQodGFyZ2V0SWQpKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlVGFyZ2V0cy5wdXNoKHRhcmdldElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHAgPSBwLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVBbmRDbGVhbnVwVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLCB0YXJnZXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlUmVsZWFzZVRhcmdldChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCB0YXJnZXRJZCwgXG4gICAgICAgICAgICAgICAgICAgIC8qa2VlcFBlcnNpc3RlZFRhcmdldERhdGE9Ki8gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1vdGVTdG9yZVVubGlzdGVuKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCB0YXJnZXRJZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBwO1xuICAgICAgICBhd2FpdCBzeW5jaHJvbml6ZVF1ZXJ5Vmlld3NBbmRSYWlzZVNuYXBzaG90cyhzeW5jRW5naW5lSW1wbCwgYWN0aXZlVGFyZ2V0cyk7XG4gICAgICAgIHJlc2V0TGltYm9Eb2N1bWVudHMoc3luY0VuZ2luZUltcGwpO1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5faXNQcmltYXJ5Q2xpZW50ID0gZmFsc2U7XG4gICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlQXBwbHlQcmltYXJ5U3RhdGUoc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIGZhbHNlKTtcbiAgICB9XG59XG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxuZnVuY3Rpb24gcmVzZXRMaW1ib0RvY3VtZW50cyhzeW5jRW5naW5lKSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9SZXNvbHV0aW9uc0J5VGFyZ2V0LmZvckVhY2goKF8sIHRhcmdldElkKSA9PiB7XG4gICAgICAgIHJlbW90ZVN0b3JlVW5saXN0ZW4oc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIHRhcmdldElkKTtcbiAgICB9KTtcbiAgICBzeW5jRW5naW5lSW1wbC5saW1ib0RvY3VtZW50UmVmcy5yZW1vdmVBbGxSZWZlcmVuY2VzKCk7XG4gICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9SZXNvbHV0aW9uc0J5VGFyZ2V0ID0gbmV3IE1hcCgpO1xuICAgIHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvVGFyZ2V0c0J5S2V5ID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcbn1cbi8qKlxuICogUmVjb25jaWxlIHRoZSBxdWVyeSB2aWV3cyBvZiB0aGUgcHJvdmlkZWQgcXVlcnkgdGFyZ2V0cyB3aXRoIHRoZSBzdGF0ZSBmcm9tXG4gKiBwZXJzaXN0ZW5jZS4gUmFpc2VzIHNuYXBzaG90cyBmb3IgYW55IGNoYW5nZXMgdGhhdCBhZmZlY3QgdGhlIGxvY2FsXG4gKiBjbGllbnQgYW5kIHJldHVybnMgdGhlIHVwZGF0ZWQgc3RhdGUgb2YgYWxsIHRhcmdldCdzIHF1ZXJ5IGRhdGEuXG4gKlxuICogQHBhcmFtIHN5bmNFbmdpbmUgLSBUaGUgc3luYyBlbmdpbmUgaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB0YXJnZXRzIC0gdGhlIGxpc3Qgb2YgdGFyZ2V0cyB3aXRoIHZpZXdzIHRoYXQgbmVlZCB0byBiZSByZWNvbXB1dGVkXG4gKiBAcGFyYW0gdHJhbnNpdGlvblRvUHJpbWFyeSAtIGB0cnVlYCBpZmYgdGhlIHRhYiB0cmFuc2l0aW9ucyBmcm9tIGEgc2Vjb25kYXJ5XG4gKiB0YWIgdG8gYSBwcmltYXJ5IHRhYlxuICovXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxuYXN5bmMgZnVuY3Rpb24gc3luY2hyb25pemVRdWVyeVZpZXdzQW5kUmFpc2VTbmFwc2hvdHMoc3luY0VuZ2luZSwgdGFyZ2V0cywgdHJhbnNpdGlvblRvUHJpbWFyeSkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIGNvbnN0IGFjdGl2ZVF1ZXJpZXMgPSBbXTtcbiAgICBjb25zdCBuZXdWaWV3U25hcHNob3RzID0gW107XG4gICAgZm9yIChjb25zdCB0YXJnZXRJZCBvZiB0YXJnZXRzKSB7XG4gICAgICAgIGxldCB0YXJnZXREYXRhO1xuICAgICAgICBjb25zdCBxdWVyaWVzID0gc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LmdldCh0YXJnZXRJZCk7XG4gICAgICAgIGlmIChxdWVyaWVzICYmIHF1ZXJpZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAvLyBGb3IgcXVlcmllcyB0aGF0IGhhdmUgYSBsb2NhbCBWaWV3LCB3ZSBmZXRjaCB0aGVpciBjdXJyZW50IHN0YXRlXG4gICAgICAgICAgICAvLyBmcm9tIExvY2FsU3RvcmUgKGFzIHRoZSByZXN1bWUgdG9rZW4gYW5kIHRoZSBzbmFwc2hvdCB2ZXJzaW9uXG4gICAgICAgICAgICAvLyBtaWdodCBoYXZlIGNoYW5nZWQpIGFuZCByZWNvbmNpbGUgdGhlaXIgdmlld3Mgd2l0aCB0aGUgcGVyc2lzdGVkXG4gICAgICAgICAgICAvLyBzdGF0ZSAodGhlIGxpc3Qgb2Ygc3luY2VkRG9jdW1lbnRzIG1heSBoYXZlIGdvdHRlbiBvdXQgb2Ygc3luYykuXG4gICAgICAgICAgICB0YXJnZXREYXRhID0gYXdhaXQgbG9jYWxTdG9yZUFsbG9jYXRlVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHF1ZXJ5VG9UYXJnZXQocXVlcmllc1swXSkpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBxdWVyeSBvZiBxdWVyaWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcXVlcnlWaWV3ID0gc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZ2V0KHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3Q2hhbmdlID0gYXdhaXQgc3luY2hyb25pemVWaWV3QW5kQ29tcHV0ZVNuYXBzaG90KHN5bmNFbmdpbmVJbXBsLCBxdWVyeVZpZXcpO1xuICAgICAgICAgICAgICAgIGlmICh2aWV3Q2hhbmdlLnNuYXBzaG90KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZpZXdTbmFwc2hvdHMucHVzaCh2aWV3Q2hhbmdlLnNuYXBzaG90KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3IgcXVlcmllcyB0aGF0IG5ldmVyIGV4ZWN1dGVkIG9uIHRoaXMgY2xpZW50LCB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAvLyBhbGxvY2F0ZSB0aGUgdGFyZ2V0IGluIExvY2FsU3RvcmUgYW5kIGluaXRpYWxpemUgYSBuZXcgVmlldy5cbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGF3YWl0IGxvY2FsU3RvcmVHZXRDYWNoZWRUYXJnZXQoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgdGFyZ2V0SWQpO1xuICAgICAgICAgICAgdGFyZ2V0RGF0YSA9IGF3YWl0IGxvY2FsU3RvcmVBbGxvY2F0ZVRhcmdldChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCB0YXJnZXQpO1xuICAgICAgICAgICAgYXdhaXQgaW5pdGlhbGl6ZVZpZXdBbmRDb21wdXRlU25hcHNob3Qoc3luY0VuZ2luZUltcGwsIHN5bnRoZXNpemVUYXJnZXRUb1F1ZXJ5KHRhcmdldCksIHRhcmdldElkLCBcbiAgICAgICAgICAgIC8qY3VycmVudD0qLyBmYWxzZSwgdGFyZ2V0RGF0YS5yZXN1bWVUb2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZlUXVlcmllcy5wdXNoKHRhcmdldERhdGEpO1xuICAgIH1cbiAgICBzeW5jRW5naW5lSW1wbC5zeW5jRW5naW5lTGlzdGVuZXIub25XYXRjaENoYW5nZShuZXdWaWV3U25hcHNob3RzKTtcbiAgICByZXR1cm4gYWN0aXZlUXVlcmllcztcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBRdWVyeWAgb2JqZWN0IGZyb20gdGhlIHNwZWNpZmllZCBgVGFyZ2V0YC4gVGhlcmUgaXMgbm8gd2F5IHRvXG4gKiBvYnRhaW4gdGhlIG9yaWdpbmFsIGBRdWVyeWAsIHNvIHdlIHN5bnRoZXNpemUgYSBgUXVlcnlgIGZyb20gdGhlIGBUYXJnZXRgXG4gKiBvYmplY3QuXG4gKlxuICogVGhlIHN5bnRoZXNpemVkIHJlc3VsdCBtaWdodCBiZSBkaWZmZXJlbnQgZnJvbSB0aGUgb3JpZ2luYWwgYFF1ZXJ5YCwgYnV0XG4gKiBzaW5jZSB0aGUgc3ludGhlc2l6ZWQgYFF1ZXJ5YCBzaG91bGQgcmV0dXJuIHRoZSBzYW1lIHJlc3VsdHMgYXMgdGhlXG4gKiBvcmlnaW5hbCBvbmUgKG9ubHkgdGhlIHByZXNlbnRhdGlvbiBvZiByZXN1bHRzIG1pZ2h0IGRpZmZlciksIHRoZSBwb3RlbnRpYWxcbiAqIGRpZmZlcmVuY2Ugd2lsbCBub3QgY2F1c2UgaXNzdWVzLlxuICovXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxuZnVuY3Rpb24gc3ludGhlc2l6ZVRhcmdldFRvUXVlcnkodGFyZ2V0KSB7XG4gICAgcmV0dXJuIG5ld1F1ZXJ5KHRhcmdldC5wYXRoLCB0YXJnZXQuY29sbGVjdGlvbkdyb3VwLCB0YXJnZXQub3JkZXJCeSwgdGFyZ2V0LmZpbHRlcnMsIHRhcmdldC5saW1pdCwgXCJGXCIgLyogTGltaXRUeXBlLkZpcnN0ICovLCB0YXJnZXQuc3RhcnRBdCwgdGFyZ2V0LmVuZEF0KTtcbn1cbi8qKiBSZXR1cm5zIHRoZSBJRHMgb2YgdGhlIGNsaWVudHMgdGhhdCBhcmUgY3VycmVudGx5IGFjdGl2ZS4gKi9cbi8vIFBPUlRJTkcgTk9URTogTXVsdGktVGFiIG9ubHkuXG5mdW5jdGlvbiBzeW5jRW5naW5lR2V0QWN0aXZlQ2xpZW50cyhzeW5jRW5naW5lKSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmVHZXRBY3RpdmVDbGllbnRzKHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUpO1xufVxuLyoqIEFwcGxpZXMgYSBxdWVyeSB0YXJnZXQgY2hhbmdlIGZyb20gYSBkaWZmZXJlbnQgdGFiLiAqL1xuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVBcHBseVRhcmdldFN0YXRlKHN5bmNFbmdpbmUsIHRhcmdldElkLCBzdGF0ZSwgZXJyb3IpIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcbiAgICBpZiAoc3luY0VuZ2luZUltcGwuX2lzUHJpbWFyeUNsaWVudCkge1xuICAgICAgICAvLyBJZiB3ZSByZWNlaXZlIGEgdGFyZ2V0IHN0YXRlIG5vdGlmaWNhdGlvbiB2aWEgV2ViU3RvcmFnZSwgd2UgYXJlXG4gICAgICAgIC8vIGVpdGhlciBhbHJlYWR5IHNlY29uZGFyeSBvciBhbm90aGVyIHRhYiBoYXMgdGFrZW4gdGhlIHByaW1hcnkgbGVhc2UuXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckMywgJ0lnbm9yaW5nIHVuZXhwZWN0ZWQgcXVlcnkgc3RhdGUgbm90aWZpY2F0aW9uLicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHF1ZXJ5ID0gc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LmdldCh0YXJnZXRJZCk7XG4gICAgaWYgKHF1ZXJ5ICYmIHF1ZXJ5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnY3VycmVudCc6XG4gICAgICAgICAgICBjYXNlICdub3QtY3VycmVudCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gYXdhaXQgbG9jYWxTdG9yZUdldE5ld0RvY3VtZW50Q2hhbmdlcyhzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCBxdWVyeUNvbGxlY3Rpb25Hcm91cChxdWVyeVswXSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN5bnRoZXNpemVkUmVtb3RlRXZlbnQgPSBSZW1vdGVFdmVudC5jcmVhdGVTeW50aGVzaXplZFJlbW90ZUV2ZW50Rm9yQ3VycmVudENoYW5nZSh0YXJnZXRJZCwgc3RhdGUgPT09ICdjdXJyZW50JywgQnl0ZVN0cmluZy5FTVBUWV9CWVRFX1NUUklORyk7XG4gICAgICAgICAgICAgICAgYXdhaXQgc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZUltcGwsIGNoYW5nZXMsIHN5bnRoZXNpemVkUmVtb3RlRXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAncmVqZWN0ZWQnOiB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbG9jYWxTdG9yZVJlbGVhc2VUYXJnZXQoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgdGFyZ2V0SWQsIFxuICAgICAgICAgICAgICAgIC8qIGtlZXBQZXJzaXN0ZWRUYXJnZXREYXRhICovIHRydWUpO1xuICAgICAgICAgICAgICAgIHJlbW92ZUFuZENsZWFudXBUYXJnZXQoc3luY0VuZ2luZUltcGwsIHRhcmdldElkLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGZhaWwoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKiBBZGRzIG9yIHJlbW92ZXMgV2F0Y2ggdGFyZ2V0cyBmb3IgcXVlcmllcyBmcm9tIGRpZmZlcmVudCB0YWJzLiAqL1xuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZUFwcGx5QWN0aXZlVGFyZ2V0c0NoYW5nZShzeW5jRW5naW5lLCBhZGRlZCwgcmVtb3ZlZCkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZW5zdXJlV2F0Y2hDYWxsYmFja3Moc3luY0VuZ2luZSk7XG4gICAgaWYgKCFzeW5jRW5naW5lSW1wbC5faXNQcmltYXJ5Q2xpZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCB0YXJnZXRJZCBvZiBhZGRlZCkge1xuICAgICAgICAvLyBBIHRhcmdldCBpcyBhbHJlYWR5IGxpc3RlbmluZyB0byByZW1vdGUgc3RvcmUgaWYgaXQgaXMgYWxyZWFkeSByZWdpc3RlcmVkIHRvXG4gICAgICAgIC8vIHNoYXJlZENsaWVudFN0YXRlLlxuICAgICAgICBjb25zdCB0YXJnZXRBbHJlYWR5TGlzdGVuaW5nVG9SZW1vdGVTdG9yZSA9IHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5oYXModGFyZ2V0SWQpICYmXG4gICAgICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5pc0FjdGl2ZVF1ZXJ5VGFyZ2V0KHRhcmdldElkKTtcbiAgICAgICAgaWYgKHRhcmdldEFscmVhZHlMaXN0ZW5pbmdUb1JlbW90ZVN0b3JlKSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDMsICdBZGRpbmcgYW4gYWxyZWFkeSBhY3RpdmUgdGFyZ2V0ICcgKyB0YXJnZXRJZCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSBhd2FpdCBsb2NhbFN0b3JlR2V0Q2FjaGVkVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHRhcmdldElkKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0RGF0YSA9IGF3YWl0IGxvY2FsU3RvcmVBbGxvY2F0ZVRhcmdldChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCB0YXJnZXQpO1xuICAgICAgICBhd2FpdCBpbml0aWFsaXplVmlld0FuZENvbXB1dGVTbmFwc2hvdChzeW5jRW5naW5lSW1wbCwgc3ludGhlc2l6ZVRhcmdldFRvUXVlcnkodGFyZ2V0KSwgdGFyZ2V0RGF0YS50YXJnZXRJZCwgXG4gICAgICAgIC8qY3VycmVudD0qLyBmYWxzZSwgdGFyZ2V0RGF0YS5yZXN1bWVUb2tlbik7XG4gICAgICAgIHJlbW90ZVN0b3JlTGlzdGVuKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCB0YXJnZXREYXRhKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB0YXJnZXRJZCBvZiByZW1vdmVkKSB7XG4gICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIHRhcmdldCBpcyBzdGlsbCBhY3RpdmUgc2luY2UgdGhlIHRhcmdldCBtaWdodCBoYXZlIGJlZW5cbiAgICAgICAgLy8gcmVtb3ZlZCBpZiBpdCBoYXMgYmVlbiByZWplY3RlZCBieSB0aGUgYmFja2VuZC5cbiAgICAgICAgaWYgKCFzeW5jRW5naW5lSW1wbC5xdWVyaWVzQnlUYXJnZXQuaGFzKHRhcmdldElkKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVsZWFzZSBxdWVyaWVzIHRoYXQgYXJlIHN0aWxsIGFjdGl2ZS5cbiAgICAgICAgYXdhaXQgbG9jYWxTdG9yZVJlbGVhc2VUYXJnZXQoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgdGFyZ2V0SWQsIFxuICAgICAgICAvKiBrZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YSAqLyBmYWxzZSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHJlbW90ZVN0b3JlVW5saXN0ZW4oc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIHRhcmdldElkKTtcbiAgICAgICAgICAgIHJlbW92ZUFuZENsZWFudXBUYXJnZXQoc3luY0VuZ2luZUltcGwsIHRhcmdldElkKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChpZ25vcmVJZlByaW1hcnlMZWFzZUxvc3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVuc3VyZVdhdGNoQ2FsbGJhY2tzKHN5bmNFbmdpbmUpIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcbiAgICBzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZS5yZW1vdGVTeW5jZXIuYXBwbHlSZW1vdGVFdmVudCA9XG4gICAgICAgIHN5bmNFbmdpbmVBcHBseVJlbW90ZUV2ZW50LmJpbmQobnVsbCwgc3luY0VuZ2luZUltcGwpO1xuICAgIHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLnJlbW90ZVN5bmNlci5nZXRSZW1vdGVLZXlzRm9yVGFyZ2V0ID1cbiAgICAgICAgc3luY0VuZ2luZUdldFJlbW90ZUtleXNGb3JUYXJnZXQuYmluZChudWxsLCBzeW5jRW5naW5lSW1wbCk7XG4gICAgc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUucmVtb3RlU3luY2VyLnJlamVjdExpc3RlbiA9XG4gICAgICAgIHN5bmNFbmdpbmVSZWplY3RMaXN0ZW4uYmluZChudWxsLCBzeW5jRW5naW5lSW1wbCk7XG4gICAgc3luY0VuZ2luZUltcGwuc3luY0VuZ2luZUxpc3RlbmVyLm9uV2F0Y2hDaGFuZ2UgPVxuICAgICAgICBldmVudE1hbmFnZXJPbldhdGNoQ2hhbmdlLmJpbmQobnVsbCwgc3luY0VuZ2luZUltcGwuZXZlbnRNYW5hZ2VyKTtcbiAgICBzeW5jRW5naW5lSW1wbC5zeW5jRW5naW5lTGlzdGVuZXIub25XYXRjaEVycm9yID1cbiAgICAgICAgZXZlbnRNYW5hZ2VyT25XYXRjaEVycm9yLmJpbmQobnVsbCwgc3luY0VuZ2luZUltcGwuZXZlbnRNYW5hZ2VyKTtcbiAgICByZXR1cm4gc3luY0VuZ2luZUltcGw7XG59XG5mdW5jdGlvbiBzeW5jRW5naW5lRW5zdXJlV3JpdGVDYWxsYmFja3Moc3luY0VuZ2luZSkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLnJlbW90ZVN5bmNlci5hcHBseVN1Y2Nlc3NmdWxXcml0ZSA9XG4gICAgICAgIHN5bmNFbmdpbmVBcHBseVN1Y2Nlc3NmdWxXcml0ZS5iaW5kKG51bGwsIHN5bmNFbmdpbmVJbXBsKTtcbiAgICBzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZS5yZW1vdGVTeW5jZXIucmVqZWN0RmFpbGVkV3JpdGUgPVxuICAgICAgICBzeW5jRW5naW5lUmVqZWN0RmFpbGVkV3JpdGUuYmluZChudWxsLCBzeW5jRW5naW5lSW1wbCk7XG4gICAgcmV0dXJuIHN5bmNFbmdpbmVJbXBsO1xufVxuLyoqXG4gKiBMb2FkcyBhIEZpcmVzdG9yZSBidW5kbGUgaW50byB0aGUgU0RLLiBUaGUgcmV0dXJuZWQgcHJvbWlzZSByZXNvbHZlcyB3aGVuXG4gKiB0aGUgYnVuZGxlIGZpbmlzaGVkIGxvYWRpbmcuXG4gKlxuICogQHBhcmFtIHN5bmNFbmdpbmUgLSBTeW5jRW5naW5lIHRvIHVzZS5cbiAqIEBwYXJhbSBidW5kbGVSZWFkZXIgLSBCdW5kbGUgdG8gbG9hZCBpbnRvIHRoZSBTREsuXG4gKiBAcGFyYW0gdGFzayAtIExvYWRCdW5kbGVUYXNrIHVzZWQgdG8gdXBkYXRlIHRoZSBsb2FkaW5nIHByb2dyZXNzIHRvIHB1YmxpYyBBUEkuXG4gKi9cbmZ1bmN0aW9uIHN5bmNFbmdpbmVMb2FkQnVuZGxlKHN5bmNFbmdpbmUsIGJ1bmRsZVJlYWRlciwgdGFzaykge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICBsb2FkQnVuZGxlSW1wbChzeW5jRW5naW5lSW1wbCwgYnVuZGxlUmVhZGVyLCB0YXNrKS50aGVuKGNvbGxlY3Rpb25Hcm91cHMgPT4ge1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5ub3RpZnlCdW5kbGVMb2FkZWQoY29sbGVjdGlvbkdyb3Vwcyk7XG4gICAgfSk7XG59XG4vKiogTG9hZHMgYSBidW5kbGUgYW5kIHJldHVybnMgdGhlIGxpc3Qgb2YgYWZmZWN0ZWQgY29sbGVjdGlvbiBncm91cHMuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkQnVuZGxlSW1wbChzeW5jRW5naW5lLCByZWFkZXIsIHRhc2spIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHJlYWRlci5nZXRNZXRhZGF0YSgpO1xuICAgICAgICBjb25zdCBza2lwID0gYXdhaXQgbG9jYWxTdG9yZUhhc05ld2VyQnVuZGxlKHN5bmNFbmdpbmUubG9jYWxTdG9yZSwgbWV0YWRhdGEpO1xuICAgICAgICBpZiAoc2tpcCkge1xuICAgICAgICAgICAgYXdhaXQgcmVhZGVyLmNsb3NlKCk7XG4gICAgICAgICAgICB0YXNrLl9jb21wbGV0ZVdpdGgoYnVuZGxlU3VjY2Vzc1Byb2dyZXNzKG1ldGFkYXRhKSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBTZXQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGFzay5fdXBkYXRlUHJvZ3Jlc3MoYnVuZGxlSW5pdGlhbFByb2dyZXNzKG1ldGFkYXRhKSk7XG4gICAgICAgIGNvbnN0IGxvYWRlciA9IG5ldyBCdW5kbGVMb2FkZXIobWV0YWRhdGEsIHN5bmNFbmdpbmUubG9jYWxTdG9yZSwgcmVhZGVyLnNlcmlhbGl6ZXIpO1xuICAgICAgICBsZXQgZWxlbWVudCA9IGF3YWl0IHJlYWRlci5uZXh0RWxlbWVudCgpO1xuICAgICAgICB3aGlsZSAoZWxlbWVudCkge1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBhd2FpdCBsb2FkZXIuYWRkU2l6ZWRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgdGFzay5fdXBkYXRlUHJvZ3Jlc3MocHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudCA9IGF3YWl0IHJlYWRlci5uZXh0RWxlbWVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxvYWRlci5jb21wbGV0ZSgpO1xuICAgICAgICBhd2FpdCBzeW5jRW5naW5lRW1pdE5ld1NuYXBzQW5kTm90aWZ5TG9jYWxTdG9yZShzeW5jRW5naW5lLCByZXN1bHQuY2hhbmdlZERvY3MsIFxuICAgICAgICAvKiByZW1vdGVFdmVudCAqLyB1bmRlZmluZWQpO1xuICAgICAgICAvLyBTYXZlIG1ldGFkYXRhLCBzbyBsb2FkaW5nIHRoZSBzYW1lIGJ1bmRsZSB3aWxsIHNraXAuXG4gICAgICAgIGF3YWl0IGxvY2FsU3RvcmVTYXZlQnVuZGxlKHN5bmNFbmdpbmUubG9jYWxTdG9yZSwgbWV0YWRhdGEpO1xuICAgICAgICB0YXNrLl9jb21wbGV0ZVdpdGgocmVzdWx0LnByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQuY2hhbmdlZENvbGxlY3Rpb25Hcm91cHMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBsb2dXYXJuKExPR19UQUckMywgYExvYWRpbmcgYnVuZGxlIGZhaWxlZCB3aXRoICR7ZX1gKTtcbiAgICAgICAgdGFzay5fZmFpbFdpdGgoZSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IFNldCgpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFByb3ZpZGVzIGFsbCBjb21wb25lbnRzIG5lZWRlZCBmb3IgRmlyZXN0b3JlIHdpdGggaW4tbWVtb3J5IHBlcnNpc3RlbmNlLlxuICogVXNlcyBFYWdlckdDIGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAqL1xuY2xhc3MgTWVtb3J5T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5raW5kID0gJ21lbW9yeSc7XG4gICAgICAgIHRoaXMuc3luY2hyb25pemVUYWJzID0gZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIGluaXRpYWxpemUoY2ZnKSB7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IG5ld1NlcmlhbGl6ZXIoY2ZnLmRhdGFiYXNlSW5mby5kYXRhYmFzZUlkKTtcbiAgICAgICAgdGhpcy5zaGFyZWRDbGllbnRTdGF0ZSA9IHRoaXMuY3JlYXRlU2hhcmVkQ2xpZW50U3RhdGUoY2ZnKTtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZSA9IHRoaXMuY3JlYXRlUGVyc2lzdGVuY2UoY2ZnKTtcbiAgICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZS5zdGFydCgpO1xuICAgICAgICB0aGlzLmxvY2FsU3RvcmUgPSB0aGlzLmNyZWF0ZUxvY2FsU3RvcmUoY2ZnKTtcbiAgICAgICAgdGhpcy5nY1NjaGVkdWxlciA9IHRoaXMuY3JlYXRlR2FyYmFnZUNvbGxlY3Rpb25TY2hlZHVsZXIoY2ZnLCB0aGlzLmxvY2FsU3RvcmUpO1xuICAgICAgICB0aGlzLmluZGV4QmFja2ZpbGxlclNjaGVkdWxlciA9IHRoaXMuY3JlYXRlSW5kZXhCYWNrZmlsbGVyU2NoZWR1bGVyKGNmZywgdGhpcy5sb2NhbFN0b3JlKTtcbiAgICB9XG4gICAgY3JlYXRlR2FyYmFnZUNvbGxlY3Rpb25TY2hlZHVsZXIoY2ZnLCBsb2NhbFN0b3JlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjcmVhdGVJbmRleEJhY2tmaWxsZXJTY2hlZHVsZXIoY2ZnLCBsb2NhbFN0b3JlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjcmVhdGVMb2NhbFN0b3JlKGNmZykge1xuICAgICAgICByZXR1cm4gbmV3TG9jYWxTdG9yZSh0aGlzLnBlcnNpc3RlbmNlLCBuZXcgUXVlcnlFbmdpbmUoKSwgY2ZnLmluaXRpYWxVc2VyLCB0aGlzLnNlcmlhbGl6ZXIpO1xuICAgIH1cbiAgICBjcmVhdGVQZXJzaXN0ZW5jZShjZmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNZW1vcnlQZXJzaXN0ZW5jZShNZW1vcnlFYWdlckRlbGVnYXRlLmZhY3RvcnksIHRoaXMuc2VyaWFsaXplcik7XG4gICAgfVxuICAgIGNyZWF0ZVNoYXJlZENsaWVudFN0YXRlKGNmZykge1xuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeVNoYXJlZENsaWVudFN0YXRlKCk7XG4gICAgfVxuICAgIGFzeW5jIHRlcm1pbmF0ZSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgKF9hID0gdGhpcy5nY1NjaGVkdWxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0b3AoKTtcbiAgICAgICAgKF9iID0gdGhpcy5pbmRleEJhY2tmaWxsZXJTY2hlZHVsZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdG9wKCk7XG4gICAgICAgIHRoaXMuc2hhcmVkQ2xpZW50U3RhdGUuc2h1dGRvd24oKTtcbiAgICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZS5zaHV0ZG93bigpO1xuICAgIH1cbn1cbk1lbW9yeU9mZmxpbmVDb21wb25lbnRQcm92aWRlci5wcm92aWRlciA9IHtcbiAgICBidWlsZDogKCkgPT4gbmV3IE1lbW9yeU9mZmxpbmVDb21wb25lbnRQcm92aWRlcigpXG59O1xuY2xhc3MgTHJ1R2NNZW1vcnlPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIgZXh0ZW5kcyBNZW1vcnlPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKGNhY2hlU2l6ZUJ5dGVzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY2FjaGVTaXplQnl0ZXMgPSBjYWNoZVNpemVCeXRlcztcbiAgICB9XG4gICAgY3JlYXRlR2FyYmFnZUNvbGxlY3Rpb25TY2hlZHVsZXIoY2ZnLCBsb2NhbFN0b3JlKSB7XG4gICAgICAgIGhhcmRBc3NlcnQodGhpcy5wZXJzaXN0ZW5jZS5yZWZlcmVuY2VEZWxlZ2F0ZSBpbnN0YW5jZW9mIE1lbW9yeUxydURlbGVnYXRlKTtcbiAgICAgICAgY29uc3QgZ2FyYmFnZUNvbGxlY3RvciA9IHRoaXMucGVyc2lzdGVuY2UucmVmZXJlbmNlRGVsZWdhdGUuZ2FyYmFnZUNvbGxlY3RvcjtcbiAgICAgICAgcmV0dXJuIG5ldyBMcnVTY2hlZHVsZXIoZ2FyYmFnZUNvbGxlY3RvciwgY2ZnLmFzeW5jUXVldWUsIGxvY2FsU3RvcmUpO1xuICAgIH1cbiAgICBjcmVhdGVQZXJzaXN0ZW5jZShjZmcpIHtcbiAgICAgICAgY29uc3QgbHJ1UGFyYW1zID0gdGhpcy5jYWNoZVNpemVCeXRlcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IExydVBhcmFtcy53aXRoQ2FjaGVTaXplKHRoaXMuY2FjaGVTaXplQnl0ZXMpXG4gICAgICAgICAgICA6IExydVBhcmFtcy5ERUZBVUxUO1xuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeVBlcnNpc3RlbmNlKHAgPT4gTWVtb3J5THJ1RGVsZWdhdGUuZmFjdG9yeShwLCBscnVQYXJhbXMpLCB0aGlzLnNlcmlhbGl6ZXIpO1xuICAgIH1cbn1cbi8qKlxuICogUHJvdmlkZXMgYWxsIGNvbXBvbmVudHMgbmVlZGVkIGZvciBGaXJlc3RvcmUgd2l0aCBJbmRleGVkREIgcGVyc2lzdGVuY2UuXG4gKi9cbmNsYXNzIEluZGV4ZWREYk9mZmxpbmVDb21wb25lbnRQcm92aWRlciBleHRlbmRzIE1lbW9yeU9mZmxpbmVDb21wb25lbnRQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3Iob25saW5lQ29tcG9uZW50UHJvdmlkZXIsIGNhY2hlU2l6ZUJ5dGVzLCBmb3JjZU93bmVyc2hpcCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm9ubGluZUNvbXBvbmVudFByb3ZpZGVyID0gb25saW5lQ29tcG9uZW50UHJvdmlkZXI7XG4gICAgICAgIHRoaXMuY2FjaGVTaXplQnl0ZXMgPSBjYWNoZVNpemVCeXRlcztcbiAgICAgICAgdGhpcy5mb3JjZU93bmVyc2hpcCA9IGZvcmNlT3duZXJzaGlwO1xuICAgICAgICB0aGlzLmtpbmQgPSAncGVyc2lzdGVudCc7XG4gICAgICAgIHRoaXMuc3luY2hyb25pemVUYWJzID0gZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIGluaXRpYWxpemUoY2ZnKSB7XG4gICAgICAgIGF3YWl0IHN1cGVyLmluaXRpYWxpemUoY2ZnKTtcbiAgICAgICAgYXdhaXQgdGhpcy5vbmxpbmVDb21wb25lbnRQcm92aWRlci5pbml0aWFsaXplKHRoaXMsIGNmZyk7XG4gICAgICAgIC8vIEVucXVldWUgd3JpdGVzIGZyb20gYSBwcmV2aW91cyBzZXNzaW9uXG4gICAgICAgIGF3YWl0IHN5bmNFbmdpbmVFbnN1cmVXcml0ZUNhbGxiYWNrcyh0aGlzLm9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnN5bmNFbmdpbmUpO1xuICAgICAgICBhd2FpdCBmaWxsV3JpdGVQaXBlbGluZSh0aGlzLm9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnJlbW90ZVN0b3JlKTtcbiAgICAgICAgLy8gTk9URTogVGhpcyB3aWxsIGltbWVkaWF0ZWx5IGNhbGwgdGhlIGxpc3RlbmVyLCBzbyB3ZSBtYWtlIHN1cmUgdG9cbiAgICAgICAgLy8gc2V0IGl0IGFmdGVyIGxvY2FsU3RvcmUgLyByZW1vdGVTdG9yZSBhcmUgc3RhcnRlZC5cbiAgICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZS5zZXRQcmltYXJ5U3RhdGVMaXN0ZW5lcigoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5nY1NjaGVkdWxlciAmJiAhdGhpcy5nY1NjaGVkdWxlci5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nY1NjaGVkdWxlci5zdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXhCYWNrZmlsbGVyU2NoZWR1bGVyICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuaW5kZXhCYWNrZmlsbGVyU2NoZWR1bGVyLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4QmFja2ZpbGxlclNjaGVkdWxlci5zdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlTG9jYWxTdG9yZShjZmcpIHtcbiAgICAgICAgcmV0dXJuIG5ld0xvY2FsU3RvcmUodGhpcy5wZXJzaXN0ZW5jZSwgbmV3IFF1ZXJ5RW5naW5lKCksIGNmZy5pbml0aWFsVXNlciwgdGhpcy5zZXJpYWxpemVyKTtcbiAgICB9XG4gICAgY3JlYXRlR2FyYmFnZUNvbGxlY3Rpb25TY2hlZHVsZXIoY2ZnLCBsb2NhbFN0b3JlKSB7XG4gICAgICAgIGNvbnN0IGdhcmJhZ2VDb2xsZWN0b3IgPSB0aGlzLnBlcnNpc3RlbmNlLnJlZmVyZW5jZURlbGVnYXRlLmdhcmJhZ2VDb2xsZWN0b3I7XG4gICAgICAgIHJldHVybiBuZXcgTHJ1U2NoZWR1bGVyKGdhcmJhZ2VDb2xsZWN0b3IsIGNmZy5hc3luY1F1ZXVlLCBsb2NhbFN0b3JlKTtcbiAgICB9XG4gICAgY3JlYXRlSW5kZXhCYWNrZmlsbGVyU2NoZWR1bGVyKGNmZywgbG9jYWxTdG9yZSkge1xuICAgICAgICBjb25zdCBpbmRleEJhY2tmaWxsZXIgPSBuZXcgSW5kZXhCYWNrZmlsbGVyKGxvY2FsU3RvcmUsIHRoaXMucGVyc2lzdGVuY2UpO1xuICAgICAgICByZXR1cm4gbmV3IEluZGV4QmFja2ZpbGxlclNjaGVkdWxlcihjZmcuYXN5bmNRdWV1ZSwgaW5kZXhCYWNrZmlsbGVyKTtcbiAgICB9XG4gICAgY3JlYXRlUGVyc2lzdGVuY2UoY2ZnKSB7XG4gICAgICAgIGNvbnN0IHBlcnNpc3RlbmNlS2V5ID0gaW5kZXhlZERiU3RvcmFnZVByZWZpeChjZmcuZGF0YWJhc2VJbmZvLmRhdGFiYXNlSWQsIGNmZy5kYXRhYmFzZUluZm8ucGVyc2lzdGVuY2VLZXkpO1xuICAgICAgICBjb25zdCBscnVQYXJhbXMgPSB0aGlzLmNhY2hlU2l6ZUJ5dGVzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gTHJ1UGFyYW1zLndpdGhDYWNoZVNpemUodGhpcy5jYWNoZVNpemVCeXRlcylcbiAgICAgICAgICAgIDogTHJ1UGFyYW1zLkRFRkFVTFQ7XG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhlZERiUGVyc2lzdGVuY2UodGhpcy5zeW5jaHJvbml6ZVRhYnMsIHBlcnNpc3RlbmNlS2V5LCBjZmcuY2xpZW50SWQsIGxydVBhcmFtcywgY2ZnLmFzeW5jUXVldWUsIGdldFdpbmRvdygpLCBnZXREb2N1bWVudCgpLCB0aGlzLnNlcmlhbGl6ZXIsIHRoaXMuc2hhcmVkQ2xpZW50U3RhdGUsICEhdGhpcy5mb3JjZU93bmVyc2hpcCk7XG4gICAgfVxuICAgIGNyZWF0ZVNoYXJlZENsaWVudFN0YXRlKGNmZykge1xuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeVNoYXJlZENsaWVudFN0YXRlKCk7XG4gICAgfVxufVxuLyoqXG4gKiBQcm92aWRlcyBhbGwgY29tcG9uZW50cyBuZWVkZWQgZm9yIEZpcmVzdG9yZSB3aXRoIG11bHRpLXRhYiBJbmRleGVkREJcbiAqIHBlcnNpc3RlbmNlLlxuICpcbiAqIEluIHRoZSBsZWdhY3kgY2xpZW50LCB0aGlzIHByb3ZpZGVyIGlzIHVzZWQgdG8gcHJvdmlkZSBib3RoIG11bHRpLXRhYiBhbmRcbiAqIG5vbi1tdWx0aS10YWIgcGVyc2lzdGVuY2Ugc2luY2Ugd2UgY2Fubm90IHRlbGwgYXQgYnVpbGQgdGltZSB3aGV0aGVyXG4gKiBgc3luY2hyb25pemVUYWJzYCB3aWxsIGJlIGVuYWJsZWQuXG4gKi9cbmNsYXNzIE11bHRpVGFiT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyIGV4dGVuZHMgSW5kZXhlZERiT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvbmxpbmVDb21wb25lbnRQcm92aWRlciwgY2FjaGVTaXplQnl0ZXMpIHtcbiAgICAgICAgc3VwZXIob25saW5lQ29tcG9uZW50UHJvdmlkZXIsIGNhY2hlU2l6ZUJ5dGVzLCAvKiBmb3JjZU93bmVyc2hpcD0gKi8gZmFsc2UpO1xuICAgICAgICB0aGlzLm9ubGluZUNvbXBvbmVudFByb3ZpZGVyID0gb25saW5lQ29tcG9uZW50UHJvdmlkZXI7XG4gICAgICAgIHRoaXMuY2FjaGVTaXplQnl0ZXMgPSBjYWNoZVNpemVCeXRlcztcbiAgICAgICAgdGhpcy5zeW5jaHJvbml6ZVRhYnMgPSB0cnVlO1xuICAgIH1cbiAgICBhc3luYyBpbml0aWFsaXplKGNmZykge1xuICAgICAgICBhd2FpdCBzdXBlci5pbml0aWFsaXplKGNmZyk7XG4gICAgICAgIGNvbnN0IHN5bmNFbmdpbmUgPSB0aGlzLm9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnN5bmNFbmdpbmU7XG4gICAgICAgIGlmICh0aGlzLnNoYXJlZENsaWVudFN0YXRlIGluc3RhbmNlb2YgV2ViU3RvcmFnZVNoYXJlZENsaWVudFN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnNoYXJlZENsaWVudFN0YXRlLnN5bmNFbmdpbmUgPSB7XG4gICAgICAgICAgICAgICAgYXBwbHlCYXRjaFN0YXRlOiBzeW5jRW5naW5lQXBwbHlCYXRjaFN0YXRlLmJpbmQobnVsbCwgc3luY0VuZ2luZSksXG4gICAgICAgICAgICAgICAgYXBwbHlUYXJnZXRTdGF0ZTogc3luY0VuZ2luZUFwcGx5VGFyZ2V0U3RhdGUuYmluZChudWxsLCBzeW5jRW5naW5lKSxcbiAgICAgICAgICAgICAgICBhcHBseUFjdGl2ZVRhcmdldHNDaGFuZ2U6IHN5bmNFbmdpbmVBcHBseUFjdGl2ZVRhcmdldHNDaGFuZ2UuYmluZChudWxsLCBzeW5jRW5naW5lKSxcbiAgICAgICAgICAgICAgICBnZXRBY3RpdmVDbGllbnRzOiBzeW5jRW5naW5lR2V0QWN0aXZlQ2xpZW50cy5iaW5kKG51bGwsIHN5bmNFbmdpbmUpLFxuICAgICAgICAgICAgICAgIHN5bmNocm9uaXplV2l0aENoYW5nZWREb2N1bWVudHM6IHN5bmNFbmdpbmVTeW5jaHJvbml6ZVdpdGhDaGFuZ2VkRG9jdW1lbnRzLmJpbmQobnVsbCwgc3luY0VuZ2luZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNoYXJlZENsaWVudFN0YXRlLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9URTogVGhpcyB3aWxsIGltbWVkaWF0ZWx5IGNhbGwgdGhlIGxpc3RlbmVyLCBzbyB3ZSBtYWtlIHN1cmUgdG9cbiAgICAgICAgLy8gc2V0IGl0IGFmdGVyIGxvY2FsU3RvcmUgLyByZW1vdGVTdG9yZSBhcmUgc3RhcnRlZC5cbiAgICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZS5zZXRQcmltYXJ5U3RhdGVMaXN0ZW5lcihhc3luYyAoaXNQcmltYXJ5KSA9PiB7XG4gICAgICAgICAgICBhd2FpdCBzeW5jRW5naW5lQXBwbHlQcmltYXJ5U3RhdGUodGhpcy5vbmxpbmVDb21wb25lbnRQcm92aWRlci5zeW5jRW5naW5lLCBpc1ByaW1hcnkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2NTY2hlZHVsZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmltYXJ5ICYmICF0aGlzLmdjU2NoZWR1bGVyLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nY1NjaGVkdWxlci5zdGFydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNQcmltYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2NTY2hlZHVsZXIuc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4QmFja2ZpbGxlclNjaGVkdWxlcikge1xuICAgICAgICAgICAgICAgIGlmIChpc1ByaW1hcnkgJiYgIXRoaXMuaW5kZXhCYWNrZmlsbGVyU2NoZWR1bGVyLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleEJhY2tmaWxsZXJTY2hlZHVsZXIuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzUHJpbWFyeSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4QmFja2ZpbGxlclNjaGVkdWxlci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlU2hhcmVkQ2xpZW50U3RhdGUoY2ZnKSB7XG4gICAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgICAgICBpZiAoIVdlYlN0b3JhZ2VTaGFyZWRDbGllbnRTdGF0ZS5pc0F2YWlsYWJsZSh3aW5kb3cpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTklNUExFTUVOVEVELCAnSW5kZXhlZERCIHBlcnNpc3RlbmNlIGlzIG9ubHkgYXZhaWxhYmxlIG9uIHBsYXRmb3JtcyB0aGF0IHN1cHBvcnQgTG9jYWxTdG9yYWdlLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBlcnNpc3RlbmNlS2V5ID0gaW5kZXhlZERiU3RvcmFnZVByZWZpeChjZmcuZGF0YWJhc2VJbmZvLmRhdGFiYXNlSWQsIGNmZy5kYXRhYmFzZUluZm8ucGVyc2lzdGVuY2VLZXkpO1xuICAgICAgICByZXR1cm4gbmV3IFdlYlN0b3JhZ2VTaGFyZWRDbGllbnRTdGF0ZSh3aW5kb3csIGNmZy5hc3luY1F1ZXVlLCBwZXJzaXN0ZW5jZUtleSwgY2ZnLmNsaWVudElkLCBjZmcuaW5pdGlhbFVzZXIpO1xuICAgIH1cbn1cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW5kIHdpcmVzIHRoZSBjb21wb25lbnRzIHRoYXQgYXJlIG5lZWRlZCB0byBpbnRlcmZhY2Ugd2l0aCB0aGVcbiAqIG5ldHdvcmsuXG4gKi9cbmNsYXNzIE9ubGluZUNvbXBvbmVudFByb3ZpZGVyIHtcbiAgICBhc3luYyBpbml0aWFsaXplKG9mZmxpbmVDb21wb25lbnRQcm92aWRlciwgY2ZnKSB7XG4gICAgICAgIGlmICh0aGlzLmxvY2FsU3RvcmUpIHtcbiAgICAgICAgICAgIC8vIE9ubGluZUNvbXBvbmVudFByb3ZpZGVyIG1heSBnZXQgaW5pdGlhbGl6ZWQgbXVsdGlwbGUgdGltZXMgaWZcbiAgICAgICAgICAgIC8vIG11bHRpLXRhYiBwZXJzaXN0ZW5jZSBpcyB1c2VkLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9jYWxTdG9yZSA9IG9mZmxpbmVDb21wb25lbnRQcm92aWRlci5sb2NhbFN0b3JlO1xuICAgICAgICB0aGlzLnNoYXJlZENsaWVudFN0YXRlID0gb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyLnNoYXJlZENsaWVudFN0YXRlO1xuICAgICAgICB0aGlzLmRhdGFzdG9yZSA9IHRoaXMuY3JlYXRlRGF0YXN0b3JlKGNmZyk7XG4gICAgICAgIHRoaXMucmVtb3RlU3RvcmUgPSB0aGlzLmNyZWF0ZVJlbW90ZVN0b3JlKGNmZyk7XG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyID0gdGhpcy5jcmVhdGVFdmVudE1hbmFnZXIoY2ZnKTtcbiAgICAgICAgdGhpcy5zeW5jRW5naW5lID0gdGhpcy5jcmVhdGVTeW5jRW5naW5lKGNmZywgXG4gICAgICAgIC8qIHN0YXJ0QXNQcmltYXJ5PSovICFvZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIuc3luY2hyb25pemVUYWJzKTtcbiAgICAgICAgdGhpcy5zaGFyZWRDbGllbnRTdGF0ZS5vbmxpbmVTdGF0ZUhhbmRsZXIgPSBvbmxpbmVTdGF0ZSA9PiBzeW5jRW5naW5lQXBwbHlPbmxpbmVTdGF0ZUNoYW5nZSh0aGlzLnN5bmNFbmdpbmUsIG9ubGluZVN0YXRlLCAxIC8qIE9ubGluZVN0YXRlU291cmNlLlNoYXJlZENsaWVudFN0YXRlICovKTtcbiAgICAgICAgdGhpcy5yZW1vdGVTdG9yZS5yZW1vdGVTeW5jZXIuaGFuZGxlQ3JlZGVudGlhbENoYW5nZSA9XG4gICAgICAgICAgICBzeW5jRW5naW5lSGFuZGxlQ3JlZGVudGlhbENoYW5nZS5iaW5kKG51bGwsIHRoaXMuc3luY0VuZ2luZSk7XG4gICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlQXBwbHlQcmltYXJ5U3RhdGUodGhpcy5yZW1vdGVTdG9yZSwgdGhpcy5zeW5jRW5naW5lLmlzUHJpbWFyeUNsaWVudCk7XG4gICAgfVxuICAgIGNyZWF0ZUV2ZW50TWFuYWdlcihjZmcpIHtcbiAgICAgICAgcmV0dXJuIG5ld0V2ZW50TWFuYWdlcigpO1xuICAgIH1cbiAgICBjcmVhdGVEYXRhc3RvcmUoY2ZnKSB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXdTZXJpYWxpemVyKGNmZy5kYXRhYmFzZUluZm8uZGF0YWJhc2VJZCk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBuZXdDb25uZWN0aW9uKGNmZy5kYXRhYmFzZUluZm8pO1xuICAgICAgICByZXR1cm4gbmV3RGF0YXN0b3JlKGNmZy5hdXRoQ3JlZGVudGlhbHMsIGNmZy5hcHBDaGVja0NyZWRlbnRpYWxzLCBjb25uZWN0aW9uLCBzZXJpYWxpemVyKTtcbiAgICB9XG4gICAgY3JlYXRlUmVtb3RlU3RvcmUoY2ZnKSB7XG4gICAgICAgIHJldHVybiBuZXdSZW1vdGVTdG9yZSh0aGlzLmxvY2FsU3RvcmUsIHRoaXMuZGF0YXN0b3JlLCBjZmcuYXN5bmNRdWV1ZSwgb25saW5lU3RhdGUgPT4gc3luY0VuZ2luZUFwcGx5T25saW5lU3RhdGVDaGFuZ2UodGhpcy5zeW5jRW5naW5lLCBvbmxpbmVTdGF0ZSwgMCAvKiBPbmxpbmVTdGF0ZVNvdXJjZS5SZW1vdGVTdG9yZSAqLyksIG5ld0Nvbm5lY3Rpdml0eU1vbml0b3IoKSk7XG4gICAgfVxuICAgIGNyZWF0ZVN5bmNFbmdpbmUoY2ZnLCBzdGFydEFzUHJpbWFyeSkge1xuICAgICAgICByZXR1cm4gbmV3U3luY0VuZ2luZSh0aGlzLmxvY2FsU3RvcmUsIHRoaXMucmVtb3RlU3RvcmUsIHRoaXMuZXZlbnRNYW5hZ2VyLCB0aGlzLnNoYXJlZENsaWVudFN0YXRlLCBjZmcuaW5pdGlhbFVzZXIsIGNmZy5tYXhDb25jdXJyZW50TGltYm9SZXNvbHV0aW9ucywgc3RhcnRBc1ByaW1hcnkpO1xuICAgIH1cbiAgICBhc3luYyB0ZXJtaW5hdGUoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlU2h1dGRvd24odGhpcy5yZW1vdGVTdG9yZSk7XG4gICAgICAgIChfYSA9IHRoaXMuZGF0YXN0b3JlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudGVybWluYXRlKCk7XG4gICAgICAgIChfYiA9IHRoaXMuZXZlbnRNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudGVybWluYXRlKCk7XG4gICAgfVxufVxuT25saW5lQ29tcG9uZW50UHJvdmlkZXIucHJvdmlkZXIgPSB7XG4gICAgYnVpbGQ6ICgpID0+IG5ldyBPbmxpbmVDb21wb25lbnRQcm92aWRlcigpXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBIb3cgbWFueSBieXRlcyB0byByZWFkIGVhY2ggdGltZSB3aGVuIGBSZWFkYWJsZVN0cmVhbVJlYWRlci5yZWFkKClgIGlzXG4gKiBjYWxsZWQuIE9ubHkgYXBwbGljYWJsZSBmb3IgYnl0ZSBzdHJlYW1zIHRoYXQgd2UgY29udHJvbCAoZS5nLiB0aG9zZSBiYWNrZWRcbiAqIGJ5IGFuIFVJbnQ4QXJyYXkpLlxuICovXG5jb25zdCBERUZBVUxUX0JZVEVTX1BFUl9SRUFEID0gMTAyNDA7XG4vKipcbiAqIEJ1aWxkcyBhIGBCeXRlU3RyZWFtUmVhZGVyYCBmcm9tIGEgVUludDhBcnJheS5cbiAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgZGF0YSBzb3VyY2UgdG8gdXNlLlxuICogQHBhcmFtIGJ5dGVzUGVyUmVhZCAtIEhvdyBtYW55IGJ5dGVzIGVhY2ggYHJlYWQoKWAgZnJvbSB0aGUgcmV0dXJuZWQgcmVhZGVyXG4gKiAgICAgICAgd2lsbCByZWFkLlxuICovXG5mdW5jdGlvbiB0b0J5dGVTdHJlYW1SZWFkZXJIZWxwZXIoc291cmNlLCBieXRlc1BlclJlYWQgPSBERUZBVUxUX0JZVEVTX1BFUl9SRUFEKSB7XG4gICAgbGV0IHJlYWRGcm9tID0gMDtcbiAgICAvLyBUaGUgVHlwZVNjcmlwdCBkZWZpbml0aW9uIGZvciBSZWFkYWJsZVN0cmVhbVJlYWRlciBjaGFuZ2VkLiBXZSB1c2VcbiAgICAvLyBgYW55YCBoZXJlIHRvIGFsbG93IHRoaXMgY29kZSB0byBjb21waWxlIHdpdGggZGlmZmVyZW50IHZlcnNpb25zLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzQyOTcwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjb25zdCByZWFkZXIgPSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGFzeW5jIHJlYWQoKSB7XG4gICAgICAgICAgICBpZiAocmVhZEZyb20gPCBzb3VyY2UuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHNvdXJjZS5zbGljZShyZWFkRnJvbSwgcmVhZEZyb20gKyBieXRlc1BlclJlYWQpLFxuICAgICAgICAgICAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVhZEZyb20gKz0gYnl0ZXNQZXJSZWFkO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlIH07XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGNhbmNlbCgpIHsgfSxcbiAgICAgICAgcmVsZWFzZUxvY2soKSB7IH0sXG4gICAgICAgIGNsb3NlZDogUHJvbWlzZS5yZXNvbHZlKClcbiAgICB9O1xuICAgIHJldHVybiByZWFkZXI7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU5vbkVtcHR5QXJndW1lbnQoZnVuY3Rpb25OYW1lLCBhcmd1bWVudE5hbWUsIGFyZ3VtZW50KSB7XG4gICAgaWYgKCFhcmd1bWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgRnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9KCkgY2Fubm90IGJlIGNhbGxlZCB3aXRoIGFuIGVtcHR5ICR7YXJndW1lbnROYW1lfS5gKTtcbiAgICB9XG59XG4vKipcbiAqIFZhbGlkYXRlcyB0aGF0IHR3byBib29sZWFuIG9wdGlvbnMgYXJlIG5vdCBzZXQgYXQgdGhlIHNhbWUgdGltZS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUlzTm90VXNlZFRvZ2V0aGVyKG9wdGlvbk5hbWUxLCBhcmd1bWVudDEsIG9wdGlvbk5hbWUyLCBhcmd1bWVudDIpIHtcbiAgICBpZiAoYXJndW1lbnQxID09PSB0cnVlICYmIGFyZ3VtZW50MiA9PT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgJHtvcHRpb25OYW1lMX0gYW5kICR7b3B0aW9uTmFtZTJ9IGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyLmApO1xuICAgIH1cbn1cbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgYHBhdGhgIHJlZmVycyB0byBhIGRvY3VtZW50IChpbmRpY2F0ZWQgYnkgdGhlIGZhY3QgaXQgY29udGFpbnNcbiAqIGFuIGV2ZW4gbnVtYmVycyBvZiBzZWdtZW50cykuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRG9jdW1lbnRQYXRoKHBhdGgpIHtcbiAgICBpZiAoIURvY3VtZW50S2V5LmlzRG9jdW1lbnRLZXkocGF0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgZG9jdW1lbnQgcmVmZXJlbmNlLiBEb2N1bWVudCByZWZlcmVuY2VzIG11c3QgaGF2ZSBhbiBldmVuIG51bWJlciBvZiBzZWdtZW50cywgYnV0ICR7cGF0aH0gaGFzICR7cGF0aC5sZW5ndGh9LmApO1xuICAgIH1cbn1cbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgYHBhdGhgIHJlZmVycyB0byBhIGNvbGxlY3Rpb24gKGluZGljYXRlZCBieSB0aGUgZmFjdCBpdFxuICogY29udGFpbnMgYW4gb2RkIG51bWJlcnMgb2Ygc2VnbWVudHMpLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbGxlY3Rpb25QYXRoKHBhdGgpIHtcbiAgICBpZiAoRG9jdW1lbnRLZXkuaXNEb2N1bWVudEtleShwYXRoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBjb2xsZWN0aW9uIHJlZmVyZW5jZS4gQ29sbGVjdGlvbiByZWZlcmVuY2VzIG11c3QgaGF2ZSBhbiBvZGQgbnVtYmVyIG9mIHNlZ21lbnRzLCBidXQgJHtwYXRofSBoYXMgJHtwYXRoLmxlbmd0aH0uYCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgaXQncyBhIG5vbi1udWxsIG9iamVjdCB3aXRob3V0IGEgY3VzdG9tIHByb3RvdHlwZVxuICogKGkuZS4gZXhjbHVkZXMgQXJyYXksIERhdGUsIGV0Yy4pLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KGlucHV0KSB7XG4gICAgcmV0dXJuICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmXG4gICAgICAgIGlucHV0ICE9PSBudWxsICYmXG4gICAgICAgIChPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5wdXQpID09PSBPYmplY3QucHJvdG90eXBlIHx8XG4gICAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5wdXQpID09PSBudWxsKSk7XG59XG4vKiogUmV0dXJucyBhIHN0cmluZyBkZXNjcmliaW5nIHRoZSB0eXBlIC8gdmFsdWUgb2YgdGhlIHByb3ZpZGVkIGlucHV0LiAqL1xuZnVuY3Rpb24gdmFsdWVEZXNjcmlwdGlvbihpbnB1dCkge1xuICAgIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID4gMjApIHtcbiAgICAgICAgICAgIGlucHV0ID0gYCR7aW5wdXQuc3Vic3RyaW5nKDAsIDIwKX0uLi5gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGlucHV0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuICcnICsgaW5wdXQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiAnYW4gYXJyYXknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY3VzdG9tT2JqZWN0TmFtZSA9IHRyeUdldEN1c3RvbU9iamVjdFR5cGUoaW5wdXQpO1xuICAgICAgICAgICAgaWYgKGN1c3RvbU9iamVjdE5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYGEgY3VzdG9tICR7Y3VzdG9tT2JqZWN0TmFtZX0gb2JqZWN0YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAnYW4gb2JqZWN0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuICdhIGZ1bmN0aW9uJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWlsKCk7XG4gICAgfVxufVxuLyoqIHRyeSB0byBnZXQgdGhlIGNvbnN0cnVjdG9yIG5hbWUgZm9yIGFuIG9iamVjdC4gKi9cbmZ1bmN0aW9uIHRyeUdldEN1c3RvbU9iamVjdFR5cGUoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBDYXN0cyBgb2JqYCB0byBgVGAsIG9wdGlvbmFsbHkgdW53cmFwcGluZyBDb21wYXQgdHlwZXMgdG8gZXhwb3NlIHRoZVxuICogdW5kZXJseWluZyBpbnN0YW5jZS4gVGhyb3dzIGlmICBgb2JqYCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgYFRgLlxuICpcbiAqIFRoaXMgY2FzdCBpcyB1c2VkIGluIHRoZSBMaXRlIGFuZCBGdWxsIFNESyB0byB2ZXJpZnkgaW5zdGFuY2UgdHlwZXMgZm9yXG4gKiBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBwdWJsaWMgQVBJLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGNhc3Qob2JqLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdHJ1Y3Rvcikge1xuICAgIGlmICgnX2RlbGVnYXRlJyBpbiBvYmopIHtcbiAgICAgICAgLy8gVW53cmFwIENvbXBhdCB0eXBlc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBvYmogPSBvYmouX2RlbGVnYXRlO1xuICAgIH1cbiAgICBpZiAoIShvYmogaW5zdGFuY2VvZiBjb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yLm5hbWUgPT09IG9iai5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnVHlwZSBkb2VzIG5vdCBtYXRjaCB0aGUgZXhwZWN0ZWQgaW5zdGFuY2UuIERpZCB5b3UgcGFzcyBhICcgK1xuICAgICAgICAgICAgICAgIGByZWZlcmVuY2UgZnJvbSBhIGRpZmZlcmVudCBGaXJlc3RvcmUgU0RLP2ApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB2YWx1ZURlc2NyaXB0aW9uKG9iaik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgRXhwZWN0ZWQgdHlwZSAnJHtjb25zdHJ1Y3Rvci5uYW1lfScsIGJ1dCBpdCB3YXM6ICR7ZGVzY3JpcHRpb259YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUG9zaXRpdmVOdW1iZXIoZnVuY3Rpb25OYW1lLCBuKSB7XG4gICAgaWYgKG4gPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgRnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9KCkgcmVxdWlyZXMgYSBwb3NpdGl2ZSBudW1iZXIsIGJ1dCBpdCB3YXM6ICR7bn0uYCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBPbiBOb2RlLCBvbmx5IHN1cHBvcnRlZCBkYXRhIHNvdXJjZSBpcyBhIGBVaW50OEFycmF5YCBmb3Igbm93LlxuICovXG5mdW5jdGlvbiB0b0J5dGVTdHJlYW1SZWFkZXIoc291cmNlLCBieXRlc1BlclJlYWQpIHtcbiAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgTm9kZVBsYXRmb3JtLnRvQnl0ZVN0cmVhbVJlYWRlciBleHBlY3RzIHNvdXJjZSB0byBiZSBVaW50OEFycmF5LCBnb3QgJHt2YWx1ZURlc2NyaXB0aW9uKHNvdXJjZSl9YCk7XG4gICAgfVxuICAgIHJldHVybiB0b0J5dGVTdHJlYW1SZWFkZXJIZWxwZXIoc291cmNlLCBieXRlc1BlclJlYWQpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLypcbiAqIEEgd3JhcHBlciBpbXBsZW1lbnRhdGlvbiBvZiBPYnNlcnZlcjxUPiB0aGF0IHdpbGwgZGlzcGF0Y2ggZXZlbnRzXG4gKiBhc3luY2hyb25vdXNseS4gVG8gYWxsb3cgaW1tZWRpYXRlIHNpbGVuY2luZywgYSBtdXRlIGNhbGwgaXMgYWRkZWQgd2hpY2hcbiAqIGNhdXNlcyBldmVudHMgc2NoZWR1bGVkIHRvIG5vIGxvbmdlciBiZSByYWlzZWQuXG4gKi9cbmNsYXNzIEFzeW5jT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gc2V0IHRvIHRydWUsIHdpbGwgbm90IHJhaXNlIGZ1dHVyZSBldmVudHMuIE5lY2Vzc2FyeSB0byBkZWFsIHdpdGhcbiAgICAgICAgICogYXN5bmMgZGV0YWNobWVudCBvZiBsaXN0ZW5lci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubXV0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgbmV4dCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5tdXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVFdmVudCh0aGlzLm9ic2VydmVyLm5leHQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlcnJvcihlcnJvcikge1xuICAgICAgICBpZiAodGhpcy5tdXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyLmVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlRXZlbnQodGhpcy5vYnNlcnZlci5lcnJvciwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nRXJyb3IoJ1VuY2F1Z2h0IEVycm9yIGluIHNuYXBzaG90IGxpc3RlbmVyOicsIGVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG11dGUoKSB7XG4gICAgICAgIHRoaXMubXV0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBzY2hlZHVsZUV2ZW50KGV2ZW50SGFuZGxlciwgZXZlbnQpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubXV0ZWQpIHtcbiAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEEgY29tcGxldGUgZWxlbWVudCBpbiB0aGUgYnVuZGxlIHN0cmVhbSwgdG9nZXRoZXIgd2l0aCB0aGUgYnl0ZSBsZW5ndGggaXRcbiAqIG9jY3VwaWVzIGluIHRoZSBzdHJlYW0uXG4gKi9cbmNsYXNzIFNpemVkQnVuZGxlRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IocGF5bG9hZCwgXG4gICAgLy8gSG93IG1hbnkgYnl0ZXMgdGhpcyBlbGVtZW50IHRha2VzIHRvIHN0b3JlIGluIHRoZSBidW5kbGUuXG4gICAgYnl0ZUxlbmd0aCkge1xuICAgICAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgICB0aGlzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoO1xuICAgIH1cbiAgICBpc0J1bmRsZU1ldGFkYXRhKCkge1xuICAgICAgICByZXR1cm4gJ21ldGFkYXRhJyBpbiB0aGlzLnBheWxvYWQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIGJ1bmRsZS5cbiAqXG4gKiBUYWtlcyBhIGJ1bmRsZSBzdHJlYW0gb3IgYnVmZmVyLCBhbmQgcHJlc2VudHMgYWJzdHJhY3Rpb25zIHRvIHJlYWQgYnVuZGxlZFxuICogZWxlbWVudHMgb3V0IG9mIHRoZSB1bmRlcmx5aW5nIGNvbnRlbnQuXG4gKi9cbmNsYXNzIEJ1bmRsZVJlYWRlckltcGwge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBUaGUgcmVhZGVyIHRvIHJlYWQgZnJvbSB1bmRlcmx5aW5nIGJpbmFyeSBidW5kbGUgZGF0YSBzb3VyY2UuICovXG4gICAgcmVhZGVyLCBzZXJpYWxpemVyKSB7XG4gICAgICAgIHRoaXMucmVhZGVyID0gcmVhZGVyO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xuICAgICAgICAvKiogQ2FjaGVkIGJ1bmRsZSBtZXRhZGF0YS4gKi9cbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgYnVmZmVyIHRvIGhvbGQgYnVuZGxlIGNvbnRlbnQsIGFjY3VtdWxhdGluZyBpbmNvbXBsZXRlIGVsZW1lbnRcbiAgICAgICAgICogY29udGVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgdGhpcy50ZXh0RGVjb2RlciA9IG5ld1RleHREZWNvZGVyKCk7XG4gICAgICAgIC8vIFJlYWQgdGhlIG1ldGFkYXRhICh3aGljaCBpcyB0aGUgZmlyc3QgZWxlbWVudCkuXG4gICAgICAgIHRoaXMubmV4dEVsZW1lbnRJbXBsKCkudGhlbihlbGVtZW50ID0+IHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuaXNCdW5kbGVNZXRhZGF0YSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5yZXNvbHZlKGVsZW1lbnQucGF5bG9hZC5tZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnJlamVjdChuZXcgRXJyb3IoYFRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBidW5kbGUgaXMgbm90IGEgbWV0YWRhdGEsIGl0IGlzXG4gICAgICAgICAgICAgJHtKU09OLnN0cmluZ2lmeShlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnQucGF5bG9hZCl9YCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBlcnJvciA9PiB0aGlzLm1ldGFkYXRhLnJlamVjdChlcnJvcikpO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZGVyLmNhbmNlbCgpO1xuICAgIH1cbiAgICBhc3luYyBnZXRNZXRhZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0YWRhdGEucHJvbWlzZTtcbiAgICB9XG4gICAgYXN5bmMgbmV4dEVsZW1lbnQoKSB7XG4gICAgICAgIC8vIE1ha2VzIHN1cmUgbWV0YWRhdGEgaXMgcmVhZCBiZWZvcmUgcHJvY2VlZGluZy5cbiAgICAgICAgYXdhaXQgdGhpcy5nZXRNZXRhZGF0YSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0RWxlbWVudEltcGwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgZnJvbSB0aGUgaGVhZCBvZiBpbnRlcm5hbCBidWZmZXIsIGFuZCBwdWxsaW5nIG1vcmUgZGF0YSBmcm9tXG4gICAgICogdW5kZXJseWluZyBzdHJlYW0gaWYgYSBjb21wbGV0ZSBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZCwgdW50aWwgYW5cbiAgICAgKiBlbGVtZW50KGluY2x1ZGluZyB0aGUgcHJlZml4ZWQgbGVuZ3RoIGFuZCB0aGUgSlNPTiBzdHJpbmcpIGlzIGZvdW5kLlxuICAgICAqXG4gICAgICogT25jZSBhIGNvbXBsZXRlIGVsZW1lbnQgaXMgcmVhZCwgaXQgaXMgZHJvcHBlZCBmcm9tIGludGVybmFsIGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIFJldHVybnMgZWl0aGVyIHRoZSBidW5kbGVkIGVsZW1lbnQsIG9yIG51bGwgaWYgd2UgaGF2ZSByZWFjaGVkIHRoZSBlbmQgb2ZcbiAgICAgKiB0aGUgc3RyZWFtLlxuICAgICAqL1xuICAgIGFzeW5jIG5leHRFbGVtZW50SW1wbCgpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoQnVmZmVyID0gYXdhaXQgdGhpcy5yZWFkTGVuZ3RoKCk7XG4gICAgICAgIGlmIChsZW5ndGhCdWZmZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aFN0cmluZyA9IHRoaXMudGV4dERlY29kZXIuZGVjb2RlKGxlbmd0aEJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IE51bWJlcihsZW5ndGhTdHJpbmcpO1xuICAgICAgICBpZiAoaXNOYU4obGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZUVycm9yKGBsZW5ndGggc3RyaW5nICgke2xlbmd0aFN0cmluZ30pIGlzIG5vdCB2YWxpZCBudW1iZXJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBqc29uU3RyaW5nID0gYXdhaXQgdGhpcy5yZWFkSnNvblN0cmluZyhsZW5ndGgpO1xuICAgICAgICByZXR1cm4gbmV3IFNpemVkQnVuZGxlRWxlbWVudChKU09OLnBhcnNlKGpzb25TdHJpbmcpLCBsZW5ndGhCdWZmZXIubGVuZ3RoICsgbGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqIEZpcnN0IGluZGV4IG9mICd7JyBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlci4gKi9cbiAgICBpbmRleE9mT3BlbkJyYWNrZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5maW5kSW5kZXgodiA9PiB2ID09PSAneycuY2hhckNvZGVBdCgwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgaW50ZXJuYWwgYnVmZmVyLCB1bnRpbCB0aGUgZmlyc3QgJ3snLCBhbmRcbiAgICAgKiByZXR1cm4gdGhlIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBJZiByZWFjaGVkIGVuZCBvZiB0aGUgc3RyZWFtLCByZXR1cm5zIGEgbnVsbC5cbiAgICAgKi9cbiAgICBhc3luYyByZWFkTGVuZ3RoKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5pbmRleE9mT3BlbkJyYWNrZXQoKSA8IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGRvbmUgPSBhd2FpdCB0aGlzLnB1bGxNb3JlRGF0YVRvQnVmZmVyKCk7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEJyb2tlIG91dCBvZiB0aGUgbG9vcCBiZWNhdXNlIHVuZGVybHlpbmcgc3RyZWFtIGlzIGNsb3NlZCwgYW5kIHRoZXJlXG4gICAgICAgIC8vIGhhcHBlbnMgdG8gYmUgbm8gbW9yZSBkYXRhIHRvIHByb2Nlc3MuXG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5pbmRleE9mT3BlbkJyYWNrZXQoKTtcbiAgICAgICAgLy8gQnJva2Ugb3V0IG9mIHRoZSBsb29wIGJlY2F1c2UgdW5kZXJseWluZyBzdHJlYW0gaXMgY2xvc2VkLCBidXQgc3RpbGxcbiAgICAgICAgLy8gY2Fubm90IGZpbmQgYW4gb3BlbiBicmFja2V0LlxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlRXJyb3IoJ1JlYWNoZWQgdGhlIGVuZCBvZiBidW5kbGUgd2hlbiBhIGxlbmd0aCBzdHJpbmcgaXMgZXhwZWN0ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5idWZmZXIuc2xpY2UoMCwgcG9zaXRpb24pO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGludGVybmFsIGJ1ZmZlciB0byBkcm9wIHRoZSByZWFkIGxlbmd0aC5cbiAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5zbGljZShwb3NpdGlvbik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGZyb20gYSBzcGVjaWZpZWQgcG9zaXRpb24gZnJvbSB0aGUgaW50ZXJuYWwgYnVmZmVyLCBmb3IgYSBzcGVjaWZpZWRcbiAgICAgKiBudW1iZXIgb2YgYnl0ZXMsIHB1bGxpbmcgbW9yZSBkYXRhIGZyb20gdGhlIHVuZGVybHlpbmcgc3RyZWFtIGlmIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgZGVjb2RlZCBmcm9tIHRoZSByZWFkIGJ5dGVzLlxuICAgICAqL1xuICAgIGFzeW5jIHJlYWRKc29uU3RyaW5nKGxlbmd0aCkge1xuICAgICAgICB3aGlsZSAodGhpcy5idWZmZXIubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBkb25lID0gYXdhaXQgdGhpcy5wdWxsTW9yZURhdGFUb0J1ZmZlcigpO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhaXNlRXJyb3IoJ1JlYWNoZWQgdGhlIGVuZCBvZiBidW5kbGUgd2hlbiBtb3JlIGlzIGV4cGVjdGVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudGV4dERlY29kZXIuZGVjb2RlKHRoaXMuYnVmZmVyLnNsaWNlKDAsIGxlbmd0aCkpO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGludGVybmFsIGJ1ZmZlciB0byBkcm9wIHRoZSByZWFkIGpzb24gc3RyaW5nLlxuICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyLnNsaWNlKGxlbmd0aCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJhaXNlRXJyb3IobWVzc2FnZSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICAgIHRoaXMucmVhZGVyLmNhbmNlbCgpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYnVuZGxlIGZvcm1hdDogJHttZXNzYWdlfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWxscyBtb3JlIGRhdGEgZnJvbSB1bmRlcmx5aW5nIHN0cmVhbSB0byBpbnRlcm5hbCBidWZmZXIuXG4gICAgICogUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBzdHJlYW0gaXMgZmluaXNoZWQuXG4gICAgICovXG4gICAgYXN5bmMgcHVsbE1vcmVEYXRhVG9CdWZmZXIoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKCFyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgY29uc3QgbmV3QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIubGVuZ3RoICsgcmVzdWx0LnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICBuZXdCdWZmZXIuc2V0KHRoaXMuYnVmZmVyKTtcbiAgICAgICAgICAgIG5ld0J1ZmZlci5zZXQocmVzdWx0LnZhbHVlLCB0aGlzLmJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXdCdWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5ld0J1bmRsZVJlYWRlcihyZWFkZXIsIHNlcmlhbGl6ZXIpIHtcbiAgICByZXR1cm4gbmV3IEJ1bmRsZVJlYWRlckltcGwocmVhZGVyLCBzZXJpYWxpemVyKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogSW50ZXJuYWwgdHJhbnNhY3Rpb24gb2JqZWN0IHJlc3BvbnNpYmxlIGZvciBhY2N1bXVsYXRpbmcgdGhlIG11dGF0aW9ucyB0b1xuICogcGVyZm9ybSBhbmQgdGhlIGJhc2UgdmVyc2lvbnMgZm9yIGFueSBkb2N1bWVudHMgcmVhZC5cbiAqL1xuY2xhc3MgVHJhbnNhY3Rpb24kMiB7XG4gICAgY29uc3RydWN0b3IoZGF0YXN0b3JlKSB7XG4gICAgICAgIHRoaXMuZGF0YXN0b3JlID0gZGF0YXN0b3JlO1xuICAgICAgICAvLyBUaGUgdmVyc2lvbiBvZiBlYWNoIGRvY3VtZW50IHRoYXQgd2FzIHJlYWQgZHVyaW5nIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICAgIHRoaXMucmVhZFZlcnNpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm11dGF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLmNvbW1pdHRlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBkZWZlcnJlZCB1c2FnZSBlcnJvciB0aGF0IG9jY3VycmVkIHByZXZpb3VzbHkgaW4gdGhpcyB0cmFuc2FjdGlvbiB0aGF0XG4gICAgICAgICAqIHdpbGwgY2F1c2UgdGhlIHRyYW5zYWN0aW9uIHRvIGZhaWwgb25jZSBpdCBhY3R1YWxseSBjb21taXRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXN0VHJhbnNhY3Rpb25FcnJvciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgb2YgZG9jdW1lbnRzIHRoYXQgaGF2ZSBiZWVuIHdyaXR0ZW4gaW4gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHRoZXJlJ3MgbW9yZSB0aGFuIG9uZSB3cml0ZSB0byB0aGUgc2FtZSBrZXkgaW4gYSB0cmFuc2FjdGlvbiwgYW55XG4gICAgICAgICAqIHdyaXRlcyBhZnRlciB0aGUgZmlyc3QgYXJlIGhhbmRsZWQgZGlmZmVyZW50bHkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndyaXR0ZW5Eb2NzID0gbmV3IFNldCgpO1xuICAgIH1cbiAgICBhc3luYyBsb29rdXAoa2V5cykge1xuICAgICAgICB0aGlzLmVuc3VyZUNvbW1pdE5vdENhbGxlZCgpO1xuICAgICAgICBpZiAodGhpcy5tdXRhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0VHJhbnNhY3Rpb25FcnJvciA9IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdGaXJlc3RvcmUgdHJhbnNhY3Rpb25zIHJlcXVpcmUgYWxsIHJlYWRzIHRvIGJlIGV4ZWN1dGVkIGJlZm9yZSBhbGwgd3JpdGVzLicpO1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5sYXN0VHJhbnNhY3Rpb25FcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb2NzID0gYXdhaXQgaW52b2tlQmF0Y2hHZXREb2N1bWVudHNScGModGhpcy5kYXRhc3RvcmUsIGtleXMpO1xuICAgICAgICBkb2NzLmZvckVhY2goZG9jID0+IHRoaXMucmVjb3JkVmVyc2lvbihkb2MpKTtcbiAgICAgICAgcmV0dXJuIGRvY3M7XG4gICAgfVxuICAgIHNldChrZXksIGRhdGEpIHtcbiAgICAgICAgdGhpcy53cml0ZShkYXRhLnRvTXV0YXRpb24oa2V5LCB0aGlzLnByZWNvbmRpdGlvbihrZXkpKSk7XG4gICAgICAgIHRoaXMud3JpdHRlbkRvY3MuYWRkKGtleS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgdXBkYXRlKGtleSwgZGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy53cml0ZShkYXRhLnRvTXV0YXRpb24oa2V5LCB0aGlzLnByZWNvbmRpdGlvbkZvclVwZGF0ZShrZXkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdFRyYW5zYWN0aW9uRXJyb3IgPSBlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdHRlbkRvY3MuYWRkKGtleS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICB0aGlzLndyaXRlKG5ldyBEZWxldGVNdXRhdGlvbihrZXksIHRoaXMucHJlY29uZGl0aW9uKGtleSkpKTtcbiAgICAgICAgdGhpcy53cml0dGVuRG9jcy5hZGQoa2V5LnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBhc3luYyBjb21taXQoKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlQ29tbWl0Tm90Q2FsbGVkKCk7XG4gICAgICAgIGlmICh0aGlzLmxhc3RUcmFuc2FjdGlvbkVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmxhc3RUcmFuc2FjdGlvbkVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVud3JpdHRlbiA9IHRoaXMucmVhZFZlcnNpb25zO1xuICAgICAgICAvLyBGb3IgZWFjaCBtdXRhdGlvbiwgbm90ZSB0aGF0IHRoZSBkb2Mgd2FzIHdyaXR0ZW4uXG4gICAgICAgIHRoaXMubXV0YXRpb25zLmZvckVhY2gobXV0YXRpb24gPT4ge1xuICAgICAgICAgICAgdW53cml0dGVuLmRlbGV0ZShtdXRhdGlvbi5rZXkudG9TdHJpbmcoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBGb3IgZWFjaCBkb2N1bWVudCB0aGF0IHdhcyByZWFkIGJ1dCBub3Qgd3JpdHRlbiB0bywgd2Ugd2FudCB0byBwZXJmb3JtXG4gICAgICAgIC8vIGEgYHZlcmlmeWAgb3BlcmF0aW9uLlxuICAgICAgICB1bndyaXR0ZW4uZm9yRWFjaCgoXywgcGF0aCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gRG9jdW1lbnRLZXkuZnJvbVBhdGgocGF0aCk7XG4gICAgICAgICAgICB0aGlzLm11dGF0aW9ucy5wdXNoKG5ldyBWZXJpZnlNdXRhdGlvbihrZXksIHRoaXMucHJlY29uZGl0aW9uKGtleSkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IGludm9rZUNvbW1pdFJwYyh0aGlzLmRhdGFzdG9yZSwgdGhpcy5tdXRhdGlvbnMpO1xuICAgICAgICB0aGlzLmNvbW1pdHRlZCA9IHRydWU7XG4gICAgfVxuICAgIHJlY29yZFZlcnNpb24oZG9jKSB7XG4gICAgICAgIGxldCBkb2NWZXJzaW9uO1xuICAgICAgICBpZiAoZG9jLmlzRm91bmREb2N1bWVudCgpKSB7XG4gICAgICAgICAgICBkb2NWZXJzaW9uID0gZG9jLnZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9jLmlzTm9Eb2N1bWVudCgpKSB7XG4gICAgICAgICAgICAvLyBSZXByZXNlbnQgYSBkZWxldGVkIGRvYyB1c2luZyBTbmFwc2hvdFZlcnNpb24ubWluKCkuXG4gICAgICAgICAgICBkb2NWZXJzaW9uID0gU25hcHNob3RWZXJzaW9uLm1pbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZmFpbCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVmVyc2lvbiA9IHRoaXMucmVhZFZlcnNpb25zLmdldChkb2Mua2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAoZXhpc3RpbmdWZXJzaW9uKSB7XG4gICAgICAgICAgICBpZiAoIWRvY1ZlcnNpb24uaXNFcXVhbChleGlzdGluZ1ZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyB0cmFuc2FjdGlvbiB3aWxsIGZhaWwgbm8gbWF0dGVyIHdoYXQuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuQUJPUlRFRCwgJ0RvY3VtZW50IHZlcnNpb24gY2hhbmdlZCBiZXR3ZWVuIHR3byByZWFkcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVhZFZlcnNpb25zLnNldChkb2Mua2V5LnRvU3RyaW5nKCksIGRvY1ZlcnNpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZlcnNpb24gb2YgdGhpcyBkb2N1bWVudCB3aGVuIGl0IHdhcyByZWFkIGluIHRoaXMgdHJhbnNhY3Rpb24sXG4gICAgICogYXMgYSBwcmVjb25kaXRpb24sIG9yIG5vIHByZWNvbmRpdGlvbiBpZiBpdCB3YXMgbm90IHJlYWQuXG4gICAgICovXG4gICAgcHJlY29uZGl0aW9uKGtleSkge1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gdGhpcy5yZWFkVmVyc2lvbnMuZ2V0KGtleS50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKCF0aGlzLndyaXR0ZW5Eb2NzLmhhcyhrZXkudG9TdHJpbmcoKSkgJiYgdmVyc2lvbikge1xuICAgICAgICAgICAgaWYgKHZlcnNpb24uaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByZWNvbmRpdGlvbi5leGlzdHMoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByZWNvbmRpdGlvbi51cGRhdGVUaW1lKHZlcnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFByZWNvbmRpdGlvbi5ub25lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHJlY29uZGl0aW9uIGZvciBhIGRvY3VtZW50IGlmIHRoZSBvcGVyYXRpb24gaXMgYW4gdXBkYXRlLlxuICAgICAqL1xuICAgIHByZWNvbmRpdGlvbkZvclVwZGF0ZShrZXkpIHtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IHRoaXMucmVhZFZlcnNpb25zLmdldChrZXkudG9TdHJpbmcoKSk7XG4gICAgICAgIC8vIFRoZSBmaXJzdCB0aW1lIGEgZG9jdW1lbnQgaXMgd3JpdHRlbiwgd2Ugd2FudCB0byB0YWtlIGludG8gYWNjb3VudCB0aGVcbiAgICAgICAgLy8gcmVhZCB0aW1lIGFuZCBleGlzdGVuY2VcbiAgICAgICAgaWYgKCF0aGlzLndyaXR0ZW5Eb2NzLmhhcyhrZXkudG9TdHJpbmcoKSkgJiYgdmVyc2lvbikge1xuICAgICAgICAgICAgaWYgKHZlcnNpb24uaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3QsIHNvIGZhaWwgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaGFzIHRvIGJlIHZhbGlkYXRlZCBsb2NhbGx5IGJlY2F1c2UgeW91IGNhbid0IHNlbmQgYVxuICAgICAgICAgICAgICAgIC8vIHByZWNvbmRpdGlvbiB0aGF0IGEgZG9jdW1lbnQgZG9lcyBub3QgZXhpc3Qgd2l0aG91dCBjaGFuZ2luZyB0aGVcbiAgICAgICAgICAgICAgICAvLyBzZW1hbnRpY3Mgb2YgdGhlIGJhY2tlbmQgd3JpdGUgdG8gYmUgYW4gaW5zZXJ0LiBUaGlzIGlzIHRoZSByZXZlcnNlXG4gICAgICAgICAgICAgICAgLy8gb2Ygd2hhdCB3ZSB3YW50LCBzaW5jZSB3ZSB3YW50IHRvIGFzc2VydCB0aGF0IHRoZSBkb2N1bWVudCBkb2Vzbid0XG4gICAgICAgICAgICAgICAgLy8gZXhpc3QgYnV0IHRoZW4gc2VuZCB0aGUgdXBkYXRlIGFuZCBoYXZlIGl0IGZhaWwuIFNpbmNlIHdlIGNhbid0XG4gICAgICAgICAgICAgICAgLy8gZXhwcmVzcyB0aGF0IHRvIHRoZSBiYWNrZW5kLCB3ZSBoYXZlIHRvIHZhbGlkYXRlIGxvY2FsbHkuXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogdGhpcyBjYW4gY2hhbmdlIG9uY2Ugd2UgY2FuIHNlbmQgc2VwYXJhdGUgdmVyaWZ5IHdyaXRlcyBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2FjdGlvbi5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBcIkNhbid0IHVwZGF0ZSBhIGRvY3VtZW50IHRoYXQgZG9lc24ndCBleGlzdC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEb2N1bWVudCBleGlzdHMsIGJhc2UgcHJlY29uZGl0aW9uIG9uIGRvY3VtZW50IHVwZGF0ZSB0aW1lLlxuICAgICAgICAgICAgcmV0dXJuIFByZWNvbmRpdGlvbi51cGRhdGVUaW1lKHZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRG9jdW1lbnQgd2FzIG5vdCByZWFkLCBzbyB3ZSBqdXN0IHVzZSB0aGUgcHJlY29uZGl0aW9ucyBmb3IgYSBibGluZFxuICAgICAgICAgICAgLy8gdXBkYXRlLlxuICAgICAgICAgICAgcmV0dXJuIFByZWNvbmRpdGlvbi5leGlzdHModHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd3JpdGUobXV0YXRpb24pIHtcbiAgICAgICAgdGhpcy5lbnN1cmVDb21taXROb3RDYWxsZWQoKTtcbiAgICAgICAgdGhpcy5tdXRhdGlvbnMucHVzaChtdXRhdGlvbik7XG4gICAgfVxuICAgIGVuc3VyZUNvbW1pdE5vdENhbGxlZCgpIHtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFRyYW5zYWN0aW9uUnVubmVyIGVuY2Fwc3VsYXRlcyB0aGUgbG9naWMgbmVlZGVkIHRvIHJ1biBhbmQgcmV0cnkgdHJhbnNhY3Rpb25zXG4gKiB3aXRoIGJhY2tvZmYuXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uUnVubmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihhc3luY1F1ZXVlLCBkYXRhc3RvcmUsIG9wdGlvbnMsIHVwZGF0ZUZ1bmN0aW9uLCBkZWZlcnJlZCkge1xuICAgICAgICB0aGlzLmFzeW5jUXVldWUgPSBhc3luY1F1ZXVlO1xuICAgICAgICB0aGlzLmRhdGFzdG9yZSA9IGRhdGFzdG9yZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy51cGRhdGVGdW5jdGlvbiA9IHVwZGF0ZUZ1bmN0aW9uO1xuICAgICAgICB0aGlzLmRlZmVycmVkID0gZGVmZXJyZWQ7XG4gICAgICAgIHRoaXMuYXR0ZW1wdHNSZW1haW5pbmcgPSBvcHRpb25zLm1heEF0dGVtcHRzO1xuICAgICAgICB0aGlzLmJhY2tvZmYgPSBuZXcgRXhwb25lbnRpYWxCYWNrb2ZmKHRoaXMuYXN5bmNRdWV1ZSwgXCJ0cmFuc2FjdGlvbl9yZXRyeVwiIC8qIFRpbWVySWQuVHJhbnNhY3Rpb25SZXRyeSAqLyk7XG4gICAgfVxuICAgIC8qKiBSdW5zIHRoZSB0cmFuc2FjdGlvbiBhbmQgc2V0cyB0aGUgcmVzdWx0IG9uIGRlZmVycmVkLiAqL1xuICAgIHJ1bigpIHtcbiAgICAgICAgdGhpcy5hdHRlbXB0c1JlbWFpbmluZyAtPSAxO1xuICAgICAgICB0aGlzLnJ1bldpdGhCYWNrT2ZmKCk7XG4gICAgfVxuICAgIHJ1bldpdGhCYWNrT2ZmKCkge1xuICAgICAgICB0aGlzLmJhY2tvZmYuYmFja29mZkFuZFJ1bihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbiQyKHRoaXMuZGF0YXN0b3JlKTtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJQcm9taXNlID0gdGhpcy50cnlSdW5VcGRhdGVGdW5jdGlvbih0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICBpZiAodXNlclByb21pc2UpIHtcbiAgICAgICAgICAgICAgICB1c2VyUHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29tbWl0KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChjb21taXRFcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVUcmFuc2FjdGlvbkVycm9yKGNvbW1pdEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2godXNlclByb21pc2VFcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVHJhbnNhY3Rpb25FcnJvcih1c2VyUHJvbWlzZUVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRyeVJ1blVwZGF0ZUZ1bmN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1c2VyUHJvbWlzZSA9IHRoaXMudXBkYXRlRnVuY3Rpb24odHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHVzZXJQcm9taXNlKSB8fFxuICAgICAgICAgICAgICAgICF1c2VyUHJvbWlzZS5jYXRjaCB8fFxuICAgICAgICAgICAgICAgICF1c2VyUHJvbWlzZS50aGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5yZWplY3QoRXJyb3IoJ1RyYW5zYWN0aW9uIGNhbGxiYWNrIG11c3QgcmV0dXJuIGEgUHJvbWlzZScpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1c2VyUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCByZXRyeSBlcnJvcnMgdGhyb3duIGJ5IHVzZXIgcHJvdmlkZWQgdXBkYXRlRnVuY3Rpb24uXG4gICAgICAgICAgICB0aGlzLmRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVUcmFuc2FjdGlvbkVycm9yKGVycm9yKSB7XG4gICAgICAgIGlmICh0aGlzLmF0dGVtcHRzUmVtYWluaW5nID4gMCAmJiB0aGlzLmlzUmV0cnlhYmxlVHJhbnNhY3Rpb25FcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0ZW1wdHNSZW1haW5pbmcgLT0gMTtcbiAgICAgICAgICAgIHRoaXMuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bldpdGhCYWNrT2ZmKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNSZXRyeWFibGVUcmFuc2FjdGlvbkVycm9yKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnRmlyZWJhc2VFcnJvcicpIHtcbiAgICAgICAgICAgIC8vIEluIHRyYW5zYWN0aW9ucywgdGhlIGJhY2tlbmQgd2lsbCBmYWlsIG91dGRhdGVkIHJlYWRzIHdpdGggRkFJTEVEX1BSRUNPTkRJVElPTiBhbmRcbiAgICAgICAgICAgIC8vIG5vbi1tYXRjaGluZyBkb2N1bWVudCB2ZXJzaW9ucyB3aXRoIEFCT1JURUQuIFRoZXNlIGVycm9ycyBzaG91bGQgYmUgcmV0cmllZC5cbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBlcnJvci5jb2RlO1xuICAgICAgICAgICAgcmV0dXJuIChjb2RlID09PSAnYWJvcnRlZCcgfHxcbiAgICAgICAgICAgICAgICBjb2RlID09PSAnZmFpbGVkLXByZWNvbmRpdGlvbicgfHxcbiAgICAgICAgICAgICAgICBjb2RlID09PSAnYWxyZWFkeS1leGlzdHMnIHx8XG4gICAgICAgICAgICAgICAgIWlzUGVybWFuZW50RXJyb3IoY29kZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBMT0dfVEFHJDIgPSAnRmlyZXN0b3JlQ2xpZW50JztcbmNvbnN0IE1BWF9DT05DVVJSRU5UX0xJTUJPX1JFU09MVVRJT05TID0gMTAwO1xuLyoqIERPTUV4Y2VwdGlvbiBlcnJvciBjb2RlIGNvbnN0YW50cy4gKi9cbmNvbnN0IERPTV9FWENFUFRJT05fSU5WQUxJRF9TVEFURSA9IDExO1xuY29uc3QgRE9NX0VYQ0VQVElPTl9BQk9SVEVEID0gMjA7XG5jb25zdCBET01fRVhDRVBUSU9OX1FVT1RBX0VYQ0VFREVEID0gMjI7XG4vKipcbiAqIEZpcmVzdG9yZUNsaWVudCBpcyBhIHRvcC1sZXZlbCBjbGFzcyB0aGF0IGNvbnN0cnVjdHMgYW5kIG93bnMgYWxsIG9mIHRoZSAvL1xuICogcGllY2VzIG9mIHRoZSBjbGllbnQgU0RLIGFyY2hpdGVjdHVyZS4gSXQgaXMgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoZSAvL1xuICogYXN5bmMgcXVldWUgdGhhdCBpcyBzaGFyZWQgYnkgYWxsIG9mIHRoZSBvdGhlciBjb21wb25lbnRzIGluIHRoZSBzeXN0ZW0uIC8vXG4gKi9cbmNsYXNzIEZpcmVzdG9yZUNsaWVudCB7XG4gICAgY29uc3RydWN0b3IoYXV0aENyZWRlbnRpYWxzLCBhcHBDaGVja0NyZWRlbnRpYWxzLCBcbiAgICAvKipcbiAgICAgKiBBc3luY2hyb25vdXMgcXVldWUgcmVzcG9uc2libGUgZm9yIGFsbCBvZiBvdXIgaW50ZXJuYWwgcHJvY2Vzc2luZy4gV2hlblxuICAgICAqIHdlIGdldCBpbmNvbWluZyB3b3JrIGZyb20gdGhlIHVzZXIgKHZpYSBwdWJsaWMgQVBJKSBvciB0aGUgbmV0d29ya1xuICAgICAqIChpbmNvbWluZyBHUlBDIG1lc3NhZ2VzKSwgd2Ugc2hvdWxkIGFsd2F5cyBzY2hlZHVsZSBvbnRvIHRoaXMgcXVldWUuXG4gICAgICogVGhpcyBlbnN1cmVzIGFsbCBvZiBvdXIgd29yayBpcyBwcm9wZXJseSBzZXJpYWxpemVkIChlLmcuIHdlIGRvbid0XG4gICAgICogc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBvcGVyYXRpb24gd2hpbGUgdGhlIHByZXZpb3VzIG9uZSBpcyB3YWl0aW5nIGZvclxuICAgICAqIGFuIGFzeW5jIEkvTyB0byBjb21wbGV0ZSkuXG4gICAgICovXG4gICAgYXN5bmNRdWV1ZSwgZGF0YWJhc2VJbmZvLCBjb21wb25lbnRQcm92aWRlcikge1xuICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFscyA9IGF1dGhDcmVkZW50aWFscztcbiAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzID0gYXBwQ2hlY2tDcmVkZW50aWFscztcbiAgICAgICAgdGhpcy5hc3luY1F1ZXVlID0gYXN5bmNRdWV1ZTtcbiAgICAgICAgdGhpcy5kYXRhYmFzZUluZm8gPSBkYXRhYmFzZUluZm87XG4gICAgICAgIHRoaXMudXNlciA9IFVzZXIuVU5BVVRIRU5USUNBVEVEO1xuICAgICAgICB0aGlzLmNsaWVudElkID0gQXV0b0lkLm5ld0lkKCk7XG4gICAgICAgIHRoaXMuYXV0aENyZWRlbnRpYWxMaXN0ZW5lciA9ICgpID0+IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbExpc3RlbmVyID0gKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHRoaXMuX3VuaW5pdGlhbGl6ZWRDb21wb25lbnRzUHJvdmlkZXIgPSBjb21wb25lbnRQcm92aWRlcjtcbiAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHMuc3RhcnQoYXN5bmNRdWV1ZSwgYXN5bmMgKHVzZXIpID0+IHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckMiwgJ1JlY2VpdmVkIHVzZXI9JywgdXNlci51aWQpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hdXRoQ3JlZGVudGlhbExpc3RlbmVyKHVzZXIpO1xuICAgICAgICAgICAgdGhpcy51c2VyID0gdXNlcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFscy5zdGFydChhc3luY1F1ZXVlLCBuZXdBcHBDaGVja1Rva2VuID0+IHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckMiwgJ1JlY2VpdmVkIG5ldyBhcHAgY2hlY2sgdG9rZW49JywgbmV3QXBwQ2hlY2tUb2tlbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxMaXN0ZW5lcihuZXdBcHBDaGVja1Rva2VuLCB0aGlzLnVzZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGNvbmZpZ3VyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhc3luY1F1ZXVlOiB0aGlzLmFzeW5jUXVldWUsXG4gICAgICAgICAgICBkYXRhYmFzZUluZm86IHRoaXMuZGF0YWJhc2VJbmZvLFxuICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICAgICAgICBhdXRoQ3JlZGVudGlhbHM6IHRoaXMuYXV0aENyZWRlbnRpYWxzLFxuICAgICAgICAgICAgYXBwQ2hlY2tDcmVkZW50aWFsczogdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzLFxuICAgICAgICAgICAgaW5pdGlhbFVzZXI6IHRoaXMudXNlcixcbiAgICAgICAgICAgIG1heENvbmN1cnJlbnRMaW1ib1Jlc29sdXRpb25zOiBNQVhfQ09OQ1VSUkVOVF9MSU1CT19SRVNPTFVUSU9OU1xuICAgICAgICB9O1xuICAgIH1cbiAgICBzZXRDcmVkZW50aWFsQ2hhbmdlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbExpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgfVxuICAgIHNldEFwcENoZWNrVG9rZW5DaGFuZ2VMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbExpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgfVxuICAgIHRlcm1pbmF0ZSgpIHtcbiAgICAgICAgdGhpcy5hc3luY1F1ZXVlLmVudGVyUmVzdHJpY3RlZE1vZGUoKTtcbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXRFdmVuV2hpbGVSZXN0cmljdGVkKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29ubGluZUNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fb25saW5lQ29tcG9uZW50cy50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29mZmxpbmVDb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX29mZmxpbmVDb21wb25lbnRzLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGUgY3JlZGVudGlhbHMgcHJvdmlkZXIgbXVzdCBiZSB0ZXJtaW5hdGVkIGFmdGVyIHNodXR0aW5nIGRvd24gdGhlXG4gICAgICAgICAgICAgICAgLy8gUmVtb3RlU3RvcmUgYXMgaXQgd2lsbCBwcmV2ZW50IHRoZSBSZW1vdGVTdG9yZSBmcm9tIHJldHJpZXZpbmcgYXV0aFxuICAgICAgICAgICAgICAgIC8vIHRva2Vucy5cbiAgICAgICAgICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFscy5zaHV0ZG93bigpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFscy5zaHV0ZG93bigpO1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyZXN0b3JlRXJyb3IgPSB3cmFwSW5Vc2VyRXJyb3JJZlJlY292ZXJhYmxlKGUsIGBGYWlsZWQgdG8gc2h1dGRvd24gcGVyc2lzdGVuY2VgKTtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZmlyZXN0b3JlRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gc2V0T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKGNsaWVudCwgb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKSB7XG4gICAgY2xpZW50LmFzeW5jUXVldWUudmVyaWZ5T3BlcmF0aW9uSW5Qcm9ncmVzcygpO1xuICAgIGxvZ0RlYnVnKExPR19UQUckMiwgJ0luaXRpYWxpemluZyBPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXInKTtcbiAgICBjb25zdCBjb25maWd1cmF0aW9uID0gY2xpZW50LmNvbmZpZ3VyYXRpb247XG4gICAgYXdhaXQgb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyLmluaXRpYWxpemUoY29uZmlndXJhdGlvbik7XG4gICAgbGV0IGN1cnJlbnRVc2VyID0gY29uZmlndXJhdGlvbi5pbml0aWFsVXNlcjtcbiAgICBjbGllbnQuc2V0Q3JlZGVudGlhbENoYW5nZUxpc3RlbmVyKGFzeW5jICh1c2VyKSA9PiB7XG4gICAgICAgIGlmICghY3VycmVudFVzZXIuaXNFcXVhbCh1c2VyKSkge1xuICAgICAgICAgICAgYXdhaXQgbG9jYWxTdG9yZUhhbmRsZVVzZXJDaGFuZ2Uob2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyLmxvY2FsU3RvcmUsIHVzZXIpO1xuICAgICAgICAgICAgY3VycmVudFVzZXIgPSB1c2VyO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gV2hlbiBhIHVzZXIgY2FsbHMgY2xlYXJQZXJzaXN0ZW5jZSgpIGluIG9uZSBjbGllbnQsIGFsbCBvdGhlciBjbGllbnRzXG4gICAgLy8gbmVlZCB0byBiZSB0ZXJtaW5hdGVkIHRvIGFsbG93IHRoZSBkZWxldGUgdG8gc3VjY2VlZC5cbiAgICBvZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIucGVyc2lzdGVuY2Uuc2V0RGF0YWJhc2VEZWxldGVkTGlzdGVuZXIoKCkgPT4gY2xpZW50LnRlcm1pbmF0ZSgpKTtcbiAgICBjbGllbnQuX29mZmxpbmVDb21wb25lbnRzID0gb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyO1xufVxuYXN5bmMgZnVuY3Rpb24gc2V0T25saW5lQ29tcG9uZW50UHJvdmlkZXIoY2xpZW50LCBvbmxpbmVDb21wb25lbnRQcm92aWRlcikge1xuICAgIGNsaWVudC5hc3luY1F1ZXVlLnZlcmlmeU9wZXJhdGlvbkluUHJvZ3Jlc3MoKTtcbiAgICBjb25zdCBvZmZsaW5lQ29tcG9uZW50cyA9IGF3YWl0IGVuc3VyZU9mZmxpbmVDb21wb25lbnRzKGNsaWVudCk7XG4gICAgbG9nRGVidWcoTE9HX1RBRyQyLCAnSW5pdGlhbGl6aW5nIE9ubGluZUNvbXBvbmVudFByb3ZpZGVyJyk7XG4gICAgYXdhaXQgb25saW5lQ29tcG9uZW50UHJvdmlkZXIuaW5pdGlhbGl6ZShvZmZsaW5lQ29tcG9uZW50cywgY2xpZW50LmNvbmZpZ3VyYXRpb24pO1xuICAgIC8vIFRoZSBDcmVkZW50aWFsQ2hhbmdlTGlzdGVuZXIgb2YgdGhlIG9ubGluZSBjb21wb25lbnQgcHJvdmlkZXIgdGFrZXNcbiAgICAvLyBwcmVjZWRlbmNlIG92ZXIgdGhlIG9mZmxpbmUgY29tcG9uZW50IHByb3ZpZGVyLlxuICAgIGNsaWVudC5zZXRDcmVkZW50aWFsQ2hhbmdlTGlzdGVuZXIodXNlciA9PiByZW1vdGVTdG9yZUhhbmRsZUNyZWRlbnRpYWxDaGFuZ2Uob25saW5lQ29tcG9uZW50UHJvdmlkZXIucmVtb3RlU3RvcmUsIHVzZXIpKTtcbiAgICBjbGllbnQuc2V0QXBwQ2hlY2tUb2tlbkNoYW5nZUxpc3RlbmVyKChfLCB1c2VyKSA9PiByZW1vdGVTdG9yZUhhbmRsZUNyZWRlbnRpYWxDaGFuZ2Uob25saW5lQ29tcG9uZW50UHJvdmlkZXIucmVtb3RlU3RvcmUsIHVzZXIpKTtcbiAgICBjbGllbnQuX29ubGluZUNvbXBvbmVudHMgPSBvbmxpbmVDb21wb25lbnRQcm92aWRlcjtcbn1cbi8qKlxuICogRGVjaWRlcyB3aGV0aGVyIHRoZSBwcm92aWRlZCBlcnJvciBhbGxvd3MgdXMgdG8gZ3JhY2VmdWxseSBkaXNhYmxlXG4gKiBwZXJzaXN0ZW5jZSAoYXMgb3Bwb3NlZCB0byBjcmFzaGluZyB0aGUgY2xpZW50KS5cbiAqL1xuZnVuY3Rpb24gY2FuRmFsbGJhY2tGcm9tSW5kZXhlZERiRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0ZpcmViYXNlRXJyb3InKSB7XG4gICAgICAgIHJldHVybiAoZXJyb3IuY29kZSA9PT0gQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OIHx8XG4gICAgICAgICAgICBlcnJvci5jb2RlID09PSBDb2RlLlVOSU1QTEVNRU5URUQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgRE9NRXhjZXB0aW9uICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBlcnJvciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbikge1xuICAgICAgICAvLyBUaGVyZSBhcmUgYSBmZXcga25vd24gY2lyY3Vtc3RhbmNlcyB3aGVyZSB3ZSBjYW4gb3BlbiBJbmRleGVkRGIgYnV0XG4gICAgICAgIC8vIHRyeWluZyB0byByZWFkL3dyaXRlIHdpbGwgZmFpbCAoZS5nLiBxdW90YSBleGNlZWRlZCkuIEZvclxuICAgICAgICAvLyB3ZWxsLXVuZGVyc3Rvb2QgY2FzZXMsIHdlIGF0dGVtcHQgdG8gZGV0ZWN0IHRoZXNlIGFuZCB0aGVuIGdyYWNlZnVsbHlcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIG1lbW9yeSBwZXJzaXN0ZW5jZS5cbiAgICAgICAgLy8gTk9URTogUmF0aGVyIHRoYW4gY29udGludWUgdG8gYWRkIHRvIHRoaXMgbGlzdCwgd2UgY291bGQgZGVjaWRlIHRvXG4gICAgICAgIC8vIGFsd2F5cyBmYWxsIGJhY2ssIHdpdGggdGhlIHJpc2sgdGhhdCB3ZSBtaWdodCBhY2NpZGVudGFsbHkgaGlkZSBlcnJvcnNcbiAgICAgICAgLy8gcmVwcmVzZW50aW5nIGFjdHVhbCBTREsgYnVncy5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgLy8gV2hlbiB0aGUgYnJvd3NlciBpcyBvdXQgb2YgcXVvdGEgd2UgY291bGQgZ2V0IGVpdGhlciBxdW90YSBleGNlZWRlZFxuICAgICAgICAvLyBvciBhbiBhYm9ydGVkIGVycm9yIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBlcnJvciBoYXBwZW5lZCBkdXJpbmdcbiAgICAgICAgLy8gc2NoZW1hIG1pZ3JhdGlvbi5cbiAgICAgICAgZXJyb3IuY29kZSA9PT0gRE9NX0VYQ0VQVElPTl9RVU9UQV9FWENFRURFRCB8fFxuICAgICAgICAgICAgZXJyb3IuY29kZSA9PT0gRE9NX0VYQ0VQVElPTl9BQk9SVEVEIHx8XG4gICAgICAgICAgICAvLyBGaXJlZm94IFByaXZhdGUgQnJvd3NpbmcgbW9kZSBkaXNhYmxlcyBJbmRleGVkRGIgYW5kIHJldHVybnNcbiAgICAgICAgICAgIC8vIElOVkFMSURfU1RBVEUgZm9yIGFueSB1c2FnZS5cbiAgICAgICAgICAgIGVycm9yLmNvZGUgPT09IERPTV9FWENFUFRJT05fSU5WQUxJRF9TVEFURSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuYXN5bmMgZnVuY3Rpb24gZW5zdXJlT2ZmbGluZUNvbXBvbmVudHMoY2xpZW50KSB7XG4gICAgaWYgKCFjbGllbnQuX29mZmxpbmVDb21wb25lbnRzKSB7XG4gICAgICAgIGlmIChjbGllbnQuX3VuaW5pdGlhbGl6ZWRDb21wb25lbnRzUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckMiwgJ1VzaW5nIHVzZXIgcHJvdmlkZWQgT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyJyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHNldE9mZmxpbmVDb21wb25lbnRQcm92aWRlcihjbGllbnQsIGNsaWVudC5fdW5pbml0aWFsaXplZENvbXBvbmVudHNQcm92aWRlci5fb2ZmbGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbkZhbGxiYWNrRnJvbUluZGV4ZWREYkVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9nV2FybignRXJyb3IgdXNpbmcgdXNlciBwcm92aWRlZCBjYWNoZS4gRmFsbGluZyBiYWNrIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAnbWVtb3J5IGNhY2hlOiAnICtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHNldE9mZmxpbmVDb21wb25lbnRQcm92aWRlcihjbGllbnQsIG5ldyBNZW1vcnlPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDIsICdVc2luZyBkZWZhdWx0IE9mZmxpbmVDb21wb25lbnRQcm92aWRlcicpO1xuICAgICAgICAgICAgYXdhaXQgc2V0T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKGNsaWVudCwgbmV3IExydUdjTWVtb3J5T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKHVuZGVmaW5lZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbGllbnQuX29mZmxpbmVDb21wb25lbnRzO1xufVxuYXN5bmMgZnVuY3Rpb24gZW5zdXJlT25saW5lQ29tcG9uZW50cyhjbGllbnQpIHtcbiAgICBpZiAoIWNsaWVudC5fb25saW5lQ29tcG9uZW50cykge1xuICAgICAgICBpZiAoY2xpZW50Ll91bmluaXRpYWxpemVkQ29tcG9uZW50c1Byb3ZpZGVyKSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDIsICdVc2luZyB1c2VyIHByb3ZpZGVkIE9ubGluZUNvbXBvbmVudFByb3ZpZGVyJyk7XG4gICAgICAgICAgICBhd2FpdCBzZXRPbmxpbmVDb21wb25lbnRQcm92aWRlcihjbGllbnQsIGNsaWVudC5fdW5pbml0aWFsaXplZENvbXBvbmVudHNQcm92aWRlci5fb25saW5lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckMiwgJ1VzaW5nIGRlZmF1bHQgT25saW5lQ29tcG9uZW50UHJvdmlkZXInKTtcbiAgICAgICAgICAgIGF3YWl0IHNldE9ubGluZUNvbXBvbmVudFByb3ZpZGVyKGNsaWVudCwgbmV3IE9ubGluZUNvbXBvbmVudFByb3ZpZGVyKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbGllbnQuX29ubGluZUNvbXBvbmVudHM7XG59XG5mdW5jdGlvbiBnZXRQZXJzaXN0ZW5jZShjbGllbnQpIHtcbiAgICByZXR1cm4gZW5zdXJlT2ZmbGluZUNvbXBvbmVudHMoY2xpZW50KS50aGVuKGMgPT4gYy5wZXJzaXN0ZW5jZSk7XG59XG5mdW5jdGlvbiBnZXRMb2NhbFN0b3JlKGNsaWVudCkge1xuICAgIHJldHVybiBlbnN1cmVPZmZsaW5lQ29tcG9uZW50cyhjbGllbnQpLnRoZW4oYyA9PiBjLmxvY2FsU3RvcmUpO1xufVxuZnVuY3Rpb24gZ2V0UmVtb3RlU3RvcmUoY2xpZW50KSB7XG4gICAgcmV0dXJuIGVuc3VyZU9ubGluZUNvbXBvbmVudHMoY2xpZW50KS50aGVuKGMgPT4gYy5yZW1vdGVTdG9yZSk7XG59XG5mdW5jdGlvbiBnZXRTeW5jRW5naW5lKGNsaWVudCkge1xuICAgIHJldHVybiBlbnN1cmVPbmxpbmVDb21wb25lbnRzKGNsaWVudCkudGhlbihjID0+IGMuc3luY0VuZ2luZSk7XG59XG5mdW5jdGlvbiBnZXREYXRhc3RvcmUoY2xpZW50KSB7XG4gICAgcmV0dXJuIGVuc3VyZU9ubGluZUNvbXBvbmVudHMoY2xpZW50KS50aGVuKGMgPT4gYy5kYXRhc3RvcmUpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0RXZlbnRNYW5hZ2VyKGNsaWVudCkge1xuICAgIGNvbnN0IG9ubGluZUNvbXBvbmVudFByb3ZpZGVyID0gYXdhaXQgZW5zdXJlT25saW5lQ29tcG9uZW50cyhjbGllbnQpO1xuICAgIGNvbnN0IGV2ZW50TWFuYWdlciA9IG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLmV2ZW50TWFuYWdlcjtcbiAgICBldmVudE1hbmFnZXIub25MaXN0ZW4gPSBzeW5jRW5naW5lTGlzdGVuLmJpbmQobnVsbCwgb25saW5lQ29tcG9uZW50UHJvdmlkZXIuc3luY0VuZ2luZSk7XG4gICAgZXZlbnRNYW5hZ2VyLm9uVW5saXN0ZW4gPSBzeW5jRW5naW5lVW5saXN0ZW4uYmluZChudWxsLCBvbmxpbmVDb21wb25lbnRQcm92aWRlci5zeW5jRW5naW5lKTtcbiAgICBldmVudE1hbmFnZXIub25GaXJzdFJlbW90ZVN0b3JlTGlzdGVuID0gdHJpZ2dlclJlbW90ZVN0b3JlTGlzdGVuLmJpbmQobnVsbCwgb25saW5lQ29tcG9uZW50UHJvdmlkZXIuc3luY0VuZ2luZSk7XG4gICAgZXZlbnRNYW5hZ2VyLm9uTGFzdFJlbW90ZVN0b3JlVW5saXN0ZW4gPSB0cmlnZ2VyUmVtb3RlU3RvcmVVbmxpc3Rlbi5iaW5kKG51bGwsIG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnN5bmNFbmdpbmUpO1xuICAgIHJldHVybiBldmVudE1hbmFnZXI7XG59XG4vKiogRW5hYmxlcyB0aGUgbmV0d29yayBjb25uZWN0aW9uIGFuZCByZS1lbnF1ZXVlcyBhbGwgcGVuZGluZyBvcGVyYXRpb25zLiAqL1xuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50RW5hYmxlTmV0d29yayhjbGllbnQpIHtcbiAgICByZXR1cm4gY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZShhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBlcnNpc3RlbmNlID0gYXdhaXQgZ2V0UGVyc2lzdGVuY2UoY2xpZW50KTtcbiAgICAgICAgY29uc3QgcmVtb3RlU3RvcmUgPSBhd2FpdCBnZXRSZW1vdGVTdG9yZShjbGllbnQpO1xuICAgICAgICBwZXJzaXN0ZW5jZS5zZXROZXR3b3JrRW5hYmxlZCh0cnVlKTtcbiAgICAgICAgcmV0dXJuIHJlbW90ZVN0b3JlRW5hYmxlTmV0d29yayhyZW1vdGVTdG9yZSk7XG4gICAgfSk7XG59XG4vKiogRGlzYWJsZXMgdGhlIG5ldHdvcmsgY29ubmVjdGlvbi4gUGVuZGluZyBvcGVyYXRpb25zIHdpbGwgbm90IGNvbXBsZXRlLiAqL1xuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50RGlzYWJsZU5ldHdvcmsoY2xpZW50KSB7XG4gICAgcmV0dXJuIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWUoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBwZXJzaXN0ZW5jZSA9IGF3YWl0IGdldFBlcnNpc3RlbmNlKGNsaWVudCk7XG4gICAgICAgIGNvbnN0IHJlbW90ZVN0b3JlID0gYXdhaXQgZ2V0UmVtb3RlU3RvcmUoY2xpZW50KTtcbiAgICAgICAgcGVyc2lzdGVuY2Uuc2V0TmV0d29ya0VuYWJsZWQoZmFsc2UpO1xuICAgICAgICByZXR1cm4gcmVtb3RlU3RvcmVEaXNhYmxlTmV0d29yayhyZW1vdGVTdG9yZSk7XG4gICAgfSk7XG59XG4vKipcbiAqIFJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBhbGwgd3JpdGVzIHRoYXQgd2VyZSBwZW5kaW5nIGF0IHRoZSB0aW1lXG4gKiB0aGlzIG1ldGhvZCB3YXMgY2FsbGVkIHJlY2VpdmVkIHNlcnZlciBhY2tub3dsZWRnZW1lbnQuIEFuIGFja25vd2xlZGdlbWVudFxuICogY2FuIGJlIGVpdGhlciBhY2NlcHRhbmNlIG9yIHJlamVjdGlvbi5cbiAqL1xuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50V2FpdEZvclBlbmRpbmdXcml0ZXMoY2xpZW50KSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3Qgc3luY0VuZ2luZSA9IGF3YWl0IGdldFN5bmNFbmdpbmUoY2xpZW50KTtcbiAgICAgICAgcmV0dXJuIHN5bmNFbmdpbmVSZWdpc3RlclBlbmRpbmdXcml0ZXNDYWxsYmFjayhzeW5jRW5naW5lLCBkZWZlcnJlZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRMaXN0ZW4oY2xpZW50LCBxdWVyeSwgb3B0aW9ucywgb2JzZXJ2ZXIpIHtcbiAgICBjb25zdCB3cmFwcGVkT2JzZXJ2ZXIgPSBuZXcgQXN5bmNPYnNlcnZlcihvYnNlcnZlcik7XG4gICAgY29uc3QgbGlzdGVuZXIgPSBuZXcgUXVlcnlMaXN0ZW5lcihxdWVyeSwgd3JhcHBlZE9ic2VydmVyLCBvcHRpb25zKTtcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZXZlbnRNYW5hZ2VyID0gYXdhaXQgZ2V0RXZlbnRNYW5hZ2VyKGNsaWVudCk7XG4gICAgICAgIHJldHVybiBldmVudE1hbmFnZXJMaXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcik7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgd3JhcHBlZE9ic2VydmVyLm11dGUoKTtcbiAgICAgICAgY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBldmVudE1hbmFnZXIgPSBhd2FpdCBnZXRFdmVudE1hbmFnZXIoY2xpZW50KTtcbiAgICAgICAgICAgIHJldHVybiBldmVudE1hbmFnZXJVbmxpc3RlbihldmVudE1hbmFnZXIsIGxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudEdldERvY3VtZW50RnJvbUxvY2FsQ2FjaGUoY2xpZW50LCBkb2NLZXkpIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBsb2NhbFN0b3JlID0gYXdhaXQgZ2V0TG9jYWxTdG9yZShjbGllbnQpO1xuICAgICAgICByZXR1cm4gcmVhZERvY3VtZW50RnJvbUNhY2hlKGxvY2FsU3RvcmUsIGRvY0tleSwgZGVmZXJyZWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRWaWFTbmFwc2hvdExpc3RlbmVyKGNsaWVudCwga2V5LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBldmVudE1hbmFnZXIgPSBhd2FpdCBnZXRFdmVudE1hbmFnZXIoY2xpZW50KTtcbiAgICAgICAgcmV0dXJuIHJlYWREb2N1bWVudFZpYVNuYXBzaG90TGlzdGVuZXIoZXZlbnRNYW5hZ2VyLCBjbGllbnQuYXN5bmNRdWV1ZSwga2V5LCBvcHRpb25zLCBkZWZlcnJlZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudHNGcm9tTG9jYWxDYWNoZShjbGllbnQsIHF1ZXJ5KSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbG9jYWxTdG9yZSA9IGF3YWl0IGdldExvY2FsU3RvcmUoY2xpZW50KTtcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGVRdWVyeUZyb21DYWNoZShsb2NhbFN0b3JlLCBxdWVyeSwgZGVmZXJyZWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRzVmlhU25hcHNob3RMaXN0ZW5lcihjbGllbnQsIHF1ZXJ5LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBldmVudE1hbmFnZXIgPSBhd2FpdCBnZXRFdmVudE1hbmFnZXIoY2xpZW50KTtcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGVRdWVyeVZpYVNuYXBzaG90TGlzdGVuZXIoZXZlbnRNYW5hZ2VyLCBjbGllbnQuYXN5bmNRdWV1ZSwgcXVlcnksIG9wdGlvbnMsIGRlZmVycmVkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudFJ1bkFnZ3JlZ2F0ZVF1ZXJ5KGNsaWVudCwgcXVlcnksIGFnZ3JlZ2F0ZXMpIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBJbXBsZW1lbnQgYW5kIGNhbGwgZXhlY3V0ZUFnZ3JlZ2F0ZVF1ZXJ5VmlhU25hcHNob3RMaXN0ZW5lciwgc2ltaWxhclxuICAgICAgICAvLyB0byB0aGUgaW1wbGVtZW50YXRpb24gaW4gZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRzVmlhU25hcHNob3RMaXN0ZW5lclxuICAgICAgICAvLyBhYm92ZVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVE9ETyhiLzI3NzYyODM4NCk6IGNoZWNrIGBjYW5Vc2VOZXR3b3JrKClgIGFuZCBoYW5kbGUgbXVsdGktdGFiLlxuICAgICAgICAgICAgY29uc3QgZGF0YXN0b3JlID0gYXdhaXQgZ2V0RGF0YXN0b3JlKGNsaWVudCk7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGludm9rZVJ1bkFnZ3JlZ2F0aW9uUXVlcnlScGMoZGF0YXN0b3JlLCBxdWVyeSwgYWdncmVnYXRlcykpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudFdyaXRlKGNsaWVudCwgbXV0YXRpb25zKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3Qgc3luY0VuZ2luZSA9IGF3YWl0IGdldFN5bmNFbmdpbmUoY2xpZW50KTtcbiAgICAgICAgcmV0dXJuIHN5bmNFbmdpbmVXcml0ZShzeW5jRW5naW5lLCBtdXRhdGlvbnMsIGRlZmVycmVkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudEFkZFNuYXBzaG90c0luU3luY0xpc3RlbmVyKGNsaWVudCwgb2JzZXJ2ZXIpIHtcbiAgICBjb25zdCB3cmFwcGVkT2JzZXJ2ZXIgPSBuZXcgQXN5bmNPYnNlcnZlcihvYnNlcnZlcik7XG4gICAgY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGV2ZW50TWFuYWdlciA9IGF3YWl0IGdldEV2ZW50TWFuYWdlcihjbGllbnQpO1xuICAgICAgICByZXR1cm4gYWRkU25hcHNob3RzSW5TeW5jTGlzdGVuZXIoZXZlbnRNYW5hZ2VyLCB3cmFwcGVkT2JzZXJ2ZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdyYXBwZWRPYnNlcnZlci5tdXRlKCk7XG4gICAgICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRNYW5hZ2VyID0gYXdhaXQgZ2V0RXZlbnRNYW5hZ2VyKGNsaWVudCk7XG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlU25hcHNob3RzSW5TeW5jTGlzdGVuZXIoZXZlbnRNYW5hZ2VyLCB3cmFwcGVkT2JzZXJ2ZXIpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuLyoqXG4gKiBUYWtlcyBhbiB1cGRhdGVGdW5jdGlvbiBpbiB3aGljaCBhIHNldCBvZiByZWFkcyBhbmQgd3JpdGVzIGNhbiBiZSBwZXJmb3JtZWRcbiAqIGF0b21pY2FsbHkuIEluIHRoZSB1cGRhdGVGdW5jdGlvbiwgdGhlIGNsaWVudCBjYW4gcmVhZCBhbmQgd3JpdGUgdmFsdWVzXG4gKiB1c2luZyB0aGUgc3VwcGxpZWQgdHJhbnNhY3Rpb24gb2JqZWN0LiBBZnRlciB0aGUgdXBkYXRlRnVuY3Rpb24sIGFsbFxuICogY2hhbmdlcyB3aWxsIGJlIGNvbW1pdHRlZC4gSWYgYSByZXRyeWFibGUgZXJyb3Igb2NjdXJzIChleDogc29tZSBvdGhlclxuICogY2xpZW50IGhhcyBjaGFuZ2VkIGFueSBvZiB0aGUgZGF0YSByZWZlcmVuY2VkKSwgdGhlbiB0aGUgdXBkYXRlRnVuY3Rpb25cbiAqIHdpbGwgYmUgY2FsbGVkIGFnYWluIGFmdGVyIGEgYmFja29mZi4gSWYgdGhlIHVwZGF0ZUZ1bmN0aW9uIHN0aWxsIGZhaWxzXG4gKiBhZnRlciBhbGwgcmV0cmllcywgdGhlbiB0aGUgdHJhbnNhY3Rpb24gd2lsbCBiZSByZWplY3RlZC5cbiAqXG4gKiBUaGUgdHJhbnNhY3Rpb24gb2JqZWN0IHBhc3NlZCB0byB0aGUgdXBkYXRlRnVuY3Rpb24gY29udGFpbnMgbWV0aG9kcyBmb3JcbiAqIGFjY2Vzc2luZyBkb2N1bWVudHMgYW5kIGNvbGxlY3Rpb25zLiBVbmxpa2Ugb3RoZXIgZGF0YXN0b3JlIGFjY2VzcywgZGF0YVxuICogYWNjZXNzZWQgd2l0aCB0aGUgdHJhbnNhY3Rpb24gd2lsbCBub3QgcmVmbGVjdCBsb2NhbCBjaGFuZ2VzIHRoYXQgaGF2ZSBub3RcbiAqIGJlZW4gY29tbWl0dGVkLiBGb3IgdGhpcyByZWFzb24sIGl0IGlzIHJlcXVpcmVkIHRoYXQgYWxsIHJlYWRzIGFyZVxuICogcGVyZm9ybWVkIGJlZm9yZSBhbnkgd3JpdGVzLiBUcmFuc2FjdGlvbnMgbXVzdCBiZSBwZXJmb3JtZWQgd2hpbGUgb25saW5lLlxuICovXG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRUcmFuc2FjdGlvbihjbGllbnQsIHVwZGF0ZUZ1bmN0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YXN0b3JlID0gYXdhaXQgZ2V0RGF0YXN0b3JlKGNsaWVudCk7XG4gICAgICAgIG5ldyBUcmFuc2FjdGlvblJ1bm5lcihjbGllbnQuYXN5bmNRdWV1ZSwgZGF0YXN0b3JlLCBvcHRpb25zLCB1cGRhdGVGdW5jdGlvbiwgZGVmZXJyZWQpLnJ1bigpO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVhZERvY3VtZW50RnJvbUNhY2hlKGxvY2FsU3RvcmUsIGRvY0tleSwgcmVzdWx0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBhd2FpdCBsb2NhbFN0b3JlUmVhZERvY3VtZW50KGxvY2FsU3RvcmUsIGRvY0tleSk7XG4gICAgICAgIGlmIChkb2N1bWVudC5pc0ZvdW5kRG9jdW1lbnQoKSkge1xuICAgICAgICAgICAgcmVzdWx0LnJlc29sdmUoZG9jdW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvY3VtZW50LmlzTm9Eb2N1bWVudCgpKSB7XG4gICAgICAgICAgICByZXN1bHQucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5yZWplY3QobmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5BVkFJTEFCTEUsICdGYWlsZWQgdG8gZ2V0IGRvY3VtZW50IGZyb20gY2FjaGUuIChIb3dldmVyLCB0aGlzIGRvY3VtZW50IG1heSAnICtcbiAgICAgICAgICAgICAgICBcImV4aXN0IG9uIHRoZSBzZXJ2ZXIuIFJ1biBhZ2FpbiB3aXRob3V0IHNldHRpbmcgJ3NvdXJjZScgaW4gXCIgK1xuICAgICAgICAgICAgICAgICd0aGUgR2V0T3B0aW9ucyB0byBhdHRlbXB0IHRvIHJldHJpZXZlIHRoZSBkb2N1bWVudCBmcm9tIHRoZSAnICtcbiAgICAgICAgICAgICAgICAnc2VydmVyLiknKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc3QgZmlyZXN0b3JlRXJyb3IgPSB3cmFwSW5Vc2VyRXJyb3JJZlJlY292ZXJhYmxlKGUsIGBGYWlsZWQgdG8gZ2V0IGRvY3VtZW50ICcke2RvY0tleX0gZnJvbSBjYWNoZWApO1xuICAgICAgICByZXN1bHQucmVqZWN0KGZpcmVzdG9yZUVycm9yKTtcbiAgICB9XG59XG4vKipcbiAqIFJldHJpZXZlcyBhIGxhdGVuY3ktY29tcGVuc2F0ZWQgZG9jdW1lbnQgZnJvbSB0aGUgYmFja2VuZCB2aWEgYVxuICogU25hcHNob3RMaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gcmVhZERvY3VtZW50VmlhU25hcHNob3RMaXN0ZW5lcihldmVudE1hbmFnZXIsIGFzeW5jUXVldWUsIGtleSwgb3B0aW9ucywgcmVzdWx0KSB7XG4gICAgY29uc3Qgd3JhcHBlZE9ic2VydmVyID0gbmV3IEFzeW5jT2JzZXJ2ZXIoe1xuICAgICAgICBuZXh0OiAoc25hcCkgPT4ge1xuICAgICAgICAgICAgLy8gTXV0ZSBhbmQgcmVtb3ZlIHF1ZXJ5IGZpcnN0IGJlZm9yZSBwYXNzaW5nIGV2ZW50IHRvIHVzZXIgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIHVzZXIgYWN0aW9ucyBhZmZlY3RpbmcgdGhlIG5vdyBzdGFsZSBxdWVyeS5cbiAgICAgICAgICAgIHdyYXBwZWRPYnNlcnZlci5tdXRlKCk7XG4gICAgICAgICAgICBhc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoKCkgPT4gZXZlbnRNYW5hZ2VyVW5saXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcikpO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RzID0gc25hcC5kb2NzLmhhcyhrZXkpO1xuICAgICAgICAgICAgaWYgKCFleGlzdHMgJiYgc25hcC5mcm9tQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGRpbW9uZCk6IElmIHdlJ3JlIG9ubGluZSBhbmQgdGhlIGRvY3VtZW50IGRvZXNuJ3RcbiAgICAgICAgICAgICAgICAvLyBleGlzdCB0aGVuIHdlIHJlc29sdmUgd2l0aCBhIGRvYy5leGlzdHMgc2V0IHRvIGZhbHNlLiBJZlxuICAgICAgICAgICAgICAgIC8vIHdlJ3JlIG9mZmxpbmUgaG93ZXZlciwgd2UgcmVqZWN0IHRoZSBQcm9taXNlIGluIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBjYXNlLiBUd28gb3B0aW9uczogMSkgQ2FjaGUgdGhlIG5lZ2F0aXZlIHJlc3BvbnNlIGZyb21cbiAgICAgICAgICAgICAgICAvLyB0aGUgc2VydmVyIHNvIHdlIGNhbiBkZWxpdmVyIHRoYXQgZXZlbiB3aGVuIHlvdSdyZVxuICAgICAgICAgICAgICAgIC8vIG9mZmxpbmUgMikgQWN0dWFsbHkgcmVqZWN0IHRoZSBQcm9taXNlIGluIHRoZSBvbmxpbmUgY2FzZVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBkb2N1bWVudCBkb2Vzbid0IGV4aXN0LlxuICAgICAgICAgICAgICAgIHJlc3VsdC5yZWplY3QobmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5BVkFJTEFCTEUsICdGYWlsZWQgdG8gZ2V0IGRvY3VtZW50IGJlY2F1c2UgdGhlIGNsaWVudCBpcyBvZmZsaW5lLicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV4aXN0cyAmJlxuICAgICAgICAgICAgICAgIHNuYXAuZnJvbUNhY2hlICYmXG4gICAgICAgICAgICAgICAgb3B0aW9ucyAmJlxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc291cmNlID09PSAnc2VydmVyJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5yZWplY3QobmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5BVkFJTEFCTEUsICdGYWlsZWQgdG8gZ2V0IGRvY3VtZW50IGZyb20gc2VydmVyLiAoSG93ZXZlciwgdGhpcyAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2RvY3VtZW50IGRvZXMgZXhpc3QgaW4gdGhlIGxvY2FsIGNhY2hlLiBSdW4gYWdhaW4gJyArXG4gICAgICAgICAgICAgICAgICAgICd3aXRob3V0IHNldHRpbmcgc291cmNlIHRvIFwic2VydmVyXCIgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICdyZXRyaWV2ZSB0aGUgY2FjaGVkIGRvY3VtZW50LiknKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVzb2x2ZShzbmFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGUgPT4gcmVzdWx0LnJlamVjdChlKVxuICAgIH0pO1xuICAgIGNvbnN0IGxpc3RlbmVyID0gbmV3IFF1ZXJ5TGlzdGVuZXIobmV3UXVlcnlGb3JQYXRoKGtleS5wYXRoKSwgd3JhcHBlZE9ic2VydmVyLCB7XG4gICAgICAgIGluY2x1ZGVNZXRhZGF0YUNoYW5nZXM6IHRydWUsXG4gICAgICAgIHdhaXRGb3JTeW5jV2hlbk9ubGluZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBldmVudE1hbmFnZXJMaXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcik7XG59XG5hc3luYyBmdW5jdGlvbiBleGVjdXRlUXVlcnlGcm9tQ2FjaGUobG9jYWxTdG9yZSwgcXVlcnksIHJlc3VsdCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UmVzdWx0ID0gYXdhaXQgbG9jYWxTdG9yZUV4ZWN1dGVRdWVyeShsb2NhbFN0b3JlLCBxdWVyeSwgXG4gICAgICAgIC8qIHVzZVByZXZpb3VzUmVzdWx0cz0gKi8gdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVmlldyhxdWVyeSwgcXVlcnlSZXN1bHQucmVtb3RlS2V5cyk7XG4gICAgICAgIGNvbnN0IHZpZXdEb2NDaGFuZ2VzID0gdmlldy5jb21wdXRlRG9jQ2hhbmdlcyhxdWVyeVJlc3VsdC5kb2N1bWVudHMpO1xuICAgICAgICBjb25zdCB2aWV3Q2hhbmdlID0gdmlldy5hcHBseUNoYW5nZXModmlld0RvY0NoYW5nZXMsIFxuICAgICAgICAvKiBsaW1ib1Jlc29sdXRpb25FbmFibGVkPSAqLyBmYWxzZSk7XG4gICAgICAgIHJlc3VsdC5yZXNvbHZlKHZpZXdDaGFuZ2Uuc25hcHNob3QpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBmaXJlc3RvcmVFcnJvciA9IHdyYXBJblVzZXJFcnJvcklmUmVjb3ZlcmFibGUoZSwgYEZhaWxlZCB0byBleGVjdXRlIHF1ZXJ5ICcke3F1ZXJ5fSBhZ2FpbnN0IGNhY2hlYCk7XG4gICAgICAgIHJlc3VsdC5yZWplY3QoZmlyZXN0b3JlRXJyb3IpO1xuICAgIH1cbn1cbi8qKlxuICogUmV0cmlldmVzIGEgbGF0ZW5jeS1jb21wZW5zYXRlZCBxdWVyeSBzbmFwc2hvdCBmcm9tIHRoZSBiYWNrZW5kIHZpYSBhXG4gKiBTbmFwc2hvdExpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBleGVjdXRlUXVlcnlWaWFTbmFwc2hvdExpc3RlbmVyKGV2ZW50TWFuYWdlciwgYXN5bmNRdWV1ZSwgcXVlcnksIG9wdGlvbnMsIHJlc3VsdCkge1xuICAgIGNvbnN0IHdyYXBwZWRPYnNlcnZlciA9IG5ldyBBc3luY09ic2VydmVyKHtcbiAgICAgICAgbmV4dDogc25hcHNob3QgPT4ge1xuICAgICAgICAgICAgLy8gTXV0ZSBhbmQgcmVtb3ZlIHF1ZXJ5IGZpcnN0IGJlZm9yZSBwYXNzaW5nIGV2ZW50IHRvIHVzZXIgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIHVzZXIgYWN0aW9ucyBhZmZlY3RpbmcgdGhlIG5vdyBzdGFsZSBxdWVyeS5cbiAgICAgICAgICAgIHdyYXBwZWRPYnNlcnZlci5tdXRlKCk7XG4gICAgICAgICAgICBhc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoKCkgPT4gZXZlbnRNYW5hZ2VyVW5saXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcikpO1xuICAgICAgICAgICAgaWYgKHNuYXBzaG90LmZyb21DYWNoZSAmJiBvcHRpb25zLnNvdXJjZSA9PT0gJ3NlcnZlcicpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVqZWN0KG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLlVOQVZBSUxBQkxFLCAnRmFpbGVkIHRvIGdldCBkb2N1bWVudHMgZnJvbSBzZXJ2ZXIuIChIb3dldmVyLCB0aGVzZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2RvY3VtZW50cyBtYXkgZXhpc3QgaW4gdGhlIGxvY2FsIGNhY2hlLiBSdW4gYWdhaW4gJyArXG4gICAgICAgICAgICAgICAgICAgICd3aXRob3V0IHNldHRpbmcgc291cmNlIHRvIFwic2VydmVyXCIgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICdyZXRyaWV2ZSB0aGUgY2FjaGVkIGRvY3VtZW50cy4pJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlc29sdmUoc25hcHNob3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogZSA9PiByZXN1bHQucmVqZWN0KGUpXG4gICAgfSk7XG4gICAgY29uc3QgbGlzdGVuZXIgPSBuZXcgUXVlcnlMaXN0ZW5lcihxdWVyeSwgd3JhcHBlZE9ic2VydmVyLCB7XG4gICAgICAgIGluY2x1ZGVNZXRhZGF0YUNoYW5nZXM6IHRydWUsXG4gICAgICAgIHdhaXRGb3JTeW5jV2hlbk9ubGluZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBldmVudE1hbmFnZXJMaXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcik7XG59XG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRMb2FkQnVuZGxlKGNsaWVudCwgZGF0YWJhc2VJZCwgZGF0YSwgcmVzdWx0VGFzaykge1xuICAgIGNvbnN0IHJlYWRlciA9IGNyZWF0ZUJ1bmRsZVJlYWRlcihkYXRhLCBuZXdTZXJpYWxpemVyKGRhdGFiYXNlSWQpKTtcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgc3luY0VuZ2luZUxvYWRCdW5kbGUoYXdhaXQgZ2V0U3luY0VuZ2luZShjbGllbnQpLCByZWFkZXIsIHJlc3VsdFRhc2spO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50R2V0TmFtZWRRdWVyeShjbGllbnQsIHF1ZXJ5TmFtZSkge1xuICAgIHJldHVybiBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlKGFzeW5jICgpID0+IGxvY2FsU3RvcmVHZXROYW1lZFF1ZXJ5KGF3YWl0IGdldExvY2FsU3RvcmUoY2xpZW50KSwgcXVlcnlOYW1lKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVCdW5kbGVSZWFkZXIoZGF0YSwgc2VyaWFsaXplcikge1xuICAgIGxldCBjb250ZW50O1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29udGVudCA9IG5ld1RleHRFbmNvZGVyKCkuZW5jb2RlKGRhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29udGVudCA9IGRhdGE7XG4gICAgfVxuICAgIHJldHVybiBuZXdCdW5kbGVSZWFkZXIodG9CeXRlU3RyZWFtUmVhZGVyKGNvbnRlbnQpLCBzZXJpYWxpemVyKTtcbn1cbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudFNldEluZGV4Q29uZmlndXJhdGlvbihjbGllbnQsIGluZGV4ZXMpIHtcbiAgICByZXR1cm4gY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZShhc3luYyAoKSA9PiB7XG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlQ29uZmlndXJlRmllbGRJbmRleGVzKGF3YWl0IGdldExvY2FsU3RvcmUoY2xpZW50KSwgaW5kZXhlcyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRTZXRQZXJzaXN0ZW50Q2FjaGVJbmRleEF1dG9DcmVhdGlvbkVuYWJsZWQoY2xpZW50LCBpc0VuYWJsZWQpIHtcbiAgICByZXR1cm4gY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZShhc3luYyAoKSA9PiB7XG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlU2V0SW5kZXhBdXRvQ3JlYXRpb25FbmFibGVkKGF3YWl0IGdldExvY2FsU3RvcmUoY2xpZW50KSwgaXNFbmFibGVkKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudERlbGV0ZUFsbEZpZWxkSW5kZXhlcyhjbGllbnQpIHtcbiAgICByZXR1cm4gY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZShhc3luYyAoKSA9PiB7XG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlRGVsZXRlQWxsRmllbGRJbmRleGVzKGF3YWl0IGdldExvY2FsU3RvcmUoY2xpZW50KSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIENvbXBhcmVzIHR3byBgRXhwZXJpbWVudGFsTG9uZ1BvbGxpbmdPcHRpb25zYCBvYmplY3RzIGZvciBlcXVhbGl0eS5cbiAqL1xuZnVuY3Rpb24gbG9uZ1BvbGxpbmdPcHRpb25zRXF1YWwob3B0aW9uczEsIG9wdGlvbnMyKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMxLnRpbWVvdXRTZWNvbmRzID09PSBvcHRpb25zMi50aW1lb3V0U2Vjb25kcztcbn1cbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyBgRXhwZXJpbWVudGFsTG9uZ1BvbGxpbmdPcHRpb25zYCB3aXRoIHRoZSBzYW1lXG4gKiBvcHRpb24gdmFsdWVzIGFzIHRoZSBnaXZlbiBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVMb25nUG9sbGluZ09wdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IGNsb25lID0ge307XG4gICAgaWYgKG9wdGlvbnMudGltZW91dFNlY29uZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjbG9uZS50aW1lb3V0U2Vjb25kcyA9IG9wdGlvbnMudGltZW91dFNlY29uZHM7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IExPR19UQUckMSA9ICdDb21wb25lbnRQcm92aWRlcic7XG4vKipcbiAqIEFuIGluc3RhbmNlIG1hcCB0aGF0IGVuc3VyZXMgb25seSBvbmUgRGF0YXN0b3JlIGV4aXN0cyBwZXIgRmlyZXN0b3JlXG4gKiBpbnN0YW5jZS5cbiAqL1xuY29uc3QgZGF0YXN0b3JlSW5zdGFuY2VzID0gbmV3IE1hcCgpO1xuLyoqXG4gKiBSZW1vdmVzIGFsbCBjb21wb25lbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQgaW5zdGFuY2UuIE11c3QgYmUgY2FsbGVkXG4gKiB3aGVuIHRoZSBgRmlyZXN0b3JlYCBpbnN0YW5jZSBpcyB0ZXJtaW5hdGVkLlxuICovXG5mdW5jdGlvbiByZW1vdmVDb21wb25lbnRzKGZpcmVzdG9yZSkge1xuICAgIGNvbnN0IGRhdGFzdG9yZSA9IGRhdGFzdG9yZUluc3RhbmNlcy5nZXQoZmlyZXN0b3JlKTtcbiAgICBpZiAoZGF0YXN0b3JlKSB7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckMSwgJ1JlbW92aW5nIERhdGFzdG9yZScpO1xuICAgICAgICBkYXRhc3RvcmVJbnN0YW5jZXMuZGVsZXRlKGZpcmVzdG9yZSk7XG4gICAgICAgIGRhdGFzdG9yZS50ZXJtaW5hdGUoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYWtlRGF0YWJhc2VJbmZvKGRhdGFiYXNlSWQsIGFwcElkLCBwZXJzaXN0ZW5jZUtleSwgc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gbmV3IERhdGFiYXNlSW5mbyhkYXRhYmFzZUlkLCBhcHBJZCwgcGVyc2lzdGVuY2VLZXksIHNldHRpbmdzLmhvc3QsIHNldHRpbmdzLnNzbCwgc2V0dGluZ3MuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZywgc2V0dGluZ3MuZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nLCBjbG9uZUxvbmdQb2xsaW5nT3B0aW9ucyhzZXR0aW5ncy5leHBlcmltZW50YWxMb25nUG9sbGluZ09wdGlvbnMpLCBzZXR0aW5ncy51c2VGZXRjaFN0cmVhbXMpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gc2V0dGluZ3MoKSBkZWZhdWx0czpcbmNvbnN0IERFRkFVTFRfSE9TVCA9ICdmaXJlc3RvcmUuZ29vZ2xlYXBpcy5jb20nO1xuY29uc3QgREVGQVVMVF9TU0wgPSB0cnVlO1xuLy8gVGhlIG1pbmltdW0gbG9uZy1wb2xsaW5nIHRpbWVvdXQgaXMgaGFyZGNvZGVkIG9uIHRoZSBzZXJ2ZXIuIFRoZSB2YWx1ZSBoZXJlXG4vLyBzaG91bGQgYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIHZhbHVlIHVzZWQgYnkgdGhlIHNlcnZlciwgYXMgdGhlIHNlcnZlciB3aWxsXG4vLyBzaWxlbnRseSBpZ25vcmUgYSB2YWx1ZSBiZWxvdyB0aGUgbWluaW11bSBhbmQgZmFsbCBiYWNrIHRvIHRoZSBkZWZhdWx0LlxuLy8gR29vZ2xlcnMgc2VlIGIvMjY2ODY4ODcxIGZvciByZWxldmFudCBkaXNjdXNzaW9uLlxuY29uc3QgTUlOX0xPTkdfUE9MTElOR19USU1FT1VUX1NFQ09ORFMgPSA1O1xuLy8gTm8gbWF4aW11bSBsb25nLXBvbGxpbmcgdGltZW91dCBpcyBjb25maWd1cmVkIGluIHRoZSBzZXJ2ZXIsIGFuZCBkZWZhdWx0cyB0b1xuLy8gMzAgc2Vjb25kcywgd2hpY2ggaXMgd2hhdCBXYXRjaCBhcHBlYXJzIHRvIHVzZS5cbi8vIEdvb2dsZXJzIHNlZSBiLzI2Njg2ODg3MSBmb3IgcmVsZXZhbnQgZGlzY3Vzc2lvbi5cbmNvbnN0IE1BWF9MT05HX1BPTExJTkdfVElNRU9VVF9TRUNPTkRTID0gMzA7XG4vLyBXaGV0aGVyIGxvbmctcG9sbGluZyBhdXRvLWRldGVjdGVkIGlzIGVuYWJsZWQgYnkgZGVmYXVsdC5cbmNvbnN0IERFRkFVTFRfQVVUT19ERVRFQ1RfTE9OR19QT0xMSU5HID0gdHJ1ZTtcbi8qKlxuICogQSBjb25jcmV0ZSB0eXBlIGRlc2NyaWJpbmcgYWxsIHRoZSB2YWx1ZXMgdGhhdCBjYW4gYmUgYXBwbGllZCB2aWEgYVxuICogdXNlci1zdXBwbGllZCBgRmlyZXN0b3JlU2V0dGluZ3NgIG9iamVjdC4gVGhpcyBpcyBhIHNlcGFyYXRlIHR5cGUgc28gdGhhdFxuICogZGVmYXVsdHMgY2FuIGJlIHN1cHBsaWVkIGFuZCB0aGUgdmFsdWUgY2FuIGJlIGNoZWNrZWQgZm9yIGVxdWFsaXR5LlxuICovXG5jbGFzcyBGaXJlc3RvcmVTZXR0aW5nc0ltcGwge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChzZXR0aW5ncy5ob3N0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zc2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIFwiQ2FuJ3QgcHJvdmlkZSBzc2wgb3B0aW9uIGlmIGhvc3Qgb3B0aW9uIGlzIG5vdCBzZXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3QgPSBERUZBVUxUX0hPU1Q7XG4gICAgICAgICAgICB0aGlzLnNzbCA9IERFRkFVTFRfU1NMO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ob3N0ID0gc2V0dGluZ3MuaG9zdDtcbiAgICAgICAgICAgIHRoaXMuc3NsID0gKF9hID0gc2V0dGluZ3Muc3NsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBERUZBVUxUX1NTTDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gc2V0dGluZ3MuY3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcyA9ICEhc2V0dGluZ3MuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcztcbiAgICAgICAgdGhpcy5sb2NhbENhY2hlID0gc2V0dGluZ3MubG9jYWxDYWNoZTtcbiAgICAgICAgaWYgKHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVTaXplQnl0ZXMgPSBMUlVfREVGQVVMVF9DQUNIRV9TSVpFX0JZVEVTO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzICE9PSBMUlVfQ09MTEVDVElPTl9ESVNBQkxFRCAmJlxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzIDwgTFJVX01JTklNVU1fQ0FDSEVfU0laRV9CWVRFUykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBjYWNoZVNpemVCeXRlcyBtdXN0IGJlIGF0IGxlYXN0ICR7TFJVX01JTklNVU1fQ0FDSEVfU0laRV9CWVRFU31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVTaXplQnl0ZXMgPSBzZXR0aW5ncy5jYWNoZVNpemVCeXRlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YWxpZGF0ZUlzTm90VXNlZFRvZ2V0aGVyKCdleHBlcmltZW50YWxGb3JjZUxvbmdQb2xsaW5nJywgc2V0dGluZ3MuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZywgJ2V4cGVyaW1lbnRhbEF1dG9EZXRlY3RMb25nUG9sbGluZycsIHNldHRpbmdzLmV4cGVyaW1lbnRhbEF1dG9EZXRlY3RMb25nUG9sbGluZyk7XG4gICAgICAgIHRoaXMuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZyA9ICEhc2V0dGluZ3MuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZztcbiAgICAgICAgaWYgKHRoaXMuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZykge1xuICAgICAgICAgICAgdGhpcy5leHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZXR0aW5ncy5leHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5leHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmcgPSBERUZBVUxUX0FVVE9fREVURUNUX0xPTkdfUE9MTElORztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgY29lcmNlIHRoZSB2YWx1ZSB0byBib29sZWFuIGV2ZW4gdGhvdWdoXG4gICAgICAgICAgICAvLyB0aGUgVHlwZVNjcmlwdCBjb21waWxlciBoYXMgbmFycm93ZWQgdGhlIHR5cGUgdG8gYm9vbGVhbiBhbHJlYWR5LlxuICAgICAgICAgICAgLy8gbm9pbnNwZWN0aW9uIFBvaW50bGVzc0Jvb2xlYW5FeHByZXNzaW9uSlNcbiAgICAgICAgICAgIHRoaXMuZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nID1cbiAgICAgICAgICAgICAgICAhIXNldHRpbmdzLmV4cGVyaW1lbnRhbEF1dG9EZXRlY3RMb25nUG9sbGluZztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV4cGVyaW1lbnRhbExvbmdQb2xsaW5nT3B0aW9ucyA9IGNsb25lTG9uZ1BvbGxpbmdPcHRpb25zKChfYiA9IHNldHRpbmdzLmV4cGVyaW1lbnRhbExvbmdQb2xsaW5nT3B0aW9ucykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge30pO1xuICAgICAgICB2YWxpZGF0ZUxvbmdQb2xsaW5nT3B0aW9ucyh0aGlzLmV4cGVyaW1lbnRhbExvbmdQb2xsaW5nT3B0aW9ucyk7XG4gICAgICAgIHRoaXMudXNlRmV0Y2hTdHJlYW1zID0gISFzZXR0aW5ncy51c2VGZXRjaFN0cmVhbXM7XG4gICAgfVxuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmhvc3QgPT09IG90aGVyLmhvc3QgJiZcbiAgICAgICAgICAgIHRoaXMuc3NsID09PSBvdGhlci5zc2wgJiZcbiAgICAgICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPT09IG90aGVyLmNyZWRlbnRpYWxzICYmXG4gICAgICAgICAgICB0aGlzLmNhY2hlU2l6ZUJ5dGVzID09PSBvdGhlci5jYWNoZVNpemVCeXRlcyAmJlxuICAgICAgICAgICAgdGhpcy5leHBlcmltZW50YWxGb3JjZUxvbmdQb2xsaW5nID09PVxuICAgICAgICAgICAgICAgIG90aGVyLmV4cGVyaW1lbnRhbEZvcmNlTG9uZ1BvbGxpbmcgJiZcbiAgICAgICAgICAgIHRoaXMuZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nID09PVxuICAgICAgICAgICAgICAgIG90aGVyLmV4cGVyaW1lbnRhbEF1dG9EZXRlY3RMb25nUG9sbGluZyAmJlxuICAgICAgICAgICAgbG9uZ1BvbGxpbmdPcHRpb25zRXF1YWwodGhpcy5leHBlcmltZW50YWxMb25nUG9sbGluZ09wdGlvbnMsIG90aGVyLmV4cGVyaW1lbnRhbExvbmdQb2xsaW5nT3B0aW9ucykgJiZcbiAgICAgICAgICAgIHRoaXMuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcyA9PT0gb3RoZXIuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcyAmJlxuICAgICAgICAgICAgdGhpcy51c2VGZXRjaFN0cmVhbXMgPT09IG90aGVyLnVzZUZldGNoU3RyZWFtcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVMb25nUG9sbGluZ09wdGlvbnMob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnRpbWVvdXRTZWNvbmRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzTmFOKG9wdGlvbnMudGltZW91dFNlY29uZHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgaW52YWxpZCBsb25nIHBvbGxpbmcgdGltZW91dDogYCArXG4gICAgICAgICAgICAgICAgYCR7b3B0aW9ucy50aW1lb3V0U2Vjb25kc30gKG11c3Qgbm90IGJlIE5hTilgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy50aW1lb3V0U2Vjb25kcyA8IE1JTl9MT05HX1BPTExJTkdfVElNRU9VVF9TRUNPTkRTKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgaW52YWxpZCBsb25nIHBvbGxpbmcgdGltZW91dDogJHtvcHRpb25zLnRpbWVvdXRTZWNvbmRzfSBgICtcbiAgICAgICAgICAgICAgICBgKG1pbmltdW0gYWxsb3dlZCB2YWx1ZSBpcyAke01JTl9MT05HX1BPTExJTkdfVElNRU9VVF9TRUNPTkRTfSlgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy50aW1lb3V0U2Vjb25kcyA+IE1BWF9MT05HX1BPTExJTkdfVElNRU9VVF9TRUNPTkRTKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgaW52YWxpZCBsb25nIHBvbGxpbmcgdGltZW91dDogJHtvcHRpb25zLnRpbWVvdXRTZWNvbmRzfSBgICtcbiAgICAgICAgICAgICAgICBgKG1heGltdW0gYWxsb3dlZCB2YWx1ZSBpcyAke01BWF9MT05HX1BPTExJTkdfVElNRU9VVF9TRUNPTkRTfSlgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVGhlIENsb3VkIEZpcmVzdG9yZSBzZXJ2aWNlIGludGVyZmFjZS5cbiAqXG4gKiBEbyBub3QgY2FsbCB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LiBJbnN0ZWFkLCB1c2Uge0BsaW5rIChnZXRGaXJlc3RvcmU6MSl9LlxuICovXG5jbGFzcyBGaXJlc3RvcmUkMSB7XG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cbiAgICBjb25zdHJ1Y3RvcihfYXV0aENyZWRlbnRpYWxzLCBfYXBwQ2hlY2tDcmVkZW50aWFscywgX2RhdGFiYXNlSWQsIF9hcHApIHtcbiAgICAgICAgdGhpcy5fYXV0aENyZWRlbnRpYWxzID0gX2F1dGhDcmVkZW50aWFscztcbiAgICAgICAgdGhpcy5fYXBwQ2hlY2tDcmVkZW50aWFscyA9IF9hcHBDaGVja0NyZWRlbnRpYWxzO1xuICAgICAgICB0aGlzLl9kYXRhYmFzZUlkID0gX2RhdGFiYXNlSWQ7XG4gICAgICAgIHRoaXMuX2FwcCA9IF9hcHA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIGl0J3MgYSBGaXJlc3RvcmUgb3IgRmlyZXN0b3JlIExpdGUgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAnZmlyZXN0b3JlLWxpdGUnO1xuICAgICAgICB0aGlzLl9wZXJzaXN0ZW5jZUtleSA9ICcobGl0ZSknO1xuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IG5ldyBGaXJlc3RvcmVTZXR0aW5nc0ltcGwoe30pO1xuICAgICAgICB0aGlzLl9zZXR0aW5nc0Zyb3plbiA9IGZhbHNlO1xuICAgICAgICAvLyBBIHRhc2sgdGhhdCBpcyBhc3NpZ25lZCB3aGVuIHRoZSB0ZXJtaW5hdGUoKSBpcyBpbnZva2VkIGFuZCByZXNvbHZlZCB3aGVuXG4gICAgICAgIC8vIGFsbCBjb21wb25lbnRzIGhhdmUgc2h1dCBkb3duLiBPdGhlcndpc2UsIEZpcmVzdG9yZSBpcyBub3QgdGVybWluYXRlZCxcbiAgICAgICAgLy8gd2hpY2ggY2FuIG1lYW4gZWl0aGVyIHRoZSBGaXJlc3RvcmVDbGllbnQgaXMgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcsXG4gICAgICAgIC8vIG9yIHJlc3RhcnRpbmcuXG4gICAgICAgIHRoaXMuX3Rlcm1pbmF0ZVRhc2sgPSAnbm90VGVybWluYXRlZCc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gYXNzb2NpYXRlZCB3aXRoIHRoaXMgYEZpcmVzdG9yZWAgc2VydmljZVxuICAgICAqIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldCBhcHAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fYXBwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCBcIkZpcmVzdG9yZSB3YXMgbm90IGluaXRpYWxpemVkIHVzaW5nIHRoZSBGaXJlYmFzZSBTREsuICdhcHAnIGlzIFwiICtcbiAgICAgICAgICAgICAgICAnbm90IGF2YWlsYWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHA7XG4gICAgfVxuICAgIGdldCBfaW5pdGlhbGl6ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXR0aW5nc0Zyb3plbjtcbiAgICB9XG4gICAgZ2V0IF90ZXJtaW5hdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGVybWluYXRlVGFzayAhPT0gJ25vdFRlcm1pbmF0ZWQnO1xuICAgIH1cbiAgICBfc2V0U2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzRnJvemVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnRmlyZXN0b3JlIGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZCBhbmQgaXRzIHNldHRpbmdzIGNhbiBubyBsb25nZXIgJyArXG4gICAgICAgICAgICAgICAgJ2JlIGNoYW5nZWQuIFlvdSBjYW4gb25seSBtb2RpZnkgc2V0dGluZ3MgYmVmb3JlIGNhbGxpbmcgYW55IG90aGVyICcgK1xuICAgICAgICAgICAgICAgICdtZXRob2RzIG9uIGEgRmlyZXN0b3JlIG9iamVjdC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IG5ldyBGaXJlc3RvcmVTZXR0aW5nc0ltcGwoc2V0dGluZ3MpO1xuICAgICAgICBpZiAoc2V0dGluZ3MuY3JlZGVudGlhbHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fYXV0aENyZWRlbnRpYWxzID0gbWFrZUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyKHNldHRpbmdzLmNyZWRlbnRpYWxzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZ2V0U2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXR0aW5ncztcbiAgICB9XG4gICAgX2ZyZWV6ZVNldHRpbmdzKCkge1xuICAgICAgICB0aGlzLl9zZXR0aW5nc0Zyb3plbiA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXR0aW5ncztcbiAgICB9XG4gICAgX2RlbGV0ZSgpIHtcbiAgICAgICAgLy8gVGhlIGBfdGVybWluYXRlVGFza2AgbXVzdCBiZSBhc3NpZ25lZCBmdXR1cmUgdGhhdCBjb21wbGV0ZXMgd2hlblxuICAgICAgICAvLyB0ZXJtaW5hdGUgaXMgY29tcGxldGUuIFRoZSBleGlzdGVuY2Ugb2YgdGhpcyBmdXR1cmUgcHV0cyBTREsgaW4gc3RhdGVcbiAgICAgICAgLy8gdGhhdCB3aWxsIG5vdCBhY2NlcHQgZnVydGhlciBBUEkgaW50ZXJhY3Rpb24uXG4gICAgICAgIGlmICh0aGlzLl90ZXJtaW5hdGVUYXNrID09PSAnbm90VGVybWluYXRlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmF0ZVRhc2sgPSB0aGlzLl90ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdGVybWluYXRlVGFzaztcbiAgICB9XG4gICAgYXN5bmMgX3Jlc3RhcnQoKSB7XG4gICAgICAgIC8vIFRoZSBgX3Rlcm1pbmF0ZVRhc2tgIG11c3QgZXF1YWwgJ25vdFRlcm1pbmF0ZWQnIGFmdGVyIHJlc3RhcnQgdG9cbiAgICAgICAgLy8gc2lnbmFsIHRoYXQgY2xpZW50IGlzIGluIGEgc3RhdGUgdGhhdCBhY2NlcHRzIEFQSSBjYWxscy5cbiAgICAgICAgaWYgKHRoaXMuX3Rlcm1pbmF0ZVRhc2sgPT09ICdub3RUZXJtaW5hdGVkJykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fdGVybWluYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90ZXJtaW5hdGVUYXNrID0gJ25vdFRlcm1pbmF0ZWQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBgRmlyZXN0b3JlYCBpbnN0YW5jZS4gKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhcHA6IHRoaXMuX2FwcCxcbiAgICAgICAgICAgIGRhdGFiYXNlSWQ6IHRoaXMuX2RhdGFiYXNlSWQsXG4gICAgICAgICAgICBzZXR0aW5nczogdGhpcy5fc2V0dGluZ3NcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVybWluYXRlcyBhbGwgY29tcG9uZW50cyB1c2VkIGJ5IHRoaXMgY2xpZW50LiBTdWJjbGFzc2VzIGNhbiBvdmVycmlkZVxuICAgICAqIHRoaXMgbWV0aG9kIHRvIGNsZWFuIHVwIHRoZWlyIG93biBkZXBlbmRlbmNpZXMsIGJ1dCBtdXN0IGFsc28gY2FsbCB0aGlzXG4gICAgICogbWV0aG9kLlxuICAgICAqXG4gICAgICogT25seSBldmVyIGNhbGxlZCBvbmNlLlxuICAgICAqL1xuICAgIF90ZXJtaW5hdGUoKSB7XG4gICAgICAgIHJlbW92ZUNvbXBvbmVudHModGhpcyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG59XG4vKipcbiAqIE1vZGlmeSB0aGlzIGluc3RhbmNlIHRvIGNvbW11bmljYXRlIHdpdGggdGhlIENsb3VkIEZpcmVzdG9yZSBlbXVsYXRvci5cbiAqXG4gKiBOb3RlOiBUaGlzIG11c3QgYmUgY2FsbGVkIGJlZm9yZSB0aGlzIGluc3RhbmNlIGhhcyBiZWVuIHVzZWQgdG8gZG8gYW55XG4gKiBvcGVyYXRpb25zLlxuICpcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBUaGUgYEZpcmVzdG9yZWAgaW5zdGFuY2UgdG8gY29uZmlndXJlIHRvIGNvbm5lY3QgdG8gdGhlXG4gKiBlbXVsYXRvci5cbiAqIEBwYXJhbSBob3N0IC0gdGhlIGVtdWxhdG9yIGhvc3QgKGV4OiBsb2NhbGhvc3QpLlxuICogQHBhcmFtIHBvcnQgLSB0aGUgZW11bGF0b3IgcG9ydCAoZXg6IDkwMDApLlxuICogQHBhcmFtIG9wdGlvbnMubW9ja1VzZXJUb2tlbiAtIHRoZSBtb2NrIGF1dGggdG9rZW4gdG8gdXNlIGZvciB1bml0IHRlc3RpbmdcbiAqIFNlY3VyaXR5IFJ1bGVzLlxuICovXG5mdW5jdGlvbiBjb25uZWN0RmlyZXN0b3JlRW11bGF0b3IoZmlyZXN0b3JlLCBob3N0LCBwb3J0LCBvcHRpb25zID0ge30pIHtcbiAgICB2YXIgX2E7XG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSQxKTtcbiAgICBjb25zdCBzZXR0aW5ncyA9IGZpcmVzdG9yZS5fZ2V0U2V0dGluZ3MoKTtcbiAgICBjb25zdCBuZXdIb3N0U2V0dGluZyA9IGAke2hvc3R9OiR7cG9ydH1gO1xuICAgIGlmIChzZXR0aW5ncy5ob3N0ICE9PSBERUZBVUxUX0hPU1QgJiYgc2V0dGluZ3MuaG9zdCAhPT0gbmV3SG9zdFNldHRpbmcpIHtcbiAgICAgICAgbG9nV2FybignSG9zdCBoYXMgYmVlbiBzZXQgaW4gYm90aCBzZXR0aW5ncygpIGFuZCBjb25uZWN0RmlyZXN0b3JlRW11bGF0b3IoKSwgZW11bGF0b3IgaG9zdCAnICtcbiAgICAgICAgICAgICd3aWxsIGJlIHVzZWQuJyk7XG4gICAgfVxuICAgIGZpcmVzdG9yZS5fc2V0U2V0dGluZ3MoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzZXR0aW5ncyksIHsgaG9zdDogbmV3SG9zdFNldHRpbmcsIHNzbDogZmFsc2UgfSkpO1xuICAgIGlmIChvcHRpb25zLm1vY2tVc2VyVG9rZW4pIHtcbiAgICAgICAgbGV0IHRva2VuO1xuICAgICAgICBsZXQgdXNlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1vY2tVc2VyVG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IG9wdGlvbnMubW9ja1VzZXJUb2tlbjtcbiAgICAgICAgICAgIHVzZXIgPSBVc2VyLk1PQ0tfVVNFUjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIExldCBjcmVhdGVNb2NrVXNlclRva2VuIHZhbGlkYXRlIGZpcnN0IChjYXRjaGVzIGNvbW1vbiBtaXN0YWtlcyBsaWtlXG4gICAgICAgICAgICAvLyBpbnZhbGlkIGZpZWxkIFwidWlkXCIgYW5kIG1pc3NpbmcgZmllbGQgXCJzdWJcIiAvIFwidXNlcl9pZFwiLilcbiAgICAgICAgICAgIHRva2VuID0gY3JlYXRlTW9ja1VzZXJUb2tlbihvcHRpb25zLm1vY2tVc2VyVG9rZW4sIChfYSA9IGZpcmVzdG9yZS5fYXBwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW9ucy5wcm9qZWN0SWQpO1xuICAgICAgICAgICAgY29uc3QgdWlkID0gb3B0aW9ucy5tb2NrVXNlclRva2VuLnN1YiB8fCBvcHRpb25zLm1vY2tVc2VyVG9rZW4udXNlcl9pZDtcbiAgICAgICAgICAgIGlmICghdWlkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgXCJtb2NrVXNlclRva2VuIG11c3QgY29udGFpbiAnc3ViJyBvciAndXNlcl9pZCcgZmllbGQhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXNlciA9IG5ldyBVc2VyKHVpZCk7XG4gICAgICAgIH1cbiAgICAgICAgZmlyZXN0b3JlLl9hdXRoQ3JlZGVudGlhbHMgPSBuZXcgRW11bGF0b3JBdXRoQ3JlZGVudGlhbHNQcm92aWRlcihuZXcgT0F1dGhUb2tlbih0b2tlbiwgdXNlcikpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSBgUXVlcnlgIHJlZmVycyB0byBhIHF1ZXJ5IHdoaWNoIHlvdSBjYW4gcmVhZCBvciBsaXN0ZW4gdG8uIFlvdSBjYW4gYWxzb1xuICogY29uc3RydWN0IHJlZmluZWQgYFF1ZXJ5YCBvYmplY3RzIGJ5IGFkZGluZyBmaWx0ZXJzIGFuZCBvcmRlcmluZy5cbiAqL1xuY2xhc3MgUXVlcnkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGxpdGUgdmVyc2lvbiBvZiB0aGUgUXVlcnkgY2xhc3MgaW4gdGhlIG1haW4gU0RLLlxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yIHByb3RlY3RlZCAqL1xuICAgIGNvbnN0cnVjdG9yKGZpcmVzdG9yZSwgXG4gICAgLyoqXG4gICAgICogSWYgcHJvdmlkZWQsIHRoZSBgRmlyZXN0b3JlRGF0YUNvbnZlcnRlcmAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5zdGFuY2UuXG4gICAgICovXG4gICAgY29udmVydGVyLCBfcXVlcnkpIHtcbiAgICAgICAgdGhpcy5jb252ZXJ0ZXIgPSBjb252ZXJ0ZXI7XG4gICAgICAgIHRoaXMuX3F1ZXJ5ID0gX3F1ZXJ5O1xuICAgICAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyBGaXJlc3RvcmUgcmVmZXJlbmNlLiAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAncXVlcnknO1xuICAgICAgICB0aGlzLmZpcmVzdG9yZSA9IGZpcmVzdG9yZTtcbiAgICB9XG4gICAgd2l0aENvbnZlcnRlcihjb252ZXJ0ZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeSh0aGlzLmZpcmVzdG9yZSwgY29udmVydGVyLCB0aGlzLl9xdWVyeSk7XG4gICAgfVxufVxuLyoqXG4gKiBBIGBEb2N1bWVudFJlZmVyZW5jZWAgcmVmZXJzIHRvIGEgZG9jdW1lbnQgbG9jYXRpb24gaW4gYSBGaXJlc3RvcmUgZGF0YWJhc2VcbiAqIGFuZCBjYW4gYmUgdXNlZCB0byB3cml0ZSwgcmVhZCwgb3IgbGlzdGVuIHRvIHRoZSBsb2NhdGlvbi4gVGhlIGRvY3VtZW50IGF0XG4gKiB0aGUgcmVmZXJlbmNlZCBsb2NhdGlvbiBtYXkgb3IgbWF5IG5vdCBleGlzdC5cbiAqL1xuY2xhc3MgRG9jdW1lbnRSZWZlcmVuY2Uge1xuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXG4gICAgY29uc3RydWN0b3IoZmlyZXN0b3JlLCBcbiAgICAvKipcbiAgICAgKiBJZiBwcm92aWRlZCwgdGhlIGBGaXJlc3RvcmVEYXRhQ29udmVydGVyYCBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBjb252ZXJ0ZXIsIF9rZXkpIHtcbiAgICAgICAgdGhpcy5jb252ZXJ0ZXIgPSBjb252ZXJ0ZXI7XG4gICAgICAgIHRoaXMuX2tleSA9IF9rZXk7XG4gICAgICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIEZpcmVzdG9yZSByZWZlcmVuY2UuICovXG4gICAgICAgIHRoaXMudHlwZSA9ICdkb2N1bWVudCc7XG4gICAgICAgIHRoaXMuZmlyZXN0b3JlID0gZmlyZXN0b3JlO1xuICAgIH1cbiAgICBnZXQgX3BhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXkucGF0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGRvY3VtZW50J3MgaWRlbnRpZmllciB3aXRoaW4gaXRzIGNvbGxlY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fa2V5LnBhdGgubGFzdFNlZ21lbnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBwYXRoIG9mIHRoZSByZWZlcmVuY2VkIGRvY3VtZW50IChyZWxhdGl2ZVxuICAgICAqIHRvIHRoZSByb290IG9mIHRoZSBkYXRhYmFzZSkuXG4gICAgICovXG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXkucGF0aC5jYW5vbmljYWxTdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNvbGxlY3Rpb24gdGhpcyBgRG9jdW1lbnRSZWZlcmVuY2VgIGJlbG9uZ3MgdG8uXG4gICAgICovXG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uUmVmZXJlbmNlKHRoaXMuZmlyZXN0b3JlLCB0aGlzLmNvbnZlcnRlciwgdGhpcy5fa2V5LnBhdGgucG9wTGFzdCgpKTtcbiAgICB9XG4gICAgd2l0aENvbnZlcnRlcihjb252ZXJ0ZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFJlZmVyZW5jZSh0aGlzLmZpcmVzdG9yZSwgY29udmVydGVyLCB0aGlzLl9rZXkpO1xuICAgIH1cbn1cbi8qKlxuICogQSBgQ29sbGVjdGlvblJlZmVyZW5jZWAgb2JqZWN0IGNhbiBiZSB1c2VkIGZvciBhZGRpbmcgZG9jdW1lbnRzLCBnZXR0aW5nXG4gKiBkb2N1bWVudCByZWZlcmVuY2VzLCBhbmQgcXVlcnlpbmcgZm9yIGRvY3VtZW50cyAodXNpbmcge0BsaW5rIChxdWVyeToxKX0pLlxuICovXG5jbGFzcyBDb2xsZWN0aW9uUmVmZXJlbmNlIGV4dGVuZHMgUXVlcnkge1xuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXG4gICAgY29uc3RydWN0b3IoZmlyZXN0b3JlLCBjb252ZXJ0ZXIsIF9wYXRoKSB7XG4gICAgICAgIHN1cGVyKGZpcmVzdG9yZSwgY29udmVydGVyLCBuZXdRdWVyeUZvclBhdGgoX3BhdGgpKTtcbiAgICAgICAgdGhpcy5fcGF0aCA9IF9wYXRoO1xuICAgICAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyBGaXJlc3RvcmUgcmVmZXJlbmNlLiAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAnY29sbGVjdGlvbic7XG4gICAgfVxuICAgIC8qKiBUaGUgY29sbGVjdGlvbidzIGlkZW50aWZpZXIuICovXG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVlcnkucGF0aC5sYXN0U2VnbWVudCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHBhdGggb2YgdGhlIHJlZmVyZW5jZWQgY29sbGVjdGlvbiAocmVsYXRpdmVcbiAgICAgKiB0byB0aGUgcm9vdCBvZiB0aGUgZGF0YWJhc2UpLlxuICAgICAqL1xuICAgIGdldCBwYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVlcnkucGF0aC5jYW5vbmljYWxTdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGNvbnRhaW5pbmcgYERvY3VtZW50UmVmZXJlbmNlYCBpZiB0aGlzIGlzIGFcbiAgICAgKiBzdWJjb2xsZWN0aW9uLiBJZiB0aGlzIGlzbid0IGEgc3ViY29sbGVjdGlvbiwgdGhlIHJlZmVyZW5jZSBpcyBudWxsLlxuICAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSB0aGlzLl9wYXRoLnBvcExhc3QoKTtcbiAgICAgICAgaWYgKHBhcmVudFBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRSZWZlcmVuY2UodGhpcy5maXJlc3RvcmUsIFxuICAgICAgICAgICAgLyogY29udmVydGVyPSAqLyBudWxsLCBuZXcgRG9jdW1lbnRLZXkocGFyZW50UGF0aCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdpdGhDb252ZXJ0ZXIoY29udmVydGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29sbGVjdGlvblJlZmVyZW5jZSh0aGlzLmZpcmVzdG9yZSwgY29udmVydGVyLCB0aGlzLl9wYXRoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb2xsZWN0aW9uKHBhcmVudCwgcGF0aCwgLi4ucGF0aFNlZ21lbnRzKSB7XG4gICAgcGFyZW50ID0gZ2V0TW9kdWxhckluc3RhbmNlKHBhcmVudCk7XG4gICAgdmFsaWRhdGVOb25FbXB0eUFyZ3VtZW50KCdjb2xsZWN0aW9uJywgJ3BhdGgnLCBwYXRoKTtcbiAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgRmlyZXN0b3JlJDEpIHtcbiAgICAgICAgY29uc3QgYWJzb2x1dGVQYXRoID0gUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcocGF0aCwgLi4ucGF0aFNlZ21lbnRzKTtcbiAgICAgICAgdmFsaWRhdGVDb2xsZWN0aW9uUGF0aChhYnNvbHV0ZVBhdGgpO1xuICAgICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25SZWZlcmVuY2UocGFyZW50LCAvKiBjb252ZXJ0ZXI9ICovIG51bGwsIGFic29sdXRlUGF0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIShwYXJlbnQgaW5zdGFuY2VvZiBEb2N1bWVudFJlZmVyZW5jZSkgJiZcbiAgICAgICAgICAgICEocGFyZW50IGluc3RhbmNlb2YgQ29sbGVjdGlvblJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBjb2xsZWN0aW9uKCkgdG8gYmUgYSBDb2xsZWN0aW9uUmVmZXJlbmNlLCAnICtcbiAgICAgICAgICAgICAgICAnYSBEb2N1bWVudFJlZmVyZW5jZSBvciBGaXJlYmFzZUZpcmVzdG9yZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFic29sdXRlUGF0aCA9IHBhcmVudC5fcGF0aC5jaGlsZChSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhwYXRoLCAuLi5wYXRoU2VnbWVudHMpKTtcbiAgICAgICAgdmFsaWRhdGVDb2xsZWN0aW9uUGF0aChhYnNvbHV0ZVBhdGgpO1xuICAgICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25SZWZlcmVuY2UocGFyZW50LmZpcmVzdG9yZSwgXG4gICAgICAgIC8qIGNvbnZlcnRlcj0gKi8gbnVsbCwgYWJzb2x1dGVQYXRoKTtcbiAgICB9XG59XG4vLyBUT0RPKGZpcmVzdG9yZWxpdGUpOiBDb25zaWRlciB1c2luZyBFcnJvckZhY3RvcnkgLVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2ZpcmViYXNlLWpzLXNkay9ibG9iLzAxMzFlMWYvcGFja2FnZXMvdXRpbC9zcmMvZXJyb3JzLnRzI0wxMDZcbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyBgUXVlcnlgIGluc3RhbmNlIHRoYXQgaW5jbHVkZXMgYWxsIGRvY3VtZW50cyBpbiB0aGVcbiAqIGRhdGFiYXNlIHRoYXQgYXJlIGNvbnRhaW5lZCBpbiBhIGNvbGxlY3Rpb24gb3Igc3ViY29sbGVjdGlvbiB3aXRoIHRoZVxuICogZ2l2ZW4gYGNvbGxlY3Rpb25JZGAuXG4gKlxuICogQHBhcmFtIGZpcmVzdG9yZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSByb290IGBGaXJlc3RvcmVgIGluc3RhbmNlLlxuICogQHBhcmFtIGNvbGxlY3Rpb25JZCAtIElkZW50aWZpZXMgdGhlIGNvbGxlY3Rpb25zIHRvIHF1ZXJ5IG92ZXIuIEV2ZXJ5XG4gKiBjb2xsZWN0aW9uIG9yIHN1YmNvbGxlY3Rpb24gd2l0aCB0aGlzIElEIGFzIHRoZSBsYXN0IHNlZ21lbnQgb2YgaXRzIHBhdGhcbiAqIHdpbGwgYmUgaW5jbHVkZWQuIENhbm5vdCBjb250YWluIGEgc2xhc2guXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBgUXVlcnlgLlxuICovXG5mdW5jdGlvbiBjb2xsZWN0aW9uR3JvdXAoZmlyZXN0b3JlLCBjb2xsZWN0aW9uSWQpIHtcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlJDEpO1xuICAgIHZhbGlkYXRlTm9uRW1wdHlBcmd1bWVudCgnY29sbGVjdGlvbkdyb3VwJywgJ2NvbGxlY3Rpb24gaWQnLCBjb2xsZWN0aW9uSWQpO1xuICAgIGlmIChjb2xsZWN0aW9uSWQuaW5kZXhPZignLycpID49IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgY29sbGVjdGlvbiBJRCAnJHtjb2xsZWN0aW9uSWR9JyBwYXNzZWQgdG8gZnVuY3Rpb24gYCArXG4gICAgICAgICAgICBgY29sbGVjdGlvbkdyb3VwKCkuIENvbGxlY3Rpb24gSURzIG11c3Qgbm90IGNvbnRhaW4gJy8nLmApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFF1ZXJ5KGZpcmVzdG9yZSwgXG4gICAgLyogY29udmVydGVyPSAqLyBudWxsLCBuZXdRdWVyeUZvckNvbGxlY3Rpb25Hcm91cChjb2xsZWN0aW9uSWQpKTtcbn1cbmZ1bmN0aW9uIGRvYyhwYXJlbnQsIHBhdGgsIC4uLnBhdGhTZWdtZW50cykge1xuICAgIHBhcmVudCA9IGdldE1vZHVsYXJJbnN0YW5jZShwYXJlbnQpO1xuICAgIC8vIFdlIGFsbG93IG9taXNzaW9uIG9mICdwYXRoU3RyaW5nJyBidXQgZXhwbGljaXRseSBwcm9oaWJpdCBwYXNzaW5nIGluIGJvdGhcbiAgICAvLyAndW5kZWZpbmVkJyBhbmQgJ251bGwnLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHBhdGggPSBBdXRvSWQubmV3SWQoKTtcbiAgICB9XG4gICAgdmFsaWRhdGVOb25FbXB0eUFyZ3VtZW50KCdkb2MnLCAncGF0aCcsIHBhdGgpO1xuICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBGaXJlc3RvcmUkMSkge1xuICAgICAgICBjb25zdCBhYnNvbHV0ZVBhdGggPSBSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhwYXRoLCAuLi5wYXRoU2VnbWVudHMpO1xuICAgICAgICB2YWxpZGF0ZURvY3VtZW50UGF0aChhYnNvbHV0ZVBhdGgpO1xuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50UmVmZXJlbmNlKHBhcmVudCwgXG4gICAgICAgIC8qIGNvbnZlcnRlcj0gKi8gbnVsbCwgbmV3IERvY3VtZW50S2V5KGFic29sdXRlUGF0aCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCEocGFyZW50IGluc3RhbmNlb2YgRG9jdW1lbnRSZWZlcmVuY2UpICYmXG4gICAgICAgICAgICAhKHBhcmVudCBpbnN0YW5jZW9mIENvbGxlY3Rpb25SZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gY29sbGVjdGlvbigpIHRvIGJlIGEgQ29sbGVjdGlvblJlZmVyZW5jZSwgJyArXG4gICAgICAgICAgICAgICAgJ2EgRG9jdW1lbnRSZWZlcmVuY2Ugb3IgRmlyZWJhc2VGaXJlc3RvcmUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhYnNvbHV0ZVBhdGggPSBwYXJlbnQuX3BhdGguY2hpbGQoUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcocGF0aCwgLi4ucGF0aFNlZ21lbnRzKSk7XG4gICAgICAgIHZhbGlkYXRlRG9jdW1lbnRQYXRoKGFic29sdXRlUGF0aCk7XG4gICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRSZWZlcmVuY2UocGFyZW50LmZpcmVzdG9yZSwgcGFyZW50IGluc3RhbmNlb2YgQ29sbGVjdGlvblJlZmVyZW5jZSA/IHBhcmVudC5jb252ZXJ0ZXIgOiBudWxsLCBuZXcgRG9jdW1lbnRLZXkoYWJzb2x1dGVQYXRoKSk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIHJlZmVyZW5jZXMgYXJlIGVxdWFsLlxuICpcbiAqIEBwYXJhbSBsZWZ0IC0gQSByZWZlcmVuY2UgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSByaWdodCAtIEEgcmVmZXJlbmNlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSByZWZlcmVuY2VzIHBvaW50IHRvIHRoZSBzYW1lIGxvY2F0aW9uIGluIHRoZSBzYW1lXG4gKiBGaXJlc3RvcmUgZGF0YWJhc2UuXG4gKi9cbmZ1bmN0aW9uIHJlZkVxdWFsKGxlZnQsIHJpZ2h0KSB7XG4gICAgbGVmdCA9IGdldE1vZHVsYXJJbnN0YW5jZShsZWZ0KTtcbiAgICByaWdodCA9IGdldE1vZHVsYXJJbnN0YW5jZShyaWdodCk7XG4gICAgaWYgKChsZWZ0IGluc3RhbmNlb2YgRG9jdW1lbnRSZWZlcmVuY2UgfHxcbiAgICAgICAgbGVmdCBpbnN0YW5jZW9mIENvbGxlY3Rpb25SZWZlcmVuY2UpICYmXG4gICAgICAgIChyaWdodCBpbnN0YW5jZW9mIERvY3VtZW50UmVmZXJlbmNlIHx8IHJpZ2h0IGluc3RhbmNlb2YgQ29sbGVjdGlvblJlZmVyZW5jZSkpIHtcbiAgICAgICAgcmV0dXJuIChsZWZ0LmZpcmVzdG9yZSA9PT0gcmlnaHQuZmlyZXN0b3JlICYmXG4gICAgICAgICAgICBsZWZ0LnBhdGggPT09IHJpZ2h0LnBhdGggJiZcbiAgICAgICAgICAgIGxlZnQuY29udmVydGVyID09PSByaWdodC5jb252ZXJ0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgcXVlcmllcyBwb2ludCB0byB0aGUgc2FtZSBjb2xsZWN0aW9uIGFuZCBhcHBseVxuICogdGhlIHNhbWUgY29uc3RyYWludHMuXG4gKlxuICogQHBhcmFtIGxlZnQgLSBBIGBRdWVyeWAgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSByaWdodCAtIEEgYFF1ZXJ5YCB0byBjb21wYXJlLlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcmVmZXJlbmNlcyBwb2ludCB0byB0aGUgc2FtZSBsb2NhdGlvbiBpbiB0aGUgc2FtZVxuICogRmlyZXN0b3JlIGRhdGFiYXNlLlxuICovXG5mdW5jdGlvbiBxdWVyeUVxdWFsKGxlZnQsIHJpZ2h0KSB7XG4gICAgbGVmdCA9IGdldE1vZHVsYXJJbnN0YW5jZShsZWZ0KTtcbiAgICByaWdodCA9IGdldE1vZHVsYXJJbnN0YW5jZShyaWdodCk7XG4gICAgaWYgKGxlZnQgaW5zdGFuY2VvZiBRdWVyeSAmJiByaWdodCBpbnN0YW5jZW9mIFF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiAobGVmdC5maXJlc3RvcmUgPT09IHJpZ2h0LmZpcmVzdG9yZSAmJlxuICAgICAgICAgICAgcXVlcnlFcXVhbHMobGVmdC5fcXVlcnksIHJpZ2h0Ll9xdWVyeSkgJiZcbiAgICAgICAgICAgIGxlZnQuY29udmVydGVyID09PSByaWdodC5jb252ZXJ0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBMT0dfVEFHID0gJ0FzeW5jUXVldWUnO1xuY2xhc3MgQXN5bmNRdWV1ZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHRhaWwgPSBQcm9taXNlLnJlc29sdmUoKSkge1xuICAgICAgICAvLyBBIGxpc3Qgb2YgcmV0cnlhYmxlIG9wZXJhdGlvbnMuIFJldHJ5YWJsZSBvcGVyYXRpb25zIGFyZSBydW4gaW4gb3JkZXIgYW5kXG4gICAgICAgIC8vIHJldHJpZWQgd2l0aCBiYWNrb2ZmLlxuICAgICAgICB0aGlzLnJldHJ5YWJsZU9wcyA9IFtdO1xuICAgICAgICAvLyBJcyB0aGlzIEFzeW5jUXVldWUgYmVpbmcgc2h1dCBkb3duPyBPbmNlIGl0IGlzIHNldCB0byB0cnVlLCBpdCB3aWxsIG5vdFxuICAgICAgICAvLyBiZSBjaGFuZ2VkIGFnYWluLlxuICAgICAgICB0aGlzLl9pc1NodXR0aW5nRG93biA9IGZhbHNlO1xuICAgICAgICAvLyBPcGVyYXRpb25zIHNjaGVkdWxlZCB0byBiZSBxdWV1ZWQgaW4gdGhlIGZ1dHVyZS4gT3BlcmF0aW9ucyBhcmVcbiAgICAgICAgLy8gYXV0b21hdGljYWxseSByZW1vdmVkIGFmdGVyIHRoZXkgYXJlIHJ1biBvciBjYW5jZWxlZC5cbiAgICAgICAgdGhpcy5kZWxheWVkT3BlcmF0aW9ucyA9IFtdO1xuICAgICAgICAvLyB2aXNpYmxlIGZvciB0ZXN0aW5nXG4gICAgICAgIHRoaXMuZmFpbHVyZSA9IG51bGw7XG4gICAgICAgIC8vIEZsYWcgc2V0IHdoaWxlIHRoZXJlJ3MgYW4gb3V0c3RhbmRpbmcgQXN5bmNRdWV1ZSBvcGVyYXRpb24sIHVzZWQgZm9yXG4gICAgICAgIC8vIGFzc2VydGlvbiBzYW5pdHktY2hlY2tzLlxuICAgICAgICB0aGlzLm9wZXJhdGlvbkluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgLy8gRW5hYmxlZCBkdXJpbmcgc2h1dGRvd24gb24gU2FmYXJpIHRvIHByZXZlbnQgZnV0dXJlIGFjY2VzcyB0byBJbmRleGVkREIuXG4gICAgICAgIHRoaXMuc2tpcE5vblJlc3RyaWN0ZWRUYXNrcyA9IGZhbHNlO1xuICAgICAgICAvLyBMaXN0IG9mIFRpbWVySWRzIHRvIGZhc3QtZm9yd2FyZCBkZWxheXMgZm9yLlxuICAgICAgICB0aGlzLnRpbWVySWRzVG9Ta2lwID0gW107XG4gICAgICAgIC8vIEJhY2tvZmYgdGltZXIgdXNlZCB0byBzY2hlZHVsZSByZXRyaWVzIGZvciByZXRyeWFibGUgb3BlcmF0aW9uc1xuICAgICAgICB0aGlzLmJhY2tvZmYgPSBuZXcgRXhwb25lbnRpYWxCYWNrb2ZmKHRoaXMsIFwiYXN5bmNfcXVldWVfcmV0cnlcIiAvKiBUaW1lcklkLkFzeW5jUXVldWVSZXRyeSAqLyk7XG4gICAgICAgIC8vIFZpc2liaWxpdHkgaGFuZGxlciB0aGF0IHRyaWdnZXJzIGFuIGltbWVkaWF0ZSByZXRyeSBvZiBhbGwgcmV0cnlhYmxlXG4gICAgICAgIC8vIG9wZXJhdGlvbnMuIE1lYW50IHRvIHNwZWVkIHVwIHJlY292ZXJ5IHdoZW4gd2UgcmVnYWluIGZpbGUgc3lzdGVtIGFjY2Vzc1xuICAgICAgICAvLyBhZnRlciBwYWdlIGNvbWVzIGludG8gZm9yZWdyb3VuZC5cbiAgICAgICAgdGhpcy52aXNpYmlsaXR5SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYmFja29mZi5za2lwQmFja29mZigpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRhaWwgPSB0YWlsO1xuICAgIH1cbiAgICBnZXQgaXNTaHV0dGluZ0Rvd24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1NodXR0aW5nRG93bjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBvcGVyYXRpb24gdG8gdGhlIHF1ZXVlIHdpdGhvdXQgd2FpdGluZyBmb3IgaXQgdG8gY29tcGxldGUgKGkuZS5cbiAgICAgKiB3ZSBpZ25vcmUgdGhlIFByb21pc2UgcmVzdWx0KS5cbiAgICAgKi9cbiAgICBlbnF1ZXVlQW5kRm9yZ2V0KG9wKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICAgICAgdGhpcy5lbnF1ZXVlKG9wKTtcbiAgICB9XG4gICAgZW5xdWV1ZUFuZEZvcmdldEV2ZW5XaGlsZVJlc3RyaWN0ZWQob3ApIHtcbiAgICAgICAgdGhpcy52ZXJpZnlOb3RGYWlsZWQoKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICB0aGlzLmVucXVldWVJbnRlcm5hbChvcCk7XG4gICAgfVxuICAgIGVudGVyUmVzdHJpY3RlZE1vZGUocHVyZ2VFeGlzdGluZ1Rhc2tzKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNTaHV0dGluZ0Rvd24pIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2h1dHRpbmdEb3duID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2tpcE5vblJlc3RyaWN0ZWRUYXNrcyA9IHB1cmdlRXhpc3RpbmdUYXNrcyB8fCBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbnF1ZXVlKG9wKSB7XG4gICAgICAgIHRoaXMudmVyaWZ5Tm90RmFpbGVkKCk7XG4gICAgICAgIGlmICh0aGlzLl9pc1NodXR0aW5nRG93bikge1xuICAgICAgICAgICAgLy8gUmV0dXJuIGEgUHJvbWlzZSB3aGljaCBuZXZlciByZXNvbHZlcy5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7IH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIGRlZmVycmVkIFByb21pc2UgdGhhdCB3ZSBjYW4gcmV0dXJuIHRvIHRoZSBjYWxsZWUuIFRoaXNcbiAgICAgICAgLy8gYWxsb3dzIHVzIHRvIHJldHVybiBhIFwiaGFuZ2luZyBQcm9taXNlXCIgb25seSB0byB0aGUgY2FsbGVlIGFuZCBzdGlsbFxuICAgICAgICAvLyBhZHZhbmNlIHRoZSBxdWV1ZSBldmVuIHdoZW4gdGhlIG9wZXJhdGlvbiBpcyBub3QgcnVuLlxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmVucXVldWVJbnRlcm5hbCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNTaHV0dGluZ0Rvd24gJiYgdGhpcy5za2lwTm9uUmVzdHJpY3RlZFRhc2tzKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG8gbm90IHJlc29sdmUgJ3Rhc2snXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AoKS50aGVuKHRhc2sucmVzb2x2ZSwgdGFzay5yZWplY3QpO1xuICAgICAgICAgICAgcmV0dXJuIHRhc2sucHJvbWlzZTtcbiAgICAgICAgfSkudGhlbigoKSA9PiB0YXNrLnByb21pc2UpO1xuICAgIH1cbiAgICBlbnF1ZXVlUmV0cnlhYmxlKG9wKSB7XG4gICAgICAgIHRoaXMuZW5xdWV1ZUFuZEZvcmdldCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJldHJ5YWJsZU9wcy5wdXNoKG9wKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldHJ5TmV4dE9wKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW5zIHRoZSBuZXh0IG9wZXJhdGlvbiBmcm9tIHRoZSByZXRyeWFibGUgcXVldWUuIElmIHRoZSBvcGVyYXRpb24gZmFpbHMsXG4gICAgICogcmVzY2hlZHVsZXMgd2l0aCBiYWNrb2ZmLlxuICAgICAqL1xuICAgIGFzeW5jIHJldHJ5TmV4dE9wKCkge1xuICAgICAgICBpZiAodGhpcy5yZXRyeWFibGVPcHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmV0cnlhYmxlT3BzWzBdKCk7XG4gICAgICAgICAgICB0aGlzLnJldHJ5YWJsZU9wcy5zaGlmdCgpO1xuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChpc0luZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoZSkpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHLCAnT3BlcmF0aW9uIGZhaWxlZCB3aXRoIHJldHJ5YWJsZSBlcnJvcjogJyArIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTsgLy8gRmFpbHVyZSB3aWxsIGJlIGhhbmRsZWQgYnkgQXN5bmNRdWV1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJldHJ5YWJsZU9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgYWRkaXRpb25hbCBvcGVyYXRpb25zLCB3ZSByZS1zY2hlZHVsZSBgcmV0cnlOZXh0T3AoKWAuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSB0byBydW4gcmV0cnlhYmxlIG9wZXJhdGlvbnMgdGhhdCBmYWlsZWQgZHVyaW5nXG4gICAgICAgICAgICAvLyB0aGVpciBpbml0aWFsIGF0dGVtcHQgc2luY2Ugd2UgZG9uJ3Qga25vdyB3aGV0aGVyIHRoZXkgYXJlIGFscmVhZHlcbiAgICAgICAgICAgIC8vIGVucXVldWVkLiBJZiwgZm9yIGV4YW1wbGUsIGBvcDFgLCBgb3AyYCwgYG9wM2AgYXJlIGVucXVldWVkIGFuZCBgb3AxYFxuICAgICAgICAgICAgLy8gbmVlZHMgdG8gIGJlIHJlLXJ1biwgd2Ugd2lsbCBydW4gYG9wMWAsIGBvcDFgLCBgb3AyYCB1c2luZyB0aGVcbiAgICAgICAgICAgIC8vIGFscmVhZHkgZW5xdWV1ZWQgY2FsbHMgdG8gYHJldHJ5TmV4dE9wKClgLiBgb3AzKClgIHdpbGwgdGhlbiBydW4gaW4gdGhlXG4gICAgICAgICAgICAvLyBjYWxsIHNjaGVkdWxlZCBoZXJlLlxuICAgICAgICAgICAgLy8gU2luY2UgYGJhY2tvZmZBbmRSdW4oKWAgY2FuY2VscyBhbiBleGlzdGluZyBiYWNrb2ZmIGFuZCBzY2hlZHVsZXMgYVxuICAgICAgICAgICAgLy8gbmV3IGJhY2tvZmYgb24gZXZlcnkgY2FsbCwgdGhlcmUgaXMgb25seSBldmVyIGEgc2luZ2xlIGFkZGl0aW9uYWxcbiAgICAgICAgICAgIC8vIG9wZXJhdGlvbiBpbiB0aGUgcXVldWUuXG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYuYmFja29mZkFuZFJ1bigoKSA9PiB0aGlzLnJldHJ5TmV4dE9wKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVucXVldWVJbnRlcm5hbChvcCkge1xuICAgICAgICBjb25zdCBuZXdUYWlsID0gdGhpcy50YWlsLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vcGVyYXRpb25JblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBvcCgpXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZmFpbHVyZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgIHRoaXMub3BlcmF0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnZXRNZXNzYWdlT3JTdGFjayhlcnJvcik7XG4gICAgICAgICAgICAgICAgbG9nRXJyb3IoJ0lOVEVSTkFMIFVOSEFORExFRCBFUlJPUjogJywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgLy8gUmUtdGhyb3cgdGhlIGVycm9yIHNvIHRoYXQgdGhpcy50YWlsIGJlY29tZXMgYSByZWplY3RlZCBQcm9taXNlIGFuZFxuICAgICAgICAgICAgICAgIC8vIGFsbCBmdXJ0aGVyIGF0dGVtcHRzIHRvIGNoYWluICh2aWEgLnRoZW4pIHdpbGwganVzdCBzaG9ydC1jaXJjdWl0XG4gICAgICAgICAgICAgICAgLy8gYW5kIHJldHVybiB0aGUgcmVqZWN0ZWQgUHJvbWlzZS5cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZXJhdGlvbkluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRhaWwgPSBuZXdUYWlsO1xuICAgICAgICByZXR1cm4gbmV3VGFpbDtcbiAgICB9XG4gICAgZW5xdWV1ZUFmdGVyRGVsYXkodGltZXJJZCwgZGVsYXlNcywgb3ApIHtcbiAgICAgICAgdGhpcy52ZXJpZnlOb3RGYWlsZWQoKTtcbiAgICAgICAgLy8gRmFzdC1mb3J3YXJkIGRlbGF5cyBmb3IgdGltZXJJZHMgdGhhdCBoYXZlIGJlZW4gb3ZlcnJpZGRlbi5cbiAgICAgICAgaWYgKHRoaXMudGltZXJJZHNUb1NraXAuaW5kZXhPZih0aW1lcklkKSA+IC0xKSB7XG4gICAgICAgICAgICBkZWxheU1zID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWxheWVkT3AgPSBEZWxheWVkT3BlcmF0aW9uLmNyZWF0ZUFuZFNjaGVkdWxlKHRoaXMsIHRpbWVySWQsIGRlbGF5TXMsIG9wLCByZW1vdmVkT3AgPT4gdGhpcy5yZW1vdmVEZWxheWVkT3BlcmF0aW9uKHJlbW92ZWRPcCkpO1xuICAgICAgICB0aGlzLmRlbGF5ZWRPcGVyYXRpb25zLnB1c2goZGVsYXllZE9wKTtcbiAgICAgICAgcmV0dXJuIGRlbGF5ZWRPcDtcbiAgICB9XG4gICAgdmVyaWZ5Tm90RmFpbGVkKCkge1xuICAgICAgICBpZiAodGhpcy5mYWlsdXJlKSB7XG4gICAgICAgICAgICBmYWlsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmVyaWZ5T3BlcmF0aW9uSW5Qcm9ncmVzcygpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdHMgdW50aWwgYWxsIGN1cnJlbnRseSBxdWV1ZWQgdGFza3MgYXJlIGZpbmlzaGVkIGV4ZWN1dGluZy4gRGVsYXllZFxuICAgICAqIG9wZXJhdGlvbnMgYXJlIG5vdCBydW4uXG4gICAgICovXG4gICAgYXN5bmMgZHJhaW4oKSB7XG4gICAgICAgIC8vIE9wZXJhdGlvbnMgaW4gdGhlIHF1ZXVlIHByaW9yIHRvIGRyYWluaW5nIG1heSBoYXZlIGVucXVldWVkIGFkZGl0aW9uYWxcbiAgICAgICAgLy8gb3BlcmF0aW9ucy4gS2VlcCBkcmFpbmluZyB0aGUgcXVldWUgdW50aWwgdGhlIHRhaWwgaXMgbm8gbG9uZ2VyIGFkdmFuY2VkLFxuICAgICAgICAvLyB3aGljaCBpbmRpY2F0ZXMgdGhhdCBubyBtb3JlIG5ldyBvcGVyYXRpb25zIHdlcmUgZW5xdWV1ZWQgYW5kIHRoYXQgYWxsXG4gICAgICAgIC8vIG9wZXJhdGlvbnMgd2VyZSBleGVjdXRlZC5cbiAgICAgICAgbGV0IGN1cnJlbnRUYWlsO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjdXJyZW50VGFpbCA9IHRoaXMudGFpbDtcbiAgICAgICAgICAgIGF3YWl0IGN1cnJlbnRUYWlsO1xuICAgICAgICB9IHdoaWxlIChjdXJyZW50VGFpbCAhPT0gdGhpcy50YWlsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yIFRlc3RzOiBEZXRlcm1pbmUgaWYgYSBkZWxheWVkIG9wZXJhdGlvbiB3aXRoIGEgcGFydGljdWxhciBUaW1lcklkXG4gICAgICogZXhpc3RzLlxuICAgICAqL1xuICAgIGNvbnRhaW5zRGVsYXllZE9wZXJhdGlvbih0aW1lcklkKSB7XG4gICAgICAgIGZvciAoY29uc3Qgb3Agb2YgdGhpcy5kZWxheWVkT3BlcmF0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wLnRpbWVySWQgPT09IHRpbWVySWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciBUZXN0czogUnVucyBzb21lIG9yIGFsbCBkZWxheWVkIG9wZXJhdGlvbnMgZWFybHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGFzdFRpbWVySWQgLSBEZWxheWVkIG9wZXJhdGlvbnMgdXAgdG8gYW5kIGluY2x1ZGluZyB0aGlzIFRpbWVySWRcbiAgICAgKiB3aWxsIGJlIGRyYWluZWQuIFBhc3MgVGltZXJJZC5BbGwgdG8gcnVuIGFsbCBkZWxheWVkIG9wZXJhdGlvbnMuXG4gICAgICogQHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25jZSBhbGwgb3BlcmF0aW9ucyBoYXZlIGJlZW4gcnVuLlxuICAgICAqL1xuICAgIHJ1bkFsbERlbGF5ZWRPcGVyYXRpb25zVW50aWwobGFzdFRpbWVySWQpIHtcbiAgICAgICAgLy8gTm90ZSB0aGF0IGRyYWluaW5nIG1heSBnZW5lcmF0ZSBtb3JlIGRlbGF5ZWQgb3BzLCBzbyB3ZSBkbyB0aGF0IGZpcnN0LlxuICAgICAgICByZXR1cm4gdGhpcy5kcmFpbigpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gUnVuIG9wcyBpbiB0aGUgc2FtZSBvcmRlciB0aGV5J2QgcnVuIGlmIHRoZXkgcmFuIG5hdHVyYWxseS5cbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXMgKi9cbiAgICAgICAgICAgIHRoaXMuZGVsYXllZE9wZXJhdGlvbnMuc29ydCgoYSwgYikgPT4gYS50YXJnZXRUaW1lTXMgLSBiLnRhcmdldFRpbWVNcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wIG9mIHRoaXMuZGVsYXllZE9wZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBvcC5za2lwRGVsYXkoKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFRpbWVySWQgIT09IFwiYWxsXCIgLyogVGltZXJJZC5BbGwgKi8gJiYgb3AudGltZXJJZCA9PT0gbGFzdFRpbWVySWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHJhaW4oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciBUZXN0czogU2tpcCBhbGwgc3Vic2VxdWVudCBkZWxheXMgZm9yIGEgdGltZXIgaWQuXG4gICAgICovXG4gICAgc2tpcERlbGF5c0ZvclRpbWVySWQodGltZXJJZCkge1xuICAgICAgICB0aGlzLnRpbWVySWRzVG9Ta2lwLnB1c2godGltZXJJZCk7XG4gICAgfVxuICAgIC8qKiBDYWxsZWQgb25jZSBhIERlbGF5ZWRPcGVyYXRpb24gaXMgcnVuIG9yIGNhbmNlbGVkLiAqL1xuICAgIHJlbW92ZURlbGF5ZWRPcGVyYXRpb24ob3ApIHtcbiAgICAgICAgLy8gTk9URTogaW5kZXhPZiAvIHNsaWNlIGFyZSBPKG4pLCBidXQgZGVsYXllZE9wZXJhdGlvbnMgaXMgZXhwZWN0ZWQgdG8gYmUgc21hbGwuXG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5kZWxheWVkT3BlcmF0aW9ucy5pbmRleE9mKG9wKTtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlcyAqL1xuICAgICAgICB0aGlzLmRlbGF5ZWRPcGVyYXRpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxufVxuLyoqXG4gKiBDaHJvbWUgaW5jbHVkZXMgRXJyb3IubWVzc2FnZSBpbiBFcnJvci5zdGFjay4gT3RoZXIgYnJvd3NlcnMgZG8gbm90LlxuICogVGhpcyByZXR1cm5zIGV4cGVjdGVkIG91dHB1dCBvZiBtZXNzYWdlICsgc3RhY2sgd2hlbiBhdmFpbGFibGUuXG4gKiBAcGFyYW0gZXJyb3IgLSBFcnJvciBvciBGaXJlc3RvcmVFcnJvclxuICovXG5mdW5jdGlvbiBnZXRNZXNzYWdlT3JTdGFjayhlcnJvcikge1xuICAgIGxldCBtZXNzYWdlID0gZXJyb3IubWVzc2FnZSB8fCAnJztcbiAgICBpZiAoZXJyb3Iuc3RhY2spIHtcbiAgICAgICAgaWYgKGVycm9yLnN0YWNrLmluY2x1ZGVzKGVycm9yLm1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZXJyb3Iuc3RhY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZXJyb3IubWVzc2FnZSArICdcXG4nICsgZXJyb3Iuc3RhY2s7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHRhc2sgb2YgbG9hZGluZyBhIEZpcmVzdG9yZSBidW5kbGUuIEl0IHByb3ZpZGVzIHByb2dyZXNzIG9mIGJ1bmRsZVxuICogbG9hZGluZywgYXMgd2VsbCBhcyB0YXNrIGNvbXBsZXRpb24gYW5kIGVycm9yIGV2ZW50cy5cbiAqXG4gKiBUaGUgQVBJIGlzIGNvbXBhdGlibGUgd2l0aCBgUHJvbWlzZTxMb2FkQnVuZGxlVGFza1Byb2dyZXNzPmAuXG4gKi9cbmNsYXNzIExvYWRCdW5kbGVUYXNrIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NPYnNlcnZlciA9IHt9O1xuICAgICAgICB0aGlzLl90YXNrQ29tcGxldGlvblJlc29sdmVyID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgIHRoaXMuX2xhc3RQcm9ncmVzcyA9IHtcbiAgICAgICAgICAgIHRhc2tTdGF0ZTogJ1J1bm5pbmcnLFxuICAgICAgICAgICAgdG90YWxCeXRlczogMCxcbiAgICAgICAgICAgIHRvdGFsRG9jdW1lbnRzOiAwLFxuICAgICAgICAgICAgYnl0ZXNMb2FkZWQ6IDAsXG4gICAgICAgICAgICBkb2N1bWVudHNMb2FkZWQ6IDBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGZ1bmN0aW9ucyB0byBsaXN0ZW4gdG8gYnVuZGxlIGxvYWRpbmcgcHJvZ3Jlc3MgZXZlbnRzLlxuICAgICAqIEBwYXJhbSBuZXh0IC0gQ2FsbGVkIHdoZW4gdGhlcmUgaXMgYSBwcm9ncmVzcyB1cGRhdGUgZnJvbSBidW5kbGUgbG9hZGluZy4gVHlwaWNhbGx5IGBuZXh0YCBjYWxscyBvY2N1clxuICAgICAqICAgZWFjaCB0aW1lIGEgRmlyZXN0b3JlIGRvY3VtZW50IGlzIGxvYWRlZCBmcm9tIHRoZSBidW5kbGUuXG4gICAgICogQHBhcmFtIGVycm9yIC0gQ2FsbGVkIHdoZW4gYW4gZXJyb3Igb2NjdXJzIGR1cmluZyBidW5kbGUgbG9hZGluZy4gVGhlIHRhc2sgYWJvcnRzIGFmdGVyIHJlcG9ydGluZyB0aGVcbiAgICAgKiAgIGVycm9yLCBhbmQgdGhlcmUgc2hvdWxkIGJlIG5vIG1vcmUgdXBkYXRlcyBhZnRlciB0aGlzLlxuICAgICAqIEBwYXJhbSBjb21wbGV0ZSAtIENhbGxlZCB3aGVuIHRoZSBsb2FkaW5nIHRhc2sgaXMgY29tcGxldGUuXG4gICAgICovXG4gICAgb25Qcm9ncmVzcyhuZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NPYnNlcnZlciA9IHtcbiAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIGNvbXBsZXRlXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgdGhlIGBQcm9taXNlPExvYWRCdW5kbGVUYXNrUHJvZ3Jlc3M+LmNhdGNoYCBpbnRlcmZhY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb25SZWplY3RlZCAtIENhbGxlZCB3aGVuIGFuIGVycm9yIG9jY3VycyBkdXJpbmcgYnVuZGxlIGxvYWRpbmcuXG4gICAgICovXG4gICAgY2F0Y2gob25SZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFza0NvbXBsZXRpb25SZXNvbHZlci5wcm9taXNlLmNhdGNoKG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIHRoZSBgUHJvbWlzZTxMb2FkQnVuZGxlVGFza1Byb2dyZXNzPi50aGVuYCBpbnRlcmZhY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb25GdWxmaWxsZWQgLSBDYWxsZWQgb24gdGhlIGNvbXBsZXRpb24gb2YgdGhlIGxvYWRpbmcgdGFzayB3aXRoIGEgZmluYWwgYExvYWRCdW5kbGVUYXNrUHJvZ3Jlc3NgIHVwZGF0ZS5cbiAgICAgKiAgIFRoZSB1cGRhdGUgd2lsbCBhbHdheXMgaGF2ZSBpdHMgYHRhc2tTdGF0ZWAgc2V0IHRvIGBcIlN1Y2Nlc3NcImAuXG4gICAgICogQHBhcmFtIG9uUmVqZWN0ZWQgLSBDYWxsZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMgZHVyaW5nIGJ1bmRsZSBsb2FkaW5nLlxuICAgICAqL1xuICAgIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rhc2tDb21wbGV0aW9uUmVzb2x2ZXIucHJvbWlzZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm90aWZpZXMgYWxsIG9ic2VydmVycyB0aGF0IGJ1bmRsZSBsb2FkaW5nIGhhcyBjb21wbGV0ZWQsIHdpdGggYSBwcm92aWRlZFxuICAgICAqIGBMb2FkQnVuZGxlVGFza1Byb2dyZXNzYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jb21wbGV0ZVdpdGgocHJvZ3Jlc3MpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlUHJvZ3Jlc3MocHJvZ3Jlc3MpO1xuICAgICAgICBpZiAodGhpcy5fcHJvZ3Jlc3NPYnNlcnZlci5jb21wbGV0ZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NPYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Rhc2tDb21wbGV0aW9uUmVzb2x2ZXIucmVzb2x2ZShwcm9ncmVzcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIGFsbCBvYnNlcnZlcnMgdGhhdCBidW5kbGUgbG9hZGluZyBoYXMgZmFpbGVkLCB3aXRoIGEgcHJvdmlkZWRcbiAgICAgKiBgRXJyb3JgIGFzIHRoZSByZWFzb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9mYWlsV2l0aChlcnJvcikge1xuICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3MudGFza1N0YXRlID0gJ0Vycm9yJztcbiAgICAgICAgaWYgKHRoaXMuX3Byb2dyZXNzT2JzZXJ2ZXIubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NPYnNlcnZlci5uZXh0KHRoaXMuX2xhc3RQcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Byb2dyZXNzT2JzZXJ2ZXIuZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzT2JzZXJ2ZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Rhc2tDb21wbGV0aW9uUmVzb2x2ZXIucmVqZWN0KGVycm9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm90aWZpZXMgYSBwcm9ncmVzcyB1cGRhdGUgb2YgbG9hZGluZyBhIGJ1bmRsZS5cbiAgICAgKiBAcGFyYW0gcHJvZ3Jlc3MgLSBUaGUgbmV3IHByb2dyZXNzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlUHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcbiAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICAgIGlmICh0aGlzLl9wcm9ncmVzc09ic2VydmVyLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzT2JzZXJ2ZXIubmV4dChwcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIENvbnN0YW50IHVzZWQgdG8gaW5kaWNhdGUgdGhlIExSVSBnYXJiYWdlIGNvbGxlY3Rpb24gc2hvdWxkIGJlIGRpc2FibGVkLlxuICogU2V0IHRoaXMgdmFsdWUgYXMgdGhlIGBjYWNoZVNpemVCeXRlc2Agb24gdGhlIHNldHRpbmdzIHBhc3NlZCB0byB0aGVcbiAqIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlLlxuICovXG5jb25zdCBDQUNIRV9TSVpFX1VOTElNSVRFRCA9IExSVV9DT0xMRUNUSU9OX0RJU0FCTEVEO1xuLyoqXG4gKiBUaGUgQ2xvdWQgRmlyZXN0b3JlIHNlcnZpY2UgaW50ZXJmYWNlLlxuICpcbiAqIERvIG5vdCBjYWxsIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuIEluc3RlYWQsIHVzZSB7QGxpbmsgKGdldEZpcmVzdG9yZToxKX0uXG4gKi9cbmNsYXNzIEZpcmVzdG9yZSBleHRlbmRzIEZpcmVzdG9yZSQxIHtcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xuICAgIGNvbnN0cnVjdG9yKGF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyLCBhcHBDaGVja0NyZWRlbnRpYWxzUHJvdmlkZXIsIGRhdGFiYXNlSWQsIGFwcCkge1xuICAgICAgICBzdXBlcihhdXRoQ3JlZGVudGlhbHNQcm92aWRlciwgYXBwQ2hlY2tDcmVkZW50aWFsc1Byb3ZpZGVyLCBkYXRhYmFzZUlkLCBhcHApO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBpdCdzIGEge0BsaW5rIEZpcmVzdG9yZX0gb3IgRmlyZXN0b3JlIExpdGUgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAnZmlyZXN0b3JlJztcbiAgICAgICAgdGhpcy5fcXVldWUgPSBuZXcgQXN5bmNRdWV1ZUltcGwoKTtcbiAgICAgICAgdGhpcy5fcGVyc2lzdGVuY2VLZXkgPSAoYXBwID09PSBudWxsIHx8IGFwcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXBwLm5hbWUpIHx8ICdbREVGQVVMVF0nO1xuICAgIH1cbiAgICBhc3luYyBfdGVybWluYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5fZmlyZXN0b3JlQ2xpZW50KSB7XG4gICAgICAgICAgICBjb25zdCB0ZXJtaW5hdGUgPSB0aGlzLl9maXJlc3RvcmVDbGllbnQudGVybWluYXRlKCk7XG4gICAgICAgICAgICB0aGlzLl9xdWV1ZSA9IG5ldyBBc3luY1F1ZXVlSW1wbCh0ZXJtaW5hdGUpO1xuICAgICAgICAgICAgdGhpcy5fZmlyZXN0b3JlQ2xpZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgYXdhaXQgdGVybWluYXRlO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgRmlyZXN0b3JlfSB3aXRoIHRoZSBwcm92aWRlZCBzZXR0aW5ncy5cbiAqIENhbiBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgYW55IG90aGVyIGZ1bmN0aW9uLCBpbmNsdWRpbmdcbiAqIHtAbGluayAoZ2V0RmlyZXN0b3JlOjEpfS4gSWYgdGhlIGN1c3RvbSBzZXR0aW5ncyBhcmUgZW1wdHksIHRoaXMgZnVuY3Rpb24gaXNcbiAqIGVxdWl2YWxlbnQgdG8gY2FsbGluZyB7QGxpbmsgKGdldEZpcmVzdG9yZToxKX0uXG4gKlxuICogQHBhcmFtIGFwcCAtIFRoZSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gd2l0aCB3aGljaCB0aGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2Ugd2lsbFxuICogYmUgYXNzb2NpYXRlZC5cbiAqIEBwYXJhbSBzZXR0aW5ncyAtIEEgc2V0dGluZ3Mgb2JqZWN0IHRvIGNvbmZpZ3VyZSB0aGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gZGF0YWJhc2VJZCAtIFRoZSBuYW1lIG9mIHRoZSBkYXRhYmFzZS5cbiAqIEByZXR1cm5zIEEgbmV3bHkgaW5pdGlhbGl6ZWQge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemVGaXJlc3RvcmUoYXBwLCBzZXR0aW5ncywgZGF0YWJhc2VJZCkge1xuICAgIGlmICghZGF0YWJhc2VJZCkge1xuICAgICAgICBkYXRhYmFzZUlkID0gREVGQVVMVF9EQVRBQkFTRV9OQU1FO1xuICAgIH1cbiAgICBjb25zdCBwcm92aWRlciA9IF9nZXRQcm92aWRlcihhcHAsICdmaXJlc3RvcmUnKTtcbiAgICBpZiAocHJvdmlkZXIuaXNJbml0aWFsaXplZChkYXRhYmFzZUlkKSkge1xuICAgICAgICBjb25zdCBleGlzdGluZ0luc3RhbmNlID0gcHJvdmlkZXIuZ2V0SW1tZWRpYXRlKHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6IGRhdGFiYXNlSWRcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGluaXRpYWxTZXR0aW5ncyA9IHByb3ZpZGVyLmdldE9wdGlvbnMoZGF0YWJhc2VJZCk7XG4gICAgICAgIGlmIChkZWVwRXF1YWwoaW5pdGlhbFNldHRpbmdzLCBzZXR0aW5ncykpIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0luc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgJ2luaXRpYWxpemVGaXJlc3RvcmUoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCB3aXRoICcgK1xuICAgICAgICAgICAgICAgICdkaWZmZXJlbnQgb3B0aW9ucy4gVG8gYXZvaWQgdGhpcyBlcnJvciwgY2FsbCBpbml0aWFsaXplRmlyZXN0b3JlKCkgd2l0aCB0aGUgJyArXG4gICAgICAgICAgICAgICAgJ3NhbWUgb3B0aW9ucyBhcyB3aGVuIGl0IHdhcyBvcmlnaW5hbGx5IGNhbGxlZCwgb3IgY2FsbCBnZXRGaXJlc3RvcmUoKSB0byByZXR1cm4gdGhlJyArXG4gICAgICAgICAgICAgICAgJyBhbHJlYWR5IGluaXRpYWxpemVkIGluc3RhbmNlLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzZXR0aW5ncy5jYWNoZVNpemVCeXRlcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHNldHRpbmdzLmxvY2FsQ2FjaGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgY2FjaGUgYW5kIGNhY2hlU2l6ZUJ5dGVzIGNhbm5vdCBiZSBzcGVjaWZpZWQgYXQgdGhlIHNhbWUgdGltZSBhcyBjYWNoZVNpemVCeXRlcyB3aWxsYCArXG4gICAgICAgICAgICBgYmUgZGVwcmVjYXRlZC4gSW5zdGVhZCwgc3BlY2lmeSB0aGUgY2FjaGUgc2l6ZSBpbiB0aGUgY2FjaGUgb2JqZWN0YCk7XG4gICAgfVxuICAgIGlmIChzZXR0aW5ncy5jYWNoZVNpemVCeXRlcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzICE9PSBDQUNIRV9TSVpFX1VOTElNSVRFRCAmJlxuICAgICAgICBzZXR0aW5ncy5jYWNoZVNpemVCeXRlcyA8IExSVV9NSU5JTVVNX0NBQ0hFX1NJWkVfQllURVMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYGNhY2hlU2l6ZUJ5dGVzIG11c3QgYmUgYXQgbGVhc3QgJHtMUlVfTUlOSU1VTV9DQUNIRV9TSVpFX0JZVEVTfWApO1xuICAgIH1cbiAgICByZXR1cm4gcHJvdmlkZXIuaW5pdGlhbGl6ZSh7XG4gICAgICAgIG9wdGlvbnM6IHNldHRpbmdzLFxuICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IGRhdGFiYXNlSWRcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldEZpcmVzdG9yZShhcHBPckRhdGFiYXNlSWQsIG9wdGlvbmFsRGF0YWJhc2VJZCkge1xuICAgIGNvbnN0IGFwcCA9IHR5cGVvZiBhcHBPckRhdGFiYXNlSWQgPT09ICdvYmplY3QnID8gYXBwT3JEYXRhYmFzZUlkIDogZ2V0QXBwKCk7XG4gICAgY29uc3QgZGF0YWJhc2VJZCA9IHR5cGVvZiBhcHBPckRhdGFiYXNlSWQgPT09ICdzdHJpbmcnXG4gICAgICAgID8gYXBwT3JEYXRhYmFzZUlkXG4gICAgICAgIDogb3B0aW9uYWxEYXRhYmFzZUlkIHx8IERFRkFVTFRfREFUQUJBU0VfTkFNRTtcbiAgICBjb25zdCBkYiA9IF9nZXRQcm92aWRlcihhcHAsICdmaXJlc3RvcmUnKS5nZXRJbW1lZGlhdGUoe1xuICAgICAgICBpZGVudGlmaWVyOiBkYXRhYmFzZUlkXG4gICAgfSk7XG4gICAgaWYgKCFkYi5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgY29uc3QgZW11bGF0b3IgPSBnZXREZWZhdWx0RW11bGF0b3JIb3N0bmFtZUFuZFBvcnQoJ2ZpcmVzdG9yZScpO1xuICAgICAgICBpZiAoZW11bGF0b3IpIHtcbiAgICAgICAgICAgIGNvbm5lY3RGaXJlc3RvcmVFbXVsYXRvcihkYiwgLi4uZW11bGF0b3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYjtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKSB7XG4gICAgaWYgKGZpcmVzdG9yZS5fdGVybWluYXRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnVGhlIGNsaWVudCBoYXMgYWxyZWFkeSBiZWVuIHRlcm1pbmF0ZWQuJyk7XG4gICAgfVxuICAgIGlmICghZmlyZXN0b3JlLl9maXJlc3RvcmVDbGllbnQpIHtcbiAgICAgICAgY29uZmlndXJlRmlyZXN0b3JlKGZpcmVzdG9yZSk7XG4gICAgfVxuICAgIHJldHVybiBmaXJlc3RvcmUuX2ZpcmVzdG9yZUNsaWVudDtcbn1cbmZ1bmN0aW9uIGNvbmZpZ3VyZUZpcmVzdG9yZShmaXJlc3RvcmUpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBzZXR0aW5ncyA9IGZpcmVzdG9yZS5fZnJlZXplU2V0dGluZ3MoKTtcbiAgICBjb25zdCBkYXRhYmFzZUluZm8gPSBtYWtlRGF0YWJhc2VJbmZvKGZpcmVzdG9yZS5fZGF0YWJhc2VJZCwgKChfYSA9IGZpcmVzdG9yZS5fYXBwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW9ucy5hcHBJZCkgfHwgJycsIGZpcmVzdG9yZS5fcGVyc2lzdGVuY2VLZXksIHNldHRpbmdzKTtcbiAgICBpZiAoIWZpcmVzdG9yZS5fY29tcG9uZW50c1Byb3ZpZGVyKSB7XG4gICAgICAgIGlmICgoKF9iID0gc2V0dGluZ3MubG9jYWxDYWNoZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIpICYmXG4gICAgICAgICAgICAoKF9jID0gc2V0dGluZ3MubG9jYWxDYWNoZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLl9vbmxpbmVDb21wb25lbnRQcm92aWRlcikpIHtcbiAgICAgICAgICAgIGZpcmVzdG9yZS5fY29tcG9uZW50c1Byb3ZpZGVyID0ge1xuICAgICAgICAgICAgICAgIF9vZmZsaW5lOiBzZXR0aW5ncy5sb2NhbENhY2hlLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgX29ubGluZTogc2V0dGluZ3MubG9jYWxDYWNoZS5fb25saW5lQ29tcG9uZW50UHJvdmlkZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmlyZXN0b3JlLl9maXJlc3RvcmVDbGllbnQgPSBuZXcgRmlyZXN0b3JlQ2xpZW50KGZpcmVzdG9yZS5fYXV0aENyZWRlbnRpYWxzLCBmaXJlc3RvcmUuX2FwcENoZWNrQ3JlZGVudGlhbHMsIGZpcmVzdG9yZS5fcXVldWUsIGRhdGFiYXNlSW5mbywgZmlyZXN0b3JlLl9jb21wb25lbnRzUHJvdmlkZXIgJiZcbiAgICAgICAgYnVpbGRDb21wb25lbnRQcm92aWRlcihmaXJlc3RvcmUuX2NvbXBvbmVudHNQcm92aWRlcikpO1xufVxuZnVuY3Rpb24gYnVpbGRDb21wb25lbnRQcm92aWRlcihjb21wb25lbnRzUHJvdmlkZXIpIHtcbiAgICBjb25zdCBvbmxpbmUgPSBjb21wb25lbnRzUHJvdmlkZXIgPT09IG51bGwgfHwgY29tcG9uZW50c1Byb3ZpZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb21wb25lbnRzUHJvdmlkZXIuX29ubGluZS5idWlsZCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIF9vZmZsaW5lOiBjb21wb25lbnRzUHJvdmlkZXIgPT09IG51bGwgfHwgY29tcG9uZW50c1Byb3ZpZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb21wb25lbnRzUHJvdmlkZXIuX29mZmxpbmUuYnVpbGQob25saW5lKSxcbiAgICAgICAgX29ubGluZTogb25saW5lXG4gICAgfTtcbn1cbi8qKlxuICogQXR0ZW1wdHMgdG8gZW5hYmxlIHBlcnNpc3RlbnQgc3RvcmFnZSwgaWYgcG9zc2libGUuXG4gKlxuICogT24gZmFpbHVyZSwgYGVuYWJsZUluZGV4ZWREYlBlcnNpc3RlbmNlKClgIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlIG9yXG4gKiB0aHJvdyBhbiBleGNlcHRpb24uIFRoZXJlIGFyZSBzZXZlcmFsIHJlYXNvbnMgd2h5IHRoaXMgY2FuIGZhaWwsIHdoaWNoIGNhbiBiZVxuICogaWRlbnRpZmllZCBieSB0aGUgYGNvZGVgIG9uIHRoZSBlcnJvci5cbiAqXG4gKiAgICogZmFpbGVkLXByZWNvbmRpdGlvbjogVGhlIGFwcCBpcyBhbHJlYWR5IG9wZW4gaW4gYW5vdGhlciBicm93c2VyIHRhYi5cbiAqICAgKiB1bmltcGxlbWVudGVkOiBUaGUgYnJvd3NlciBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgb2ZmbGluZSBwZXJzaXN0ZW5jZVxuICogICAgIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIE5vdGUgdGhhdCBldmVuIGFmdGVyIGEgZmFpbHVyZSwgdGhlIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlIHdpbGwgcmVtYWluXG4gKiB1c2FibGUsIGhvd2V2ZXIgb2ZmbGluZSBwZXJzaXN0ZW5jZSB3aWxsIGJlIGRpc2FibGVkLlxuICpcbiAqIE5vdGU6IGBlbmFibGVJbmRleGVkRGJQZXJzaXN0ZW5jZSgpYCBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgYW55IG90aGVyIGZ1bmN0aW9uc1xuICogKG90aGVyIHRoYW4ge0BsaW5rIGluaXRpYWxpemVGaXJlc3RvcmV9LCB7QGxpbmsgKGdldEZpcmVzdG9yZToxKX0gb3JcbiAqIHtAbGluayBjbGVhckluZGV4ZWREYlBlcnNpc3RlbmNlfS5cbiAqXG4gKiBQZXJzaXN0ZW5jZSBjYW5ub3QgYmUgdXNlZCBpbiBhIE5vZGUuanMgZW52aXJvbm1lbnQuXG4gKlxuICogQHBhcmFtIGZpcmVzdG9yZSAtIFRoZSB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZSB0byBlbmFibGUgcGVyc2lzdGVuY2UgZm9yLlxuICogQHBhcmFtIHBlcnNpc3RlbmNlU2V0dGluZ3MgLSBPcHRpb25hbCBzZXR0aW5ncyBvYmplY3QgdG8gY29uZmlndXJlXG4gKiBwZXJzaXN0ZW5jZS5cbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgcmVwcmVzZW50cyBzdWNjZXNzZnVsbHkgZW5hYmxpbmcgcGVyc2lzdGVudCBzdG9yYWdlLlxuICogQGRlcHJlY2F0ZWQgVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gSW5zdGVhZCwgc2V0XG4gKiBgRmlyZXN0b3JlU2V0dGluZ3MubG9jYWxDYWNoZWAgdG8gYW4gaW5zdGFuY2Ugb2YgYFBlcnNpc3RlbnRMb2NhbENhY2hlYCB0b1xuICogdHVybiBvbiBJbmRleGVkRGIgY2FjaGUuIENhbGxpbmcgdGhpcyBmdW5jdGlvbiB3aGVuIGBGaXJlc3RvcmVTZXR0aW5ncy5sb2NhbENhY2hlYFxuICogaXMgYWxyZWFkeSBzcGVjaWZpZWQgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24uXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUluZGV4ZWREYlBlcnNpc3RlbmNlKGZpcmVzdG9yZSwgcGVyc2lzdGVuY2VTZXR0aW5ncykge1xuICAgIGxvZ1dhcm4oJ2VuYWJsZUluZGV4ZWREYlBlcnNpc3RlbmNlKCkgd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUsICcgK1xuICAgICAgICAneW91IGNhbiB1c2UgYEZpcmVzdG9yZVNldHRpbmdzLmNhY2hlYCBpbnN0ZWFkLicpO1xuICAgIGNvbnN0IHNldHRpbmdzID0gZmlyZXN0b3JlLl9mcmVlemVTZXR0aW5ncygpO1xuICAgIHNldFBlcnNpc3RlbmNlUHJvdmlkZXJzKGZpcmVzdG9yZSwgT25saW5lQ29tcG9uZW50UHJvdmlkZXIucHJvdmlkZXIsIHtcbiAgICAgICAgYnVpbGQ6IChvbmxpbmVDb21wb25lbnRzKSA9PiBuZXcgSW5kZXhlZERiT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKG9ubGluZUNvbXBvbmVudHMsIHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzLCBwZXJzaXN0ZW5jZVNldHRpbmdzID09PSBudWxsIHx8IHBlcnNpc3RlbmNlU2V0dGluZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBlcnNpc3RlbmNlU2V0dGluZ3MuZm9yY2VPd25lcnNoaXApXG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xufVxuLyoqXG4gKiBBdHRlbXB0cyB0byBlbmFibGUgbXVsdGktdGFiIHBlcnNpc3RlbnQgc3RvcmFnZSwgaWYgcG9zc2libGUuIElmIGVuYWJsZWRcbiAqIGFjcm9zcyBhbGwgdGFicywgYWxsIG9wZXJhdGlvbnMgc2hhcmUgYWNjZXNzIHRvIGxvY2FsIHBlcnNpc3RlbmNlLCBpbmNsdWRpbmdcbiAqIHNoYXJlZCBleGVjdXRpb24gb2YgcXVlcmllcyBhbmQgbGF0ZW5jeS1jb21wZW5zYXRlZCBsb2NhbCBkb2N1bWVudCB1cGRhdGVzXG4gKiBhY3Jvc3MgYWxsIGNvbm5lY3RlZCBpbnN0YW5jZXMuXG4gKlxuICogT24gZmFpbHVyZSwgYGVuYWJsZU11bHRpVGFiSW5kZXhlZERiUGVyc2lzdGVuY2UoKWAgd2lsbCByZWplY3QgdGhlIHByb21pc2Ugb3JcbiAqIHRocm93IGFuIGV4Y2VwdGlvbi4gVGhlcmUgYXJlIHNldmVyYWwgcmVhc29ucyB3aHkgdGhpcyBjYW4gZmFpbCwgd2hpY2ggY2FuIGJlXG4gKiBpZGVudGlmaWVkIGJ5IHRoZSBgY29kZWAgb24gdGhlIGVycm9yLlxuICpcbiAqICAgKiBmYWlsZWQtcHJlY29uZGl0aW9uOiBUaGUgYXBwIGlzIGFscmVhZHkgb3BlbiBpbiBhbm90aGVyIGJyb3dzZXIgdGFiIGFuZFxuICogICAgIG11bHRpLXRhYiBpcyBub3QgZW5hYmxlZC5cbiAqICAgKiB1bmltcGxlbWVudGVkOiBUaGUgYnJvd3NlciBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgb2ZmbGluZSBwZXJzaXN0ZW5jZVxuICogICAgIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIE5vdGUgdGhhdCBldmVuIGFmdGVyIGEgZmFpbHVyZSwgdGhlIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlIHdpbGwgcmVtYWluXG4gKiB1c2FibGUsIGhvd2V2ZXIgb2ZmbGluZSBwZXJzaXN0ZW5jZSB3aWxsIGJlIGRpc2FibGVkLlxuICpcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBUaGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UgdG8gZW5hYmxlIHBlcnNpc3RlbmNlIGZvci5cbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgcmVwcmVzZW50cyBzdWNjZXNzZnVsbHkgZW5hYmxpbmcgcGVyc2lzdGVudFxuICogc3RvcmFnZS5cbiAqIEBkZXByZWNhdGVkIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIEluc3RlYWQsIHNldFxuICogYEZpcmVzdG9yZVNldHRpbmdzLmxvY2FsQ2FjaGVgIHRvIGFuIGluc3RhbmNlIG9mIGBQZXJzaXN0ZW50TG9jYWxDYWNoZWAgdG9cbiAqIHR1cm4gb24gaW5kZXhlZGRiIGNhY2hlLiBDYWxsaW5nIHRoaXMgZnVuY3Rpb24gd2hlbiBgRmlyZXN0b3JlU2V0dGluZ3MubG9jYWxDYWNoZWBcbiAqIGlzIGFscmVhZHkgc3BlY2lmaWVkIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uLlxuICovXG5hc3luYyBmdW5jdGlvbiBlbmFibGVNdWx0aVRhYkluZGV4ZWREYlBlcnNpc3RlbmNlKGZpcmVzdG9yZSkge1xuICAgIGxvZ1dhcm4oJ2VuYWJsZU11bHRpVGFiSW5kZXhlZERiUGVyc2lzdGVuY2UoKSB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gdGhlIGZ1dHVyZSwgJyArXG4gICAgICAgICd5b3UgY2FuIHVzZSBgRmlyZXN0b3JlU2V0dGluZ3MuY2FjaGVgIGluc3RlYWQuJyk7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSBmaXJlc3RvcmUuX2ZyZWV6ZVNldHRpbmdzKCk7XG4gICAgc2V0UGVyc2lzdGVuY2VQcm92aWRlcnMoZmlyZXN0b3JlLCBPbmxpbmVDb21wb25lbnRQcm92aWRlci5wcm92aWRlciwge1xuICAgICAgICBidWlsZDogKG9ubGluZUNvbXBvbmVudHMpID0+IG5ldyBNdWx0aVRhYk9mZmxpbmVDb21wb25lbnRQcm92aWRlcihvbmxpbmVDb21wb25lbnRzLCBzZXR0aW5ncy5jYWNoZVNpemVCeXRlcylcbiAgICB9KTtcbn1cbi8qKlxuICogUmVnaXN0ZXJzIGJvdGggdGhlIGBPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXJgIGFuZCBgT25saW5lQ29tcG9uZW50UHJvdmlkZXJgLlxuICogSWYgdGhlIG9wZXJhdGlvbiBmYWlscyB3aXRoIGEgcmVjb3ZlcmFibGUgZXJyb3IgKHNlZVxuICogYGNhblJlY292ZXJGcm9tSW5kZXhlZERiRXJyb3IoKWAgYmVsb3cpLCB0aGUgcmV0dXJuZWQgUHJvbWlzZSBpcyByZWplY3RlZFxuICogYnV0IHRoZSBjbGllbnQgcmVtYWlucyB1c2FibGUuXG4gKi9cbmZ1bmN0aW9uIHNldFBlcnNpc3RlbmNlUHJvdmlkZXJzKGZpcmVzdG9yZSwgb25saW5lQ29tcG9uZW50UHJvdmlkZXIsIG9mZmxpbmVDb21wb25lbnRQcm92aWRlcikge1xuICAgIGZpcmVzdG9yZSA9IGNhc3QoZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgIGlmIChmaXJlc3RvcmUuX2ZpcmVzdG9yZUNsaWVudCB8fCBmaXJlc3RvcmUuX3Rlcm1pbmF0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgJ0ZpcmVzdG9yZSBoYXMgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQgYW5kIHBlcnNpc3RlbmNlIGNhbiBubyBsb25nZXIgYmUgJyArXG4gICAgICAgICAgICAnZW5hYmxlZC4gWW91IGNhbiBvbmx5IGVuYWJsZSBwZXJzaXN0ZW5jZSBiZWZvcmUgY2FsbGluZyBhbnkgb3RoZXIgJyArXG4gICAgICAgICAgICAnbWV0aG9kcyBvbiBhIEZpcmVzdG9yZSBvYmplY3QuJyk7XG4gICAgfVxuICAgIGlmIChmaXJlc3RvcmUuX2NvbXBvbmVudHNQcm92aWRlciB8fCBmaXJlc3RvcmUuX2dldFNldHRpbmdzKCkubG9jYWxDYWNoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnU0RLIGNhY2hlIGlzIGFscmVhZHkgc3BlY2lmaWVkLicpO1xuICAgIH1cbiAgICBmaXJlc3RvcmUuX2NvbXBvbmVudHNQcm92aWRlciA9IHtcbiAgICAgICAgX29ubGluZTogb25saW5lQ29tcG9uZW50UHJvdmlkZXIsXG4gICAgICAgIF9vZmZsaW5lOiBvZmZsaW5lQ29tcG9uZW50UHJvdmlkZXJcbiAgICB9O1xuICAgIGNvbmZpZ3VyZUZpcmVzdG9yZShmaXJlc3RvcmUpO1xufVxuLyoqXG4gKiBDbGVhcnMgdGhlIHBlcnNpc3RlbnQgc3RvcmFnZS4gVGhpcyBpbmNsdWRlcyBwZW5kaW5nIHdyaXRlcyBhbmQgY2FjaGVkXG4gKiBkb2N1bWVudHMuXG4gKlxuICogTXVzdCBiZSBjYWxsZWQgd2hpbGUgdGhlIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlIGlzIG5vdCBzdGFydGVkIChhZnRlciB0aGUgYXBwIGlzXG4gKiB0ZXJtaW5hdGVkIG9yIHdoZW4gdGhlIGFwcCBpcyBmaXJzdCBpbml0aWFsaXplZCkuIE9uIHN0YXJ0dXAsIHRoaXMgZnVuY3Rpb25cbiAqIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBvdGhlciBmdW5jdGlvbnMgKG90aGVyIHRoYW4ge0BsaW5rXG4gKiBpbml0aWFsaXplRmlyZXN0b3JlfSBvciB7QGxpbmsgKGdldEZpcmVzdG9yZToxKX0pKS4gSWYgdGhlIHtAbGluayBGaXJlc3RvcmV9XG4gKiBpbnN0YW5jZSBpcyBzdGlsbCBydW5uaW5nLCB0aGUgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIGVycm9yIGNvZGVcbiAqIG9mIGBmYWlsZWQtcHJlY29uZGl0aW9uYC5cbiAqXG4gKiBOb3RlOiBgY2xlYXJJbmRleGVkRGJQZXJzaXN0ZW5jZSgpYCBpcyBwcmltYXJpbHkgaW50ZW5kZWQgdG8gaGVscCB3cml0ZVxuICogcmVsaWFibGUgdGVzdHMgdGhhdCB1c2UgQ2xvdWQgRmlyZXN0b3JlLiBJdCB1c2VzIGFuIGVmZmljaWVudCBtZWNoYW5pc20gZm9yXG4gKiBkcm9wcGluZyBleGlzdGluZyBkYXRhIGJ1dCBkb2VzIG5vdCBhdHRlbXB0IHRvIHNlY3VyZWx5IG92ZXJ3cml0ZSBvclxuICogb3RoZXJ3aXNlIG1ha2UgY2FjaGVkIGRhdGEgdW5yZWNvdmVyYWJsZS4gRm9yIGFwcGxpY2F0aW9ucyB0aGF0IGFyZSBzZW5zaXRpdmVcbiAqIHRvIHRoZSBkaXNjbG9zdXJlIG9mIGNhY2hlZCBkYXRhIGluIGJldHdlZW4gdXNlciBzZXNzaW9ucywgd2Ugc3Ryb25nbHlcbiAqIHJlY29tbWVuZCBub3QgZW5hYmxpbmcgcGVyc2lzdGVuY2UgYXQgYWxsLlxuICpcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBUaGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UgdG8gY2xlYXIgcGVyc2lzdGVuY2UgZm9yLlxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCBpcyByZXNvbHZlZCB3aGVuIHRoZSBwZXJzaXN0ZW50IHN0b3JhZ2UgaXNcbiAqIGNsZWFyZWQuIE90aGVyd2lzZSwgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvci5cbiAqL1xuZnVuY3Rpb24gY2xlYXJJbmRleGVkRGJQZXJzaXN0ZW5jZShmaXJlc3RvcmUpIHtcbiAgICBpZiAoZmlyZXN0b3JlLl9pbml0aWFsaXplZCAmJiAhZmlyZXN0b3JlLl90ZXJtaW5hdGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sICdQZXJzaXN0ZW5jZSBjYW4gb25seSBiZSBjbGVhcmVkIGJlZm9yZSBhIEZpcmVzdG9yZSBpbnN0YW5jZSBpcyAnICtcbiAgICAgICAgICAgICdpbml0aWFsaXplZCBvciBhZnRlciBpdCBpcyB0ZXJtaW5hdGVkLicpO1xuICAgIH1cbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIGZpcmVzdG9yZS5fcXVldWUuZW5xdWV1ZUFuZEZvcmdldEV2ZW5XaGlsZVJlc3RyaWN0ZWQoYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgaW5kZXhlZERiQ2xlYXJQZXJzaXN0ZW5jZShpbmRleGVkRGJTdG9yYWdlUHJlZml4KGZpcmVzdG9yZS5fZGF0YWJhc2VJZCwgZmlyZXN0b3JlLl9wZXJzaXN0ZW5jZUtleSkpO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cbi8qKlxuICogV2FpdHMgdW50aWwgYWxsIGN1cnJlbnRseSBwZW5kaW5nIHdyaXRlcyBmb3IgdGhlIGFjdGl2ZSB1c2VyIGhhdmUgYmVlblxuICogYWNrbm93bGVkZ2VkIGJ5IHRoZSBiYWNrZW5kLlxuICpcbiAqIFRoZSByZXR1cm5lZCBwcm9taXNlIHJlc29sdmVzIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyBvdXRzdGFuZGluZyB3cml0ZXMuXG4gKiBPdGhlcndpc2UsIHRoZSBwcm9taXNlIHdhaXRzIGZvciBhbGwgcHJldmlvdXNseSBpc3N1ZWQgd3JpdGVzIChpbmNsdWRpbmdcbiAqIHRob3NlIHdyaXR0ZW4gaW4gYSBwcmV2aW91cyBhcHAgc2Vzc2lvbiksIGJ1dCBpdCBkb2VzIG5vdCB3YWl0IGZvciB3cml0ZXNcbiAqIHRoYXQgd2VyZSBhZGRlZCBhZnRlciB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkLiBJZiB5b3Ugd2FudCB0byB3YWl0IGZvclxuICogYWRkaXRpb25hbCB3cml0ZXMsIGNhbGwgYHdhaXRGb3JQZW5kaW5nV3JpdGVzKClgIGFnYWluLlxuICpcbiAqIEFueSBvdXRzdGFuZGluZyBgd2FpdEZvclBlbmRpbmdXcml0ZXMoKWAgcHJvbWlzZXMgYXJlIHJlamVjdGVkIGR1cmluZyB1c2VyXG4gKiBjaGFuZ2VzLlxuICpcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHdoaWNoIHJlc29sdmVzIHdoZW4gYWxsIGN1cnJlbnRseSBwZW5kaW5nIHdyaXRlcyBoYXZlIGJlZW5cbiAqIGFja25vd2xlZGdlZCBieSB0aGUgYmFja2VuZC5cbiAqL1xuZnVuY3Rpb24gd2FpdEZvclBlbmRpbmdXcml0ZXMoZmlyZXN0b3JlKSB7XG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRXYWl0Rm9yUGVuZGluZ1dyaXRlcyhjbGllbnQpO1xufVxuLyoqXG4gKiBSZS1lbmFibGVzIHVzZSBvZiB0aGUgbmV0d29yayBmb3IgdGhpcyB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZSBhZnRlciBhIHByaW9yXG4gKiBjYWxsIHRvIHtAbGluayBkaXNhYmxlTmV0d29ya30uXG4gKlxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCBpcyByZXNvbHZlZCBvbmNlIHRoZSBuZXR3b3JrIGhhcyBiZWVuIGVuYWJsZWQuXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZU5ldHdvcmsoZmlyZXN0b3JlKSB7XG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRFbmFibGVOZXR3b3JrKGNsaWVudCk7XG59XG4vKipcbiAqIERpc2FibGVzIG5ldHdvcmsgdXNhZ2UgZm9yIHRoaXMgaW5zdGFuY2UuIEl0IGNhbiBiZSByZS1lbmFibGVkIHZpYSB7QGxpbmtcbiAqIGVuYWJsZU5ldHdvcmt9LiBXaGlsZSB0aGUgbmV0d29yayBpcyBkaXNhYmxlZCwgYW55IHNuYXBzaG90IGxpc3RlbmVycyxcbiAqIGBnZXREb2MoKWAgb3IgYGdldERvY3MoKWAgY2FsbHMgd2lsbCByZXR1cm4gcmVzdWx0cyBmcm9tIGNhY2hlLCBhbmQgYW55IHdyaXRlXG4gKiBvcGVyYXRpb25zIHdpbGwgYmUgcXVldWVkIHVudGlsIHRoZSBuZXR3b3JrIGlzIHJlc3RvcmVkLlxuICpcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgaXMgcmVzb2x2ZWQgb25jZSB0aGUgbmV0d29yayBoYXMgYmVlbiBkaXNhYmxlZC5cbiAqL1xuZnVuY3Rpb24gZGlzYWJsZU5ldHdvcmsoZmlyZXN0b3JlKSB7XG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnREaXNhYmxlTmV0d29yayhjbGllbnQpO1xufVxuLyoqXG4gKiBUZXJtaW5hdGVzIHRoZSBwcm92aWRlZCB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZS5cbiAqXG4gKiBBZnRlciBjYWxsaW5nIGB0ZXJtaW5hdGUoKWAgb25seSB0aGUgYGNsZWFySW5kZXhlZERiUGVyc2lzdGVuY2UoKWAgZnVuY3Rpb25cbiAqIG1heSBiZSB1c2VkLiBBbnkgb3RoZXIgZnVuY3Rpb24gd2lsbCB0aHJvdyBhIGBGaXJlc3RvcmVFcnJvcmAuXG4gKlxuICogVG8gcmVzdGFydCBhZnRlciB0ZXJtaW5hdGlvbiwgY3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEZpcmViYXNlRmlyZXN0b3JlIHdpdGhcbiAqIHtAbGluayAoZ2V0RmlyZXN0b3JlOjEpfS5cbiAqXG4gKiBUZXJtaW5hdGlvbiBkb2VzIG5vdCBjYW5jZWwgYW55IHBlbmRpbmcgd3JpdGVzLCBhbmQgYW55IHByb21pc2VzIHRoYXQgYXJlXG4gKiBhd2FpdGluZyBhIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlciB3aWxsIG5vdCBiZSByZXNvbHZlZC4gSWYgeW91IGhhdmVcbiAqIHBlcnNpc3RlbmNlIGVuYWJsZWQsIHRoZSBuZXh0IHRpbWUgeW91IHN0YXJ0IHRoaXMgaW5zdGFuY2UsIGl0IHdpbGwgcmVzdW1lXG4gKiBzZW5kaW5nIHRoZXNlIHdyaXRlcyB0byB0aGUgc2VydmVyLlxuICpcbiAqIE5vdGU6IFVuZGVyIG5vcm1hbCBjaXJjdW1zdGFuY2VzLCBjYWxsaW5nIGB0ZXJtaW5hdGUoKWAgaXMgbm90IHJlcXVpcmVkLiBUaGlzXG4gKiBmdW5jdGlvbiBpcyB1c2VmdWwgb25seSB3aGVuIHlvdSB3YW50IHRvIGZvcmNlIHRoaXMgaW5zdGFuY2UgdG8gcmVsZWFzZSBhbGxcbiAqIG9mIGl0cyByZXNvdXJjZXMgb3IgaW4gY29tYmluYXRpb24gd2l0aCBgY2xlYXJJbmRleGVkRGJQZXJzaXN0ZW5jZSgpYCB0b1xuICogZW5zdXJlIHRoYXQgYWxsIGxvY2FsIHN0YXRlIGlzIGRlc3Ryb3llZCBiZXR3ZWVuIHRlc3QgcnVucy5cbiAqXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IGlzIHJlc29sdmVkIHdoZW4gdGhlIGluc3RhbmNlIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseVxuICogdGVybWluYXRlZC5cbiAqL1xuZnVuY3Rpb24gdGVybWluYXRlKGZpcmVzdG9yZSkge1xuICAgIF9yZW1vdmVTZXJ2aWNlSW5zdGFuY2UoZmlyZXN0b3JlLmFwcCwgJ2ZpcmVzdG9yZScsIGZpcmVzdG9yZS5fZGF0YWJhc2VJZC5kYXRhYmFzZSk7XG4gICAgcmV0dXJuIGZpcmVzdG9yZS5fZGVsZXRlKCk7XG59XG4vKipcbiAqIExvYWRzIGEgRmlyZXN0b3JlIGJ1bmRsZSBpbnRvIHRoZSBsb2NhbCBjYWNoZS5cbiAqXG4gKiBAcGFyYW0gZmlyZXN0b3JlIC0gVGhlIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlIHRvIGxvYWQgYnVuZGxlcyBmb3IuXG4gKiBAcGFyYW0gYnVuZGxlRGF0YSAtIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGJ1bmRsZSB0byBiZSBsb2FkZWQuIFZhbGlkXG4gKiBvYmplY3RzIGFyZSBgQXJyYXlCdWZmZXJgLCBgUmVhZGFibGVTdHJlYW08VWludDhBcnJheT5gIG9yIGBzdHJpbmdgLlxuICpcbiAqIEByZXR1cm5zIEEgYExvYWRCdW5kbGVUYXNrYCBvYmplY3QsIHdoaWNoIG5vdGlmaWVzIGNhbGxlcnMgd2l0aCBwcm9ncmVzc1xuICogdXBkYXRlcywgYW5kIGNvbXBsZXRpb24gb3IgZXJyb3IgZXZlbnRzLiBJdCBjYW4gYmUgdXNlZCBhcyBhXG4gKiBgUHJvbWlzZTxMb2FkQnVuZGxlVGFza1Byb2dyZXNzPmAuXG4gKi9cbmZ1bmN0aW9uIGxvYWRCdW5kbGUoZmlyZXN0b3JlLCBidW5kbGVEYXRhKSB7XG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIGNvbnN0IHJlc3VsdFRhc2sgPSBuZXcgTG9hZEJ1bmRsZVRhc2soKTtcbiAgICBmaXJlc3RvcmVDbGllbnRMb2FkQnVuZGxlKGNsaWVudCwgZmlyZXN0b3JlLl9kYXRhYmFzZUlkLCBidW5kbGVEYXRhLCByZXN1bHRUYXNrKTtcbiAgICByZXR1cm4gcmVzdWx0VGFzaztcbn1cbi8qKlxuICogUmVhZHMgYSBGaXJlc3RvcmUge0BsaW5rIFF1ZXJ5fSBmcm9tIGxvY2FsIGNhY2hlLCBpZGVudGlmaWVkIGJ5IHRoZSBnaXZlblxuICogbmFtZS5cbiAqXG4gKiBUaGUgbmFtZWQgcXVlcmllcyBhcmUgcGFja2FnZWQgIGludG8gYnVuZGxlcyBvbiB0aGUgc2VydmVyIHNpZGUgKGFsb25nXG4gKiB3aXRoIHJlc3VsdGluZyBkb2N1bWVudHMpLCBhbmQgbG9hZGVkIHRvIGxvY2FsIGNhY2hlIHVzaW5nIGBsb2FkQnVuZGxlYC4gT25jZVxuICogaW4gbG9jYWwgY2FjaGUsIHVzZSB0aGlzIG1ldGhvZCB0byBleHRyYWN0IGEge0BsaW5rIFF1ZXJ5fSBieSBuYW1lLlxuICpcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBUaGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UgdG8gcmVhZCB0aGUgcXVlcnkgZnJvbS5cbiAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHF1ZXJ5LlxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCBpcyByZXNvbHZlZCB3aXRoIHRoZSBRdWVyeSBvciBgbnVsbGAuXG4gKi9cbmZ1bmN0aW9uIG5hbWVkUXVlcnkoZmlyZXN0b3JlLCBuYW1lKSB7XG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRHZXROYW1lZFF1ZXJ5KGNsaWVudCwgbmFtZSkudGhlbihuYW1lZFF1ZXJ5ID0+IHtcbiAgICAgICAgaWYgKCFuYW1lZFF1ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KGZpcmVzdG9yZSwgbnVsbCwgbmFtZWRRdWVyeS5xdWVyeSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiByZWdpc3RlckZpcmVzdG9yZSh2YXJpYW50LCB1c2VGZXRjaFN0cmVhbXMgPSB0cnVlKSB7XG4gICAgc2V0U0RLVmVyc2lvbihTREtfVkVSU0lPTiQxKTtcbiAgICBfcmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudCgnZmlyZXN0b3JlJywgKGNvbnRhaW5lciwgeyBpbnN0YW5jZUlkZW50aWZpZXI6IGRhdGFiYXNlSWQsIG9wdGlvbnM6IHNldHRpbmdzIH0pID0+IHtcbiAgICAgICAgY29uc3QgYXBwID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAnKS5nZXRJbW1lZGlhdGUoKTtcbiAgICAgICAgY29uc3QgZmlyZXN0b3JlSW5zdGFuY2UgPSBuZXcgRmlyZXN0b3JlKG5ldyBGaXJlYmFzZUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyKGNvbnRhaW5lci5nZXRQcm92aWRlcignYXV0aC1pbnRlcm5hbCcpKSwgbmV3IEZpcmViYXNlQXBwQ2hlY2tUb2tlblByb3ZpZGVyKGNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwLWNoZWNrLWludGVybmFsJykpLCBkYXRhYmFzZUlkRnJvbUFwcChhcHAsIGRhdGFiYXNlSWQpLCBhcHApO1xuICAgICAgICBzZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oeyB1c2VGZXRjaFN0cmVhbXMgfSwgc2V0dGluZ3MpO1xuICAgICAgICBmaXJlc3RvcmVJbnN0YW5jZS5fc2V0U2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgICAgICByZXR1cm4gZmlyZXN0b3JlSW5zdGFuY2U7XG4gICAgfSwgJ1BVQkxJQycpLnNldE11bHRpcGxlSW5zdGFuY2VzKHRydWUpKTtcbiAgICByZWdpc3RlclZlcnNpb24obmFtZSwgdmVyc2lvbiQxLCB2YXJpYW50KTtcbiAgICAvLyBCVUlMRF9UQVJHRVQgd2lsbCBiZSByZXBsYWNlZCBieSB2YWx1ZXMgbGlrZSBlc20yMDE3LCBjanMyMDE3LCBldGMgZHVyaW5nIHRoZSBjb21waWxhdGlvblxuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uJDEsICdlc20yMDE3Jyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIENvbmNyZXRlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBBZ2dyZWdhdGUgdHlwZS5cbiAqL1xuY2xhc3MgQWdncmVnYXRlSW1wbCB7XG4gICAgY29uc3RydWN0b3IoYWxpYXMsIGFnZ3JlZ2F0ZVR5cGUsIGZpZWxkUGF0aCkge1xuICAgICAgICB0aGlzLmFsaWFzID0gYWxpYXM7XG4gICAgICAgIHRoaXMuYWdncmVnYXRlVHlwZSA9IGFnZ3JlZ2F0ZVR5cGU7XG4gICAgICAgIHRoaXMuZmllbGRQYXRoID0gZmllbGRQYXRoO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUmVwcmVzZW50cyBhbiBhZ2dyZWdhdGlvbiB0aGF0IGNhbiBiZSBwZXJmb3JtZWQgYnkgRmlyZXN0b3JlLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5jbGFzcyBBZ2dyZWdhdGVGaWVsZCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IEFnZ3JlZ2F0ZUZpZWxkPFQ+XG4gICAgICogQHBhcmFtIGFnZ3JlZ2F0ZVR5cGUgU3BlY2lmaWVzIHRoZSB0eXBlIG9mIGFnZ3JlZ2F0aW9uIG9wZXJhdGlvbiB0byBwZXJmb3JtLlxuICAgICAqIEBwYXJhbSBfaW50ZXJuYWxGaWVsZFBhdGggT3B0aW9uYWxseSBzcGVjaWZpZXMgdGhlIGZpZWxkIHRoYXQgaXMgYWdncmVnYXRlZC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhZ2dyZWdhdGVUeXBlID0gJ2NvdW50JywgX2ludGVybmFsRmllbGRQYXRoKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsRmllbGRQYXRoID0gX2ludGVybmFsRmllbGRQYXRoO1xuICAgICAgICAvKiogQSB0eXBlIHN0cmluZyB0byB1bmlxdWVseSBpZGVudGlmeSBpbnN0YW5jZXMgb2YgdGhpcyBjbGFzcy4gKi9cbiAgICAgICAgdGhpcy50eXBlID0gJ0FnZ3JlZ2F0ZUZpZWxkJztcbiAgICAgICAgdGhpcy5hZ2dyZWdhdGVUeXBlID0gYWdncmVnYXRlVHlwZTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSByZXN1bHRzIG9mIGV4ZWN1dGluZyBhbiBhZ2dyZWdhdGlvbiBxdWVyeS5cbiAqL1xuY2xhc3MgQWdncmVnYXRlUXVlcnlTbmFwc2hvdCB7XG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cbiAgICBjb25zdHJ1Y3RvcihxdWVyeSwgX3VzZXJEYXRhV3JpdGVyLCBfZGF0YSkge1xuICAgICAgICB0aGlzLl91c2VyRGF0YVdyaXRlciA9IF91c2VyRGF0YVdyaXRlcjtcbiAgICAgICAgdGhpcy5fZGF0YSA9IF9kYXRhO1xuICAgICAgICAvKiogQSB0eXBlIHN0cmluZyB0byB1bmlxdWVseSBpZGVudGlmeSBpbnN0YW5jZXMgb2YgdGhpcyBjbGFzcy4gKi9cbiAgICAgICAgdGhpcy50eXBlID0gJ0FnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3QnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJlc3VsdHMgb2YgdGhlIGFnZ3JlZ2F0aW9ucyBwZXJmb3JtZWQgb3ZlciB0aGUgdW5kZXJseWluZ1xuICAgICAqIHF1ZXJ5LlxuICAgICAqXG4gICAgICogVGhlIGtleXMgb2YgdGhlIHJldHVybmVkIG9iamVjdCB3aWxsIGJlIHRoZSBzYW1lIGFzIHRob3NlIG9mIHRoZVxuICAgICAqIGBBZ2dyZWdhdGVTcGVjYCBvYmplY3Qgc3BlY2lmaWVkIHRvIHRoZSBhZ2dyZWdhdGlvbiBtZXRob2QsIGFuZCB0aGUgdmFsdWVzXG4gICAgICogd2lsbCBiZSB0aGUgY29ycmVzcG9uZGluZyBhZ2dyZWdhdGlvbiByZXN1bHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcmVzdWx0cyBvZiB0aGUgYWdncmVnYXRpb25zIHBlcmZvcm1lZCBvdmVyIHRoZSB1bmRlcmx5aW5nXG4gICAgICogcXVlcnkuXG4gICAgICovXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VzZXJEYXRhV3JpdGVyLmNvbnZlcnRPYmplY3RNYXAodGhpcy5fZGF0YSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBbiBpbW11dGFibGUgb2JqZWN0IHJlcHJlc2VudGluZyBhbiBhcnJheSBvZiBieXRlcy5cbiAqL1xuY2xhc3MgQnl0ZXMge1xuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXG4gICAgY29uc3RydWN0b3IoYnl0ZVN0cmluZykge1xuICAgICAgICB0aGlzLl9ieXRlU3RyaW5nID0gYnl0ZVN0cmluZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgQnl0ZXNgIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBCYXNlNjQgc3RyaW5nLCBjb252ZXJ0aW5nIGl0IHRvXG4gICAgICogYnl0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYmFzZTY0IC0gVGhlIEJhc2U2NCBzdHJpbmcgdXNlZCB0byBjcmVhdGUgdGhlIGBCeXRlc2Agb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQmFzZTY0U3RyaW5nKGJhc2U2NCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCeXRlcyhCeXRlU3RyaW5nLmZyb21CYXNlNjRTdHJpbmcoYmFzZTY0KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdGYWlsZWQgdG8gY29uc3RydWN0IGRhdGEgZnJvbSBCYXNlNjQgc3RyaW5nOiAnICsgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgQnl0ZXNgIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBVaW50OEFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFycmF5IC0gVGhlIFVpbnQ4QXJyYXkgdXNlZCB0byBjcmVhdGUgdGhlIGBCeXRlc2Agb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tVWludDhBcnJheShhcnJheSkge1xuICAgICAgICByZXR1cm4gbmV3IEJ5dGVzKEJ5dGVTdHJpbmcuZnJvbVVpbnQ4QXJyYXkoYXJyYXkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBieXRlcyBhcyBhIEJhc2U2NC1lbmNvZGVkIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBCYXNlNjQtZW5jb2RlZCBzdHJpbmcgY3JlYXRlZCBmcm9tIHRoZSBgQnl0ZXNgIG9iamVjdC5cbiAgICAgKi9cbiAgICB0b0Jhc2U2NCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J5dGVTdHJpbmcudG9CYXNlNjQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBieXRlcyBpbiBhIG5ldyBgVWludDhBcnJheWAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgVWludDhBcnJheSBjcmVhdGVkIGZyb20gdGhlIGBCeXRlc2Agb2JqZWN0LlxuICAgICAqL1xuICAgIHRvVWludDhBcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J5dGVTdHJpbmcudG9VaW50OEFycmF5KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGBCeXRlc2Agb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGBCeXRlc2Agb2JqZWN0LlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gJ0J5dGVzKGJhc2U2NDogJyArIHRoaXMudG9CYXNlNjQoKSArICcpJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgYEJ5dGVzYCBvYmplY3QgaXMgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBgQnl0ZXNgIG9iamVjdCB0byBjb21wYXJlIGFnYWluc3QuXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGlzIGBCeXRlc2Agb2JqZWN0IGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXG4gICAgICovXG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnl0ZVN0cmluZy5pc0VxdWFsKG90aGVyLl9ieXRlU3RyaW5nKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEEgYEZpZWxkUGF0aGAgcmVmZXJzIHRvIGEgZmllbGQgaW4gYSBkb2N1bWVudC4gVGhlIHBhdGggbWF5IGNvbnNpc3Qgb2YgYVxuICogc2luZ2xlIGZpZWxkIG5hbWUgKHJlZmVycmluZyB0byBhIHRvcC1sZXZlbCBmaWVsZCBpbiB0aGUgZG9jdW1lbnQpLCBvciBhXG4gKiBsaXN0IG9mIGZpZWxkIG5hbWVzIChyZWZlcnJpbmcgdG8gYSBuZXN0ZWQgZmllbGQgaW4gdGhlIGRvY3VtZW50KS5cbiAqXG4gKiBDcmVhdGUgYSBgRmllbGRQYXRoYCBieSBwcm92aWRpbmcgZmllbGQgbmFtZXMuIElmIG1vcmUgdGhhbiBvbmUgZmllbGRcbiAqIG5hbWUgaXMgcHJvdmlkZWQsIHRoZSBwYXRoIHdpbGwgcG9pbnQgdG8gYSBuZXN0ZWQgZmllbGQgaW4gYSBkb2N1bWVudC5cbiAqL1xuY2xhc3MgRmllbGRQYXRoIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYEZpZWxkUGF0aGAgZnJvbSB0aGUgcHJvdmlkZWQgZmllbGQgbmFtZXMuIElmIG1vcmUgdGhhbiBvbmUgZmllbGRcbiAgICAgKiBuYW1lIGlzIHByb3ZpZGVkLCB0aGUgcGF0aCB3aWxsIHBvaW50IHRvIGEgbmVzdGVkIGZpZWxkIGluIGEgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmllbGROYW1lcyAtIEEgbGlzdCBvZiBmaWVsZCBuYW1lcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciguLi5maWVsZE5hbWVzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGROYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZXNbaV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgZmllbGQgbmFtZSBhdCBhcmd1bWVudCAkKGkgKyAxKS4gYCArXG4gICAgICAgICAgICAgICAgICAgICdGaWVsZCBuYW1lcyBtdXN0IG5vdCBiZSBlbXB0eS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnRlcm5hbFBhdGggPSBuZXcgRmllbGRQYXRoJDEoZmllbGROYW1lcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGBGaWVsZFBhdGhgIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgYEZpZWxkUGF0aGAgdG8gY29tcGFyZSBhZ2FpbnN0LlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhpcyBgRmllbGRQYXRoYCBpcyBlcXVhbCB0byB0aGUgcHJvdmlkZWQgb25lLlxuICAgICAqL1xuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsUGF0aC5pc0VxdWFsKG90aGVyLl9pbnRlcm5hbFBhdGgpO1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyBhIHNwZWNpYWwgc2VudGluZWwgYEZpZWxkUGF0aGAgdG8gcmVmZXIgdG8gdGhlIElEIG9mIGEgZG9jdW1lbnQuXG4gKiBJdCBjYW4gYmUgdXNlZCBpbiBxdWVyaWVzIHRvIHNvcnQgb3IgZmlsdGVyIGJ5IHRoZSBkb2N1bWVudCBJRC5cbiAqL1xuZnVuY3Rpb24gZG9jdW1lbnRJZCgpIHtcbiAgICByZXR1cm4gbmV3IEZpZWxkUGF0aChET0NVTUVOVF9LRVlfTkFNRSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFNlbnRpbmVsIHZhbHVlcyB0aGF0IGNhbiBiZSB1c2VkIHdoZW4gd3JpdGluZyBkb2N1bWVudCBmaWVsZHMgd2l0aCBgc2V0KClgXG4gKiBvciBgdXBkYXRlKClgLlxuICovXG5jbGFzcyBGaWVsZFZhbHVlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gX21ldGhvZE5hbWUgLSBUaGUgcHVibGljIEFQSSBlbmRwb2ludCB0aGF0IHJldHVybnMgdGhpcyBjbGFzcy5cbiAgICAgKiBAaGlkZWNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX21ldGhvZE5hbWUpIHtcbiAgICAgICAgdGhpcy5fbWV0aG9kTmFtZSA9IF9tZXRob2ROYW1lO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQW4gaW1tdXRhYmxlIG9iamVjdCByZXByZXNlbnRpbmcgYSBnZW9ncmFwaGljIGxvY2F0aW9uIGluIEZpcmVzdG9yZS4gVGhlXG4gKiBsb2NhdGlvbiBpcyByZXByZXNlbnRlZCBhcyBsYXRpdHVkZS9sb25naXR1ZGUgcGFpci5cbiAqXG4gKiBMYXRpdHVkZSB2YWx1ZXMgYXJlIGluIHRoZSByYW5nZSBvZiBbLTkwLCA5MF0uXG4gKiBMb25naXR1ZGUgdmFsdWVzIGFyZSBpbiB0aGUgcmFuZ2Ugb2YgWy0xODAsIDE4MF0uXG4gKi9cbmNsYXNzIEdlb1BvaW50IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGltbXV0YWJsZSBgR2VvUG9pbnRgIG9iamVjdCB3aXRoIHRoZSBwcm92aWRlZCBsYXRpdHVkZSBhbmRcbiAgICAgKiBsb25naXR1ZGUgdmFsdWVzLlxuICAgICAqIEBwYXJhbSBsYXRpdHVkZSAtIFRoZSBsYXRpdHVkZSBhcyBudW1iZXIgYmV0d2VlbiAtOTAgYW5kIDkwLlxuICAgICAqIEBwYXJhbSBsb25naXR1ZGUgLSBUaGUgbG9uZ2l0dWRlIGFzIG51bWJlciBiZXR3ZWVuIC0xODAgYW5kIDE4MC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsYXRpdHVkZSwgbG9uZ2l0dWRlKSB7XG4gICAgICAgIGlmICghaXNGaW5pdGUobGF0aXR1ZGUpIHx8IGxhdGl0dWRlIDwgLTkwIHx8IGxhdGl0dWRlID4gOTApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdMYXRpdHVkZSBtdXN0IGJlIGEgbnVtYmVyIGJldHdlZW4gLTkwIGFuZCA5MCwgYnV0IHdhczogJyArIGxhdGl0dWRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRmluaXRlKGxvbmdpdHVkZSkgfHwgbG9uZ2l0dWRlIDwgLTE4MCB8fCBsb25naXR1ZGUgPiAxODApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdMb25naXR1ZGUgbXVzdCBiZSBhIG51bWJlciBiZXR3ZWVuIC0xODAgYW5kIDE4MCwgYnV0IHdhczogJyArIGxvbmdpdHVkZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGF0ID0gbGF0aXR1ZGU7XG4gICAgICAgIHRoaXMuX2xvbmcgPSBsb25naXR1ZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBsYXRpdHVkZSBvZiB0aGlzIGBHZW9Qb2ludGAgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZ2V0IGxhdGl0dWRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbG9uZ2l0dWRlIG9mIHRoaXMgYEdlb1BvaW50YCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBnZXQgbG9uZ2l0dWRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9uZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgYEdlb1BvaW50YCBpcyBlcXVhbCB0byB0aGUgcHJvdmlkZWQgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIG90aGVyIC0gVGhlIGBHZW9Qb2ludGAgdG8gY29tcGFyZSBhZ2FpbnN0LlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhpcyBgR2VvUG9pbnRgIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXG4gICAgICovXG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF0ID09PSBvdGhlci5fbGF0ICYmIHRoaXMuX2xvbmcgPT09IG90aGVyLl9sb25nO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIEpTT04tc2VyaWFsaXphYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgR2VvUG9pbnQuICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBsYXRpdHVkZTogdGhpcy5fbGF0LCBsb25naXR1ZGU6IHRoaXMuX2xvbmcgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWN0dWFsbHkgcHJpdmF0ZSB0byBKUyBjb25zdW1lcnMgb2Ygb3VyIEFQSSwgc28gdGhpcyBmdW5jdGlvbiBpcyBwcmVmaXhlZFxuICAgICAqIHdpdGggYW4gdW5kZXJzY29yZS5cbiAgICAgKi9cbiAgICBfY29tcGFyZVRvKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAocHJpbWl0aXZlQ29tcGFyYXRvcih0aGlzLl9sYXQsIG90aGVyLl9sYXQpIHx8XG4gICAgICAgICAgICBwcmltaXRpdmVDb21wYXJhdG9yKHRoaXMuX2xvbmcsIG90aGVyLl9sb25nKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgdmVjdG9yIHR5cGUgaW4gRmlyZXN0b3JlIGRvY3VtZW50cy5cbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSB3aXRoIHtAbGluayBGaWVsZFZhbHVlLnZlY3Rvcn0uXG4gKlxuICogQGNsYXNzIFZlY3RvclZhbHVlXG4gKi9cbmNsYXNzIFZlY3RvclZhbHVlIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlcykge1xuICAgICAgICAvLyBNYWtpbmcgYSBjb3B5IG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9ICh2YWx1ZXMgfHwgW10pLm1hcChuID0+IG4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgcmF3IG51bWJlciBhcnJheSBmb3JtIG9mIHRoZSB2ZWN0b3IuXG4gICAgICovXG4gICAgdG9BcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlcy5tYXAobiA9PiBuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHR3byBWZWN0b3JWYWx1ZSBoYXMgdGhlIHNhbWUgcmF3IG51bWJlciBhcnJheXMsIHJldHVybnMgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gaXNQcmltaXRpdmVBcnJheUVxdWFsKHRoaXMuX3ZhbHVlcywgb3RoZXIuX3ZhbHVlcyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgUkVTRVJWRURfRklFTERfUkVHRVggPSAvXl9fLipfXyQvO1xuLyoqIFRoZSByZXN1bHQgb2YgcGFyc2luZyBkb2N1bWVudCBkYXRhIChlLmcuIGZvciBhIHNldERhdGEgY2FsbCkuICovXG5jbGFzcyBQYXJzZWRTZXREYXRhIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBmaWVsZE1hc2ssIGZpZWxkVHJhbnNmb3Jtcykge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmZpZWxkTWFzayA9IGZpZWxkTWFzaztcbiAgICAgICAgdGhpcy5maWVsZFRyYW5zZm9ybXMgPSBmaWVsZFRyYW5zZm9ybXM7XG4gICAgfVxuICAgIHRvTXV0YXRpb24oa2V5LCBwcmVjb25kaXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuZmllbGRNYXNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhdGNoTXV0YXRpb24oa2V5LCB0aGlzLmRhdGEsIHRoaXMuZmllbGRNYXNrLCBwcmVjb25kaXRpb24sIHRoaXMuZmllbGRUcmFuc2Zvcm1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2V0TXV0YXRpb24oa2V5LCB0aGlzLmRhdGEsIHByZWNvbmRpdGlvbiwgdGhpcy5maWVsZFRyYW5zZm9ybXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqIFRoZSByZXN1bHQgb2YgcGFyc2luZyBcInVwZGF0ZVwiIGRhdGEgKGkuZS4gZm9yIGFuIHVwZGF0ZURhdGEgY2FsbCkuICovXG5jbGFzcyBQYXJzZWRVcGRhdGVEYXRhIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBcbiAgICAvLyBUaGUgZmllbGRNYXNrIGRvZXMgbm90IGluY2x1ZGUgZG9jdW1lbnQgdHJhbnNmb3Jtcy5cbiAgICBmaWVsZE1hc2ssIGZpZWxkVHJhbnNmb3Jtcykge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmZpZWxkTWFzayA9IGZpZWxkTWFzaztcbiAgICAgICAgdGhpcy5maWVsZFRyYW5zZm9ybXMgPSBmaWVsZFRyYW5zZm9ybXM7XG4gICAgfVxuICAgIHRvTXV0YXRpb24oa2V5LCBwcmVjb25kaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXRjaE11dGF0aW9uKGtleSwgdGhpcy5kYXRhLCB0aGlzLmZpZWxkTWFzaywgcHJlY29uZGl0aW9uLCB0aGlzLmZpZWxkVHJhbnNmb3Jtcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNXcml0ZShkYXRhU291cmNlKSB7XG4gICAgc3dpdGNoIChkYXRhU291cmNlKSB7XG4gICAgICAgIGNhc2UgMCAvKiBVc2VyRGF0YVNvdXJjZS5TZXQgKi86IC8vIGZhbGwgdGhyb3VnaFxuICAgICAgICBjYXNlIDIgLyogVXNlckRhdGFTb3VyY2UuTWVyZ2VTZXQgKi86IC8vIGZhbGwgdGhyb3VnaFxuICAgICAgICBjYXNlIDEgLyogVXNlckRhdGFTb3VyY2UuVXBkYXRlICovOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgMyAvKiBVc2VyRGF0YVNvdXJjZS5Bcmd1bWVudCAqLzpcbiAgICAgICAgY2FzZSA0IC8qIFVzZXJEYXRhU291cmNlLkFycmF5QXJndW1lbnQgKi86XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBmYWlsKCk7XG4gICAgfVxufVxuLyoqIEEgXCJjb250ZXh0XCIgb2JqZWN0IHBhc3NlZCBhcm91bmQgd2hpbGUgcGFyc2luZyB1c2VyIGRhdGEuICovXG5jbGFzcyBQYXJzZUNvbnRleHRJbXBsIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhIFBhcnNlQ29udGV4dCB3aXRoIHRoZSBnaXZlbiBzb3VyY2UgYW5kIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2V0dGluZ3MgLSBUaGUgc2V0dGluZ3MgZm9yIHRoZSBwYXJzZXIuXG4gICAgICogQHBhcmFtIGRhdGFiYXNlSWQgLSBUaGUgZGF0YWJhc2UgSUQgb2YgdGhlIEZpcmVzdG9yZSBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0gc2VyaWFsaXplciAtIFRoZSBzZXJpYWxpemVyIHRvIHVzZSB0byBnZW5lcmF0ZSB0aGUgVmFsdWUgcHJvdG8uXG4gICAgICogQHBhcmFtIGlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMgLSBXaGV0aGVyIHRvIGlnbm9yZSB1bmRlZmluZWQgcHJvcGVydGllc1xuICAgICAqIHJhdGhlciB0aGFuIHRocm93LlxuICAgICAqIEBwYXJhbSBmaWVsZFRyYW5zZm9ybXMgLSBBIG11dGFibGUgbGlzdCBvZiBmaWVsZCB0cmFuc2Zvcm1zIGVuY291bnRlcmVkXG4gICAgICogd2hpbGUgcGFyc2luZyB0aGUgZGF0YS5cbiAgICAgKiBAcGFyYW0gZmllbGRNYXNrIC0gQSBtdXRhYmxlIGxpc3Qgb2YgZmllbGQgcGF0aHMgZW5jb3VudGVyZWQgd2hpbGUgcGFyc2luZ1xuICAgICAqIHRoZSBkYXRhLlxuICAgICAqXG4gICAgICogVE9ETyhiLzM0ODcxMTMxKTogV2UgZG9uJ3Qgc3VwcG9ydCBhcnJheSBwYXRocyByaWdodCBub3csIHNvIHBhdGggY2FuIGJlXG4gICAgICogbnVsbCB0byBpbmRpY2F0ZSB0aGUgY29udGV4dCByZXByZXNlbnRzIGFueSBsb2NhdGlvbiB3aXRoaW4gYW4gYXJyYXkgKGluXG4gICAgICogd2hpY2ggY2FzZSBjZXJ0YWluIGZlYXR1cmVzIHdpbGwgbm90IHdvcmsgYW5kIGVycm9ycyB3aWxsIGJlIHNvbWV3aGF0XG4gICAgICogY29tcHJvbWlzZWQpLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzLCBkYXRhYmFzZUlkLCBzZXJpYWxpemVyLCBpZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzLCBmaWVsZFRyYW5zZm9ybXMsIGZpZWxkTWFzaykge1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgICAgIHRoaXMuZGF0YWJhc2VJZCA9IGRhdGFiYXNlSWQ7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XG4gICAgICAgIHRoaXMuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcyA9IGlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXM7XG4gICAgICAgIC8vIE1pbm9yIGhhY2s6IElmIGZpZWxkVHJhbnNmb3JtcyBpcyB1bmRlZmluZWQsIHdlIGFzc3VtZSB0aGlzIGlzIGFuXG4gICAgICAgIC8vIGV4dGVybmFsIGNhbGwgYW5kIHdlIG5lZWQgdG8gdmFsaWRhdGUgdGhlIGVudGlyZSBwYXRoLlxuICAgICAgICBpZiAoZmllbGRUcmFuc2Zvcm1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maWVsZFRyYW5zZm9ybXMgPSBmaWVsZFRyYW5zZm9ybXMgfHwgW107XG4gICAgICAgIHRoaXMuZmllbGRNYXNrID0gZmllbGRNYXNrIHx8IFtdO1xuICAgIH1cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MucGF0aDtcbiAgICB9XG4gICAgZ2V0IGRhdGFTb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLmRhdGFTb3VyY2U7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGEgbmV3IGNvbnRleHQgd2l0aCB0aGUgc3BlY2lmaWVkIHNldHRpbmdzIG92ZXJ3cml0dGVuLiAqL1xuICAgIGNvbnRleHRXaXRoKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUNvbnRleHRJbXBsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zZXR0aW5ncyksIGNvbmZpZ3VyYXRpb24pLCB0aGlzLmRhdGFiYXNlSWQsIHRoaXMuc2VyaWFsaXplciwgdGhpcy5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzLCB0aGlzLmZpZWxkVHJhbnNmb3JtcywgdGhpcy5maWVsZE1hc2spO1xuICAgIH1cbiAgICBjaGlsZENvbnRleHRGb3JGaWVsZChmaWVsZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IChfYSA9IHRoaXMucGF0aCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNoaWxkKGZpZWxkKTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dFdpdGgoeyBwYXRoOiBjaGlsZFBhdGgsIGFycmF5RWxlbWVudDogZmFsc2UgfSk7XG4gICAgICAgIGNvbnRleHQudmFsaWRhdGVQYXRoU2VnbWVudChmaWVsZCk7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgICBjaGlsZENvbnRleHRGb3JGaWVsZFBhdGgoZmllbGQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjaGlsZFBhdGggPSAoX2EgPSB0aGlzLnBhdGgpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jaGlsZChmaWVsZCk7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHRXaXRoKHsgcGF0aDogY2hpbGRQYXRoLCBhcnJheUVsZW1lbnQ6IGZhbHNlIH0pO1xuICAgICAgICBjb250ZXh0LnZhbGlkYXRlUGF0aCgpO1xuICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gICAgY2hpbGRDb250ZXh0Rm9yQXJyYXkoaW5kZXgpIHtcbiAgICAgICAgLy8gVE9ETyhiLzM0ODcxMTMxKTogV2UgZG9uJ3Qgc3VwcG9ydCBhcnJheSBwYXRocyByaWdodCBub3c7IHNvIG1ha2UgcGF0aFxuICAgICAgICAvLyB1bmRlZmluZWQuXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHRXaXRoKHsgcGF0aDogdW5kZWZpbmVkLCBhcnJheUVsZW1lbnQ6IHRydWUgfSk7XG4gICAgfVxuICAgIGNyZWF0ZUVycm9yKHJlYXNvbikge1xuICAgICAgICByZXR1cm4gY3JlYXRlRXJyb3IocmVhc29uLCB0aGlzLnNldHRpbmdzLm1ldGhvZE5hbWUsIHRoaXMuc2V0dGluZ3MuaGFzQ29udmVydGVyIHx8IGZhbHNlLCB0aGlzLnBhdGgsIHRoaXMuc2V0dGluZ3MudGFyZ2V0RG9jKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgJ3RydWUnIGlmICdmaWVsZFBhdGgnIHdhcyB0cmF2ZXJzZWQgd2hlbiBjcmVhdGluZyB0aGlzIGNvbnRleHQuICovXG4gICAgY29udGFpbnMoZmllbGRQYXRoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5maWVsZE1hc2suZmluZChmaWVsZCA9PiBmaWVsZFBhdGguaXNQcmVmaXhPZihmaWVsZCkpICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIHRoaXMuZmllbGRUcmFuc2Zvcm1zLmZpbmQodHJhbnNmb3JtID0+IGZpZWxkUGF0aC5pc1ByZWZpeE9mKHRyYW5zZm9ybS5maWVsZCkpICE9PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICB2YWxpZGF0ZVBhdGgoKSB7XG4gICAgICAgIC8vIFRPRE8oYi8zNDg3MTEzMSk6IFJlbW92ZSBudWxsIGNoZWNrIG9uY2Ugd2UgaGF2ZSBwcm9wZXIgcGF0aHMgZm9yIGZpZWxkc1xuICAgICAgICAvLyB3aXRoaW4gYXJyYXlzLlxuICAgICAgICBpZiAoIXRoaXMucGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlUGF0aFNlZ21lbnQodGhpcy5wYXRoLmdldChpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFsaWRhdGVQYXRoU2VnbWVudChzZWdtZW50KSB7XG4gICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVFcnJvcignRG9jdW1lbnQgZmllbGRzIG11c3Qgbm90IGJlIGVtcHR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzV3JpdGUodGhpcy5kYXRhU291cmNlKSAmJiBSRVNFUlZFRF9GSUVMRF9SRUdFWC50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKCdEb2N1bWVudCBmaWVsZHMgY2Fubm90IGJlZ2luIGFuZCBlbmQgd2l0aCBcIl9fXCInKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogSGVscGVyIGZvciBwYXJzaW5nIHJhdyB1c2VyIGlucHV0IChwcm92aWRlZCB2aWEgdGhlIEFQSSkgaW50byBpbnRlcm5hbCBtb2RlbFxuICogY2xhc3Nlcy5cbiAqL1xuY2xhc3MgVXNlckRhdGFSZWFkZXIge1xuICAgIGNvbnN0cnVjdG9yKGRhdGFiYXNlSWQsIGlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMsIHNlcmlhbGl6ZXIpIHtcbiAgICAgICAgdGhpcy5kYXRhYmFzZUlkID0gZGF0YWJhc2VJZDtcbiAgICAgICAgdGhpcy5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzID0gaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcztcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplciB8fCBuZXdTZXJpYWxpemVyKGRhdGFiYXNlSWQpO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlcyBhIG5ldyB0b3AtbGV2ZWwgcGFyc2UgY29udGV4dC4gKi9cbiAgICBjcmVhdGVDb250ZXh0KGRhdGFTb3VyY2UsIG1ldGhvZE5hbWUsIHRhcmdldERvYywgaGFzQ29udmVydGVyID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUNvbnRleHRJbXBsKHtcbiAgICAgICAgICAgIGRhdGFTb3VyY2UsXG4gICAgICAgICAgICBtZXRob2ROYW1lLFxuICAgICAgICAgICAgdGFyZ2V0RG9jLFxuICAgICAgICAgICAgcGF0aDogRmllbGRQYXRoJDEuZW1wdHlQYXRoKCksXG4gICAgICAgICAgICBhcnJheUVsZW1lbnQ6IGZhbHNlLFxuICAgICAgICAgICAgaGFzQ29udmVydGVyXG4gICAgICAgIH0sIHRoaXMuZGF0YWJhc2VJZCwgdGhpcy5zZXJpYWxpemVyLCB0aGlzLmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5ld1VzZXJEYXRhUmVhZGVyKGZpcmVzdG9yZSkge1xuICAgIGNvbnN0IHNldHRpbmdzID0gZmlyZXN0b3JlLl9mcmVlemVTZXR0aW5ncygpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXdTZXJpYWxpemVyKGZpcmVzdG9yZS5fZGF0YWJhc2VJZCk7XG4gICAgcmV0dXJuIG5ldyBVc2VyRGF0YVJlYWRlcihmaXJlc3RvcmUuX2RhdGFiYXNlSWQsICEhc2V0dGluZ3MuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcywgc2VyaWFsaXplcik7XG59XG4vKiogUGFyc2UgZG9jdW1lbnQgZGF0YSBmcm9tIGEgc2V0KCkgY2FsbC4gKi9cbmZ1bmN0aW9uIHBhcnNlU2V0RGF0YSh1c2VyRGF0YVJlYWRlciwgbWV0aG9kTmFtZSwgdGFyZ2V0RG9jLCBpbnB1dCwgaGFzQ29udmVydGVyLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlckRhdGFSZWFkZXIuY3JlYXRlQ29udGV4dChvcHRpb25zLm1lcmdlIHx8IG9wdGlvbnMubWVyZ2VGaWVsZHNcbiAgICAgICAgPyAyIC8qIFVzZXJEYXRhU291cmNlLk1lcmdlU2V0ICovXG4gICAgICAgIDogMCAvKiBVc2VyRGF0YVNvdXJjZS5TZXQgKi8sIG1ldGhvZE5hbWUsIHRhcmdldERvYywgaGFzQ29udmVydGVyKTtcbiAgICB2YWxpZGF0ZVBsYWluT2JqZWN0KCdEYXRhIG11c3QgYmUgYW4gb2JqZWN0LCBidXQgaXQgd2FzOicsIGNvbnRleHQsIGlucHV0KTtcbiAgICBjb25zdCB1cGRhdGVEYXRhID0gcGFyc2VPYmplY3QoaW5wdXQsIGNvbnRleHQpO1xuICAgIGxldCBmaWVsZE1hc2s7XG4gICAgbGV0IGZpZWxkVHJhbnNmb3JtcztcbiAgICBpZiAob3B0aW9ucy5tZXJnZSkge1xuICAgICAgICBmaWVsZE1hc2sgPSBuZXcgRmllbGRNYXNrKGNvbnRleHQuZmllbGRNYXNrKTtcbiAgICAgICAgZmllbGRUcmFuc2Zvcm1zID0gY29udGV4dC5maWVsZFRyYW5zZm9ybXM7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnMubWVyZ2VGaWVsZHMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkRmllbGRQYXRocyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHN0cmluZ09yRmllbGRQYXRoIG9mIG9wdGlvbnMubWVyZ2VGaWVsZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkUGF0aCA9IGZpZWxkUGF0aEZyb21Bcmd1bWVudCQxKG1ldGhvZE5hbWUsIHN0cmluZ09yRmllbGRQYXRoLCB0YXJnZXREb2MpO1xuICAgICAgICAgICAgaWYgKCFjb250ZXh0LmNvbnRhaW5zKGZpZWxkUGF0aCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgRmllbGQgJyR7ZmllbGRQYXRofScgaXMgc3BlY2lmaWVkIGluIHlvdXIgZmllbGQgbWFzayBidXQgbWlzc2luZyBmcm9tIHlvdXIgaW5wdXQgZGF0YS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZmllbGRNYXNrQ29udGFpbnModmFsaWRhdGVkRmllbGRQYXRocywgZmllbGRQYXRoKSkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRlZEZpZWxkUGF0aHMucHVzaChmaWVsZFBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpZWxkTWFzayA9IG5ldyBGaWVsZE1hc2sodmFsaWRhdGVkRmllbGRQYXRocyk7XG4gICAgICAgIGZpZWxkVHJhbnNmb3JtcyA9IGNvbnRleHQuZmllbGRUcmFuc2Zvcm1zLmZpbHRlcih0cmFuc2Zvcm0gPT4gZmllbGRNYXNrLmNvdmVycyh0cmFuc2Zvcm0uZmllbGQpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZpZWxkTWFzayA9IG51bGw7XG4gICAgICAgIGZpZWxkVHJhbnNmb3JtcyA9IGNvbnRleHQuZmllbGRUcmFuc2Zvcm1zO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFBhcnNlZFNldERhdGEobmV3IE9iamVjdFZhbHVlKHVwZGF0ZURhdGEpLCBmaWVsZE1hc2ssIGZpZWxkVHJhbnNmb3Jtcyk7XG59XG5jbGFzcyBEZWxldGVGaWVsZFZhbHVlSW1wbCBleHRlbmRzIEZpZWxkVmFsdWUge1xuICAgIF90b0ZpZWxkVHJhbnNmb3JtKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuZGF0YVNvdXJjZSA9PT0gMiAvKiBVc2VyRGF0YVNvdXJjZS5NZXJnZVNldCAqLykge1xuICAgICAgICAgICAgLy8gTm8gdHJhbnNmb3JtIHRvIGFkZCBmb3IgYSBkZWxldGUsIGJ1dCB3ZSBuZWVkIHRvIGFkZCBpdCB0byBvdXJcbiAgICAgICAgICAgIC8vIGZpZWxkTWFzayBzbyBpdCBnZXRzIGRlbGV0ZWQuXG4gICAgICAgICAgICBjb250ZXh0LmZpZWxkTWFzay5wdXNoKGNvbnRleHQucGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGV4dC5kYXRhU291cmNlID09PSAxIC8qIFVzZXJEYXRhU291cmNlLlVwZGF0ZSAqLykge1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5jcmVhdGVFcnJvcihgJHt0aGlzLl9tZXRob2ROYW1lfSgpIGNhbiBvbmx5IGFwcGVhciBhdCB0aGUgdG9wIGxldmVsIGAgK1xuICAgICAgICAgICAgICAgICdvZiB5b3VyIHVwZGF0ZSBkYXRhJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBzaG91bGRuJ3QgZW5jb3VudGVyIGRlbGV0ZSBzZW50aW5lbHMgZm9yIHF1ZXJpZXMgb3Igbm9uLW1lcmdlIHNldCgpIGNhbGxzLlxuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5jcmVhdGVFcnJvcihgJHt0aGlzLl9tZXRob2ROYW1lfSgpIGNhbm5vdCBiZSB1c2VkIHdpdGggc2V0KCkgdW5sZXNzIHlvdSBwYXNzIGAgK1xuICAgICAgICAgICAgICAgICd7bWVyZ2U6dHJ1ZX0nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBEZWxldGVGaWVsZFZhbHVlSW1wbDtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYSBjaGlsZCBjb250ZXh0IGZvciBwYXJzaW5nIFNlcmlhbGl6YWJsZUZpZWxkVmFsdWVzLlxuICpcbiAqIFRoaXMgaXMgZGlmZmVyZW50IHRoYW4gY2FsbGluZyBgUGFyc2VDb250ZXh0LmNvbnRleHRXaXRoYCBiZWNhdXNlIGl0IGtlZXBzXG4gKiB0aGUgZmllbGRUcmFuc2Zvcm1zIGFuZCBmaWVsZE1hc2sgc2VwYXJhdGUuXG4gKlxuICogVGhlIGNyZWF0ZWQgY29udGV4dCBoYXMgaXRzIGBkYXRhU291cmNlYCBzZXQgdG8gYFVzZXJEYXRhU291cmNlLkFyZ3VtZW50YC5cbiAqIEFsdGhvdWdoIHRoZXNlIHZhbHVlcyBhcmUgdXNlZCB3aXRoIHdyaXRlcywgYW55IGVsZW1lbnRzIGluIHRoZXNlIEZpZWxkVmFsdWVzXG4gKiBhcmUgbm90IGNvbnNpZGVyZWQgd3JpdGVzIHNpbmNlIHRoZXkgY2Fubm90IGNvbnRhaW4gYW55IEZpZWxkVmFsdWUgc2VudGluZWxzLFxuICogZXRjLlxuICpcbiAqIEBwYXJhbSBmaWVsZFZhbHVlIC0gVGhlIHNlbnRpbmVsIEZpZWxkVmFsdWUgZm9yIHdoaWNoIHRvIGNyZWF0ZSBhIGNoaWxkXG4gKiAgICAgY29udGV4dC5cbiAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIHBhcmVudCBjb250ZXh0LlxuICogQHBhcmFtIGFycmF5RWxlbWVudCAtIFdoZXRoZXIgb3Igbm90IHRoZSBGaWVsZFZhbHVlIGhhcyBhbiBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2VudGluZWxDaGlsZENvbnRleHQoZmllbGRWYWx1ZSwgY29udGV4dCwgYXJyYXlFbGVtZW50KSB7XG4gICAgcmV0dXJuIG5ldyBQYXJzZUNvbnRleHRJbXBsKHtcbiAgICAgICAgZGF0YVNvdXJjZTogMyAvKiBVc2VyRGF0YVNvdXJjZS5Bcmd1bWVudCAqLyxcbiAgICAgICAgdGFyZ2V0RG9jOiBjb250ZXh0LnNldHRpbmdzLnRhcmdldERvYyxcbiAgICAgICAgbWV0aG9kTmFtZTogZmllbGRWYWx1ZS5fbWV0aG9kTmFtZSxcbiAgICAgICAgYXJyYXlFbGVtZW50XG4gICAgfSwgY29udGV4dC5kYXRhYmFzZUlkLCBjb250ZXh0LnNlcmlhbGl6ZXIsIGNvbnRleHQuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcyk7XG59XG5jbGFzcyBTZXJ2ZXJUaW1lc3RhbXBGaWVsZFZhbHVlSW1wbCBleHRlbmRzIEZpZWxkVmFsdWUge1xuICAgIF90b0ZpZWxkVHJhbnNmb3JtKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFRyYW5zZm9ybShjb250ZXh0LnBhdGgsIG5ldyBTZXJ2ZXJUaW1lc3RhbXBUcmFuc2Zvcm0oKSk7XG4gICAgfVxuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgU2VydmVyVGltZXN0YW1wRmllbGRWYWx1ZUltcGw7XG4gICAgfVxufVxuY2xhc3MgQXJyYXlVbmlvbkZpZWxkVmFsdWVJbXBsIGV4dGVuZHMgRmllbGRWYWx1ZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kTmFtZSwgX2VsZW1lbnRzKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZE5hbWUpO1xuICAgICAgICB0aGlzLl9lbGVtZW50cyA9IF9lbGVtZW50cztcbiAgICB9XG4gICAgX3RvRmllbGRUcmFuc2Zvcm0oY29udGV4dCkge1xuICAgICAgICBjb25zdCBwYXJzZUNvbnRleHQgPSBjcmVhdGVTZW50aW5lbENoaWxkQ29udGV4dCh0aGlzLCBjb250ZXh0LCBcbiAgICAgICAgLyphcnJheT0qLyB0cnVlKTtcbiAgICAgICAgY29uc3QgcGFyc2VkRWxlbWVudHMgPSB0aGlzLl9lbGVtZW50cy5tYXAoZWxlbWVudCA9PiBwYXJzZURhdGEoZWxlbWVudCwgcGFyc2VDb250ZXh0KSk7XG4gICAgICAgIGNvbnN0IGFycmF5VW5pb24gPSBuZXcgQXJyYXlVbmlvblRyYW5zZm9ybU9wZXJhdGlvbihwYXJzZWRFbGVtZW50cyk7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGRUcmFuc2Zvcm0oY29udGV4dC5wYXRoLCBhcnJheVVuaW9uKTtcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gKG90aGVyIGluc3RhbmNlb2YgQXJyYXlVbmlvbkZpZWxkVmFsdWVJbXBsICYmXG4gICAgICAgICAgICBkZWVwRXF1YWwodGhpcy5fZWxlbWVudHMsIG90aGVyLl9lbGVtZW50cykpO1xuICAgIH1cbn1cbmNsYXNzIEFycmF5UmVtb3ZlRmllbGRWYWx1ZUltcGwgZXh0ZW5kcyBGaWVsZFZhbHVlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2ROYW1lLCBfZWxlbWVudHMpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kTmFtZSk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzID0gX2VsZW1lbnRzO1xuICAgIH1cbiAgICBfdG9GaWVsZFRyYW5zZm9ybShjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlQ29udGV4dCA9IGNyZWF0ZVNlbnRpbmVsQ2hpbGRDb250ZXh0KHRoaXMsIGNvbnRleHQsIFxuICAgICAgICAvKmFycmF5PSovIHRydWUpO1xuICAgICAgICBjb25zdCBwYXJzZWRFbGVtZW50cyA9IHRoaXMuX2VsZW1lbnRzLm1hcChlbGVtZW50ID0+IHBhcnNlRGF0YShlbGVtZW50LCBwYXJzZUNvbnRleHQpKTtcbiAgICAgICAgY29uc3QgYXJyYXlVbmlvbiA9IG5ldyBBcnJheVJlbW92ZVRyYW5zZm9ybU9wZXJhdGlvbihwYXJzZWRFbGVtZW50cyk7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGRUcmFuc2Zvcm0oY29udGV4dC5wYXRoLCBhcnJheVVuaW9uKTtcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gKG90aGVyIGluc3RhbmNlb2YgQXJyYXlSZW1vdmVGaWVsZFZhbHVlSW1wbCAmJlxuICAgICAgICAgICAgZGVlcEVxdWFsKHRoaXMuX2VsZW1lbnRzLCBvdGhlci5fZWxlbWVudHMpKTtcbiAgICB9XG59XG5jbGFzcyBOdW1lcmljSW5jcmVtZW50RmllbGRWYWx1ZUltcGwgZXh0ZW5kcyBGaWVsZFZhbHVlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2ROYW1lLCBfb3BlcmFuZCkge1xuICAgICAgICBzdXBlcihtZXRob2ROYW1lKTtcbiAgICAgICAgdGhpcy5fb3BlcmFuZCA9IF9vcGVyYW5kO1xuICAgIH1cbiAgICBfdG9GaWVsZFRyYW5zZm9ybShjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IG51bWVyaWNJbmNyZW1lbnQgPSBuZXcgTnVtZXJpY0luY3JlbWVudFRyYW5zZm9ybU9wZXJhdGlvbihjb250ZXh0LnNlcmlhbGl6ZXIsIHRvTnVtYmVyKGNvbnRleHQuc2VyaWFsaXplciwgdGhpcy5fb3BlcmFuZCkpO1xuICAgICAgICByZXR1cm4gbmV3IEZpZWxkVHJhbnNmb3JtKGNvbnRleHQucGF0aCwgbnVtZXJpY0luY3JlbWVudCk7XG4gICAgfVxuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIChvdGhlciBpbnN0YW5jZW9mIE51bWVyaWNJbmNyZW1lbnRGaWVsZFZhbHVlSW1wbCAmJlxuICAgICAgICAgICAgdGhpcy5fb3BlcmFuZCA9PT0gb3RoZXIuX29wZXJhbmQpO1xuICAgIH1cbn1cbi8qKiBQYXJzZSB1cGRhdGUgZGF0YSBmcm9tIGFuIHVwZGF0ZSgpIGNhbGwuICovXG5mdW5jdGlvbiBwYXJzZVVwZGF0ZURhdGEodXNlckRhdGFSZWFkZXIsIG1ldGhvZE5hbWUsIHRhcmdldERvYywgaW5wdXQpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlckRhdGFSZWFkZXIuY3JlYXRlQ29udGV4dCgxIC8qIFVzZXJEYXRhU291cmNlLlVwZGF0ZSAqLywgbWV0aG9kTmFtZSwgdGFyZ2V0RG9jKTtcbiAgICB2YWxpZGF0ZVBsYWluT2JqZWN0KCdEYXRhIG11c3QgYmUgYW4gb2JqZWN0LCBidXQgaXQgd2FzOicsIGNvbnRleHQsIGlucHV0KTtcbiAgICBjb25zdCBmaWVsZE1hc2tQYXRocyA9IFtdO1xuICAgIGNvbnN0IHVwZGF0ZURhdGEgPSBPYmplY3RWYWx1ZS5lbXB0eSgpO1xuICAgIGZvckVhY2goaW5wdXQsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBmaWVsZFBhdGhGcm9tRG90U2VwYXJhdGVkU3RyaW5nKG1ldGhvZE5hbWUsIGtleSwgdGFyZ2V0RG9jKTtcbiAgICAgICAgLy8gRm9yIENvbXBhdCB0eXBlcywgd2UgaGF2ZSB0byBcImV4dHJhY3RcIiB0aGUgdW5kZXJseWluZyB0eXBlcyBiZWZvcmVcbiAgICAgICAgLy8gcGVyZm9ybWluZyB2YWxpZGF0aW9uLlxuICAgICAgICB2YWx1ZSA9IGdldE1vZHVsYXJJbnN0YW5jZSh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IGNoaWxkQ29udGV4dCA9IGNvbnRleHQuY2hpbGRDb250ZXh0Rm9yRmllbGRQYXRoKHBhdGgpO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEZWxldGVGaWVsZFZhbHVlSW1wbCkge1xuICAgICAgICAgICAgLy8gQWRkIGl0IHRvIHRoZSBmaWVsZCBtYXNrLCBidXQgZG9uJ3QgYWRkIGFueXRoaW5nIHRvIHVwZGF0ZURhdGEuXG4gICAgICAgICAgICBmaWVsZE1hc2tQYXRocy5wdXNoKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZURhdGEodmFsdWUsIGNoaWxkQ29udGV4dCk7XG4gICAgICAgICAgICBpZiAocGFyc2VkVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZpZWxkTWFza1BhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlRGF0YS5zZXQocGF0aCwgcGFyc2VkVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgbWFzayA9IG5ldyBGaWVsZE1hc2soZmllbGRNYXNrUGF0aHMpO1xuICAgIHJldHVybiBuZXcgUGFyc2VkVXBkYXRlRGF0YSh1cGRhdGVEYXRhLCBtYXNrLCBjb250ZXh0LmZpZWxkVHJhbnNmb3Jtcyk7XG59XG4vKiogUGFyc2UgdXBkYXRlIGRhdGEgZnJvbSBhIGxpc3Qgb2YgZmllbGQvdmFsdWUgYXJndW1lbnRzLiAqL1xuZnVuY3Rpb24gcGFyc2VVcGRhdGVWYXJhcmdzKHVzZXJEYXRhUmVhZGVyLCBtZXRob2ROYW1lLCB0YXJnZXREb2MsIGZpZWxkLCB2YWx1ZSwgbW9yZUZpZWxkc0FuZFZhbHVlcykge1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VyRGF0YVJlYWRlci5jcmVhdGVDb250ZXh0KDEgLyogVXNlckRhdGFTb3VyY2UuVXBkYXRlICovLCBtZXRob2ROYW1lLCB0YXJnZXREb2MpO1xuICAgIGNvbnN0IGtleXMgPSBbZmllbGRQYXRoRnJvbUFyZ3VtZW50JDEobWV0aG9kTmFtZSwgZmllbGQsIHRhcmdldERvYyldO1xuICAgIGNvbnN0IHZhbHVlcyA9IFt2YWx1ZV07XG4gICAgaWYgKG1vcmVGaWVsZHNBbmRWYWx1ZXMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgRnVuY3Rpb24gJHttZXRob2ROYW1lfSgpIG5lZWRzIHRvIGJlIGNhbGxlZCB3aXRoIGFuIGV2ZW4gbnVtYmVyIGAgK1xuICAgICAgICAgICAgJ29mIGFyZ3VtZW50cyB0aGF0IGFsdGVybmF0ZSBiZXR3ZWVuIGZpZWxkIG5hbWVzIGFuZCB2YWx1ZXMuJyk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9yZUZpZWxkc0FuZFZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBrZXlzLnB1c2goZmllbGRQYXRoRnJvbUFyZ3VtZW50JDEobWV0aG9kTmFtZSwgbW9yZUZpZWxkc0FuZFZhbHVlc1tpXSkpO1xuICAgICAgICB2YWx1ZXMucHVzaChtb3JlRmllbGRzQW5kVmFsdWVzW2kgKyAxXSk7XG4gICAgfVxuICAgIGNvbnN0IGZpZWxkTWFza1BhdGhzID0gW107XG4gICAgY29uc3QgdXBkYXRlRGF0YSA9IE9iamVjdFZhbHVlLmVtcHR5KCk7XG4gICAgLy8gV2UgaXRlcmF0ZSBpbiByZXZlcnNlIG9yZGVyIHRvIHBpY2sgdGhlIGxhc3QgdmFsdWUgZm9yIGEgZmllbGQgaWYgdGhlXG4gICAgLy8gdXNlciBzcGVjaWZpZWQgdGhlIGZpZWxkIG11bHRpcGxlIHRpbWVzLlxuICAgIGZvciAobGV0IGkgPSBrZXlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGlmICghZmllbGRNYXNrQ29udGFpbnMoZmllbGRNYXNrUGF0aHMsIGtleXNbaV0pKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIC8vIEZvciBDb21wYXQgdHlwZXMsIHdlIGhhdmUgdG8gXCJleHRyYWN0XCIgdGhlIHVuZGVybHlpbmcgdHlwZXMgYmVmb3JlXG4gICAgICAgICAgICAvLyBwZXJmb3JtaW5nIHZhbGlkYXRpb24uXG4gICAgICAgICAgICB2YWx1ZSA9IGdldE1vZHVsYXJJbnN0YW5jZSh2YWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZENvbnRleHQgPSBjb250ZXh0LmNoaWxkQ29udGV4dEZvckZpZWxkUGF0aChwYXRoKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERlbGV0ZUZpZWxkVmFsdWVJbXBsKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGl0IHRvIHRoZSBmaWVsZCBtYXNrLCBidXQgZG9uJ3QgYWRkIGFueXRoaW5nIHRvIHVwZGF0ZURhdGEuXG4gICAgICAgICAgICAgICAgZmllbGRNYXNrUGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VEYXRhKHZhbHVlLCBjaGlsZENvbnRleHQpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkTWFza1BhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZURhdGEuc2V0KHBhdGgsIHBhcnNlZFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWFzayA9IG5ldyBGaWVsZE1hc2soZmllbGRNYXNrUGF0aHMpO1xuICAgIHJldHVybiBuZXcgUGFyc2VkVXBkYXRlRGF0YSh1cGRhdGVEYXRhLCBtYXNrLCBjb250ZXh0LmZpZWxkVHJhbnNmb3Jtcyk7XG59XG4vKipcbiAqIFBhcnNlIGEgXCJxdWVyeSB2YWx1ZVwiIChlLmcuIHZhbHVlIGluIGEgd2hlcmUgZmlsdGVyIG9yIGEgdmFsdWUgaW4gYSBjdXJzb3JcbiAqIGJvdW5kKS5cbiAqXG4gKiBAcGFyYW0gYWxsb3dBcnJheXMgLSBXaGV0aGVyIHRoZSBxdWVyeSB2YWx1ZSBpcyBhbiBhcnJheSB0aGF0IG1heSBkaXJlY3RseVxuICogY29udGFpbiBhZGRpdGlvbmFsIGFycmF5cyAoZS5nLiB0aGUgb3BlcmFuZCBvZiBhbiBgaW5gIHF1ZXJ5KS5cbiAqL1xuZnVuY3Rpb24gcGFyc2VRdWVyeVZhbHVlKHVzZXJEYXRhUmVhZGVyLCBtZXRob2ROYW1lLCBpbnB1dCwgYWxsb3dBcnJheXMgPSBmYWxzZSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VyRGF0YVJlYWRlci5jcmVhdGVDb250ZXh0KGFsbG93QXJyYXlzID8gNCAvKiBVc2VyRGF0YVNvdXJjZS5BcnJheUFyZ3VtZW50ICovIDogMyAvKiBVc2VyRGF0YVNvdXJjZS5Bcmd1bWVudCAqLywgbWV0aG9kTmFtZSk7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VEYXRhKGlucHV0LCBjb250ZXh0KTtcbiAgICByZXR1cm4gcGFyc2VkO1xufVxuLyoqXG4gKiBQYXJzZXMgdXNlciBkYXRhIHRvIFByb3RvYnVmIFZhbHVlcy5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBEYXRhIHRvIGJlIHBhcnNlZC5cbiAqIEBwYXJhbSBjb250ZXh0IC0gQSBjb250ZXh0IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgcGF0aCBiZWluZyBwYXJzZWQsXG4gKiB0aGUgc291cmNlIG9mIHRoZSBkYXRhIGJlaW5nIHBhcnNlZCwgZXRjLlxuICogQHJldHVybnMgVGhlIHBhcnNlZCB2YWx1ZSwgb3IgbnVsbCBpZiB0aGUgdmFsdWUgd2FzIGEgRmllbGRWYWx1ZSBzZW50aW5lbFxuICogdGhhdCBzaG91bGQgbm90IGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHRpbmcgcGFyc2VkIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRGF0YShpbnB1dCwgY29udGV4dCkge1xuICAgIC8vIFVud3JhcCB0aGUgQVBJIHR5cGUgZnJvbSB0aGUgQ29tcGF0IFNESy4gVGhpcyB3aWxsIHJldHVybiB0aGUgQVBJIHR5cGVcbiAgICAvLyBmcm9tIGZpcmVzdG9yZS1leHAuXG4gICAgaW5wdXQgPSBnZXRNb2R1bGFySW5zdGFuY2UoaW5wdXQpO1xuICAgIGlmIChsb29rc0xpa2VKc29uT2JqZWN0KGlucHV0KSkge1xuICAgICAgICB2YWxpZGF0ZVBsYWluT2JqZWN0KCdVbnN1cHBvcnRlZCBmaWVsZCB2YWx1ZTonLCBjb250ZXh0LCBpbnB1dCk7XG4gICAgICAgIHJldHVybiBwYXJzZU9iamVjdChpbnB1dCwgY29udGV4dCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgRmllbGRWYWx1ZSkge1xuICAgICAgICAvLyBGaWVsZFZhbHVlcyB1c3VhbGx5IHBhcnNlIGludG8gdHJhbnNmb3JtcyAoZXhjZXB0IGRlbGV0ZUZpZWxkKCkpXG4gICAgICAgIC8vIGluIHdoaWNoIGNhc2Ugd2UgZG8gbm90IHdhbnQgdG8gaW5jbHVkZSB0aGlzIGZpZWxkIGluIG91ciBwYXJzZWQgZGF0YVxuICAgICAgICAvLyAoYXMgZG9pbmcgc28gd2lsbCBvdmVyd3JpdGUgdGhlIGZpZWxkIGRpcmVjdGx5IHByaW9yIHRvIHRoZSB0cmFuc2Zvcm1cbiAgICAgICAgLy8gdHJ5aW5nIHRvIHRyYW5zZm9ybSBpdCkuIFNvIHdlIGRvbid0IGFkZCB0aGlzIGxvY2F0aW9uIHRvXG4gICAgICAgIC8vIGNvbnRleHQuZmllbGRNYXNrIGFuZCB3ZSByZXR1cm4gbnVsbCBhcyBvdXIgcGFyc2luZyByZXN1bHQuXG4gICAgICAgIHBhcnNlU2VudGluZWxGaWVsZFZhbHVlKGlucHV0LCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlucHV0ID09PSB1bmRlZmluZWQgJiYgY29udGV4dC5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzKSB7XG4gICAgICAgIC8vIElmIHRoZSBpbnB1dCBpcyB1bmRlZmluZWQgaXQgY2FuIG5ldmVyIHBhcnRpY2lwYXRlIGluIHRoZSBmaWVsZE1hc2ssIHNvXG4gICAgICAgIC8vIGRvbid0IGhhbmRsZSB0aGlzIGJlbG93LiBJZiBgaWdub3JlVW5kZWZpbmVkUHJvcGVydGllc2AgaXMgZmFsc2UsXG4gICAgICAgIC8vIGBwYXJzZVNjYWxhclZhbHVlYCB3aWxsIHJlamVjdCBhbiB1bmRlZmluZWQgdmFsdWUuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSWYgY29udGV4dC5wYXRoIGlzIG51bGwgd2UgYXJlIGluc2lkZSBhbiBhcnJheSBhbmQgd2UgZG9uJ3Qgc3VwcG9ydFxuICAgICAgICAvLyBmaWVsZCBtYXNrIHBhdGhzIG1vcmUgZ3JhbnVsYXIgdGhhbiB0aGUgdG9wLWxldmVsIGFycmF5LlxuICAgICAgICBpZiAoY29udGV4dC5wYXRoKSB7XG4gICAgICAgICAgICBjb250ZXh0LmZpZWxkTWFzay5wdXNoKGNvbnRleHQucGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIC8vIFRPRE8oYi8zNDg3MTEzMSk6IEluY2x1ZGUgdGhlIHBhdGggY29udGFpbmluZyB0aGUgYXJyYXkgaW4gdGhlIGVycm9yXG4gICAgICAgICAgICAvLyBtZXNzYWdlLlxuICAgICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgSU4gcXVlcmllcywgdGhlIHBhcnNlZCBkYXRhIGlzIGFuIGFycmF5IChyZXByZXNlbnRpbmdcbiAgICAgICAgICAgIC8vIHRoZSBzZXQgb2YgdmFsdWVzIHRvIGJlIGluY2x1ZGVkIGZvciB0aGUgSU4gcXVlcnkpIHRoYXQgbWF5IGRpcmVjdGx5XG4gICAgICAgICAgICAvLyBjb250YWluIGFkZGl0aW9uYWwgYXJyYXlzIChlYWNoIHJlcHJlc2VudGluZyBhbiBpbmRpdmlkdWFsIGZpZWxkXG4gICAgICAgICAgICAvLyB2YWx1ZSksIHNvIHdlIGRpc2FibGUgdGhpcyB2YWxpZGF0aW9uLlxuICAgICAgICAgICAgaWYgKGNvbnRleHQuc2V0dGluZ3MuYXJyYXlFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgY29udGV4dC5kYXRhU291cmNlICE9PSA0IC8qIFVzZXJEYXRhU291cmNlLkFycmF5QXJndW1lbnQgKi8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKCdOZXN0ZWQgYXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VBcnJheShpbnB1dCwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VTY2FsYXJWYWx1ZShpbnB1dCwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZU9iamVjdChvYmosIGNvbnRleHQpIHtcbiAgICBjb25zdCBmaWVsZHMgPSB7fTtcbiAgICBpZiAoaXNFbXB0eShvYmopKSB7XG4gICAgICAgIC8vIElmIHdlIGVuY291bnRlciBhbiBlbXB0eSBvYmplY3QsIHdlIGV4cGxpY2l0bHkgYWRkIGl0IHRvIHRoZSB1cGRhdGVcbiAgICAgICAgLy8gbWFzayB0byBlbnN1cmUgdGhhdCB0aGUgc2VydmVyIGNyZWF0ZXMgYSBtYXAgZW50cnkuXG4gICAgICAgIGlmIChjb250ZXh0LnBhdGggJiYgY29udGV4dC5wYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnRleHQuZmllbGRNYXNrLnB1c2goY29udGV4dC5wYXRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yRWFjaChvYmosIChrZXksIHZhbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZURhdGEodmFsLCBjb250ZXh0LmNoaWxkQ29udGV4dEZvckZpZWxkKGtleSkpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmaWVsZHNba2V5XSA9IHBhcnNlZFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWFwVmFsdWU6IHsgZmllbGRzIH0gfTtcbn1cbmZ1bmN0aW9uIHBhcnNlQXJyYXkoYXJyYXksIGNvbnRleHQpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBsZXQgZW50cnlJbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBhcnJheSkge1xuICAgICAgICBsZXQgcGFyc2VkRW50cnkgPSBwYXJzZURhdGEoZW50cnksIGNvbnRleHQuY2hpbGRDb250ZXh0Rm9yQXJyYXkoZW50cnlJbmRleCkpO1xuICAgICAgICBpZiAocGFyc2VkRW50cnkgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSnVzdCBpbmNsdWRlIG51bGxzIGluIHRoZSBhcnJheSBmb3IgZmllbGRzIGJlaW5nIHJlcGxhY2VkIHdpdGggYVxuICAgICAgICAgICAgLy8gc2VudGluZWwuXG4gICAgICAgICAgICBwYXJzZWRFbnRyeSA9IHsgbnVsbFZhbHVlOiAnTlVMTF9WQUxVRScgfTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXMucHVzaChwYXJzZWRFbnRyeSk7XG4gICAgICAgIGVudHJ5SW5kZXgrKztcbiAgICB9XG4gICAgcmV0dXJuIHsgYXJyYXlWYWx1ZTogeyB2YWx1ZXMgfSB9O1xufVxuLyoqXG4gKiBcIlBhcnNlc1wiIHRoZSBwcm92aWRlZCBGaWVsZFZhbHVlSW1wbCwgYWRkaW5nIGFueSBuZWNlc3NhcnkgdHJhbnNmb3JtcyB0b1xuICogY29udGV4dC5maWVsZFRyYW5zZm9ybXMuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU2VudGluZWxGaWVsZFZhbHVlKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgLy8gU2VudGluZWxzIGFyZSBvbmx5IHN1cHBvcnRlZCB3aXRoIHdyaXRlcywgYW5kIG5vdCB3aXRoaW4gYXJyYXlzLlxuICAgIGlmICghaXNXcml0ZShjb250ZXh0LmRhdGFTb3VyY2UpKSB7XG4gICAgICAgIHRocm93IGNvbnRleHQuY3JlYXRlRXJyb3IoYCR7dmFsdWUuX21ldGhvZE5hbWV9KCkgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIHVwZGF0ZSgpIGFuZCBzZXQoKWApO1xuICAgIH1cbiAgICBpZiAoIWNvbnRleHQucGF0aCkge1xuICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKGAke3ZhbHVlLl9tZXRob2ROYW1lfSgpIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGluc2lkZSBhcnJheXNgKTtcbiAgICB9XG4gICAgY29uc3QgZmllbGRUcmFuc2Zvcm0gPSB2YWx1ZS5fdG9GaWVsZFRyYW5zZm9ybShjb250ZXh0KTtcbiAgICBpZiAoZmllbGRUcmFuc2Zvcm0pIHtcbiAgICAgICAgY29udGV4dC5maWVsZFRyYW5zZm9ybXMucHVzaChmaWVsZFRyYW5zZm9ybSk7XG4gICAgfVxufVxuLyoqXG4gKiBIZWxwZXIgdG8gcGFyc2UgYSBzY2FsYXIgdmFsdWUgKGkuZS4gbm90IGFuIE9iamVjdCwgQXJyYXksIG9yIEZpZWxkVmFsdWUpXG4gKlxuICogQHJldHVybnMgVGhlIHBhcnNlZCB2YWx1ZVxuICovXG5mdW5jdGlvbiBwYXJzZVNjYWxhclZhbHVlKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgdmFsdWUgPSBnZXRNb2R1bGFySW5zdGFuY2UodmFsdWUpO1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4geyBudWxsVmFsdWU6ICdOVUxMX1ZBTFVFJyB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB0b051bWJlcihjb250ZXh0LnNlcmlhbGl6ZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIHsgYm9vbGVhblZhbHVlOiB2YWx1ZSB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB7IHN0cmluZ1ZhbHVlOiB2YWx1ZSB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gVGltZXN0YW1wLmZyb21EYXRlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcFZhbHVlOiB0b1RpbWVzdGFtcChjb250ZXh0LnNlcmlhbGl6ZXIsIHRpbWVzdGFtcClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBUaW1lc3RhbXApIHtcbiAgICAgICAgLy8gRmlyZXN0b3JlIGJhY2tlbmQgdHJ1bmNhdGVzIHByZWNpc2lvbiBkb3duIHRvIG1pY3Jvc2Vjb25kcy4gVG8gZW5zdXJlXG4gICAgICAgIC8vIG9mZmxpbmUgbW9kZSB3b3JrcyB0aGUgc2FtZSB3aXRoIHJlZ2FyZHMgdG8gdHJ1bmNhdGlvbiwgcGVyZm9ybSB0aGVcbiAgICAgICAgLy8gdHJ1bmNhdGlvbiBpbW1lZGlhdGVseSB3aXRob3V0IHdhaXRpbmcgZm9yIHRoZSBiYWNrZW5kIHRvIGRvIHRoYXQuXG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBUaW1lc3RhbXAodmFsdWUuc2Vjb25kcywgTWF0aC5mbG9vcih2YWx1ZS5uYW5vc2Vjb25kcyAvIDEwMDApICogMTAwMCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0aW1lc3RhbXBWYWx1ZTogdG9UaW1lc3RhbXAoY29udGV4dC5zZXJpYWxpemVyLCB0aW1lc3RhbXApXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgR2VvUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdlb1BvaW50VmFsdWU6IHtcbiAgICAgICAgICAgICAgICBsYXRpdHVkZTogdmFsdWUubGF0aXR1ZGUsXG4gICAgICAgICAgICAgICAgbG9uZ2l0dWRlOiB2YWx1ZS5sb25naXR1ZGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBCeXRlcykge1xuICAgICAgICByZXR1cm4geyBieXRlc1ZhbHVlOiB0b0J5dGVzKGNvbnRleHQuc2VyaWFsaXplciwgdmFsdWUuX2J5dGVTdHJpbmcpIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRG9jdW1lbnRSZWZlcmVuY2UpIHtcbiAgICAgICAgY29uc3QgdGhpc0RiID0gY29udGV4dC5kYXRhYmFzZUlkO1xuICAgICAgICBjb25zdCBvdGhlckRiID0gdmFsdWUuZmlyZXN0b3JlLl9kYXRhYmFzZUlkO1xuICAgICAgICBpZiAoIW90aGVyRGIuaXNFcXVhbCh0aGlzRGIpKSB7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKCdEb2N1bWVudCByZWZlcmVuY2UgaXMgZm9yIGRhdGFiYXNlICcgK1xuICAgICAgICAgICAgICAgIGAke290aGVyRGIucHJvamVjdElkfS8ke290aGVyRGIuZGF0YWJhc2V9IGJ1dCBzaG91bGQgYmUgYCArXG4gICAgICAgICAgICAgICAgYGZvciBkYXRhYmFzZSAke3RoaXNEYi5wcm9qZWN0SWR9LyR7dGhpc0RiLmRhdGFiYXNlfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWZlcmVuY2VWYWx1ZTogdG9SZXNvdXJjZU5hbWUodmFsdWUuZmlyZXN0b3JlLl9kYXRhYmFzZUlkIHx8IGNvbnRleHQuZGF0YWJhc2VJZCwgdmFsdWUuX2tleS5wYXRoKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFZlY3RvclZhbHVlKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVZlY3RvclZhbHVlKHZhbHVlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IGNvbnRleHQuY3JlYXRlRXJyb3IoYFVuc3VwcG9ydGVkIGZpZWxkIHZhbHVlOiAke3ZhbHVlRGVzY3JpcHRpb24odmFsdWUpfWApO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBWZWN0b3JWYWx1ZSBwcm90byB2YWx1ZSAodXNpbmcgdGhlIGludGVybmFsIGZvcm1hdCkuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlVmVjdG9yVmFsdWUodmFsdWUsIGNvbnRleHQpIHtcbiAgICBjb25zdCBtYXBWYWx1ZSA9IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICBbVFlQRV9LRVldOiB7XG4gICAgICAgICAgICAgICAgc3RyaW5nVmFsdWU6IFZFQ1RPUl9WQUxVRV9TRU5USU5FTFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtWRUNUT1JfTUFQX1ZFQ1RPUlNfS0VZXToge1xuICAgICAgICAgICAgICAgIGFycmF5VmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiB2YWx1ZS50b0FycmF5KCkubWFwKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgY29udGV4dC5jcmVhdGVFcnJvcignVmVjdG9yVmFsdWVzIG11c3Qgb25seSBjb250YWluIG51bWVyaWMgdmFsdWVzLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvRG91YmxlKGNvbnRleHQuc2VyaWFsaXplciwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHsgbWFwVmFsdWUgfTtcbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYW4gb2JqZWN0IGxvb2tzIGxpa2UgYSBKU09OIG9iamVjdCB0aGF0IHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAqIGludG8gYSBzdHJ1Y3QuIE5vcm1hbCBjbGFzcy9wcm90b3R5cGUgaW5zdGFuY2VzIGFyZSBjb25zaWRlcmVkIHRvIGxvb2sgbGlrZVxuICogSlNPTiBvYmplY3RzIHNpbmNlIHRoZXkgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBhIHN0cnVjdCB2YWx1ZS4gQXJyYXlzLCBEYXRlcyxcbiAqIEdlb1BvaW50cywgZXRjLiBhcmUgbm90IGNvbnNpZGVyZWQgdG8gbG9vayBsaWtlIEpTT04gb2JqZWN0cyBzaW5jZSB0aGV5IG1hcFxuICogdG8gc3BlY2lmaWMgRmllbGRWYWx1ZSB0eXBlcyBvdGhlciB0aGFuIE9iamVjdFZhbHVlLlxuICovXG5mdW5jdGlvbiBsb29rc0xpa2VKc29uT2JqZWN0KGlucHV0KSB7XG4gICAgcmV0dXJuICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmXG4gICAgICAgIGlucHV0ICE9PSBudWxsICYmXG4gICAgICAgICEoaW5wdXQgaW5zdGFuY2VvZiBBcnJheSkgJiZcbiAgICAgICAgIShpbnB1dCBpbnN0YW5jZW9mIERhdGUpICYmXG4gICAgICAgICEoaW5wdXQgaW5zdGFuY2VvZiBUaW1lc3RhbXApICYmXG4gICAgICAgICEoaW5wdXQgaW5zdGFuY2VvZiBHZW9Qb2ludCkgJiZcbiAgICAgICAgIShpbnB1dCBpbnN0YW5jZW9mIEJ5dGVzKSAmJlxuICAgICAgICAhKGlucHV0IGluc3RhbmNlb2YgRG9jdW1lbnRSZWZlcmVuY2UpICYmXG4gICAgICAgICEoaW5wdXQgaW5zdGFuY2VvZiBGaWVsZFZhbHVlKSAmJlxuICAgICAgICAhKGlucHV0IGluc3RhbmNlb2YgVmVjdG9yVmFsdWUpKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUGxhaW5PYmplY3QobWVzc2FnZSwgY29udGV4dCwgaW5wdXQpIHtcbiAgICBpZiAoIWxvb2tzTGlrZUpzb25PYmplY3QoaW5wdXQpIHx8ICFpc1BsYWluT2JqZWN0KGlucHV0KSkge1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHZhbHVlRGVzY3JpcHRpb24oaW5wdXQpO1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24gPT09ICdhbiBvYmplY3QnKSB7XG4gICAgICAgICAgICAvLyBNYXNzYWdlIHRoZSBlcnJvciBpZiBpdCB3YXMgYW4gb2JqZWN0LlxuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5jcmVhdGVFcnJvcihtZXNzYWdlICsgJyBhIGN1c3RvbSBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuY3JlYXRlRXJyb3IobWVzc2FnZSArICcgJyArIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogSGVscGVyIHRoYXQgY2FsbHMgZnJvbURvdFNlcGFyYXRlZFN0cmluZygpIGJ1dCB3cmFwcyBhbnkgZXJyb3IgdGhyb3duLlxuICovXG5mdW5jdGlvbiBmaWVsZFBhdGhGcm9tQXJndW1lbnQkMShtZXRob2ROYW1lLCBwYXRoLCB0YXJnZXREb2MpIHtcbiAgICAvLyBJZiByZXF1aXJlZCwgcmVwbGFjZSB0aGUgRmllbGRQYXRoIENvbXBhdCBjbGFzcyB3aXRoIHRoZSBmaXJlc3RvcmUtZXhwXG4gICAgLy8gRmllbGRQYXRoLlxuICAgIHBhdGggPSBnZXRNb2R1bGFySW5zdGFuY2UocGF0aCk7XG4gICAgaWYgKHBhdGggaW5zdGFuY2VvZiBGaWVsZFBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGguX2ludGVybmFsUGF0aDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmaWVsZFBhdGhGcm9tRG90U2VwYXJhdGVkU3RyaW5nKG1ldGhvZE5hbWUsIHBhdGgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdGaWVsZCBwYXRoIGFyZ3VtZW50cyBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nIG9yICc7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKG1lc3NhZ2UsIG1ldGhvZE5hbWUsIFxuICAgICAgICAvKiBoYXNDb252ZXJ0ZXI9ICovIGZhbHNlLCBcbiAgICAgICAgLyogcGF0aD0gKi8gdW5kZWZpbmVkLCB0YXJnZXREb2MpO1xuICAgIH1cbn1cbi8qKlxuICogTWF0Y2hlcyBhbnkgY2hhcmFjdGVycyBpbiBhIGZpZWxkIHBhdGggc3RyaW5nIHRoYXQgYXJlIHJlc2VydmVkLlxuICovXG5jb25zdCBGSUVMRF9QQVRIX1JFU0VSVkVEID0gbmV3IFJlZ0V4cCgnW35cXFxcKi9cXFxcW1xcXFxdXScpO1xuLyoqXG4gKiBXcmFwcyBmcm9tRG90U2VwYXJhdGVkU3RyaW5nIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBhYm91dCB0aGUgbWV0aG9kIHRoYXRcbiAqIHdhcyB0aHJvd24uXG4gKiBAcGFyYW0gbWV0aG9kTmFtZSAtIFRoZSBwdWJsaWNseSB2aXNpYmxlIG1ldGhvZCBuYW1lXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBkb3Qtc2VwYXJhdGVkIHN0cmluZyBmb3JtIG9mIGEgZmllbGQgcGF0aCB3aGljaCB3aWxsIGJlXG4gKiBzcGxpdCBvbiBkb3RzLlxuICogQHBhcmFtIHRhcmdldERvYyAtIFRoZSBkb2N1bWVudCBhZ2FpbnN0IHdoaWNoIHRoZSBmaWVsZCBwYXRoIHdpbGwgYmVcbiAqIGV2YWx1YXRlZC5cbiAqL1xuZnVuY3Rpb24gZmllbGRQYXRoRnJvbURvdFNlcGFyYXRlZFN0cmluZyhtZXRob2ROYW1lLCBwYXRoLCB0YXJnZXREb2MpIHtcbiAgICBjb25zdCBmb3VuZCA9IHBhdGguc2VhcmNoKEZJRUxEX1BBVEhfUkVTRVJWRUQpO1xuICAgIGlmIChmb3VuZCA+PSAwKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKGBJbnZhbGlkIGZpZWxkIHBhdGggKCR7cGF0aH0pLiBQYXRocyBtdXN0IG5vdCBjb250YWluIGAgK1xuICAgICAgICAgICAgYCd+JywgJyonLCAnLycsICdbJywgb3IgJ10nYCwgbWV0aG9kTmFtZSwgXG4gICAgICAgIC8qIGhhc0NvbnZlcnRlcj0gKi8gZmFsc2UsIFxuICAgICAgICAvKiBwYXRoPSAqLyB1bmRlZmluZWQsIHRhcmdldERvYyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGRQYXRoKC4uLnBhdGguc3BsaXQoJy4nKSkuX2ludGVybmFsUGF0aDtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoYEludmFsaWQgZmllbGQgcGF0aCAoJHtwYXRofSkuIFBhdGhzIG11c3Qgbm90IGJlIGVtcHR5LCBgICtcbiAgICAgICAgICAgIGBiZWdpbiB3aXRoICcuJywgZW5kIHdpdGggJy4nLCBvciBjb250YWluICcuLidgLCBtZXRob2ROYW1lLCBcbiAgICAgICAgLyogaGFzQ29udmVydGVyPSAqLyBmYWxzZSwgXG4gICAgICAgIC8qIHBhdGg9ICovIHVuZGVmaW5lZCwgdGFyZ2V0RG9jKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVFcnJvcihyZWFzb24sIG1ldGhvZE5hbWUsIGhhc0NvbnZlcnRlciwgcGF0aCwgdGFyZ2V0RG9jKSB7XG4gICAgY29uc3QgaGFzUGF0aCA9IHBhdGggJiYgIXBhdGguaXNFbXB0eSgpO1xuICAgIGNvbnN0IGhhc0RvY3VtZW50ID0gdGFyZ2V0RG9jICE9PSB1bmRlZmluZWQ7XG4gICAgbGV0IG1lc3NhZ2UgPSBgRnVuY3Rpb24gJHttZXRob2ROYW1lfSgpIGNhbGxlZCB3aXRoIGludmFsaWQgZGF0YWA7XG4gICAgaWYgKGhhc0NvbnZlcnRlcikge1xuICAgICAgICBtZXNzYWdlICs9ICcgKHZpYSBgdG9GaXJlc3RvcmUoKWApJztcbiAgICB9XG4gICAgbWVzc2FnZSArPSAnLiAnO1xuICAgIGxldCBkZXNjcmlwdGlvbiA9ICcnO1xuICAgIGlmIChoYXNQYXRoIHx8IGhhc0RvY3VtZW50KSB7XG4gICAgICAgIGRlc2NyaXB0aW9uICs9ICcgKGZvdW5kJztcbiAgICAgICAgaWYgKGhhc1BhdGgpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uICs9IGAgaW4gZmllbGQgJHtwYXRofWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0RvY3VtZW50KSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbiArPSBgIGluIGRvY3VtZW50ICR7dGFyZ2V0RG9jfWA7XG4gICAgICAgIH1cbiAgICAgICAgZGVzY3JpcHRpb24gKz0gJyknO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgbWVzc2FnZSArIHJlYXNvbiArIGRlc2NyaXB0aW9uKTtcbn1cbi8qKiBDaGVja3MgYGhheXN0YWNrYCBpZiBGaWVsZFBhdGggYG5lZWRsZWAgaXMgcHJlc2VudC4gUnVucyBpbiBPKG4pLiAqL1xuZnVuY3Rpb24gZmllbGRNYXNrQ29udGFpbnMoaGF5c3RhY2ssIG5lZWRsZSkge1xuICAgIHJldHVybiBoYXlzdGFjay5zb21lKHYgPT4gdi5pc0VxdWFsKG5lZWRsZSkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIGBEb2N1bWVudFNuYXBzaG90YCBjb250YWlucyBkYXRhIHJlYWQgZnJvbSBhIGRvY3VtZW50IGluIHlvdXIgRmlyZXN0b3JlXG4gKiBkYXRhYmFzZS4gVGhlIGRhdGEgY2FuIGJlIGV4dHJhY3RlZCB3aXRoIGAuZGF0YSgpYCBvciBgLmdldCg8ZmllbGQ+KWAgdG9cbiAqIGdldCBhIHNwZWNpZmljIGZpZWxkLlxuICpcbiAqIEZvciBhIGBEb2N1bWVudFNuYXBzaG90YCB0aGF0IHBvaW50cyB0byBhIG5vbi1leGlzdGluZyBkb2N1bWVudCwgYW55IGRhdGFcbiAqIGFjY2VzcyB3aWxsIHJldHVybiAndW5kZWZpbmVkJy4gWW91IGNhbiB1c2UgdGhlIGBleGlzdHMoKWAgbWV0aG9kIHRvXG4gKiBleHBsaWNpdGx5IHZlcmlmeSBhIGRvY3VtZW50J3MgZXhpc3RlbmNlLlxuICovXG5jbGFzcyBEb2N1bWVudFNuYXBzaG90JDEge1xuICAgIC8vIE5vdGU6IFRoaXMgY2xhc3MgaXMgc3RyaXBwZWQgZG93biB2ZXJzaW9uIG9mIHRoZSBEb2N1bWVudFNuYXBzaG90IGluXG4gICAgLy8gdGhlIGxlZ2FjeSBTREsuIFRoZSBjaGFuZ2VzIGFyZTpcbiAgICAvLyAtIE5vIHN1cHBvcnQgZm9yIFNuYXBzaG90TWV0YWRhdGEuXG4gICAgLy8gLSBObyBzdXBwb3J0IGZvciBTbmFwc2hvdE9wdGlvbnMuXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgcHJvdGVjdGVkICovXG4gICAgY29uc3RydWN0b3IoX2ZpcmVzdG9yZSwgX3VzZXJEYXRhV3JpdGVyLCBfa2V5LCBfZG9jdW1lbnQsIF9jb252ZXJ0ZXIpIHtcbiAgICAgICAgdGhpcy5fZmlyZXN0b3JlID0gX2ZpcmVzdG9yZTtcbiAgICAgICAgdGhpcy5fdXNlckRhdGFXcml0ZXIgPSBfdXNlckRhdGFXcml0ZXI7XG4gICAgICAgIHRoaXMuX2tleSA9IF9rZXk7XG4gICAgICAgIHRoaXMuX2RvY3VtZW50ID0gX2RvY3VtZW50O1xuICAgICAgICB0aGlzLl9jb252ZXJ0ZXIgPSBfY29udmVydGVyO1xuICAgIH1cbiAgICAvKiogUHJvcGVydHkgb2YgdGhlIGBEb2N1bWVudFNuYXBzaG90YCB0aGF0IHByb3ZpZGVzIHRoZSBkb2N1bWVudCdzIElELiAqL1xuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleS5wYXRoLmxhc3RTZWdtZW50KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBgRG9jdW1lbnRSZWZlcmVuY2VgIGZvciB0aGUgZG9jdW1lbnQgaW5jbHVkZWQgaW4gdGhlIGBEb2N1bWVudFNuYXBzaG90YC5cbiAgICAgKi9cbiAgICBnZXQgcmVmKCkge1xuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50UmVmZXJlbmNlKHRoaXMuX2ZpcmVzdG9yZSwgdGhpcy5fY29udmVydGVyLCB0aGlzLl9rZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWduYWxzIHdoZXRoZXIgb3Igbm90IHRoZSBkb2N1bWVudCBhdCB0aGUgc25hcHNob3QncyBsb2NhdGlvbiBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBkb2N1bWVudCBleGlzdHMuXG4gICAgICovXG4gICAgZXhpc3RzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZG9jdW1lbnQgIT09IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbGwgZmllbGRzIGluIHRoZSBkb2N1bWVudCBhcyBhbiBgT2JqZWN0YC4gUmV0dXJucyBgdW5kZWZpbmVkYCBpZlxuICAgICAqIHRoZSBkb2N1bWVudCBkb2Vzbid0IGV4aXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgQW4gYE9iamVjdGAgY29udGFpbmluZyBhbGwgZmllbGRzIGluIHRoZSBkb2N1bWVudCBvciBgdW5kZWZpbmVkYFxuICAgICAqIGlmIHRoZSBkb2N1bWVudCBkb2Vzbid0IGV4aXN0LlxuICAgICAqL1xuICAgIGRhdGEoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fY29udmVydGVyKSB7XG4gICAgICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gdXNlIHRoZSBjb252ZXJ0ZXIgYW5kIGNyZWF0ZSBhIG5ldyBEb2N1bWVudFNuYXBzaG90XG4gICAgICAgICAgICAvLyBpZiBhIGNvbnZlcnRlciBoYXMgYmVlbiBwcm92aWRlZC5cbiAgICAgICAgICAgIGNvbnN0IHNuYXBzaG90ID0gbmV3IFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdCQxKHRoaXMuX2ZpcmVzdG9yZSwgdGhpcy5fdXNlckRhdGFXcml0ZXIsIHRoaXMuX2tleSwgdGhpcy5fZG9jdW1lbnQsIFxuICAgICAgICAgICAgLyogY29udmVydGVyPSAqLyBudWxsKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0ZXIuZnJvbUZpcmVzdG9yZShzbmFwc2hvdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXNlckRhdGFXcml0ZXIuY29udmVydFZhbHVlKHRoaXMuX2RvY3VtZW50LmRhdGEudmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZmllbGQgc3BlY2lmaWVkIGJ5IGBmaWVsZFBhdGhgLiBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIHRoZVxuICAgICAqIGRvY3VtZW50IG9yIGZpZWxkIGRvZXNuJ3QgZXhpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmllbGRQYXRoIC0gVGhlIHBhdGggKGZvciBleGFtcGxlICdmb28nIG9yICdmb28uYmFyJykgdG8gYSBzcGVjaWZpY1xuICAgICAqIGZpZWxkLlxuICAgICAqIEByZXR1cm5zIFRoZSBkYXRhIGF0IHRoZSBzcGVjaWZpZWQgZmllbGQgbG9jYXRpb24gb3IgdW5kZWZpbmVkIGlmIG5vIHN1Y2hcbiAgICAgKiBmaWVsZCBleGlzdHMgaW4gdGhlIGRvY3VtZW50LlxuICAgICAqL1xuICAgIC8vIFdlIGFyZSB1c2luZyBgYW55YCBoZXJlIHRvIGF2b2lkIGFuIGV4cGxpY2l0IGNhc3QgYnkgb3VyIHVzZXJzLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZ2V0KGZpZWxkUGF0aCkge1xuICAgICAgICBpZiAodGhpcy5fZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fZG9jdW1lbnQuZGF0YS5maWVsZChmaWVsZFBhdGhGcm9tQXJndW1lbnQoJ0RvY3VtZW50U25hcHNob3QuZ2V0JywgZmllbGRQYXRoKSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdXNlckRhdGFXcml0ZXIuY29udmVydFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKlxuICogQSBgUXVlcnlEb2N1bWVudFNuYXBzaG90YCBjb250YWlucyBkYXRhIHJlYWQgZnJvbSBhIGRvY3VtZW50IGluIHlvdXJcbiAqIEZpcmVzdG9yZSBkYXRhYmFzZSBhcyBwYXJ0IG9mIGEgcXVlcnkuIFRoZSBkb2N1bWVudCBpcyBndWFyYW50ZWVkIHRvIGV4aXN0XG4gKiBhbmQgaXRzIGRhdGEgY2FuIGJlIGV4dHJhY3RlZCB3aXRoIGAuZGF0YSgpYCBvciBgLmdldCg8ZmllbGQ+KWAgdG8gZ2V0IGFcbiAqIHNwZWNpZmljIGZpZWxkLlxuICpcbiAqIEEgYFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdGAgb2ZmZXJzIHRoZSBzYW1lIEFQSSBzdXJmYWNlIGFzIGFcbiAqIGBEb2N1bWVudFNuYXBzaG90YC4gU2luY2UgcXVlcnkgcmVzdWx0cyBjb250YWluIG9ubHkgZXhpc3RpbmcgZG9jdW1lbnRzLCB0aGVcbiAqIGBleGlzdHNgIHByb3BlcnR5IHdpbGwgYWx3YXlzIGJlIHRydWUgYW5kIGBkYXRhKClgIHdpbGwgbmV2ZXIgcmV0dXJuXG4gKiAndW5kZWZpbmVkJy5cbiAqL1xuY2xhc3MgUXVlcnlEb2N1bWVudFNuYXBzaG90JDEgZXh0ZW5kcyBEb2N1bWVudFNuYXBzaG90JDEge1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbGwgZmllbGRzIGluIHRoZSBkb2N1bWVudCBhcyBhbiBgT2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEByZXR1cm5zIEFuIGBPYmplY3RgIGNvbnRhaW5pbmcgYWxsIGZpZWxkcyBpbiB0aGUgZG9jdW1lbnQuXG4gICAgICovXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmRhdGEoKTtcbiAgICB9XG59XG4vKipcbiAqIEhlbHBlciB0aGF0IGNhbGxzIGBmcm9tRG90U2VwYXJhdGVkU3RyaW5nKClgIGJ1dCB3cmFwcyBhbnkgZXJyb3IgdGhyb3duLlxuICovXG5mdW5jdGlvbiBmaWVsZFBhdGhGcm9tQXJndW1lbnQobWV0aG9kTmFtZSwgYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmaWVsZFBhdGhGcm9tRG90U2VwYXJhdGVkU3RyaW5nKG1ldGhvZE5hbWUsIGFyZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIEZpZWxkUGF0aCkge1xuICAgICAgICByZXR1cm4gYXJnLl9pbnRlcm5hbFBhdGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYXJnLl9kZWxlZ2F0ZS5faW50ZXJuYWxQYXRoO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlSGFzRXhwbGljaXRPcmRlckJ5Rm9yTGltaXRUb0xhc3QocXVlcnkpIHtcbiAgICBpZiAocXVlcnkubGltaXRUeXBlID09PSBcIkxcIiAvKiBMaW1pdFR5cGUuTGFzdCAqLyAmJlxuICAgICAgICBxdWVyeS5leHBsaWNpdE9yZGVyQnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLlVOSU1QTEVNRU5URUQsICdsaW1pdFRvTGFzdCgpIHF1ZXJpZXMgcmVxdWlyZSBzcGVjaWZ5aW5nIGF0IGxlYXN0IG9uZSBvcmRlckJ5KCkgY2xhdXNlJyk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBgQXBwbGlhYmxlQ29uc3RyYWludGAgaXMgYW4gYWJzdHJhY3Rpb24gb2YgYSBjb25zdHJhaW50IHRoYXQgY2FuIGJlIGFwcGxpZWRcbiAqIHRvIGEgRmlyZXN0b3JlIHF1ZXJ5LlxuICovXG5jbGFzcyBBcHBsaWFibGVDb25zdHJhaW50IHtcbn1cbi8qKlxuICogQSBgUXVlcnlDb25zdHJhaW50YCBpcyB1c2VkIHRvIG5hcnJvdyB0aGUgc2V0IG9mIGRvY3VtZW50cyByZXR1cm5lZCBieSBhXG4gKiBGaXJlc3RvcmUgcXVlcnkuIGBRdWVyeUNvbnN0cmFpbnRgcyBhcmUgY3JlYXRlZCBieSBpbnZva2luZyB7QGxpbmsgd2hlcmV9LFxuICoge0BsaW5rIG9yZGVyQnl9LCB7QGxpbmsgKHN0YXJ0QXQ6MSl9LCB7QGxpbmsgKHN0YXJ0QWZ0ZXI6MSl9LCB7QGxpbmtcbiAqIChlbmRCZWZvcmU6MSl9LCB7QGxpbmsgKGVuZEF0OjEpfSwge0BsaW5rIGxpbWl0fSwge0BsaW5rIGxpbWl0VG9MYXN0fSBhbmRcbiAqIGNhbiB0aGVuIGJlIHBhc3NlZCB0byB7QGxpbmsgKHF1ZXJ5OjEpfSB0byBjcmVhdGUgYSBuZXcgcXVlcnkgaW5zdGFuY2UgdGhhdFxuICogYWxzbyBjb250YWlucyB0aGlzIGBRdWVyeUNvbnN0cmFpbnRgLlxuICovXG5jbGFzcyBRdWVyeUNvbnN0cmFpbnQgZXh0ZW5kcyBBcHBsaWFibGVDb25zdHJhaW50IHtcbn1cbmZ1bmN0aW9uIHF1ZXJ5KHF1ZXJ5LCBxdWVyeUNvbnN0cmFpbnQsIC4uLmFkZGl0aW9uYWxRdWVyeUNvbnN0cmFpbnRzKSB7XG4gICAgbGV0IHF1ZXJ5Q29uc3RyYWludHMgPSBbXTtcbiAgICBpZiAocXVlcnlDb25zdHJhaW50IGluc3RhbmNlb2YgQXBwbGlhYmxlQ29uc3RyYWludCkge1xuICAgICAgICBxdWVyeUNvbnN0cmFpbnRzLnB1c2gocXVlcnlDb25zdHJhaW50KTtcbiAgICB9XG4gICAgcXVlcnlDb25zdHJhaW50cyA9IHF1ZXJ5Q29uc3RyYWludHMuY29uY2F0KGFkZGl0aW9uYWxRdWVyeUNvbnN0cmFpbnRzKTtcbiAgICB2YWxpZGF0ZVF1ZXJ5Q29uc3RyYWludEFycmF5KHF1ZXJ5Q29uc3RyYWludHMpO1xuICAgIGZvciAoY29uc3QgY29uc3RyYWludCBvZiBxdWVyeUNvbnN0cmFpbnRzKSB7XG4gICAgICAgIHF1ZXJ5ID0gY29uc3RyYWludC5fYXBwbHkocXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcnk7XG59XG4vKipcbiAqIEEgYFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50YCBpcyB1c2VkIHRvIG5hcnJvdyB0aGUgc2V0IG9mIGRvY3VtZW50cyByZXR1cm5lZCBieVxuICogYSBGaXJlc3RvcmUgcXVlcnkgYnkgZmlsdGVyaW5nIG9uIG9uZSBvciBtb3JlIGRvY3VtZW50IGZpZWxkcy5cbiAqIGBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludGBzIGFyZSBjcmVhdGVkIGJ5IGludm9raW5nIHtAbGluayB3aGVyZX0gYW5kIGNhbiB0aGVuXG4gKiBiZSBwYXNzZWQgdG8ge0BsaW5rIChxdWVyeToxKX0gdG8gY3JlYXRlIGEgbmV3IHF1ZXJ5IGluc3RhbmNlIHRoYXQgYWxzbyBjb250YWluc1xuICogdGhpcyBgUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnRgLlxuICovXG5jbGFzcyBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX2ZpZWxkLCBfb3AsIF92YWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9maWVsZCA9IF9maWVsZDtcbiAgICAgICAgdGhpcy5fb3AgPSBfb3A7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX3ZhbHVlO1xuICAgICAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyBxdWVyeSBjb25zdHJhaW50ICovXG4gICAgICAgIHRoaXMudHlwZSA9ICd3aGVyZSc7XG4gICAgfVxuICAgIHN0YXRpYyBfY3JlYXRlKF9maWVsZCwgX29wLCBfdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludChfZmllbGQsIF9vcCwgX3ZhbHVlKTtcbiAgICB9XG4gICAgX2FwcGx5KHF1ZXJ5KSB7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuX3BhcnNlKHF1ZXJ5KTtcbiAgICAgICAgdmFsaWRhdGVOZXdGaWVsZEZpbHRlcihxdWVyeS5fcXVlcnksIGZpbHRlcik7XG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkocXVlcnkuZmlyZXN0b3JlLCBxdWVyeS5jb252ZXJ0ZXIsIHF1ZXJ5V2l0aEFkZGVkRmlsdGVyKHF1ZXJ5Ll9xdWVyeSwgZmlsdGVyKSk7XG4gICAgfVxuICAgIF9wYXJzZShxdWVyeSkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXdVc2VyRGF0YVJlYWRlcihxdWVyeS5maXJlc3RvcmUpO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSBuZXdRdWVyeUZpbHRlcihxdWVyeS5fcXVlcnksICd3aGVyZScsIHJlYWRlciwgcXVlcnkuZmlyZXN0b3JlLl9kYXRhYmFzZUlkLCB0aGlzLl9maWVsZCwgdGhpcy5fb3AsIHRoaXMuX3ZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGZpbHRlcjtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnR9IHRoYXQgZW5mb3JjZXMgdGhhdCBkb2N1bWVudHNcbiAqIG11c3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIGZpZWxkIGFuZCB0aGF0IHRoZSB2YWx1ZSBzaG91bGQgc2F0aXNmeSB0aGVcbiAqIHJlbGF0aW9uIGNvbnN0cmFpbnQgcHJvdmlkZWQuXG4gKlxuICogQHBhcmFtIGZpZWxkUGF0aCAtIFRoZSBwYXRoIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSBvcFN0ciAtIFRoZSBvcGVyYXRpb24gc3RyaW5nIChlLmcgXCImbHQ7XCIsIFwiJmx0Oz1cIiwgXCI9PVwiLCBcIiZsdDtcIixcbiAqICAgXCImbHQ7PVwiLCBcIiE9XCIpLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIGZvciBjb21wYXJpc29uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCB7QGxpbmsgUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnR9LlxuICovXG5mdW5jdGlvbiB3aGVyZShmaWVsZFBhdGgsIG9wU3RyLCB2YWx1ZSkge1xuICAgIGNvbnN0IG9wID0gb3BTdHI7XG4gICAgY29uc3QgZmllbGQgPSBmaWVsZFBhdGhGcm9tQXJndW1lbnQoJ3doZXJlJywgZmllbGRQYXRoKTtcbiAgICByZXR1cm4gUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnQuX2NyZWF0ZShmaWVsZCwgb3AsIHZhbHVlKTtcbn1cbi8qKlxuICogQSBgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50YCBpcyB1c2VkIHRvIG5hcnJvdyB0aGUgc2V0IG9mIGRvY3VtZW50c1xuICogcmV0dXJuZWQgYnkgYSBGaXJlc3RvcmUgcXVlcnkgYnkgcGVyZm9ybWluZyB0aGUgbG9naWNhbCBPUiBvciBBTkQgb2YgbXVsdGlwbGVcbiAqIHtAbGluayBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludH1zIG9yIHtAbGluayBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnR9cy5cbiAqIGBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnRgcyBhcmUgY3JlYXRlZCBieSBpbnZva2luZyB7QGxpbmsgb3J9IG9yXG4gKiB7QGxpbmsgYW5kfSBhbmQgY2FuIHRoZW4gYmUgcGFzc2VkIHRvIHtAbGluayAocXVlcnk6MSl9IHRvIGNyZWF0ZSBhIG5ldyBxdWVyeVxuICogaW5zdGFuY2UgdGhhdCBhbHNvIGNvbnRhaW5zIHRoZSBgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50YC5cbiAqL1xuY2xhc3MgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50IGV4dGVuZHMgQXBwbGlhYmxlQ29uc3RyYWludCB7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqIFRoZSB0eXBlIG9mIHRoaXMgcXVlcnkgY29uc3RyYWludCAqL1xuICAgIHR5cGUsIF9xdWVyeUNvbnN0cmFpbnRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuX3F1ZXJ5Q29uc3RyYWludHMgPSBfcXVlcnlDb25zdHJhaW50cztcbiAgICB9XG4gICAgc3RhdGljIF9jcmVhdGUodHlwZSwgX3F1ZXJ5Q29uc3RyYWludHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnQodHlwZSwgX3F1ZXJ5Q29uc3RyYWludHMpO1xuICAgIH1cbiAgICBfcGFyc2UocXVlcnkpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkRmlsdGVycyA9IHRoaXMuX3F1ZXJ5Q29uc3RyYWludHNcbiAgICAgICAgICAgIC5tYXAocXVlcnlDb25zdHJhaW50ID0+IHtcbiAgICAgICAgICAgIHJldHVybiBxdWVyeUNvbnN0cmFpbnQuX3BhcnNlKHF1ZXJ5KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIocGFyc2VkRmlsdGVyID0+IHBhcnNlZEZpbHRlci5nZXRGaWx0ZXJzKCkubGVuZ3RoID4gMCk7XG4gICAgICAgIGlmIChwYXJzZWRGaWx0ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZEZpbHRlcnNbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENvbXBvc2l0ZUZpbHRlci5jcmVhdGUocGFyc2VkRmlsdGVycywgdGhpcy5fZ2V0T3BlcmF0b3IoKSk7XG4gICAgfVxuICAgIF9hcHBseShxdWVyeSkge1xuICAgICAgICBjb25zdCBwYXJzZWRGaWx0ZXIgPSB0aGlzLl9wYXJzZShxdWVyeSk7XG4gICAgICAgIGlmIChwYXJzZWRGaWx0ZXIuZ2V0RmlsdGVycygpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBleGlzdGluZyBxdWVyeSBpZiBub3QgYWRkaW5nIGFueSBtb3JlIGZpbHRlcnMgKGUuZy4gYW4gZW1wdHlcbiAgICAgICAgICAgIC8vIGNvbXBvc2l0ZSBmaWx0ZXIpLlxuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRlTmV3RmlsdGVyKHF1ZXJ5Ll9xdWVyeSwgcGFyc2VkRmlsdGVyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeShxdWVyeS5maXJlc3RvcmUsIHF1ZXJ5LmNvbnZlcnRlciwgcXVlcnlXaXRoQWRkZWRGaWx0ZXIocXVlcnkuX3F1ZXJ5LCBwYXJzZWRGaWx0ZXIpKTtcbiAgICB9XG4gICAgX2dldFF1ZXJ5Q29uc3RyYWludHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9xdWVyeUNvbnN0cmFpbnRzO1xuICAgIH1cbiAgICBfZ2V0T3BlcmF0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09ICdhbmQnID8gXCJhbmRcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5BTkQgKi8gOiBcIm9yXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuT1IgKi87XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHtAbGluayBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnR9IHRoYXQgaXMgYSBkaXNqdW5jdGlvbiBvZlxuICogdGhlIGdpdmVuIGZpbHRlciBjb25zdHJhaW50cy4gQSBkaXNqdW5jdGlvbiBmaWx0ZXIgaW5jbHVkZXMgYSBkb2N1bWVudCBpZiBpdFxuICogc2F0aXNmaWVzIGFueSBvZiB0aGUgZ2l2ZW4gZmlsdGVycy5cbiAqXG4gKiBAcGFyYW0gcXVlcnlDb25zdHJhaW50cyAtIE9wdGlvbmFsLiBUaGUgbGlzdCBvZlxuICoge0BsaW5rIFF1ZXJ5RmlsdGVyQ29uc3RyYWludH1zIHRvIHBlcmZvcm0gYSBkaXNqdW5jdGlvbiBmb3IuIFRoZXNlIG11c3QgYmVcbiAqIGNyZWF0ZWQgd2l0aCBjYWxscyB0byB7QGxpbmsgd2hlcmV9LCB7QGxpbmsgb3J9LCBvciB7QGxpbmsgYW5kfS5cbiAqIEByZXR1cm5zIFRoZSBuZXdseSBjcmVhdGVkIHtAbGluayBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnR9LlxuICovXG5mdW5jdGlvbiBvciguLi5xdWVyeUNvbnN0cmFpbnRzKSB7XG4gICAgLy8gT25seSBzdXBwb3J0IFF1ZXJ5RmlsdGVyQ29uc3RyYWludHNcbiAgICBxdWVyeUNvbnN0cmFpbnRzLmZvckVhY2gocXVlcnlDb25zdHJhaW50ID0+IHZhbGlkYXRlUXVlcnlGaWx0ZXJDb25zdHJhaW50KCdvcicsIHF1ZXJ5Q29uc3RyYWludCkpO1xuICAgIHJldHVybiBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnQuX2NyZWF0ZShcIm9yXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuT1IgKi8sIHF1ZXJ5Q29uc3RyYWludHMpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHtAbGluayBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnR9IHRoYXQgaXMgYSBjb25qdW5jdGlvbiBvZlxuICogdGhlIGdpdmVuIGZpbHRlciBjb25zdHJhaW50cy4gQSBjb25qdW5jdGlvbiBmaWx0ZXIgaW5jbHVkZXMgYSBkb2N1bWVudCBpZiBpdFxuICogc2F0aXNmaWVzIGFsbCBvZiB0aGUgZ2l2ZW4gZmlsdGVycy5cbiAqXG4gKiBAcGFyYW0gcXVlcnlDb25zdHJhaW50cyAtIE9wdGlvbmFsLiBUaGUgbGlzdCBvZlxuICoge0BsaW5rIFF1ZXJ5RmlsdGVyQ29uc3RyYWludH1zIHRvIHBlcmZvcm0gYSBjb25qdW5jdGlvbiBmb3IuIFRoZXNlIG11c3QgYmVcbiAqIGNyZWF0ZWQgd2l0aCBjYWxscyB0byB7QGxpbmsgd2hlcmV9LCB7QGxpbmsgb3J9LCBvciB7QGxpbmsgYW5kfS5cbiAqIEByZXR1cm5zIFRoZSBuZXdseSBjcmVhdGVkIHtAbGluayBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnR9LlxuICovXG5mdW5jdGlvbiBhbmQoLi4ucXVlcnlDb25zdHJhaW50cykge1xuICAgIC8vIE9ubHkgc3VwcG9ydCBRdWVyeUZpbHRlckNvbnN0cmFpbnRzXG4gICAgcXVlcnlDb25zdHJhaW50cy5mb3JFYWNoKHF1ZXJ5Q29uc3RyYWludCA9PiB2YWxpZGF0ZVF1ZXJ5RmlsdGVyQ29uc3RyYWludCgnYW5kJywgcXVlcnlDb25zdHJhaW50KSk7XG4gICAgcmV0dXJuIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludC5fY3JlYXRlKFwiYW5kXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuQU5EICovLCBxdWVyeUNvbnN0cmFpbnRzKTtcbn1cbi8qKlxuICogQSBgUXVlcnlPcmRlckJ5Q29uc3RyYWludGAgaXMgdXNlZCB0byBzb3J0IHRoZSBzZXQgb2YgZG9jdW1lbnRzIHJldHVybmVkIGJ5IGFcbiAqIEZpcmVzdG9yZSBxdWVyeS4gYFF1ZXJ5T3JkZXJCeUNvbnN0cmFpbnRgcyBhcmUgY3JlYXRlZCBieSBpbnZva2luZ1xuICoge0BsaW5rIG9yZGVyQnl9IGFuZCBjYW4gdGhlbiBiZSBwYXNzZWQgdG8ge0BsaW5rIChxdWVyeToxKX0gdG8gY3JlYXRlIGEgbmV3IHF1ZXJ5XG4gKiBpbnN0YW5jZSB0aGF0IGFsc28gY29udGFpbnMgdGhpcyBgUXVlcnlPcmRlckJ5Q29uc3RyYWludGAuXG4gKlxuICogTm90ZTogRG9jdW1lbnRzIHRoYXQgZG8gbm90IGNvbnRhaW4gdGhlIG9yZGVyQnkgZmllbGQgd2lsbCBub3QgYmUgcHJlc2VudCBpblxuICogdGhlIHF1ZXJ5IHJlc3VsdC5cbiAqL1xuY2xhc3MgUXVlcnlPcmRlckJ5Q29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX2ZpZWxkLCBfZGlyZWN0aW9uKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2ZpZWxkID0gX2ZpZWxkO1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBfZGlyZWN0aW9uO1xuICAgICAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyBxdWVyeSBjb25zdHJhaW50ICovXG4gICAgICAgIHRoaXMudHlwZSA9ICdvcmRlckJ5JztcbiAgICB9XG4gICAgc3RhdGljIF9jcmVhdGUoX2ZpZWxkLCBfZGlyZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlPcmRlckJ5Q29uc3RyYWludChfZmllbGQsIF9kaXJlY3Rpb24pO1xuICAgIH1cbiAgICBfYXBwbHkocXVlcnkpIHtcbiAgICAgICAgY29uc3Qgb3JkZXJCeSA9IG5ld1F1ZXJ5T3JkZXJCeShxdWVyeS5fcXVlcnksIHRoaXMuX2ZpZWxkLCB0aGlzLl9kaXJlY3Rpb24pO1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHF1ZXJ5LmZpcmVzdG9yZSwgcXVlcnkuY29udmVydGVyLCBxdWVyeVdpdGhBZGRlZE9yZGVyQnkocXVlcnkuX3F1ZXJ5LCBvcmRlckJ5KSk7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIFF1ZXJ5T3JkZXJCeUNvbnN0cmFpbnR9IHRoYXQgc29ydHMgdGhlIHF1ZXJ5IHJlc3VsdCBieSB0aGVcbiAqIHNwZWNpZmllZCBmaWVsZCwgb3B0aW9uYWxseSBpbiBkZXNjZW5kaW5nIG9yZGVyIGluc3RlYWQgb2YgYXNjZW5kaW5nLlxuICpcbiAqIE5vdGU6IERvY3VtZW50cyB0aGF0IGRvIG5vdCBjb250YWluIHRoZSBzcGVjaWZpZWQgZmllbGQgd2lsbCBub3QgYmUgcHJlc2VudFxuICogaW4gdGhlIHF1ZXJ5IHJlc3VsdC5cbiAqXG4gKiBAcGFyYW0gZmllbGRQYXRoIC0gVGhlIGZpZWxkIHRvIHNvcnQgYnkuXG4gKiBAcGFyYW0gZGlyZWN0aW9uU3RyIC0gT3B0aW9uYWwgZGlyZWN0aW9uIHRvIHNvcnQgYnkgKCdhc2MnIG9yICdkZXNjJykuIElmXG4gKiBub3Qgc3BlY2lmaWVkLCBvcmRlciB3aWxsIGJlIGFzY2VuZGluZy5cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHtAbGluayBRdWVyeU9yZGVyQnlDb25zdHJhaW50fS5cbiAqL1xuZnVuY3Rpb24gb3JkZXJCeShmaWVsZFBhdGgsIGRpcmVjdGlvblN0ciA9ICdhc2MnKSB7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyO1xuICAgIGNvbnN0IHBhdGggPSBmaWVsZFBhdGhGcm9tQXJndW1lbnQoJ29yZGVyQnknLCBmaWVsZFBhdGgpO1xuICAgIHJldHVybiBRdWVyeU9yZGVyQnlDb25zdHJhaW50Ll9jcmVhdGUocGF0aCwgZGlyZWN0aW9uKTtcbn1cbi8qKlxuICogQSBgUXVlcnlMaW1pdENvbnN0cmFpbnRgIGlzIHVzZWQgdG8gbGltaXQgdGhlIG51bWJlciBvZiBkb2N1bWVudHMgcmV0dXJuZWQgYnlcbiAqIGEgRmlyZXN0b3JlIHF1ZXJ5LlxuICogYFF1ZXJ5TGltaXRDb25zdHJhaW50YHMgYXJlIGNyZWF0ZWQgYnkgaW52b2tpbmcge0BsaW5rIGxpbWl0fSBvclxuICoge0BsaW5rIGxpbWl0VG9MYXN0fSBhbmQgY2FuIHRoZW4gYmUgcGFzc2VkIHRvIHtAbGluayAocXVlcnk6MSl9IHRvIGNyZWF0ZSBhIG5ld1xuICogcXVlcnkgaW5zdGFuY2UgdGhhdCBhbHNvIGNvbnRhaW5zIHRoaXMgYFF1ZXJ5TGltaXRDb25zdHJhaW50YC5cbiAqL1xuY2xhc3MgUXVlcnlMaW1pdENvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIHF1ZXJ5IGNvbnN0cmFpbnQgKi9cbiAgICB0eXBlLCBfbGltaXQsIF9saW1pdFR5cGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5fbGltaXQgPSBfbGltaXQ7XG4gICAgICAgIHRoaXMuX2xpbWl0VHlwZSA9IF9saW1pdFR5cGU7XG4gICAgfVxuICAgIHN0YXRpYyBfY3JlYXRlKHR5cGUsIF9saW1pdCwgX2xpbWl0VHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5TGltaXRDb25zdHJhaW50KHR5cGUsIF9saW1pdCwgX2xpbWl0VHlwZSk7XG4gICAgfVxuICAgIF9hcHBseShxdWVyeSkge1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHF1ZXJ5LmZpcmVzdG9yZSwgcXVlcnkuY29udmVydGVyLCBxdWVyeVdpdGhMaW1pdChxdWVyeS5fcXVlcnksIHRoaXMuX2xpbWl0LCB0aGlzLl9saW1pdFR5cGUpKTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgUXVlcnlMaW1pdENvbnN0cmFpbnR9IHRoYXQgb25seSByZXR1cm5zIHRoZSBmaXJzdCBtYXRjaGluZ1xuICogZG9jdW1lbnRzLlxuICpcbiAqIEBwYXJhbSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0byByZXR1cm4uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCB7QGxpbmsgUXVlcnlMaW1pdENvbnN0cmFpbnR9LlxuICovXG5mdW5jdGlvbiBsaW1pdChsaW1pdCkge1xuICAgIHZhbGlkYXRlUG9zaXRpdmVOdW1iZXIoJ2xpbWl0JywgbGltaXQpO1xuICAgIHJldHVybiBRdWVyeUxpbWl0Q29uc3RyYWludC5fY3JlYXRlKCdsaW1pdCcsIGxpbWl0LCBcIkZcIiAvKiBMaW1pdFR5cGUuRmlyc3QgKi8pO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIFF1ZXJ5TGltaXRDb25zdHJhaW50fSB0aGF0IG9ubHkgcmV0dXJucyB0aGUgbGFzdCBtYXRjaGluZ1xuICogZG9jdW1lbnRzLlxuICpcbiAqIFlvdSBtdXN0IHNwZWNpZnkgYXQgbGVhc3Qgb25lIGBvcmRlckJ5YCBjbGF1c2UgZm9yIGBsaW1pdFRvTGFzdGAgcXVlcmllcyxcbiAqIG90aGVyd2lzZSBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24gZHVyaW5nIGV4ZWN1dGlvbi5cbiAqXG4gKiBAcGFyYW0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgaXRlbXMgdG8gcmV0dXJuLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQge0BsaW5rIFF1ZXJ5TGltaXRDb25zdHJhaW50fS5cbiAqL1xuZnVuY3Rpb24gbGltaXRUb0xhc3QobGltaXQpIHtcbiAgICB2YWxpZGF0ZVBvc2l0aXZlTnVtYmVyKCdsaW1pdFRvTGFzdCcsIGxpbWl0KTtcbiAgICByZXR1cm4gUXVlcnlMaW1pdENvbnN0cmFpbnQuX2NyZWF0ZSgnbGltaXRUb0xhc3QnLCBsaW1pdCwgXCJMXCIgLyogTGltaXRUeXBlLkxhc3QgKi8pO1xufVxuLyoqXG4gKiBBIGBRdWVyeVN0YXJ0QXRDb25zdHJhaW50YCBpcyB1c2VkIHRvIGV4Y2x1ZGUgZG9jdW1lbnRzIGZyb20gdGhlIHN0YXJ0IG9mIGFcbiAqIHJlc3VsdCBzZXQgcmV0dXJuZWQgYnkgYSBGaXJlc3RvcmUgcXVlcnkuXG4gKiBgUXVlcnlTdGFydEF0Q29uc3RyYWludGBzIGFyZSBjcmVhdGVkIGJ5IGludm9raW5nIHtAbGluayAoc3RhcnRBdDoxKX0gb3JcbiAqIHtAbGluayAoc3RhcnRBZnRlcjoxKX0gYW5kIGNhbiB0aGVuIGJlIHBhc3NlZCB0byB7QGxpbmsgKHF1ZXJ5OjEpfSB0byBjcmVhdGUgYVxuICogbmV3IHF1ZXJ5IGluc3RhbmNlIHRoYXQgYWxzbyBjb250YWlucyB0aGlzIGBRdWVyeVN0YXJ0QXRDb25zdHJhaW50YC5cbiAqL1xuY2xhc3MgUXVlcnlTdGFydEF0Q29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqIFRoZSB0eXBlIG9mIHRoaXMgcXVlcnkgY29uc3RyYWludCAqL1xuICAgIHR5cGUsIF9kb2NPckZpZWxkcywgX2luY2x1c2l2ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLl9kb2NPckZpZWxkcyA9IF9kb2NPckZpZWxkcztcbiAgICAgICAgdGhpcy5faW5jbHVzaXZlID0gX2luY2x1c2l2ZTtcbiAgICB9XG4gICAgc3RhdGljIF9jcmVhdGUodHlwZSwgX2RvY09yRmllbGRzLCBfaW5jbHVzaXZlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlTdGFydEF0Q29uc3RyYWludCh0eXBlLCBfZG9jT3JGaWVsZHMsIF9pbmNsdXNpdmUpO1xuICAgIH1cbiAgICBfYXBwbHkocXVlcnkpIHtcbiAgICAgICAgY29uc3QgYm91bmQgPSBuZXdRdWVyeUJvdW5kRnJvbURvY09yRmllbGRzKHF1ZXJ5LCB0aGlzLnR5cGUsIHRoaXMuX2RvY09yRmllbGRzLCB0aGlzLl9pbmNsdXNpdmUpO1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHF1ZXJ5LmZpcmVzdG9yZSwgcXVlcnkuY29udmVydGVyLCBxdWVyeVdpdGhTdGFydEF0KHF1ZXJ5Ll9xdWVyeSwgYm91bmQpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdGFydEF0KC4uLmRvY09yRmllbGRzKSB7XG4gICAgcmV0dXJuIFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnQuX2NyZWF0ZSgnc3RhcnRBdCcsIGRvY09yRmllbGRzLCBcbiAgICAvKmluY2x1c2l2ZT0qLyB0cnVlKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0QWZ0ZXIoLi4uZG9jT3JGaWVsZHMpIHtcbiAgICByZXR1cm4gUXVlcnlTdGFydEF0Q29uc3RyYWludC5fY3JlYXRlKCdzdGFydEFmdGVyJywgZG9jT3JGaWVsZHMsIFxuICAgIC8qaW5jbHVzaXZlPSovIGZhbHNlKTtcbn1cbi8qKlxuICogQSBgUXVlcnlFbmRBdENvbnN0cmFpbnRgIGlzIHVzZWQgdG8gZXhjbHVkZSBkb2N1bWVudHMgZnJvbSB0aGUgZW5kIG9mIGFcbiAqIHJlc3VsdCBzZXQgcmV0dXJuZWQgYnkgYSBGaXJlc3RvcmUgcXVlcnkuXG4gKiBgUXVlcnlFbmRBdENvbnN0cmFpbnRgcyBhcmUgY3JlYXRlZCBieSBpbnZva2luZyB7QGxpbmsgKGVuZEF0OjEpfSBvclxuICoge0BsaW5rIChlbmRCZWZvcmU6MSl9IGFuZCBjYW4gdGhlbiBiZSBwYXNzZWQgdG8ge0BsaW5rIChxdWVyeToxKX0gdG8gY3JlYXRlIGEgbmV3XG4gKiBxdWVyeSBpbnN0YW5jZSB0aGF0IGFsc28gY29udGFpbnMgdGhpcyBgUXVlcnlFbmRBdENvbnN0cmFpbnRgLlxuICovXG5jbGFzcyBRdWVyeUVuZEF0Q29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqIFRoZSB0eXBlIG9mIHRoaXMgcXVlcnkgY29uc3RyYWludCAqL1xuICAgIHR5cGUsIF9kb2NPckZpZWxkcywgX2luY2x1c2l2ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLl9kb2NPckZpZWxkcyA9IF9kb2NPckZpZWxkcztcbiAgICAgICAgdGhpcy5faW5jbHVzaXZlID0gX2luY2x1c2l2ZTtcbiAgICB9XG4gICAgc3RhdGljIF9jcmVhdGUodHlwZSwgX2RvY09yRmllbGRzLCBfaW5jbHVzaXZlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlFbmRBdENvbnN0cmFpbnQodHlwZSwgX2RvY09yRmllbGRzLCBfaW5jbHVzaXZlKTtcbiAgICB9XG4gICAgX2FwcGx5KHF1ZXJ5KSB7XG4gICAgICAgIGNvbnN0IGJvdW5kID0gbmV3UXVlcnlCb3VuZEZyb21Eb2NPckZpZWxkcyhxdWVyeSwgdGhpcy50eXBlLCB0aGlzLl9kb2NPckZpZWxkcywgdGhpcy5faW5jbHVzaXZlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeShxdWVyeS5maXJlc3RvcmUsIHF1ZXJ5LmNvbnZlcnRlciwgcXVlcnlXaXRoRW5kQXQocXVlcnkuX3F1ZXJ5LCBib3VuZCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVuZEJlZm9yZSguLi5kb2NPckZpZWxkcykge1xuICAgIHJldHVybiBRdWVyeUVuZEF0Q29uc3RyYWludC5fY3JlYXRlKCdlbmRCZWZvcmUnLCBkb2NPckZpZWxkcywgXG4gICAgLyppbmNsdXNpdmU9Ki8gZmFsc2UpO1xufVxuZnVuY3Rpb24gZW5kQXQoLi4uZG9jT3JGaWVsZHMpIHtcbiAgICByZXR1cm4gUXVlcnlFbmRBdENvbnN0cmFpbnQuX2NyZWF0ZSgnZW5kQXQnLCBkb2NPckZpZWxkcywgXG4gICAgLyppbmNsdXNpdmU9Ki8gdHJ1ZSk7XG59XG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIGJvdW5kIGZyb20gYSBkb2N1bWVudCBvciBmaWVsZHMgKi9cbmZ1bmN0aW9uIG5ld1F1ZXJ5Qm91bmRGcm9tRG9jT3JGaWVsZHMocXVlcnksIG1ldGhvZE5hbWUsIGRvY09yRmllbGRzLCBpbmNsdXNpdmUpIHtcbiAgICBkb2NPckZpZWxkc1swXSA9IGdldE1vZHVsYXJJbnN0YW5jZShkb2NPckZpZWxkc1swXSk7XG4gICAgaWYgKGRvY09yRmllbGRzWzBdIGluc3RhbmNlb2YgRG9jdW1lbnRTbmFwc2hvdCQxKSB7XG4gICAgICAgIHJldHVybiBuZXdRdWVyeUJvdW5kRnJvbURvY3VtZW50KHF1ZXJ5Ll9xdWVyeSwgcXVlcnkuZmlyZXN0b3JlLl9kYXRhYmFzZUlkLCBtZXRob2ROYW1lLCBkb2NPckZpZWxkc1swXS5fZG9jdW1lbnQsIGluY2x1c2l2ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXdVc2VyRGF0YVJlYWRlcihxdWVyeS5maXJlc3RvcmUpO1xuICAgICAgICByZXR1cm4gbmV3UXVlcnlCb3VuZEZyb21GaWVsZHMocXVlcnkuX3F1ZXJ5LCBxdWVyeS5maXJlc3RvcmUuX2RhdGFiYXNlSWQsIHJlYWRlciwgbWV0aG9kTmFtZSwgZG9jT3JGaWVsZHMsIGluY2x1c2l2ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbmV3UXVlcnlGaWx0ZXIocXVlcnksIG1ldGhvZE5hbWUsIGRhdGFSZWFkZXIsIGRhdGFiYXNlSWQsIGZpZWxkUGF0aCwgb3AsIHZhbHVlKSB7XG4gICAgbGV0IGZpZWxkVmFsdWU7XG4gICAgaWYgKGZpZWxkUGF0aC5pc0tleUZpZWxkKCkpIHtcbiAgICAgICAgaWYgKG9wID09PSBcImFycmF5LWNvbnRhaW5zXCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlMgKi8gfHwgb3AgPT09IFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBRdWVyeS4gWW91IGNhbid0IHBlcmZvcm0gJyR7b3B9JyBxdWVyaWVzIG9uIGRvY3VtZW50SWQoKS5gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcCA9PT0gXCJpblwiIC8qIE9wZXJhdG9yLklOICovIHx8IG9wID09PSBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLykge1xuICAgICAgICAgICAgdmFsaWRhdGVEaXNqdW5jdGl2ZUZpbHRlckVsZW1lbnRzKHZhbHVlLCBvcCk7XG4gICAgICAgICAgICBjb25zdCByZWZlcmVuY2VMaXN0ID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFycmF5VmFsdWUgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VMaXN0LnB1c2gocGFyc2VEb2N1bWVudElkVmFsdWUoZGF0YWJhc2VJZCwgcXVlcnksIGFycmF5VmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpZWxkVmFsdWUgPSB7IGFycmF5VmFsdWU6IHsgdmFsdWVzOiByZWZlcmVuY2VMaXN0IH0gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWUgPSBwYXJzZURvY3VtZW50SWRWYWx1ZShkYXRhYmFzZUlkLCBxdWVyeSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAob3AgPT09IFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqLyB8fFxuICAgICAgICAgICAgb3AgPT09IFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovIHx8XG4gICAgICAgICAgICBvcCA9PT0gXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi8pIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRGlzanVuY3RpdmVGaWx0ZXJFbGVtZW50cyh2YWx1ZSwgb3ApO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkVmFsdWUgPSBwYXJzZVF1ZXJ5VmFsdWUoZGF0YVJlYWRlciwgbWV0aG9kTmFtZSwgdmFsdWUsIFxuICAgICAgICAvKiBhbGxvd0FycmF5cz0gKi8gb3AgPT09IFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqLyB8fCBvcCA9PT0gXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi8pO1xuICAgIH1cbiAgICBjb25zdCBmaWx0ZXIgPSBGaWVsZEZpbHRlci5jcmVhdGUoZmllbGRQYXRoLCBvcCwgZmllbGRWYWx1ZSk7XG4gICAgcmV0dXJuIGZpbHRlcjtcbn1cbmZ1bmN0aW9uIG5ld1F1ZXJ5T3JkZXJCeShxdWVyeSwgZmllbGRQYXRoLCBkaXJlY3Rpb24pIHtcbiAgICBpZiAocXVlcnkuc3RhcnRBdCAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnSW52YWxpZCBxdWVyeS4gWW91IG11c3Qgbm90IGNhbGwgc3RhcnRBdCgpIG9yIHN0YXJ0QWZ0ZXIoKSBiZWZvcmUgJyArXG4gICAgICAgICAgICAnY2FsbGluZyBvcmRlckJ5KCkuJyk7XG4gICAgfVxuICAgIGlmIChxdWVyeS5lbmRBdCAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnSW52YWxpZCBxdWVyeS4gWW91IG11c3Qgbm90IGNhbGwgZW5kQXQoKSBvciBlbmRCZWZvcmUoKSBiZWZvcmUgJyArXG4gICAgICAgICAgICAnY2FsbGluZyBvcmRlckJ5KCkuJyk7XG4gICAgfVxuICAgIGNvbnN0IG9yZGVyQnkgPSBuZXcgT3JkZXJCeShmaWVsZFBhdGgsIGRpcmVjdGlvbik7XG4gICAgcmV0dXJuIG9yZGVyQnk7XG59XG4vKipcbiAqIENyZWF0ZSBhIGBCb3VuZGAgZnJvbSBhIHF1ZXJ5IGFuZCBhIGRvY3VtZW50LlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgYEJvdW5kYCB3aWxsIGFsd2F5cyBpbmNsdWRlIHRoZSBrZXkgb2YgdGhlIGRvY3VtZW50XG4gKiBhbmQgc28gb25seSB0aGUgcHJvdmlkZWQgZG9jdW1lbnQgd2lsbCBjb21wYXJlIGVxdWFsIHRvIHRoZSByZXR1cm5lZFxuICogcG9zaXRpb24uXG4gKlxuICogV2lsbCB0aHJvdyBpZiB0aGUgZG9jdW1lbnQgZG9lcyBub3QgY29udGFpbiBhbGwgZmllbGRzIG9mIHRoZSBvcmRlciBieVxuICogb2YgdGhlIHF1ZXJ5IG9yIGlmIGFueSBvZiB0aGUgZmllbGRzIGluIHRoZSBvcmRlciBieSBhcmUgYW4gdW5jb21taXR0ZWRcbiAqIHNlcnZlciB0aW1lc3RhbXAuXG4gKi9cbmZ1bmN0aW9uIG5ld1F1ZXJ5Qm91bmRGcm9tRG9jdW1lbnQocXVlcnksIGRhdGFiYXNlSWQsIG1ldGhvZE5hbWUsIGRvYywgaW5jbHVzaXZlKSB7XG4gICAgaWYgKCFkb2MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuTk9UX0ZPVU5ELCBgQ2FuJ3QgdXNlIGEgRG9jdW1lbnRTbmFwc2hvdCB0aGF0IGRvZXNuJ3QgZXhpc3QgZm9yIGAgK1xuICAgICAgICAgICAgYCR7bWV0aG9kTmFtZX0oKS5gKTtcbiAgICB9XG4gICAgY29uc3QgY29tcG9uZW50cyA9IFtdO1xuICAgIC8vIEJlY2F1c2UgcGVvcGxlIGV4cGVjdCB0byBjb250aW51ZS9lbmQgYSBxdWVyeSBhdCB0aGUgZXhhY3QgZG9jdW1lbnRcbiAgICAvLyBwcm92aWRlZCwgd2UgbmVlZCB0byB1c2UgdGhlIGltcGxpY2l0IHNvcnQgb3JkZXIgcmF0aGVyIHRoYW4gdGhlIGV4cGxpY2l0XG4gICAgLy8gc29ydCBvcmRlciwgYmVjYXVzZSBpdCdzIGd1YXJhbnRlZWQgdG8gY29udGFpbiB0aGUgZG9jdW1lbnQga2V5LiBUaGF0IHdheVxuICAgIC8vIHRoZSBwb3NpdGlvbiBiZWNvbWVzIHVuYW1iaWd1b3VzIGFuZCB0aGUgcXVlcnkgY29udGludWVzL2VuZHMgZXhhY3RseSBhdFxuICAgIC8vIHRoZSBwcm92aWRlZCBkb2N1bWVudC4gV2l0aG91dCB0aGUga2V5IChieSB1c2luZyB0aGUgZXhwbGljaXQgc29ydFxuICAgIC8vIG9yZGVycyksIG11bHRpcGxlIGRvY3VtZW50cyBjb3VsZCBtYXRjaCB0aGUgcG9zaXRpb24sIHlpZWxkaW5nIGR1cGxpY2F0ZVxuICAgIC8vIHJlc3VsdHMuXG4gICAgZm9yIChjb25zdCBvcmRlckJ5IG9mIHF1ZXJ5Tm9ybWFsaXplZE9yZGVyQnkocXVlcnkpKSB7XG4gICAgICAgIGlmIChvcmRlckJ5LmZpZWxkLmlzS2V5RmllbGQoKSkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKHJlZlZhbHVlKGRhdGFiYXNlSWQsIGRvYy5rZXkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZG9jLmRhdGEuZmllbGQob3JkZXJCeS5maWVsZCk7XG4gICAgICAgICAgICBpZiAoaXNTZXJ2ZXJUaW1lc3RhbXAodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0ludmFsaWQgcXVlcnkuIFlvdSBhcmUgdHJ5aW5nIHRvIHN0YXJ0IG9yIGVuZCBhIHF1ZXJ5IHVzaW5nIGEgJyArXG4gICAgICAgICAgICAgICAgICAgICdkb2N1bWVudCBmb3Igd2hpY2ggdGhlIGZpZWxkIFwiJyArXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyQnkuZmllbGQgK1xuICAgICAgICAgICAgICAgICAgICAnXCIgaXMgYW4gdW5jb21taXR0ZWQgc2VydmVyIHRpbWVzdGFtcC4gKFNpbmNlIHRoZSB2YWx1ZSBvZiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3RoaXMgZmllbGQgaXMgdW5rbm93biwgeW91IGNhbm5vdCBzdGFydC9lbmQgYSBxdWVyeSB3aXRoIGl0LiknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gb3JkZXJCeS5maWVsZC5jYW5vbmljYWxTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBxdWVyeS4gWW91IGFyZSB0cnlpbmcgdG8gc3RhcnQgb3IgZW5kIGEgcXVlcnkgdXNpbmcgYSBgICtcbiAgICAgICAgICAgICAgICAgICAgYGRvY3VtZW50IGZvciB3aGljaCB0aGUgZmllbGQgJyR7ZmllbGR9JyAodXNlZCBhcyB0aGUgYCArXG4gICAgICAgICAgICAgICAgICAgIGBvcmRlckJ5KSBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEJvdW5kKGNvbXBvbmVudHMsIGluY2x1c2l2ZSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgbGlzdCBvZiBmaWVsZCB2YWx1ZXMgdG8gYSBgQm91bmRgIGZvciB0aGUgZ2l2ZW4gcXVlcnkuXG4gKi9cbmZ1bmN0aW9uIG5ld1F1ZXJ5Qm91bmRGcm9tRmllbGRzKHF1ZXJ5LCBkYXRhYmFzZUlkLCBkYXRhUmVhZGVyLCBtZXRob2ROYW1lLCB2YWx1ZXMsIGluY2x1c2l2ZSkge1xuICAgIC8vIFVzZSBleHBsaWNpdCBvcmRlciBieSdzIGJlY2F1c2UgaXQgaGFzIHRvIG1hdGNoIHRoZSBxdWVyeSB0aGUgdXNlciBtYWRlXG4gICAgY29uc3Qgb3JkZXJCeSA9IHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeTtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCA+IG9yZGVyQnkubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBUb28gbWFueSBhcmd1bWVudHMgcHJvdmlkZWQgdG8gJHttZXRob2ROYW1lfSgpLiBgICtcbiAgICAgICAgICAgIGBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgYCArXG4gICAgICAgICAgICBgbnVtYmVyIG9mIG9yZGVyQnkoKSBjbGF1c2VzYCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbXBvbmVudHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCByYXdWYWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgY29uc3Qgb3JkZXJCeUNvbXBvbmVudCA9IG9yZGVyQnlbaV07XG4gICAgICAgIGlmIChvcmRlckJ5Q29tcG9uZW50LmZpZWxkLmlzS2V5RmllbGQoKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByYXdWYWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBxdWVyeS4gRXhwZWN0ZWQgYSBzdHJpbmcgZm9yIGRvY3VtZW50IElEIGluIGAgK1xuICAgICAgICAgICAgICAgICAgICBgJHttZXRob2ROYW1lfSgpLCBidXQgZ290IGEgJHt0eXBlb2YgcmF3VmFsdWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzQ29sbGVjdGlvbkdyb3VwUXVlcnkocXVlcnkpICYmIHJhd1ZhbHVlLmluZGV4T2YoJy8nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBxdWVyeS4gV2hlbiBxdWVyeWluZyBhIGNvbGxlY3Rpb24gYW5kIG9yZGVyaW5nIGJ5IGRvY3VtZW50SWQoKSwgYCArXG4gICAgICAgICAgICAgICAgICAgIGB0aGUgdmFsdWUgcGFzc2VkIHRvICR7bWV0aG9kTmFtZX0oKSBtdXN0IGJlIGEgcGxhaW4gZG9jdW1lbnQgSUQsIGJ1dCBgICtcbiAgICAgICAgICAgICAgICAgICAgYCcke3Jhd1ZhbHVlfScgY29udGFpbnMgYSBzbGFzaC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBxdWVyeS5wYXRoLmNoaWxkKFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKHJhd1ZhbHVlKSk7XG4gICAgICAgICAgICBpZiAoIURvY3VtZW50S2V5LmlzRG9jdW1lbnRLZXkocGF0aCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBxdWVyeS4gV2hlbiBxdWVyeWluZyBhIGNvbGxlY3Rpb24gZ3JvdXAgYW5kIG9yZGVyaW5nIGJ5IGAgK1xuICAgICAgICAgICAgICAgICAgICBgZG9jdW1lbnRJZCgpLCB0aGUgdmFsdWUgcGFzc2VkIHRvICR7bWV0aG9kTmFtZX0oKSBtdXN0IHJlc3VsdCBpbiBhIGAgK1xuICAgICAgICAgICAgICAgICAgICBgdmFsaWQgZG9jdW1lbnQgcGF0aCwgYnV0ICcke3BhdGh9JyBpcyBub3QgYmVjYXVzZSBpdCBjb250YWlucyBhbiBvZGQgbnVtYmVyIGAgK1xuICAgICAgICAgICAgICAgICAgICBgb2Ygc2VnbWVudHMuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBuZXcgRG9jdW1lbnRLZXkocGF0aCk7XG4gICAgICAgICAgICBjb21wb25lbnRzLnB1c2gocmVmVmFsdWUoZGF0YWJhc2VJZCwga2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB3cmFwcGVkID0gcGFyc2VRdWVyeVZhbHVlKGRhdGFSZWFkZXIsIG1ldGhvZE5hbWUsIHJhd1ZhbHVlKTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaCh3cmFwcGVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEJvdW5kKGNvbXBvbmVudHMsIGluY2x1c2l2ZSk7XG59XG4vKipcbiAqIFBhcnNlcyB0aGUgZ2l2ZW4gYGRvY3VtZW50SWRWYWx1ZWAgaW50byBhIGBSZWZlcmVuY2VWYWx1ZWAsIHRocm93aW5nXG4gKiBhcHByb3ByaWF0ZSBlcnJvcnMgaWYgdGhlIHZhbHVlIGlzIGFueXRoaW5nIG90aGVyIHRoYW4gYSBgRG9jdW1lbnRSZWZlcmVuY2VgXG4gKiBvciBgc3RyaW5nYCwgb3IgaWYgdGhlIHN0cmluZyBpcyBtYWxmb3JtZWQuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRG9jdW1lbnRJZFZhbHVlKGRhdGFiYXNlSWQsIHF1ZXJ5LCBkb2N1bWVudElkVmFsdWUpIHtcbiAgICBkb2N1bWVudElkVmFsdWUgPSBnZXRNb2R1bGFySW5zdGFuY2UoZG9jdW1lbnRJZFZhbHVlKTtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50SWRWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50SWRWYWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdJbnZhbGlkIHF1ZXJ5LiBXaGVuIHF1ZXJ5aW5nIHdpdGggZG9jdW1lbnRJZCgpLCB5b3UgJyArXG4gICAgICAgICAgICAgICAgJ211c3QgcHJvdmlkZSBhIHZhbGlkIGRvY3VtZW50IElELCBidXQgaXQgd2FzIGFuIGVtcHR5IHN0cmluZy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQ29sbGVjdGlvbkdyb3VwUXVlcnkocXVlcnkpICYmIGRvY3VtZW50SWRWYWx1ZS5pbmRleE9mKCcvJykgIT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBxdWVyeS4gV2hlbiBxdWVyeWluZyBhIGNvbGxlY3Rpb24gYnkgYCArXG4gICAgICAgICAgICAgICAgYGRvY3VtZW50SWQoKSwgeW91IG11c3QgcHJvdmlkZSBhIHBsYWluIGRvY3VtZW50IElELCBidXQgYCArXG4gICAgICAgICAgICAgICAgYCcke2RvY3VtZW50SWRWYWx1ZX0nIGNvbnRhaW5zIGEgJy8nIGNoYXJhY3Rlci5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXRoID0gcXVlcnkucGF0aC5jaGlsZChSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhkb2N1bWVudElkVmFsdWUpKTtcbiAgICAgICAgaWYgKCFEb2N1bWVudEtleS5pc0RvY3VtZW50S2V5KHBhdGgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBxdWVyeS4gV2hlbiBxdWVyeWluZyBhIGNvbGxlY3Rpb24gZ3JvdXAgYnkgYCArXG4gICAgICAgICAgICAgICAgYGRvY3VtZW50SWQoKSwgdGhlIHZhbHVlIHByb3ZpZGVkIG11c3QgcmVzdWx0IGluIGEgdmFsaWQgZG9jdW1lbnQgcGF0aCwgYCArXG4gICAgICAgICAgICAgICAgYGJ1dCAnJHtwYXRofScgaXMgbm90IGJlY2F1c2UgaXQgaGFzIGFuIG9kZCBudW1iZXIgb2Ygc2VnbWVudHMgKCR7cGF0aC5sZW5ndGh9KS5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVmVmFsdWUoZGF0YWJhc2VJZCwgbmV3IERvY3VtZW50S2V5KHBhdGgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZG9jdW1lbnRJZFZhbHVlIGluc3RhbmNlb2YgRG9jdW1lbnRSZWZlcmVuY2UpIHtcbiAgICAgICAgcmV0dXJuIHJlZlZhbHVlKGRhdGFiYXNlSWQsIGRvY3VtZW50SWRWYWx1ZS5fa2V5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHF1ZXJ5LiBXaGVuIHF1ZXJ5aW5nIHdpdGggZG9jdW1lbnRJZCgpLCB5b3UgbXVzdCBwcm92aWRlIGEgdmFsaWQgYCArXG4gICAgICAgICAgICBgc3RyaW5nIG9yIGEgRG9jdW1lbnRSZWZlcmVuY2UsIGJ1dCBpdCB3YXM6IGAgK1xuICAgICAgICAgICAgYCR7dmFsdWVEZXNjcmlwdGlvbihkb2N1bWVudElkVmFsdWUpfS5gKTtcbiAgICB9XG59XG4vKipcbiAqIFZhbGlkYXRlcyB0aGF0IHRoZSB2YWx1ZSBwYXNzZWQgaW50byBhIGRpc2p1bmN0aXZlIGZpbHRlciBzYXRpc2ZpZXMgYWxsXG4gKiBhcnJheSByZXF1aXJlbWVudHMuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRGlzanVuY3RpdmVGaWx0ZXJFbGVtZW50cyh2YWx1ZSwgb3BlcmF0b3IpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnSW52YWxpZCBRdWVyeS4gQSBub24tZW1wdHkgYXJyYXkgaXMgcmVxdWlyZWQgZm9yICcgK1xuICAgICAgICAgICAgYCcke29wZXJhdG9yLnRvU3RyaW5nKCl9JyBmaWx0ZXJzLmApO1xuICAgIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gb3BlcmF0b3IsIHJldHVybnMgdGhlIHNldCBvZiBvcGVyYXRvcnMgdGhhdCBjYW5ub3QgYmUgdXNlZCB3aXRoIGl0LlxuICpcbiAqIFRoaXMgaXMgbm90IGEgY29tcHJlaGVuc2l2ZSBjaGVjaywgYW5kIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIHJlbW92ZWQgaW4gdGhlXG4gKiBsb25nIHRlcm0uIFZhbGlkYXRpb25zIHNob3VsZCBvY2N1ciBpbiB0aGUgRmlyZXN0b3JlIGJhY2tlbmQuXG4gKlxuICogT3BlcmF0b3JzIGluIGEgcXVlcnkgbXVzdCBhZGhlcmUgdG8gdGhlIGZvbGxvd2luZyBzZXQgb2YgcnVsZXM6XG4gKiAxLiBPbmx5IG9uZSBpbmVxdWFsaXR5IHBlciBxdWVyeS5cbiAqIDIuIGBOT1RfSU5gIGNhbm5vdCBiZSB1c2VkIHdpdGggYXJyYXksIGRpc2p1bmN0aXZlLCBvciBgTk9UX0VRVUFMYCBvcGVyYXRvcnMuXG4gKi9cbmZ1bmN0aW9uIGNvbmZsaWN0aW5nT3BzKG9wKSB7XG4gICAgc3dpdGNoIChvcCkge1xuICAgICAgICBjYXNlIFwiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi86XG4gICAgICAgICAgICByZXR1cm4gW1wiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi8sIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovXTtcbiAgICAgICAgY2FzZSBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TX0FOWSAqLzpcbiAgICAgICAgY2FzZSBcImluXCIgLyogT3BlcmF0b3IuSU4gKi86XG4gICAgICAgICAgICByZXR1cm4gW1wibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovXTtcbiAgICAgICAgY2FzZSBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLzpcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi8sXG4gICAgICAgICAgICAgICAgXCJpblwiIC8qIE9wZXJhdG9yLklOICovLFxuICAgICAgICAgICAgICAgIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovLFxuICAgICAgICAgICAgICAgIFwiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi9cbiAgICAgICAgICAgIF07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVOZXdGaWVsZEZpbHRlcihxdWVyeSwgZmllbGRGaWx0ZXIpIHtcbiAgICBjb25zdCBjb25mbGljdGluZ09wID0gZmluZE9wSW5zaWRlRmlsdGVycyhxdWVyeS5maWx0ZXJzLCBjb25mbGljdGluZ09wcyhmaWVsZEZpbHRlci5vcCkpO1xuICAgIGlmIChjb25mbGljdGluZ09wICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZSB3aGVuIGl0J3MgYSBkdXBsaWNhdGUgb3AgdG8gZ2l2ZSBhIHNsaWdodGx5IGNsZWFyZXIgZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgaWYgKGNvbmZsaWN0aW5nT3AgPT09IGZpZWxkRmlsdGVyLm9wKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnSW52YWxpZCBxdWVyeS4gWW91IGNhbm5vdCB1c2UgbW9yZSB0aGFuIG9uZSAnICtcbiAgICAgICAgICAgICAgICBgJyR7ZmllbGRGaWx0ZXIub3AudG9TdHJpbmcoKX0nIGZpbHRlci5gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHF1ZXJ5LiBZb3UgY2Fubm90IHVzZSAnJHtmaWVsZEZpbHRlci5vcC50b1N0cmluZygpfScgZmlsdGVycyBgICtcbiAgICAgICAgICAgICAgICBgd2l0aCAnJHtjb25mbGljdGluZ09wLnRvU3RyaW5nKCl9JyBmaWx0ZXJzLmApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVOZXdGaWx0ZXIocXVlcnksIGZpbHRlcikge1xuICAgIGxldCB0ZXN0UXVlcnkgPSBxdWVyeTtcbiAgICBjb25zdCBzdWJGaWx0ZXJzID0gZmlsdGVyLmdldEZsYXR0ZW5lZEZpbHRlcnMoKTtcbiAgICBmb3IgKGNvbnN0IHN1YkZpbHRlciBvZiBzdWJGaWx0ZXJzKSB7XG4gICAgICAgIHZhbGlkYXRlTmV3RmllbGRGaWx0ZXIodGVzdFF1ZXJ5LCBzdWJGaWx0ZXIpO1xuICAgICAgICB0ZXN0UXVlcnkgPSBxdWVyeVdpdGhBZGRlZEZpbHRlcih0ZXN0UXVlcnksIHN1YkZpbHRlcik7XG4gICAgfVxufVxuLy8gQ2hlY2tzIGlmIGFueSBvZiB0aGUgcHJvdmlkZWQgZmlsdGVyIG9wZXJhdG9ycyBhcmUgaW5jbHVkZWQgaW4gdGhlIGdpdmVuIGxpc3Qgb2YgZmlsdGVycyBhbmRcbi8vIHJldHVybnMgdGhlIGZpcnN0IG9uZSB0aGF0IGlzLCBvciBudWxsIGlmIG5vbmUgYXJlLlxuZnVuY3Rpb24gZmluZE9wSW5zaWRlRmlsdGVycyhmaWx0ZXJzLCBvcGVyYXRvcnMpIHtcbiAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBmaWx0ZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGRGaWx0ZXIgb2YgZmlsdGVyLmdldEZsYXR0ZW5lZEZpbHRlcnMoKSkge1xuICAgICAgICAgICAgaWYgKG9wZXJhdG9ycy5pbmRleE9mKGZpZWxkRmlsdGVyLm9wKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkRmlsdGVyLm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVRdWVyeUZpbHRlckNvbnN0cmFpbnQoZnVuY3Rpb25OYW1lLCBxdWVyeUNvbnN0cmFpbnQpIHtcbiAgICBpZiAoIShxdWVyeUNvbnN0cmFpbnQgaW5zdGFuY2VvZiBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludCkgJiZcbiAgICAgICAgIShxdWVyeUNvbnN0cmFpbnQgaW5zdGFuY2VvZiBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBGdW5jdGlvbiAke2Z1bmN0aW9uTmFtZX0oKSByZXF1aXJlcyBBcHBsaWFibGVDb25zdHJhaW50cyBjcmVhdGVkIHdpdGggYSBjYWxsIHRvICd3aGVyZSguLi4pJywgJ29yKC4uLiknLCBvciAnYW5kKC4uLiknLmApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUXVlcnlDb25zdHJhaW50QXJyYXkocXVlcnlDb25zdHJhaW50KSB7XG4gICAgY29uc3QgY29tcG9zaXRlRmlsdGVyQ291bnQgPSBxdWVyeUNvbnN0cmFpbnQuZmlsdGVyKGZpbHRlciA9PiBmaWx0ZXIgaW5zdGFuY2VvZiBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnQpLmxlbmd0aDtcbiAgICBjb25zdCBmaWVsZEZpbHRlckNvdW50ID0gcXVlcnlDb25zdHJhaW50LmZpbHRlcihmaWx0ZXIgPT4gZmlsdGVyIGluc3RhbmNlb2YgUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnQpLmxlbmd0aDtcbiAgICBpZiAoY29tcG9zaXRlRmlsdGVyQ291bnQgPiAxIHx8XG4gICAgICAgIChjb21wb3NpdGVGaWx0ZXJDb3VudCA+IDAgJiYgZmllbGRGaWx0ZXJDb3VudCA+IDApKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdJbnZhbGlkUXVlcnkuIFdoZW4gdXNpbmcgY29tcG9zaXRlIGZpbHRlcnMsIHlvdSBjYW5ub3QgdXNlICcgK1xuICAgICAgICAgICAgJ21vcmUgdGhhbiBvbmUgZmlsdGVyIGF0IHRoZSB0b3AgbGV2ZWwuIENvbnNpZGVyIG5lc3RpbmcgdGhlIG11bHRpcGxlICcgK1xuICAgICAgICAgICAgJ2ZpbHRlcnMgd2l0aGluIGFuIGBhbmQoLi4uKWAgc3RhdGVtZW50LiBGb3IgZXhhbXBsZTogJyArXG4gICAgICAgICAgICAnY2hhbmdlIGBxdWVyeShxdWVyeSwgd2hlcmUoLi4uKSwgb3IoLi4uKSlgIHRvICcgK1xuICAgICAgICAgICAgJ2BxdWVyeShxdWVyeSwgYW5kKHdoZXJlKC4uLiksIG9yKC4uLikpKWAuJyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBDb252ZXJ0cyBGaXJlc3RvcmUncyBpbnRlcm5hbCB0eXBlcyB0byB0aGUgSmF2YVNjcmlwdCB0eXBlcyB0aGF0IHdlIGV4cG9zZVxuICogdG8gdGhlIHVzZXIuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIEFic3RyYWN0VXNlckRhdGFXcml0ZXIge1xuICAgIGNvbnZlcnRWYWx1ZSh2YWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IgPSAnbm9uZScpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlT3JkZXIodmFsdWUpKSB7XG4gICAgICAgICAgICBjYXNlIDAgLyogVHlwZU9yZGVyLk51bGxWYWx1ZSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBUeXBlT3JkZXIuQm9vbGVhblZhbHVlICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5ib29sZWFuVmFsdWU7XG4gICAgICAgICAgICBjYXNlIDIgLyogVHlwZU9yZGVyLk51bWJlclZhbHVlICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVOdW1iZXIodmFsdWUuaW50ZWdlclZhbHVlIHx8IHZhbHVlLmRvdWJsZVZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgMyAvKiBUeXBlT3JkZXIuVGltZXN0YW1wVmFsdWUgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFRpbWVzdGFtcCh2YWx1ZS50aW1lc3RhbXBWYWx1ZSk7XG4gICAgICAgICAgICBjYXNlIDQgLyogVHlwZU9yZGVyLlNlcnZlclRpbWVzdGFtcFZhbHVlICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTZXJ2ZXJUaW1lc3RhbXAodmFsdWUsIHNlcnZlclRpbWVzdGFtcEJlaGF2aW9yKTtcbiAgICAgICAgICAgIGNhc2UgNSAvKiBUeXBlT3JkZXIuU3RyaW5nVmFsdWUgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnN0cmluZ1ZhbHVlO1xuICAgICAgICAgICAgY2FzZSA2IC8qIFR5cGVPcmRlci5CbG9iVmFsdWUgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydEJ5dGVzKG5vcm1hbGl6ZUJ5dGVTdHJpbmcodmFsdWUuYnl0ZXNWYWx1ZSkpO1xuICAgICAgICAgICAgY2FzZSA3IC8qIFR5cGVPcmRlci5SZWZWYWx1ZSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0UmVmZXJlbmNlKHZhbHVlLnJlZmVyZW5jZVZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgOCAvKiBUeXBlT3JkZXIuR2VvUG9pbnRWYWx1ZSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0R2VvUG9pbnQodmFsdWUuZ2VvUG9pbnRWYWx1ZSk7XG4gICAgICAgICAgICBjYXNlIDkgLyogVHlwZU9yZGVyLkFycmF5VmFsdWUgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydEFycmF5KHZhbHVlLmFycmF5VmFsdWUsIHNlcnZlclRpbWVzdGFtcEJlaGF2aW9yKTtcbiAgICAgICAgICAgIGNhc2UgMTEgLyogVHlwZU9yZGVyLk9iamVjdFZhbHVlICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRPYmplY3QodmFsdWUubWFwVmFsdWUsIHNlcnZlclRpbWVzdGFtcEJlaGF2aW9yKTtcbiAgICAgICAgICAgIGNhc2UgMTAgLyogVHlwZU9yZGVyLlZlY3RvclZhbHVlICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRWZWN0b3JWYWx1ZSh2YWx1ZS5tYXBWYWx1ZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IGZhaWwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb252ZXJ0T2JqZWN0KG1hcFZhbHVlLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0T2JqZWN0TWFwKG1hcFZhbHVlLmZpZWxkcywgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb252ZXJ0T2JqZWN0TWFwKGZpZWxkcywgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IgPSAnbm9uZScpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvckVhY2goZmllbGRzLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB0aGlzLmNvbnZlcnRWYWx1ZSh2YWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29udmVydFZlY3RvclZhbHVlKG1hcFZhbHVlKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSAoX2MgPSAoX2IgPSAoX2EgPSBtYXBWYWx1ZS5maWVsZHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtWRUNUT1JfTUFQX1ZFQ1RPUlNfS0VZXS5hcnJheVZhbHVlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudmFsdWVzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubWFwKHZhbHVlID0+IHtcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVOdW1iZXIodmFsdWUuZG91YmxlVmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3JWYWx1ZSh2YWx1ZXMpO1xuICAgIH1cbiAgICBjb252ZXJ0R2VvUG9pbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW9Qb2ludChub3JtYWxpemVOdW1iZXIodmFsdWUubGF0aXR1ZGUpLCBub3JtYWxpemVOdW1iZXIodmFsdWUubG9uZ2l0dWRlKSk7XG4gICAgfVxuICAgIGNvbnZlcnRBcnJheShhcnJheVZhbHVlLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvcikge1xuICAgICAgICByZXR1cm4gKGFycmF5VmFsdWUudmFsdWVzIHx8IFtdKS5tYXAodmFsdWUgPT4gdGhpcy5jb252ZXJ0VmFsdWUodmFsdWUsIHNlcnZlclRpbWVzdGFtcEJlaGF2aW9yKSk7XG4gICAgfVxuICAgIGNvbnZlcnRTZXJ2ZXJUaW1lc3RhbXAodmFsdWUsIHNlcnZlclRpbWVzdGFtcEJlaGF2aW9yKSB7XG4gICAgICAgIHN3aXRjaCAoc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpIHtcbiAgICAgICAgICAgIGNhc2UgJ3ByZXZpb3VzJzpcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gZ2V0UHJldmlvdXNWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFZhbHVlKHByZXZpb3VzVmFsdWUsIHNlcnZlclRpbWVzdGFtcEJlaGF2aW9yKTtcbiAgICAgICAgICAgIGNhc2UgJ2VzdGltYXRlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0VGltZXN0YW1wKGdldExvY2FsV3JpdGVUaW1lKHZhbHVlKSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnZlcnRUaW1lc3RhbXAodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFZhbHVlID0gbm9ybWFsaXplVGltZXN0YW1wKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAobm9ybWFsaXplZFZhbHVlLnNlY29uZHMsIG5vcm1hbGl6ZWRWYWx1ZS5uYW5vcyk7XG4gICAgfVxuICAgIGNvbnZlcnREb2N1bWVudEtleShuYW1lLCBleHBlY3RlZERhdGFiYXNlSWQpIHtcbiAgICAgICAgY29uc3QgcmVzb3VyY2VQYXRoID0gUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcobmFtZSk7XG4gICAgICAgIGhhcmRBc3NlcnQoaXNWYWxpZFJlc291cmNlTmFtZShyZXNvdXJjZVBhdGgpKTtcbiAgICAgICAgY29uc3QgZGF0YWJhc2VJZCA9IG5ldyBEYXRhYmFzZUlkKHJlc291cmNlUGF0aC5nZXQoMSksIHJlc291cmNlUGF0aC5nZXQoMykpO1xuICAgICAgICBjb25zdCBrZXkgPSBuZXcgRG9jdW1lbnRLZXkocmVzb3VyY2VQYXRoLnBvcEZpcnN0KDUpKTtcbiAgICAgICAgaWYgKCFkYXRhYmFzZUlkLmlzRXF1YWwoZXhwZWN0ZWREYXRhYmFzZUlkKSkge1xuICAgICAgICAgICAgLy8gVE9ETyhiLzY0MTMwMjAyKTogU29tZWhvdyBzdXBwb3J0IGZvcmVpZ24gcmVmZXJlbmNlcy5cbiAgICAgICAgICAgIGxvZ0Vycm9yKGBEb2N1bWVudCAke2tleX0gY29udGFpbnMgYSBkb2N1bWVudCBgICtcbiAgICAgICAgICAgICAgICBgcmVmZXJlbmNlIHdpdGhpbiBhIGRpZmZlcmVudCBkYXRhYmFzZSAoYCArXG4gICAgICAgICAgICAgICAgYCR7ZGF0YWJhc2VJZC5wcm9qZWN0SWR9LyR7ZGF0YWJhc2VJZC5kYXRhYmFzZX0pIHdoaWNoIGlzIG5vdCBgICtcbiAgICAgICAgICAgICAgICBgc3VwcG9ydGVkLiBJdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSByZWZlcmVuY2UgaW4gdGhlIGN1cnJlbnQgYCArXG4gICAgICAgICAgICAgICAgYGRhdGFiYXNlICgke2V4cGVjdGVkRGF0YWJhc2VJZC5wcm9qZWN0SWR9LyR7ZXhwZWN0ZWREYXRhYmFzZUlkLmRhdGFiYXNlfSkgYCArXG4gICAgICAgICAgICAgICAgYGluc3RlYWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIENvbnZlcnRzIGN1c3RvbSBtb2RlbCBvYmplY3Qgb2YgdHlwZSBUIGludG8gYERvY3VtZW50RGF0YWAgYnkgYXBwbHlpbmcgdGhlXG4gKiBjb252ZXJ0ZXIgaWYgaXQgZXhpc3RzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB3aGVuIGNvbnZlcnRpbmcgdXNlciBvYmplY3RzIHRvIGBEb2N1bWVudERhdGFgXG4gKiBiZWNhdXNlIHdlIHdhbnQgdG8gcHJvdmlkZSB0aGUgdXNlciB3aXRoIGEgbW9yZSBzcGVjaWZpYyBlcnJvciBtZXNzYWdlIGlmXG4gKiB0aGVpciBgc2V0KClgIG9yIGZhaWxzIGR1ZSB0byBpbnZhbGlkIGRhdGEgb3JpZ2luYXRpbmcgZnJvbSBhIGB0b0ZpcmVzdG9yZSgpYFxuICogY2FsbC5cbiAqL1xuZnVuY3Rpb24gYXBwbHlGaXJlc3RvcmVEYXRhQ29udmVydGVyKGNvbnZlcnRlciwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICBsZXQgY29udmVydGVkVmFsdWU7XG4gICAgaWYgKGNvbnZlcnRlcikge1xuICAgICAgICBpZiAob3B0aW9ucyAmJiAob3B0aW9ucy5tZXJnZSB8fCBvcHRpb25zLm1lcmdlRmllbGRzKSkge1xuICAgICAgICAgICAgLy8gQ2FzdCB0byBgYW55YCBpbiBvcmRlciB0byBzYXRpc2Z5IHRoZSB1bmlvbiB0eXBlIGNvbnN0cmFpbnQgb25cbiAgICAgICAgICAgIC8vIHRvRmlyZXN0b3JlKCkuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgY29udmVydGVkVmFsdWUgPSBjb252ZXJ0ZXIudG9GaXJlc3RvcmUodmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udmVydGVkVmFsdWUgPSBjb252ZXJ0ZXIudG9GaXJlc3RvcmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb252ZXJ0ZWRWYWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydGVkVmFsdWU7XG59XG5jbGFzcyBMaXRlVXNlckRhdGFXcml0ZXIgZXh0ZW5kcyBBYnN0cmFjdFVzZXJEYXRhV3JpdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihmaXJlc3RvcmUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maXJlc3RvcmUgPSBmaXJlc3RvcmU7XG4gICAgfVxuICAgIGNvbnZlcnRCeXRlcyhieXRlcykge1xuICAgICAgICByZXR1cm4gbmV3IEJ5dGVzKGJ5dGVzKTtcbiAgICB9XG4gICAgY29udmVydFJlZmVyZW5jZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuY29udmVydERvY3VtZW50S2V5KG5hbWUsIHRoaXMuZmlyZXN0b3JlLl9kYXRhYmFzZUlkKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFJlZmVyZW5jZSh0aGlzLmZpcmVzdG9yZSwgLyogY29udmVydGVyPSAqLyBudWxsLCBrZXkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQ3JlYXRlIGFuIEFnZ3JlZ2F0ZUZpZWxkIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbXB1dGUgdGhlIHN1bSBvZlxuICogYSBzcGVjaWZpZWQgZmllbGQgb3ZlciBhIHJhbmdlIG9mIGRvY3VtZW50cyBpbiB0aGUgcmVzdWx0IHNldCBvZiBhIHF1ZXJ5LlxuICogQHBhcmFtIGZpZWxkIFNwZWNpZmllcyB0aGUgZmllbGQgdG8gc3VtIGFjcm9zcyB0aGUgcmVzdWx0IHNldC5cbiAqL1xuZnVuY3Rpb24gc3VtKGZpZWxkKSB7XG4gICAgcmV0dXJuIG5ldyBBZ2dyZWdhdGVGaWVsZCgnc3VtJywgZmllbGRQYXRoRnJvbUFyZ3VtZW50JDEoJ3N1bScsIGZpZWxkKSk7XG59XG4vKipcbiAqIENyZWF0ZSBhbiBBZ2dyZWdhdGVGaWVsZCBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBjb21wdXRlIHRoZSBhdmVyYWdlIG9mXG4gKiBhIHNwZWNpZmllZCBmaWVsZCBvdmVyIGEgcmFuZ2Ugb2YgZG9jdW1lbnRzIGluIHRoZSByZXN1bHQgc2V0IG9mIGEgcXVlcnkuXG4gKiBAcGFyYW0gZmllbGQgU3BlY2lmaWVzIHRoZSBmaWVsZCB0byBhdmVyYWdlIGFjcm9zcyB0aGUgcmVzdWx0IHNldC5cbiAqL1xuZnVuY3Rpb24gYXZlcmFnZShmaWVsZCkge1xuICAgIHJldHVybiBuZXcgQWdncmVnYXRlRmllbGQoJ2F2ZycsIGZpZWxkUGF0aEZyb21Bcmd1bWVudCQxKCdhdmVyYWdlJywgZmllbGQpKTtcbn1cbi8qKlxuICogQ3JlYXRlIGFuIEFnZ3JlZ2F0ZUZpZWxkIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbXB1dGUgdGhlIGNvdW50IG9mXG4gKiBkb2N1bWVudHMgaW4gdGhlIHJlc3VsdCBzZXQgb2YgYSBxdWVyeS5cbiAqL1xuZnVuY3Rpb24gY291bnQoKSB7XG4gICAgcmV0dXJuIG5ldyBBZ2dyZWdhdGVGaWVsZCgnY291bnQnKTtcbn1cbi8qKlxuICogQ29tcGFyZXMgdHdvICdBZ2dyZWdhdGVGaWVsZGAgaW5zdGFuY2VzIGZvciBlcXVhbGl0eS5cbiAqXG4gKiBAcGFyYW0gbGVmdCBDb21wYXJlIHRoaXMgQWdncmVnYXRlRmllbGQgdG8gdGhlIGByaWdodGAuXG4gKiBAcGFyYW0gcmlnaHQgQ29tcGFyZSB0aGlzIEFnZ3JlZ2F0ZUZpZWxkIHRvIHRoZSBgbGVmdGAuXG4gKi9cbmZ1bmN0aW9uIGFnZ3JlZ2F0ZUZpZWxkRXF1YWwobGVmdCwgcmlnaHQpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAobGVmdCBpbnN0YW5jZW9mIEFnZ3JlZ2F0ZUZpZWxkICYmXG4gICAgICAgIHJpZ2h0IGluc3RhbmNlb2YgQWdncmVnYXRlRmllbGQgJiZcbiAgICAgICAgbGVmdC5hZ2dyZWdhdGVUeXBlID09PSByaWdodC5hZ2dyZWdhdGVUeXBlICYmXG4gICAgICAgICgoX2EgPSBsZWZ0Ll9pbnRlcm5hbEZpZWxkUGF0aCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbm9uaWNhbFN0cmluZygpKSA9PT1cbiAgICAgICAgICAgICgoX2IgPSByaWdodC5faW50ZXJuYWxGaWVsZFBhdGgpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYW5vbmljYWxTdHJpbmcoKSkpO1xufVxuLyoqXG4gKiBDb21wYXJlcyB0d28gYEFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3RgIGluc3RhbmNlcyBmb3IgZXF1YWxpdHkuXG4gKlxuICogVHdvIGBBZ2dyZWdhdGVRdWVyeVNuYXBzaG90YCBpbnN0YW5jZXMgYXJlIGNvbnNpZGVyZWQgXCJlcXVhbFwiIGlmIHRoZXkgaGF2ZVxuICogdW5kZXJseWluZyBxdWVyaWVzIHRoYXQgY29tcGFyZSBlcXVhbCwgYW5kIHRoZSBzYW1lIGRhdGEuXG4gKlxuICogQHBhcmFtIGxlZnQgLSBUaGUgZmlyc3QgYEFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3RgIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0gcmlnaHQgLSBUaGUgc2Vjb25kIGBBZ2dyZWdhdGVRdWVyeVNuYXBzaG90YCB0byBjb21wYXJlLlxuICpcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgXCJlcXVhbFwiLCBhcyBkZWZpbmVkIGFib3ZlLCBvciBgZmFsc2VgXG4gKiBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3RFcXVhbChsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiAocXVlcnlFcXVhbChsZWZ0LnF1ZXJ5LCByaWdodC5xdWVyeSkgJiYgZGVlcEVxdWFsKGxlZnQuZGF0YSgpLCByaWdodC5kYXRhKCkpKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGlzUGFydGlhbE9ic2VydmVyKG9iaikge1xuICAgIHJldHVybiBpbXBsZW1lbnRzQW55TWV0aG9kcyhvYmosIFsnbmV4dCcsICdlcnJvcicsICdjb21wbGV0ZSddKTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iaiBpcyBhbiBvYmplY3QgYW5kIGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBvZiB0aGUgc3BlY2lmaWVkXG4gKiBtZXRob2RzLlxuICovXG5mdW5jdGlvbiBpbXBsZW1lbnRzQW55TWV0aG9kcyhvYmosIG1ldGhvZHMpIHtcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgb2JqZWN0ID0gb2JqO1xuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIG1ldGhvZHMpIHtcbiAgICAgICAgaWYgKG1ldGhvZCBpbiBvYmplY3QgJiYgdHlwZW9mIG9iamVjdFttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIE1ldGFkYXRhIGFib3V0IGEgc25hcHNob3QsIGRlc2NyaWJpbmcgdGhlIHN0YXRlIG9mIHRoZSBzbmFwc2hvdC5cbiAqL1xuY2xhc3MgU25hcHNob3RNZXRhZGF0YSB7XG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cbiAgICBjb25zdHJ1Y3RvcihoYXNQZW5kaW5nV3JpdGVzLCBmcm9tQ2FjaGUpIHtcbiAgICAgICAgdGhpcy5oYXNQZW5kaW5nV3JpdGVzID0gaGFzUGVuZGluZ1dyaXRlcztcbiAgICAgICAgdGhpcy5mcm9tQ2FjaGUgPSBmcm9tQ2FjaGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGBTbmFwc2hvdE1ldGFkYXRhYCBpcyBlcXVhbCB0byB0aGUgcHJvdmlkZWQgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIG90aGVyIC0gVGhlIGBTbmFwc2hvdE1ldGFkYXRhYCB0byBjb21wYXJlIGFnYWluc3QuXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGlzIGBTbmFwc2hvdE1ldGFkYXRhYCBpcyBlcXVhbCB0byB0aGUgcHJvdmlkZWQgb25lLlxuICAgICAqL1xuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmhhc1BlbmRpbmdXcml0ZXMgPT09IG90aGVyLmhhc1BlbmRpbmdXcml0ZXMgJiZcbiAgICAgICAgICAgIHRoaXMuZnJvbUNhY2hlID09PSBvdGhlci5mcm9tQ2FjaGUpO1xuICAgIH1cbn1cbi8qKlxuICogQSBgRG9jdW1lbnRTbmFwc2hvdGAgY29udGFpbnMgZGF0YSByZWFkIGZyb20gYSBkb2N1bWVudCBpbiB5b3VyIEZpcmVzdG9yZVxuICogZGF0YWJhc2UuIFRoZSBkYXRhIGNhbiBiZSBleHRyYWN0ZWQgd2l0aCBgLmRhdGEoKWAgb3IgYC5nZXQoPGZpZWxkPilgIHRvXG4gKiBnZXQgYSBzcGVjaWZpYyBmaWVsZC5cbiAqXG4gKiBGb3IgYSBgRG9jdW1lbnRTbmFwc2hvdGAgdGhhdCBwb2ludHMgdG8gYSBub24tZXhpc3RpbmcgZG9jdW1lbnQsIGFueSBkYXRhXG4gKiBhY2Nlc3Mgd2lsbCByZXR1cm4gJ3VuZGVmaW5lZCcuIFlvdSBjYW4gdXNlIHRoZSBgZXhpc3RzKClgIG1ldGhvZCB0b1xuICogZXhwbGljaXRseSB2ZXJpZnkgYSBkb2N1bWVudCdzIGV4aXN0ZW5jZS5cbiAqL1xuY2xhc3MgRG9jdW1lbnRTbmFwc2hvdCBleHRlbmRzIERvY3VtZW50U25hcHNob3QkMSB7XG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgcHJvdGVjdGVkICovXG4gICAgY29uc3RydWN0b3IoX2ZpcmVzdG9yZSwgdXNlckRhdGFXcml0ZXIsIGtleSwgZG9jdW1lbnQsIG1ldGFkYXRhLCBjb252ZXJ0ZXIpIHtcbiAgICAgICAgc3VwZXIoX2ZpcmVzdG9yZSwgdXNlckRhdGFXcml0ZXIsIGtleSwgZG9jdW1lbnQsIGNvbnZlcnRlcik7XG4gICAgICAgIHRoaXMuX2ZpcmVzdG9yZSA9IF9maXJlc3RvcmU7XG4gICAgICAgIHRoaXMuX2ZpcmVzdG9yZUltcGwgPSBfZmlyZXN0b3JlO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGRhdGEgZXhpc3RzLiBUcnVlIGlmIHRoZSBkb2N1bWVudCBleGlzdHMuXG4gICAgICovXG4gICAgZXhpc3RzKCkge1xuICAgICAgICByZXR1cm4gc3VwZXIuZXhpc3RzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbGwgZmllbGRzIGluIHRoZSBkb2N1bWVudCBhcyBhbiBgT2JqZWN0YC4gUmV0dXJucyBgdW5kZWZpbmVkYCBpZlxuICAgICAqIHRoZSBkb2N1bWVudCBkb2Vzbid0IGV4aXN0LlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCwgYHNlcnZlclRpbWVzdGFtcCgpYCB2YWx1ZXMgdGhhdCBoYXZlIG5vdCB5ZXQgYmVlblxuICAgICAqIHNldCB0byB0aGVpciBmaW5hbCB2YWx1ZSB3aWxsIGJlIHJldHVybmVkIGFzIGBudWxsYC4gWW91IGNhbiBvdmVycmlkZVxuICAgICAqIHRoaXMgYnkgcGFzc2luZyBhbiBvcHRpb25zIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9ucyBvYmplY3QgdG8gY29uZmlndXJlIGhvdyBkYXRhIGlzIHJldHJpZXZlZCBmcm9tXG4gICAgICogdGhlIHNuYXBzaG90IChmb3IgZXhhbXBsZSB0aGUgZGVzaXJlZCBiZWhhdmlvciBmb3Igc2VydmVyIHRpbWVzdGFtcHMgdGhhdFxuICAgICAqIGhhdmUgbm90IHlldCBiZWVuIHNldCB0byB0aGVpciBmaW5hbCB2YWx1ZSkuXG4gICAgICogQHJldHVybnMgQW4gYE9iamVjdGAgY29udGFpbmluZyBhbGwgZmllbGRzIGluIHRoZSBkb2N1bWVudCBvciBgdW5kZWZpbmVkYCBpZlxuICAgICAqIHRoZSBkb2N1bWVudCBkb2Vzbid0IGV4aXN0LlxuICAgICAqL1xuICAgIGRhdGEob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICghdGhpcy5fZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fY29udmVydGVyKSB7XG4gICAgICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gdXNlIHRoZSBjb252ZXJ0ZXIgYW5kIGNyZWF0ZSBhIG5ldyBEb2N1bWVudFNuYXBzaG90XG4gICAgICAgICAgICAvLyBpZiBhIGNvbnZlcnRlciBoYXMgYmVlbiBwcm92aWRlZC5cbiAgICAgICAgICAgIGNvbnN0IHNuYXBzaG90ID0gbmV3IFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdCh0aGlzLl9maXJlc3RvcmUsIHRoaXMuX3VzZXJEYXRhV3JpdGVyLCB0aGlzLl9rZXksIHRoaXMuX2RvY3VtZW50LCB0aGlzLm1ldGFkYXRhLCBcbiAgICAgICAgICAgIC8qIGNvbnZlcnRlcj0gKi8gbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydGVyLmZyb21GaXJlc3RvcmUoc25hcHNob3QsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VzZXJEYXRhV3JpdGVyLmNvbnZlcnRWYWx1ZSh0aGlzLl9kb2N1bWVudC5kYXRhLnZhbHVlLCBvcHRpb25zLnNlcnZlclRpbWVzdGFtcHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZmllbGQgc3BlY2lmaWVkIGJ5IGBmaWVsZFBhdGhgLiBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIHRoZVxuICAgICAqIGRvY3VtZW50IG9yIGZpZWxkIGRvZXNuJ3QgZXhpc3QuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCBhIGBzZXJ2ZXJUaW1lc3RhbXAoKWAgdGhhdCBoYXMgbm90IHlldCBiZWVuIHNldCB0b1xuICAgICAqIGl0cyBmaW5hbCB2YWx1ZSB3aWxsIGJlIHJldHVybmVkIGFzIGBudWxsYC4gWW91IGNhbiBvdmVycmlkZSB0aGlzIGJ5XG4gICAgICogcGFzc2luZyBhbiBvcHRpb25zIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWVsZFBhdGggLSBUaGUgcGF0aCAoZm9yIGV4YW1wbGUgJ2Zvbycgb3IgJ2Zvby5iYXInKSB0byBhIHNwZWNpZmljXG4gICAgICogZmllbGQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25zIG9iamVjdCB0byBjb25maWd1cmUgaG93IHRoZSBmaWVsZCBpcyByZXRyaWV2ZWRcbiAgICAgKiBmcm9tIHRoZSBzbmFwc2hvdCAoZm9yIGV4YW1wbGUgdGhlIGRlc2lyZWQgYmVoYXZpb3IgZm9yIHNlcnZlciB0aW1lc3RhbXBzXG4gICAgICogdGhhdCBoYXZlIG5vdCB5ZXQgYmVlbiBzZXQgdG8gdGhlaXIgZmluYWwgdmFsdWUpLlxuICAgICAqIEByZXR1cm5zIFRoZSBkYXRhIGF0IHRoZSBzcGVjaWZpZWQgZmllbGQgbG9jYXRpb24gb3IgdW5kZWZpbmVkIGlmIG5vIHN1Y2hcbiAgICAgKiBmaWVsZCBleGlzdHMgaW4gdGhlIGRvY3VtZW50LlxuICAgICAqL1xuICAgIC8vIFdlIGFyZSB1c2luZyBgYW55YCBoZXJlIHRvIGF2b2lkIGFuIGV4cGxpY2l0IGNhc3QgYnkgb3VyIHVzZXJzLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZ2V0KGZpZWxkUGF0aCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLl9kb2N1bWVudCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl9kb2N1bWVudC5kYXRhLmZpZWxkKGZpZWxkUGF0aEZyb21Bcmd1bWVudCgnRG9jdW1lbnRTbmFwc2hvdC5nZXQnLCBmaWVsZFBhdGgpKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl91c2VyRGF0YVdyaXRlci5jb252ZXJ0VmFsdWUodmFsdWUsIG9wdGlvbnMuc2VydmVyVGltZXN0YW1wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG4vKipcbiAqIEEgYFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdGAgY29udGFpbnMgZGF0YSByZWFkIGZyb20gYSBkb2N1bWVudCBpbiB5b3VyXG4gKiBGaXJlc3RvcmUgZGF0YWJhc2UgYXMgcGFydCBvZiBhIHF1ZXJ5LiBUaGUgZG9jdW1lbnQgaXMgZ3VhcmFudGVlZCB0byBleGlzdFxuICogYW5kIGl0cyBkYXRhIGNhbiBiZSBleHRyYWN0ZWQgd2l0aCBgLmRhdGEoKWAgb3IgYC5nZXQoPGZpZWxkPilgIHRvIGdldCBhXG4gKiBzcGVjaWZpYyBmaWVsZC5cbiAqXG4gKiBBIGBRdWVyeURvY3VtZW50U25hcHNob3RgIG9mZmVycyB0aGUgc2FtZSBBUEkgc3VyZmFjZSBhcyBhXG4gKiBgRG9jdW1lbnRTbmFwc2hvdGAuIFNpbmNlIHF1ZXJ5IHJlc3VsdHMgY29udGFpbiBvbmx5IGV4aXN0aW5nIGRvY3VtZW50cywgdGhlXG4gKiBgZXhpc3RzYCBwcm9wZXJ0eSB3aWxsIGFsd2F5cyBiZSB0cnVlIGFuZCBgZGF0YSgpYCB3aWxsIG5ldmVyIHJldHVyblxuICogJ3VuZGVmaW5lZCcuXG4gKi9cbmNsYXNzIFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdCBleHRlbmRzIERvY3VtZW50U25hcHNob3Qge1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbGwgZmllbGRzIGluIHRoZSBkb2N1bWVudCBhcyBhbiBgT2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIGBzZXJ2ZXJUaW1lc3RhbXAoKWAgdmFsdWVzIHRoYXQgaGF2ZSBub3QgeWV0IGJlZW5cbiAgICAgKiBzZXQgdG8gdGhlaXIgZmluYWwgdmFsdWUgd2lsbCBiZSByZXR1cm5lZCBhcyBgbnVsbGAuIFlvdSBjYW4gb3ZlcnJpZGVcbiAgICAgKiB0aGlzIGJ5IHBhc3NpbmcgYW4gb3B0aW9ucyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgb2JqZWN0IHRvIGNvbmZpZ3VyZSBob3cgZGF0YSBpcyByZXRyaWV2ZWQgZnJvbVxuICAgICAqIHRoZSBzbmFwc2hvdCAoZm9yIGV4YW1wbGUgdGhlIGRlc2lyZWQgYmVoYXZpb3IgZm9yIHNlcnZlciB0aW1lc3RhbXBzIHRoYXRcbiAgICAgKiBoYXZlIG5vdCB5ZXQgYmVlbiBzZXQgdG8gdGhlaXIgZmluYWwgdmFsdWUpLlxuICAgICAqIEByZXR1cm5zIEFuIGBPYmplY3RgIGNvbnRhaW5pbmcgYWxsIGZpZWxkcyBpbiB0aGUgZG9jdW1lbnQuXG4gICAgICovXG4gICAgZGF0YShvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmRhdGEob3B0aW9ucyk7XG4gICAgfVxufVxuLyoqXG4gKiBBIGBRdWVyeVNuYXBzaG90YCBjb250YWlucyB6ZXJvIG9yIG1vcmUgYERvY3VtZW50U25hcHNob3RgIG9iamVjdHNcbiAqIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0cyBvZiBhIHF1ZXJ5LiBUaGUgZG9jdW1lbnRzIGNhbiBiZSBhY2Nlc3NlZCBhcyBhblxuICogYXJyYXkgdmlhIHRoZSBgZG9jc2AgcHJvcGVydHkgb3IgZW51bWVyYXRlZCB1c2luZyB0aGUgYGZvckVhY2hgIG1ldGhvZC4gVGhlXG4gKiBudW1iZXIgb2YgZG9jdW1lbnRzIGNhbiBiZSBkZXRlcm1pbmVkIHZpYSB0aGUgYGVtcHR5YCBhbmQgYHNpemVgXG4gKiBwcm9wZXJ0aWVzLlxuICovXG5jbGFzcyBRdWVyeVNuYXBzaG90IHtcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xuICAgIGNvbnN0cnVjdG9yKF9maXJlc3RvcmUsIF91c2VyRGF0YVdyaXRlciwgcXVlcnksIF9zbmFwc2hvdCkge1xuICAgICAgICB0aGlzLl9maXJlc3RvcmUgPSBfZmlyZXN0b3JlO1xuICAgICAgICB0aGlzLl91c2VyRGF0YVdyaXRlciA9IF91c2VyRGF0YVdyaXRlcjtcbiAgICAgICAgdGhpcy5fc25hcHNob3QgPSBfc25hcHNob3Q7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBuZXcgU25hcHNob3RNZXRhZGF0YShfc25hcHNob3QuaGFzUGVuZGluZ1dyaXRlcywgX3NuYXBzaG90LmZyb21DYWNoZSk7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICB9XG4gICAgLyoqIEFuIGFycmF5IG9mIGFsbCB0aGUgZG9jdW1lbnRzIGluIHRoZSBgUXVlcnlTbmFwc2hvdGAuICovXG4gICAgZ2V0IGRvY3MoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLmZvckVhY2goZG9jID0+IHJlc3VsdC5wdXNoKGRvYykpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKiogVGhlIG51bWJlciBvZiBkb2N1bWVudHMgaW4gdGhlIGBRdWVyeVNuYXBzaG90YC4gKi9cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NuYXBzaG90LmRvY3Muc2l6ZTtcbiAgICB9XG4gICAgLyoqIFRydWUgaWYgdGhlcmUgYXJlIG5vIGRvY3VtZW50cyBpbiB0aGUgYFF1ZXJ5U25hcHNob3RgLiAqL1xuICAgIGdldCBlbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW51bWVyYXRlcyBhbGwgb2YgdGhlIGRvY3VtZW50cyBpbiB0aGUgYFF1ZXJ5U25hcHNob3RgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gQSBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2l0aCBhIGBRdWVyeURvY3VtZW50U25hcHNob3RgIGZvclxuICAgICAqIGVhY2ggZG9jdW1lbnQgaW4gdGhlIHNuYXBzaG90LlxuICAgICAqIEBwYXJhbSB0aGlzQXJnIC0gVGhlIGB0aGlzYCBiaW5kaW5nIGZvciB0aGUgY2FsbGJhY2suXG4gICAgICovXG4gICAgZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICB0aGlzLl9zbmFwc2hvdC5kb2NzLmZvckVhY2goZG9jID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgbmV3IFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdCh0aGlzLl9maXJlc3RvcmUsIHRoaXMuX3VzZXJEYXRhV3JpdGVyLCBkb2Mua2V5LCBkb2MsIG5ldyBTbmFwc2hvdE1ldGFkYXRhKHRoaXMuX3NuYXBzaG90Lm11dGF0ZWRLZXlzLmhhcyhkb2Mua2V5KSwgdGhpcy5fc25hcHNob3QuZnJvbUNhY2hlKSwgdGhpcy5xdWVyeS5jb252ZXJ0ZXIpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGRvY3VtZW50cyBjaGFuZ2VzIHNpbmNlIHRoZSBsYXN0IHNuYXBzaG90LiBJZiB0aGlzXG4gICAgICogaXMgdGhlIGZpcnN0IHNuYXBzaG90LCBhbGwgZG9jdW1lbnRzIHdpbGwgYmUgaW4gdGhlIGxpc3QgYXMgJ2FkZGVkJ1xuICAgICAqIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIGBTbmFwc2hvdExpc3Rlbk9wdGlvbnNgIHRoYXQgY29udHJvbCB3aGV0aGVyIG1ldGFkYXRhLW9ubHlcbiAgICAgKiBjaGFuZ2VzIChpLmUuIG9ubHkgYERvY3VtZW50U25hcHNob3QubWV0YWRhdGFgIGNoYW5nZWQpIHNob3VsZCB0cmlnZ2VyXG4gICAgICogc25hcHNob3QgZXZlbnRzLlxuICAgICAqL1xuICAgIGRvY0NoYW5nZXMob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGluY2x1ZGVNZXRhZGF0YUNoYW5nZXMgPSAhIW9wdGlvbnMuaW5jbHVkZU1ldGFkYXRhQ2hhbmdlcztcbiAgICAgICAgaWYgKGluY2x1ZGVNZXRhZGF0YUNoYW5nZXMgJiYgdGhpcy5fc25hcHNob3QuZXhjbHVkZXNNZXRhZGF0YUNoYW5nZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdUbyBpbmNsdWRlIG1ldGFkYXRhIGNoYW5nZXMgd2l0aCB5b3VyIGRvY3VtZW50IGNoYW5nZXMsIHlvdSBtdXN0ICcgK1xuICAgICAgICAgICAgICAgICdhbHNvIHBhc3MgeyBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzOnRydWUgfSB0byBvblNuYXBzaG90KCkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZWRDaGFuZ2VzIHx8XG4gICAgICAgICAgICB0aGlzLl9jYWNoZWRDaGFuZ2VzSW5jbHVkZU1ldGFkYXRhQ2hhbmdlcyAhPT0gaW5jbHVkZU1ldGFkYXRhQ2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVkQ2hhbmdlcyA9IGNoYW5nZXNGcm9tU25hcHNob3QodGhpcywgaW5jbHVkZU1ldGFkYXRhQ2hhbmdlcyk7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZWRDaGFuZ2VzSW5jbHVkZU1ldGFkYXRhQ2hhbmdlcyA9IGluY2x1ZGVNZXRhZGF0YUNoYW5nZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZENoYW5nZXM7XG4gICAgfVxufVxuLyoqIENhbGN1bGF0ZXMgdGhlIGFycmF5IG9mIGBEb2N1bWVudENoYW5nZWBzIGZvciBhIGdpdmVuIGBWaWV3U25hcHNob3RgLiAqL1xuZnVuY3Rpb24gY2hhbmdlc0Zyb21TbmFwc2hvdChxdWVyeVNuYXBzaG90LCBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzKSB7XG4gICAgaWYgKHF1ZXJ5U25hcHNob3QuX3NuYXBzaG90Lm9sZERvY3MuaXNFbXB0eSgpKSB7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIHJldHVybiBxdWVyeVNuYXBzaG90Ll9zbmFwc2hvdC5kb2NDaGFuZ2VzLm1hcChjaGFuZ2UgPT4ge1xuICAgICAgICAgICAgY29uc3QgZG9jID0gbmV3IFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdChxdWVyeVNuYXBzaG90Ll9maXJlc3RvcmUsIHF1ZXJ5U25hcHNob3QuX3VzZXJEYXRhV3JpdGVyLCBjaGFuZ2UuZG9jLmtleSwgY2hhbmdlLmRvYywgbmV3IFNuYXBzaG90TWV0YWRhdGEocXVlcnlTbmFwc2hvdC5fc25hcHNob3QubXV0YXRlZEtleXMuaGFzKGNoYW5nZS5kb2Mua2V5KSwgcXVlcnlTbmFwc2hvdC5fc25hcHNob3QuZnJvbUNhY2hlKSwgcXVlcnlTbmFwc2hvdC5xdWVyeS5jb252ZXJ0ZXIpO1xuICAgICAgICAgICAgY2hhbmdlLmRvYztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZGVkJyxcbiAgICAgICAgICAgICAgICBkb2MsXG4gICAgICAgICAgICAgICAgb2xkSW5kZXg6IC0xLFxuICAgICAgICAgICAgICAgIG5ld0luZGV4OiBpbmRleCsrXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEEgYERvY3VtZW50U2V0YCB0aGF0IGlzIHVwZGF0ZWQgaW5jcmVtZW50YWxseSBhcyBjaGFuZ2VzIGFyZSBhcHBsaWVkIHRvIHVzZVxuICAgICAgICAvLyB0byBsb29rdXAgdGhlIGluZGV4IG9mIGEgZG9jdW1lbnQuXG4gICAgICAgIGxldCBpbmRleFRyYWNrZXIgPSBxdWVyeVNuYXBzaG90Ll9zbmFwc2hvdC5vbGREb2NzO1xuICAgICAgICByZXR1cm4gcXVlcnlTbmFwc2hvdC5fc25hcHNob3QuZG9jQ2hhbmdlc1xuICAgICAgICAgICAgLmZpbHRlcihjaGFuZ2UgPT4gaW5jbHVkZU1ldGFkYXRhQ2hhbmdlcyB8fCBjaGFuZ2UudHlwZSAhPT0gMyAvKiBDaGFuZ2VUeXBlLk1ldGFkYXRhICovKVxuICAgICAgICAgICAgLm1hcChjaGFuZ2UgPT4ge1xuICAgICAgICAgICAgY29uc3QgZG9jID0gbmV3IFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdChxdWVyeVNuYXBzaG90Ll9maXJlc3RvcmUsIHF1ZXJ5U25hcHNob3QuX3VzZXJEYXRhV3JpdGVyLCBjaGFuZ2UuZG9jLmtleSwgY2hhbmdlLmRvYywgbmV3IFNuYXBzaG90TWV0YWRhdGEocXVlcnlTbmFwc2hvdC5fc25hcHNob3QubXV0YXRlZEtleXMuaGFzKGNoYW5nZS5kb2Mua2V5KSwgcXVlcnlTbmFwc2hvdC5fc25hcHNob3QuZnJvbUNhY2hlKSwgcXVlcnlTbmFwc2hvdC5xdWVyeS5jb252ZXJ0ZXIpO1xuICAgICAgICAgICAgbGV0IG9sZEluZGV4ID0gLTE7XG4gICAgICAgICAgICBsZXQgbmV3SW5kZXggPSAtMTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2UudHlwZSAhPT0gMCAvKiBDaGFuZ2VUeXBlLkFkZGVkICovKSB7XG4gICAgICAgICAgICAgICAgb2xkSW5kZXggPSBpbmRleFRyYWNrZXIuaW5kZXhPZihjaGFuZ2UuZG9jLmtleSk7XG4gICAgICAgICAgICAgICAgaW5kZXhUcmFja2VyID0gaW5kZXhUcmFja2VyLmRlbGV0ZShjaGFuZ2UuZG9jLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhbmdlLnR5cGUgIT09IDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovKSB7XG4gICAgICAgICAgICAgICAgaW5kZXhUcmFja2VyID0gaW5kZXhUcmFja2VyLmFkZChjaGFuZ2UuZG9jKTtcbiAgICAgICAgICAgICAgICBuZXdJbmRleCA9IGluZGV4VHJhY2tlci5pbmRleE9mKGNoYW5nZS5kb2Mua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogcmVzdWx0Q2hhbmdlVHlwZShjaGFuZ2UudHlwZSksXG4gICAgICAgICAgICAgICAgZG9jLFxuICAgICAgICAgICAgICAgIG9sZEluZGV4LFxuICAgICAgICAgICAgICAgIG5ld0luZGV4XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXN1bHRDaGFuZ2VUeXBlKHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAwIC8qIENoYW5nZVR5cGUuQWRkZWQgKi86XG4gICAgICAgICAgICByZXR1cm4gJ2FkZGVkJztcbiAgICAgICAgY2FzZSAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi86XG4gICAgICAgIGNhc2UgMyAvKiBDaGFuZ2VUeXBlLk1ldGFkYXRhICovOlxuICAgICAgICAgICAgcmV0dXJuICdtb2RpZmllZCc7XG4gICAgICAgIGNhc2UgMSAvKiBDaGFuZ2VUeXBlLlJlbW92ZWQgKi86XG4gICAgICAgICAgICByZXR1cm4gJ3JlbW92ZWQnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG59XG4vLyBUT0RPKGZpcmVzdG9yZWV4cCk6IEFkZCB0ZXN0cyBmb3Igc25hcHNob3RFcXVhbCB3aXRoIGRpZmZlcmVudCBzbmFwc2hvdFxuLy8gbWV0YWRhdGFcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBzbmFwc2hvdHMgYXJlIGVxdWFsLlxuICpcbiAqIEBwYXJhbSBsZWZ0IC0gQSBzbmFwc2hvdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHJpZ2h0IC0gQSBzbmFwc2hvdCB0byBjb21wYXJlLlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc25hcHNob3RzIGFyZSBlcXVhbC5cbiAqL1xuZnVuY3Rpb24gc25hcHNob3RFcXVhbChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0IGluc3RhbmNlb2YgRG9jdW1lbnRTbmFwc2hvdCAmJiByaWdodCBpbnN0YW5jZW9mIERvY3VtZW50U25hcHNob3QpIHtcbiAgICAgICAgcmV0dXJuIChsZWZ0Ll9maXJlc3RvcmUgPT09IHJpZ2h0Ll9maXJlc3RvcmUgJiZcbiAgICAgICAgICAgIGxlZnQuX2tleS5pc0VxdWFsKHJpZ2h0Ll9rZXkpICYmXG4gICAgICAgICAgICAobGVmdC5fZG9jdW1lbnQgPT09IG51bGxcbiAgICAgICAgICAgICAgICA/IHJpZ2h0Ll9kb2N1bWVudCA9PT0gbnVsbFxuICAgICAgICAgICAgICAgIDogbGVmdC5fZG9jdW1lbnQuaXNFcXVhbChyaWdodC5fZG9jdW1lbnQpKSAmJlxuICAgICAgICAgICAgbGVmdC5fY29udmVydGVyID09PSByaWdodC5fY29udmVydGVyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobGVmdCBpbnN0YW5jZW9mIFF1ZXJ5U25hcHNob3QgJiYgcmlnaHQgaW5zdGFuY2VvZiBRdWVyeVNuYXBzaG90KSB7XG4gICAgICAgIHJldHVybiAobGVmdC5fZmlyZXN0b3JlID09PSByaWdodC5fZmlyZXN0b3JlICYmXG4gICAgICAgICAgICBxdWVyeUVxdWFsKGxlZnQucXVlcnksIHJpZ2h0LnF1ZXJ5KSAmJlxuICAgICAgICAgICAgbGVmdC5tZXRhZGF0YS5pc0VxdWFsKHJpZ2h0Lm1ldGFkYXRhKSAmJlxuICAgICAgICAgICAgbGVmdC5fc25hcHNob3QuaXNFcXVhbChyaWdodC5fc25hcHNob3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZWFkcyB0aGUgZG9jdW1lbnQgcmVmZXJyZWQgdG8gYnkgdGhpcyBgRG9jdW1lbnRSZWZlcmVuY2VgLlxuICpcbiAqIE5vdGU6IGBnZXREb2MoKWAgYXR0ZW1wdHMgdG8gcHJvdmlkZSB1cC10by1kYXRlIGRhdGEgd2hlbiBwb3NzaWJsZSBieSB3YWl0aW5nXG4gKiBmb3IgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIsIGJ1dCBpdCBtYXkgcmV0dXJuIGNhY2hlZCBkYXRhIG9yIGZhaWwgaWYgeW91IGFyZVxuICogb2ZmbGluZSBhbmQgdGhlIHNlcnZlciBjYW5ub3QgYmUgcmVhY2hlZC4gVG8gc3BlY2lmeSB0aGlzIGJlaGF2aW9yLCBpbnZva2VcbiAqIHtAbGluayBnZXREb2NGcm9tQ2FjaGV9IG9yIHtAbGluayBnZXREb2NGcm9tU2VydmVyfS5cbiAqXG4gKiBAcGFyYW0gcmVmZXJlbmNlIC0gVGhlIHJlZmVyZW5jZSBvZiB0aGUgZG9jdW1lbnQgdG8gZmV0Y2guXG4gKiBAcmV0dXJucyBBIFByb21pc2UgcmVzb2x2ZWQgd2l0aCBhIGBEb2N1bWVudFNuYXBzaG90YCBjb250YWluaW5nIHRoZVxuICogY3VycmVudCBkb2N1bWVudCBjb250ZW50cy5cbiAqL1xuZnVuY3Rpb24gZ2V0RG9jKHJlZmVyZW5jZSkge1xuICAgIHJlZmVyZW5jZSA9IGNhc3QocmVmZXJlbmNlLCBEb2N1bWVudFJlZmVyZW5jZSk7XG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChyZWZlcmVuY2UuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRWaWFTbmFwc2hvdExpc3RlbmVyKGNsaWVudCwgcmVmZXJlbmNlLl9rZXkpLnRoZW4oc25hcHNob3QgPT4gY29udmVydFRvRG9jU25hcHNob3QoZmlyZXN0b3JlLCByZWZlcmVuY2UsIHNuYXBzaG90KSk7XG59XG5jbGFzcyBFeHBVc2VyRGF0YVdyaXRlciBleHRlbmRzIEFic3RyYWN0VXNlckRhdGFXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpcmVzdG9yZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpcmVzdG9yZSA9IGZpcmVzdG9yZTtcbiAgICB9XG4gICAgY29udmVydEJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQnl0ZXMoYnl0ZXMpO1xuICAgIH1cbiAgICBjb252ZXJ0UmVmZXJlbmNlKG5hbWUpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5jb252ZXJ0RG9jdW1lbnRLZXkobmFtZSwgdGhpcy5maXJlc3RvcmUuX2RhdGFiYXNlSWQpO1xuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50UmVmZXJlbmNlKHRoaXMuZmlyZXN0b3JlLCAvKiBjb252ZXJ0ZXI9ICovIG51bGwsIGtleSk7XG4gICAgfVxufVxuLyoqXG4gKiBSZWFkcyB0aGUgZG9jdW1lbnQgcmVmZXJyZWQgdG8gYnkgdGhpcyBgRG9jdW1lbnRSZWZlcmVuY2VgIGZyb20gY2FjaGUuXG4gKiBSZXR1cm5zIGFuIGVycm9yIGlmIHRoZSBkb2N1bWVudCBpcyBub3QgY3VycmVudGx5IGNhY2hlZC5cbiAqXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCByZXNvbHZlZCB3aXRoIGEgYERvY3VtZW50U25hcHNob3RgIGNvbnRhaW5pbmcgdGhlXG4gKiBjdXJyZW50IGRvY3VtZW50IGNvbnRlbnRzLlxuICovXG5mdW5jdGlvbiBnZXREb2NGcm9tQ2FjaGUocmVmZXJlbmNlKSB7XG4gICAgcmVmZXJlbmNlID0gY2FzdChyZWZlcmVuY2UsIERvY3VtZW50UmVmZXJlbmNlKTtcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHJlZmVyZW5jZS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIGNvbnN0IHVzZXJEYXRhV3JpdGVyID0gbmV3IEV4cFVzZXJEYXRhV3JpdGVyKGZpcmVzdG9yZSk7XG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudEdldERvY3VtZW50RnJvbUxvY2FsQ2FjaGUoY2xpZW50LCByZWZlcmVuY2UuX2tleSkudGhlbihkb2MgPT4gbmV3IERvY3VtZW50U25hcHNob3QoZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwgcmVmZXJlbmNlLl9rZXksIGRvYywgbmV3IFNuYXBzaG90TWV0YWRhdGEoZG9jICE9PSBudWxsICYmIGRvYy5oYXNMb2NhbE11dGF0aW9ucywgXG4gICAgLyogZnJvbUNhY2hlPSAqLyB0cnVlKSwgcmVmZXJlbmNlLmNvbnZlcnRlcikpO1xufVxuLyoqXG4gKiBSZWFkcyB0aGUgZG9jdW1lbnQgcmVmZXJyZWQgdG8gYnkgdGhpcyBgRG9jdW1lbnRSZWZlcmVuY2VgIGZyb20gdGhlIHNlcnZlci5cbiAqIFJldHVybnMgYW4gZXJyb3IgaWYgdGhlIG5ldHdvcmsgaXMgbm90IGF2YWlsYWJsZS5cbiAqXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCByZXNvbHZlZCB3aXRoIGEgYERvY3VtZW50U25hcHNob3RgIGNvbnRhaW5pbmcgdGhlXG4gKiBjdXJyZW50IGRvY3VtZW50IGNvbnRlbnRzLlxuICovXG5mdW5jdGlvbiBnZXREb2NGcm9tU2VydmVyKHJlZmVyZW5jZSkge1xuICAgIHJlZmVyZW5jZSA9IGNhc3QocmVmZXJlbmNlLCBEb2N1bWVudFJlZmVyZW5jZSk7XG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChyZWZlcmVuY2UuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRWaWFTbmFwc2hvdExpc3RlbmVyKGNsaWVudCwgcmVmZXJlbmNlLl9rZXksIHtcbiAgICAgICAgc291cmNlOiAnc2VydmVyJ1xuICAgIH0pLnRoZW4oc25hcHNob3QgPT4gY29udmVydFRvRG9jU25hcHNob3QoZmlyZXN0b3JlLCByZWZlcmVuY2UsIHNuYXBzaG90KSk7XG59XG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBxdWVyeSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0cyBhcyBhIGBRdWVyeVNuYXBzaG90YC5cbiAqXG4gKiBOb3RlOiBgZ2V0RG9jcygpYCBhdHRlbXB0cyB0byBwcm92aWRlIHVwLXRvLWRhdGUgZGF0YSB3aGVuIHBvc3NpYmxlIGJ5XG4gKiB3YWl0aW5nIGZvciBkYXRhIGZyb20gdGhlIHNlcnZlciwgYnV0IGl0IG1heSByZXR1cm4gY2FjaGVkIGRhdGEgb3IgZmFpbCBpZlxuICogeW91IGFyZSBvZmZsaW5lIGFuZCB0aGUgc2VydmVyIGNhbm5vdCBiZSByZWFjaGVkLiBUbyBzcGVjaWZ5IHRoaXMgYmVoYXZpb3IsXG4gKiBpbnZva2Uge0BsaW5rIGdldERvY3NGcm9tQ2FjaGV9IG9yIHtAbGluayBnZXREb2NzRnJvbVNlcnZlcn0uXG4gKlxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIHJlc3VsdHMgb2YgdGhlIHF1ZXJ5LlxuICovXG5mdW5jdGlvbiBnZXREb2NzKHF1ZXJ5KSB7XG4gICAgcXVlcnkgPSBjYXN0KHF1ZXJ5LCBRdWVyeSk7XG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChxdWVyeS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIGNvbnN0IHVzZXJEYXRhV3JpdGVyID0gbmV3IEV4cFVzZXJEYXRhV3JpdGVyKGZpcmVzdG9yZSk7XG4gICAgdmFsaWRhdGVIYXNFeHBsaWNpdE9yZGVyQnlGb3JMaW1pdFRvTGFzdChxdWVyeS5fcXVlcnkpO1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudHNWaWFTbmFwc2hvdExpc3RlbmVyKGNsaWVudCwgcXVlcnkuX3F1ZXJ5KS50aGVuKHNuYXBzaG90ID0+IG5ldyBRdWVyeVNuYXBzaG90KGZpcmVzdG9yZSwgdXNlckRhdGFXcml0ZXIsIHF1ZXJ5LCBzbmFwc2hvdCkpO1xufVxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgcXVlcnkgYW5kIHJldHVybnMgdGhlIHJlc3VsdHMgYXMgYSBgUXVlcnlTbmFwc2hvdGAgZnJvbSBjYWNoZS5cbiAqIFJldHVybnMgYW4gZW1wdHkgcmVzdWx0IHNldCBpZiBubyBkb2N1bWVudHMgbWF0Y2hpbmcgdGhlIHF1ZXJ5IGFyZSBjdXJyZW50bHlcbiAqIGNhY2hlZC5cbiAqXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgcmVzdWx0cyBvZiB0aGUgcXVlcnkuXG4gKi9cbmZ1bmN0aW9uIGdldERvY3NGcm9tQ2FjaGUocXVlcnkpIHtcbiAgICBxdWVyeSA9IGNhc3QocXVlcnksIFF1ZXJ5KTtcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHF1ZXJ5LmZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XG4gICAgY29uc3QgdXNlckRhdGFXcml0ZXIgPSBuZXcgRXhwVXNlckRhdGFXcml0ZXIoZmlyZXN0b3JlKTtcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRzRnJvbUxvY2FsQ2FjaGUoY2xpZW50LCBxdWVyeS5fcXVlcnkpLnRoZW4oc25hcHNob3QgPT4gbmV3IFF1ZXJ5U25hcHNob3QoZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwgcXVlcnksIHNuYXBzaG90KSk7XG59XG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBxdWVyeSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0cyBhcyBhIGBRdWVyeVNuYXBzaG90YCBmcm9tIHRoZVxuICogc2VydmVyLiBSZXR1cm5zIGFuIGVycm9yIGlmIHRoZSBuZXR3b3JrIGlzIG5vdCBhdmFpbGFibGUuXG4gKlxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIHJlc3VsdHMgb2YgdGhlIHF1ZXJ5LlxuICovXG5mdW5jdGlvbiBnZXREb2NzRnJvbVNlcnZlcihxdWVyeSkge1xuICAgIHF1ZXJ5ID0gY2FzdChxdWVyeSwgUXVlcnkpO1xuICAgIGNvbnN0IGZpcmVzdG9yZSA9IGNhc3QocXVlcnkuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcbiAgICBjb25zdCB1c2VyRGF0YVdyaXRlciA9IG5ldyBFeHBVc2VyRGF0YVdyaXRlcihmaXJlc3RvcmUpO1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudHNWaWFTbmFwc2hvdExpc3RlbmVyKGNsaWVudCwgcXVlcnkuX3F1ZXJ5LCB7XG4gICAgICAgIHNvdXJjZTogJ3NlcnZlcidcbiAgICB9KS50aGVuKHNuYXBzaG90ID0+IG5ldyBRdWVyeVNuYXBzaG90KGZpcmVzdG9yZSwgdXNlckRhdGFXcml0ZXIsIHF1ZXJ5LCBzbmFwc2hvdCkpO1xufVxuZnVuY3Rpb24gc2V0RG9jKHJlZmVyZW5jZSwgZGF0YSwgb3B0aW9ucykge1xuICAgIHJlZmVyZW5jZSA9IGNhc3QocmVmZXJlbmNlLCBEb2N1bWVudFJlZmVyZW5jZSk7XG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChyZWZlcmVuY2UuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgIGNvbnN0IGNvbnZlcnRlZFZhbHVlID0gYXBwbHlGaXJlc3RvcmVEYXRhQ29udmVydGVyKHJlZmVyZW5jZS5jb252ZXJ0ZXIsIGRhdGEsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGRhdGFSZWFkZXIgPSBuZXdVc2VyRGF0YVJlYWRlcihmaXJlc3RvcmUpO1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlU2V0RGF0YShkYXRhUmVhZGVyLCAnc2V0RG9jJywgcmVmZXJlbmNlLl9rZXksIGNvbnZlcnRlZFZhbHVlLCByZWZlcmVuY2UuY29udmVydGVyICE9PSBudWxsLCBvcHRpb25zKTtcbiAgICBjb25zdCBtdXRhdGlvbiA9IHBhcnNlZC50b011dGF0aW9uKHJlZmVyZW5jZS5fa2V5LCBQcmVjb25kaXRpb24ubm9uZSgpKTtcbiAgICByZXR1cm4gZXhlY3V0ZVdyaXRlKGZpcmVzdG9yZSwgW211dGF0aW9uXSk7XG59XG5mdW5jdGlvbiB1cGRhdGVEb2MocmVmZXJlbmNlLCBmaWVsZE9yVXBkYXRlRGF0YSwgdmFsdWUsIC4uLm1vcmVGaWVsZHNBbmRWYWx1ZXMpIHtcbiAgICByZWZlcmVuY2UgPSBjYXN0KHJlZmVyZW5jZSwgRG9jdW1lbnRSZWZlcmVuY2UpO1xuICAgIGNvbnN0IGZpcmVzdG9yZSA9IGNhc3QocmVmZXJlbmNlLmZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcbiAgICBjb25zdCBkYXRhUmVhZGVyID0gbmV3VXNlckRhdGFSZWFkZXIoZmlyZXN0b3JlKTtcbiAgICAvLyBGb3IgQ29tcGF0IHR5cGVzLCB3ZSBoYXZlIHRvIFwiZXh0cmFjdFwiIHRoZSB1bmRlcmx5aW5nIHR5cGVzIGJlZm9yZVxuICAgIC8vIHBlcmZvcm1pbmcgdmFsaWRhdGlvbi5cbiAgICBmaWVsZE9yVXBkYXRlRGF0YSA9IGdldE1vZHVsYXJJbnN0YW5jZShmaWVsZE9yVXBkYXRlRGF0YSk7XG4gICAgbGV0IHBhcnNlZDtcbiAgICBpZiAodHlwZW9mIGZpZWxkT3JVcGRhdGVEYXRhID09PSAnc3RyaW5nJyB8fFxuICAgICAgICBmaWVsZE9yVXBkYXRlRGF0YSBpbnN0YW5jZW9mIEZpZWxkUGF0aCkge1xuICAgICAgICBwYXJzZWQgPSBwYXJzZVVwZGF0ZVZhcmFyZ3MoZGF0YVJlYWRlciwgJ3VwZGF0ZURvYycsIHJlZmVyZW5jZS5fa2V5LCBmaWVsZE9yVXBkYXRlRGF0YSwgdmFsdWUsIG1vcmVGaWVsZHNBbmRWYWx1ZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGFyc2VkID0gcGFyc2VVcGRhdGVEYXRhKGRhdGFSZWFkZXIsICd1cGRhdGVEb2MnLCByZWZlcmVuY2UuX2tleSwgZmllbGRPclVwZGF0ZURhdGEpO1xuICAgIH1cbiAgICBjb25zdCBtdXRhdGlvbiA9IHBhcnNlZC50b011dGF0aW9uKHJlZmVyZW5jZS5fa2V5LCBQcmVjb25kaXRpb24uZXhpc3RzKHRydWUpKTtcbiAgICByZXR1cm4gZXhlY3V0ZVdyaXRlKGZpcmVzdG9yZSwgW211dGF0aW9uXSk7XG59XG4vKipcbiAqIERlbGV0ZXMgdGhlIGRvY3VtZW50IHJlZmVycmVkIHRvIGJ5IHRoZSBzcGVjaWZpZWQgYERvY3VtZW50UmVmZXJlbmNlYC5cbiAqXG4gKiBAcGFyYW0gcmVmZXJlbmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIGRvY3VtZW50IHRvIGRlbGV0ZS5cbiAqIEByZXR1cm5zIEEgUHJvbWlzZSByZXNvbHZlZCBvbmNlIHRoZSBkb2N1bWVudCBoYXMgYmVlbiBzdWNjZXNzZnVsbHlcbiAqIGRlbGV0ZWQgZnJvbSB0aGUgYmFja2VuZCAobm90ZSB0aGF0IGl0IHdvbid0IHJlc29sdmUgd2hpbGUgeW91J3JlIG9mZmxpbmUpLlxuICovXG5mdW5jdGlvbiBkZWxldGVEb2MocmVmZXJlbmNlKSB7XG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChyZWZlcmVuY2UuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgIGNvbnN0IG11dGF0aW9ucyA9IFtuZXcgRGVsZXRlTXV0YXRpb24ocmVmZXJlbmNlLl9rZXksIFByZWNvbmRpdGlvbi5ub25lKCkpXTtcbiAgICByZXR1cm4gZXhlY3V0ZVdyaXRlKGZpcmVzdG9yZSwgbXV0YXRpb25zKTtcbn1cbi8qKlxuICogQWRkIGEgbmV3IGRvY3VtZW50IHRvIHNwZWNpZmllZCBgQ29sbGVjdGlvblJlZmVyZW5jZWAgd2l0aCB0aGUgZ2l2ZW4gZGF0YSxcbiAqIGFzc2lnbmluZyBpdCBhIGRvY3VtZW50IElEIGF1dG9tYXRpY2FsbHkuXG4gKlxuICogQHBhcmFtIHJlZmVyZW5jZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjb2xsZWN0aW9uIHRvIGFkZCB0aGlzIGRvY3VtZW50IHRvLlxuICogQHBhcmFtIGRhdGEgLSBBbiBPYmplY3QgY29udGFpbmluZyB0aGUgZGF0YSBmb3IgdGhlIG5ldyBkb2N1bWVudC5cbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHJlc29sdmVkIHdpdGggYSBgRG9jdW1lbnRSZWZlcmVuY2VgIHBvaW50aW5nIHRvIHRoZVxuICogbmV3bHkgY3JlYXRlZCBkb2N1bWVudCBhZnRlciBpdCBoYXMgYmVlbiB3cml0dGVuIHRvIHRoZSBiYWNrZW5kIChOb3RlIHRoYXQgaXRcbiAqIHdvbid0IHJlc29sdmUgd2hpbGUgeW91J3JlIG9mZmxpbmUpLlxuICovXG5mdW5jdGlvbiBhZGREb2MocmVmZXJlbmNlLCBkYXRhKSB7XG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChyZWZlcmVuY2UuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgIGNvbnN0IGRvY1JlZiA9IGRvYyhyZWZlcmVuY2UpO1xuICAgIGNvbnN0IGNvbnZlcnRlZFZhbHVlID0gYXBwbHlGaXJlc3RvcmVEYXRhQ29udmVydGVyKHJlZmVyZW5jZS5jb252ZXJ0ZXIsIGRhdGEpO1xuICAgIGNvbnN0IGRhdGFSZWFkZXIgPSBuZXdVc2VyRGF0YVJlYWRlcihyZWZlcmVuY2UuZmlyZXN0b3JlKTtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZVNldERhdGEoZGF0YVJlYWRlciwgJ2FkZERvYycsIGRvY1JlZi5fa2V5LCBjb252ZXJ0ZWRWYWx1ZSwgcmVmZXJlbmNlLmNvbnZlcnRlciAhPT0gbnVsbCwge30pO1xuICAgIGNvbnN0IG11dGF0aW9uID0gcGFyc2VkLnRvTXV0YXRpb24oZG9jUmVmLl9rZXksIFByZWNvbmRpdGlvbi5leGlzdHMoZmFsc2UpKTtcbiAgICByZXR1cm4gZXhlY3V0ZVdyaXRlKGZpcmVzdG9yZSwgW211dGF0aW9uXSkudGhlbigoKSA9PiBkb2NSZWYpO1xufVxuZnVuY3Rpb24gb25TbmFwc2hvdChyZWZlcmVuY2UsIC4uLmFyZ3MpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICByZWZlcmVuY2UgPSBnZXRNb2R1bGFySW5zdGFuY2UocmVmZXJlbmNlKTtcbiAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgaW5jbHVkZU1ldGFkYXRhQ2hhbmdlczogZmFsc2UsXG4gICAgICAgIHNvdXJjZTogJ2RlZmF1bHQnXG4gICAgfTtcbiAgICBsZXQgY3VyckFyZyA9IDA7XG4gICAgaWYgKHR5cGVvZiBhcmdzW2N1cnJBcmddID09PSAnb2JqZWN0JyAmJiAhaXNQYXJ0aWFsT2JzZXJ2ZXIoYXJnc1tjdXJyQXJnXSkpIHtcbiAgICAgICAgb3B0aW9ucyA9IGFyZ3NbY3VyckFyZ107XG4gICAgICAgIGN1cnJBcmcrKztcbiAgICB9XG4gICAgY29uc3QgaW50ZXJuYWxPcHRpb25zID0ge1xuICAgICAgICBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzOiBvcHRpb25zLmluY2x1ZGVNZXRhZGF0YUNoYW5nZXMsXG4gICAgICAgIHNvdXJjZTogb3B0aW9ucy5zb3VyY2VcbiAgICB9O1xuICAgIGlmIChpc1BhcnRpYWxPYnNlcnZlcihhcmdzW2N1cnJBcmddKSkge1xuICAgICAgICBjb25zdCB1c2VyT2JzZXJ2ZXIgPSBhcmdzW2N1cnJBcmddO1xuICAgICAgICBhcmdzW2N1cnJBcmddID0gKF9hID0gdXNlck9ic2VydmVyLm5leHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iaW5kKHVzZXJPYnNlcnZlcik7XG4gICAgICAgIGFyZ3NbY3VyckFyZyArIDFdID0gKF9iID0gdXNlck9ic2VydmVyLmVycm9yKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYmluZCh1c2VyT2JzZXJ2ZXIpO1xuICAgICAgICBhcmdzW2N1cnJBcmcgKyAyXSA9IChfYyA9IHVzZXJPYnNlcnZlci5jb21wbGV0ZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmJpbmQodXNlck9ic2VydmVyKTtcbiAgICB9XG4gICAgbGV0IG9ic2VydmVyO1xuICAgIGxldCBmaXJlc3RvcmU7XG4gICAgbGV0IGludGVybmFsUXVlcnk7XG4gICAgaWYgKHJlZmVyZW5jZSBpbnN0YW5jZW9mIERvY3VtZW50UmVmZXJlbmNlKSB7XG4gICAgICAgIGZpcmVzdG9yZSA9IGNhc3QocmVmZXJlbmNlLmZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcbiAgICAgICAgaW50ZXJuYWxRdWVyeSA9IG5ld1F1ZXJ5Rm9yUGF0aChyZWZlcmVuY2UuX2tleS5wYXRoKTtcbiAgICAgICAgb2JzZXJ2ZXIgPSB7XG4gICAgICAgICAgICBuZXh0OiBzbmFwc2hvdCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3NbY3VyckFyZ10pIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tjdXJyQXJnXShjb252ZXJ0VG9Eb2NTbmFwc2hvdChmaXJlc3RvcmUsIHJlZmVyZW5jZSwgc25hcHNob3QpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGFyZ3NbY3VyckFyZyArIDFdLFxuICAgICAgICAgICAgY29tcGxldGU6IGFyZ3NbY3VyckFyZyArIDJdXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBxdWVyeSA9IGNhc3QocmVmZXJlbmNlLCBRdWVyeSk7XG4gICAgICAgIGZpcmVzdG9yZSA9IGNhc3QocXVlcnkuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgICAgICBpbnRlcm5hbFF1ZXJ5ID0gcXVlcnkuX3F1ZXJ5O1xuICAgICAgICBjb25zdCB1c2VyRGF0YVdyaXRlciA9IG5ldyBFeHBVc2VyRGF0YVdyaXRlcihmaXJlc3RvcmUpO1xuICAgICAgICBvYnNlcnZlciA9IHtcbiAgICAgICAgICAgIG5leHQ6IHNuYXBzaG90ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXJnc1tjdXJyQXJnXSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW2N1cnJBcmddKG5ldyBRdWVyeVNuYXBzaG90KGZpcmVzdG9yZSwgdXNlckRhdGFXcml0ZXIsIHF1ZXJ5LCBzbmFwc2hvdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogYXJnc1tjdXJyQXJnICsgMV0sXG4gICAgICAgICAgICBjb21wbGV0ZTogYXJnc1tjdXJyQXJnICsgMl1cbiAgICAgICAgfTtcbiAgICAgICAgdmFsaWRhdGVIYXNFeHBsaWNpdE9yZGVyQnlGb3JMaW1pdFRvTGFzdChyZWZlcmVuY2UuX3F1ZXJ5KTtcbiAgICB9XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRMaXN0ZW4oY2xpZW50LCBpbnRlcm5hbFF1ZXJ5LCBpbnRlcm5hbE9wdGlvbnMsIG9ic2VydmVyKTtcbn1cbmZ1bmN0aW9uIG9uU25hcHNob3RzSW5TeW5jKGZpcmVzdG9yZSwgYXJnKSB7XG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIGNvbnN0IG9ic2VydmVyID0gaXNQYXJ0aWFsT2JzZXJ2ZXIoYXJnKVxuICAgICAgICA/IGFyZ1xuICAgICAgICA6IHtcbiAgICAgICAgICAgIG5leHQ6IGFyZ1xuICAgICAgICB9O1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRBZGRTbmFwc2hvdHNJblN5bmNMaXN0ZW5lcihjbGllbnQsIG9ic2VydmVyKTtcbn1cbi8qKlxuICogTG9jYWxseSB3cml0ZXMgYG11dGF0aW9uc2Agb24gdGhlIGFzeW5jIHF1ZXVlLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVXcml0ZShmaXJlc3RvcmUsIG11dGF0aW9ucykge1xuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50V3JpdGUoY2xpZW50LCBtdXRhdGlvbnMpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBWaWV3U25hcHNob3R9IHRoYXQgY29udGFpbnMgdGhlIHNpbmdsZSBkb2N1bWVudCBzcGVjaWZpZWQgYnkgYHJlZmBcbiAqIHRvIGEge0BsaW5rIERvY3VtZW50U25hcHNob3R9LlxuICovXG5mdW5jdGlvbiBjb252ZXJ0VG9Eb2NTbmFwc2hvdChmaXJlc3RvcmUsIHJlZiwgc25hcHNob3QpIHtcbiAgICBjb25zdCBkb2MgPSBzbmFwc2hvdC5kb2NzLmdldChyZWYuX2tleSk7XG4gICAgY29uc3QgdXNlckRhdGFXcml0ZXIgPSBuZXcgRXhwVXNlckRhdGFXcml0ZXIoZmlyZXN0b3JlKTtcbiAgICByZXR1cm4gbmV3IERvY3VtZW50U25hcHNob3QoZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwgcmVmLl9rZXksIGRvYywgbmV3IFNuYXBzaG90TWV0YWRhdGEoc25hcHNob3QuaGFzUGVuZGluZ1dyaXRlcywgc25hcHNob3QuZnJvbUNhY2hlKSwgcmVmLmNvbnZlcnRlcik7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBkb2N1bWVudHMgaW4gdGhlIHJlc3VsdCBzZXQgb2YgdGhlIGdpdmVuIHF1ZXJ5XG4gKiB3aXRob3V0IGFjdHVhbGx5IGRvd25sb2FkaW5nIHRoZSBkb2N1bWVudHMuXG4gKlxuICogVXNpbmcgdGhpcyBmdW5jdGlvbiB0byBjb3VudCB0aGUgZG9jdW1lbnRzIGlzIGVmZmljaWVudCBiZWNhdXNlIG9ubHkgdGhlXG4gKiBmaW5hbCBjb3VudCwgbm90IHRoZSBkb2N1bWVudHMnIGRhdGEsIGlzIGRvd25sb2FkZWQuIFRoaXMgZnVuY3Rpb24gY2FuXG4gKiBjb3VudCB0aGUgZG9jdW1lbnRzIGluIGNhc2VzIHdoZXJlIHRoZSByZXN1bHQgc2V0IGlzIHByb2hpYml0aXZlbHkgbGFyZ2UgdG9cbiAqIGRvd25sb2FkIGVudGlyZWx5ICh0aG91c2FuZHMgb2YgZG9jdW1lbnRzKS5cbiAqXG4gKiBUaGUgcmVzdWx0IHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciBpcyBwcmVzZW50ZWQsIHVuYWx0ZXJlZCwgd2l0aG91dFxuICogY29uc2lkZXJpbmcgYW55IGxvY2FsIHN0YXRlLiBUaGF0IGlzLCBkb2N1bWVudHMgaW4gdGhlIGxvY2FsIGNhY2hlIGFyZSBub3RcbiAqIHRha2VuIGludG8gY29uc2lkZXJhdGlvbiwgbmVpdGhlciBhcmUgbG9jYWwgbW9kaWZpY2F0aW9ucyBub3QgeWV0XG4gKiBzeW5jaHJvbml6ZWQgd2l0aCB0aGUgc2VydmVyLiBQcmV2aW91c2x5LWRvd25sb2FkZWQgcmVzdWx0cywgaWYgYW55LCBhcmUgbm90XG4gKiB1c2VkLiBFdmVyeSBpbnZvY2F0aW9uIG9mIHRoaXMgZnVuY3Rpb24gbmVjZXNzYXJpbHkgaW52b2x2ZXMgYSByb3VuZCB0cmlwIHRvXG4gKiB0aGUgc2VydmVyLlxuICpcbiAqIEBwYXJhbSBxdWVyeSBUaGUgcXVlcnkgd2hvc2UgcmVzdWx0IHNldCBzaXplIGlzIGNhbGN1bGF0ZWQuXG4gKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIGNvdW50OyB0aGUgY291bnQgY2FuIGJlXG4gKiByZXRyaWV2ZWQgZnJvbSBgc25hcHNob3QuZGF0YSgpLmNvdW50YCwgd2hlcmUgYHNuYXBzaG90YCBpcyB0aGVcbiAqIGBBZ2dyZWdhdGVRdWVyeVNuYXBzaG90YCB0byB3aGljaCB0aGUgcmV0dXJuZWQgUHJvbWlzZSByZXNvbHZlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0Q291bnRGcm9tU2VydmVyKHF1ZXJ5KSB7XG4gICAgY29uc3QgY291bnRRdWVyeVNwZWMgPSB7XG4gICAgICAgIGNvdW50OiBjb3VudCgpXG4gICAgfTtcbiAgICByZXR1cm4gZ2V0QWdncmVnYXRlRnJvbVNlcnZlcihxdWVyeSwgY291bnRRdWVyeVNwZWMpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcGVjaWZpZWQgYWdncmVnYXRpb25zIG92ZXIgdGhlIGRvY3VtZW50cyBpbiB0aGUgcmVzdWx0XG4gKiBzZXQgb2YgdGhlIGdpdmVuIHF1ZXJ5IHdpdGhvdXQgYWN0dWFsbHkgZG93bmxvYWRpbmcgdGhlIGRvY3VtZW50cy5cbiAqXG4gKiBVc2luZyB0aGlzIGZ1bmN0aW9uIHRvIHBlcmZvcm0gYWdncmVnYXRpb25zIGlzIGVmZmljaWVudCBiZWNhdXNlIG9ubHkgdGhlXG4gKiBmaW5hbCBhZ2dyZWdhdGlvbiB2YWx1ZXMsIG5vdCB0aGUgZG9jdW1lbnRzJyBkYXRhLCBhcmUgZG93bmxvYWRlZC4gVGhpc1xuICogZnVuY3Rpb24gY2FuIHBlcmZvcm0gYWdncmVnYXRpb25zIG9mIHRoZSBkb2N1bWVudHMgaW4gY2FzZXMgd2hlcmUgdGhlIHJlc3VsdFxuICogc2V0IGlzIHByb2hpYml0aXZlbHkgbGFyZ2UgdG8gZG93bmxvYWQgZW50aXJlbHkgKHRob3VzYW5kcyBvZiBkb2N1bWVudHMpLlxuICpcbiAqIFRoZSByZXN1bHQgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyIGlzIHByZXNlbnRlZCwgdW5hbHRlcmVkLCB3aXRob3V0XG4gKiBjb25zaWRlcmluZyBhbnkgbG9jYWwgc3RhdGUuIFRoYXQgaXMsIGRvY3VtZW50cyBpbiB0aGUgbG9jYWwgY2FjaGUgYXJlIG5vdFxuICogdGFrZW4gaW50byBjb25zaWRlcmF0aW9uLCBuZWl0aGVyIGFyZSBsb2NhbCBtb2RpZmljYXRpb25zIG5vdCB5ZXRcbiAqIHN5bmNocm9uaXplZCB3aXRoIHRoZSBzZXJ2ZXIuIFByZXZpb3VzbHktZG93bmxvYWRlZCByZXN1bHRzLCBpZiBhbnksIGFyZSBub3RcbiAqIHVzZWQuIEV2ZXJ5IGludm9jYXRpb24gb2YgdGhpcyBmdW5jdGlvbiBuZWNlc3NhcmlseSBpbnZvbHZlcyBhIHJvdW5kIHRyaXAgdG9cbiAqIHRoZSBzZXJ2ZXIuXG4gKlxuICogQHBhcmFtIHF1ZXJ5IFRoZSBxdWVyeSB3aG9zZSByZXN1bHQgc2V0IGlzIGFnZ3JlZ2F0ZWQgb3Zlci5cbiAqIEBwYXJhbSBhZ2dyZWdhdGVTcGVjIEFuIGBBZ2dyZWdhdGVTcGVjYCBvYmplY3QgdGhhdCBzcGVjaWZpZXMgdGhlIGFnZ3JlZ2F0ZXNcbiAqIHRvIHBlcmZvcm0gb3ZlciB0aGUgcmVzdWx0IHNldC4gVGhlIEFnZ3JlZ2F0ZVNwZWMgc3BlY2lmaWVzIGFsaWFzZXMgZm9yIGVhY2hcbiAqIGFnZ3JlZ2F0ZSwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gcmV0cmlldmUgdGhlIGFnZ3JlZ2F0ZSByZXN1bHQuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgYWdncmVnYXRlU25hcHNob3QgPSBhd2FpdCBnZXRBZ2dyZWdhdGVGcm9tU2VydmVyKHF1ZXJ5LCB7XG4gKiAgIGNvdW50T2ZEb2NzOiBjb3VudCgpLFxuICogICB0b3RhbEhvdXJzOiBzdW0oJ2hvdXJzJyksXG4gKiAgIGF2ZXJhZ2VTY29yZTogYXZlcmFnZSgnc2NvcmUnKVxuICogfSk7XG4gKlxuICogY29uc3QgY291bnRPZkRvY3M6IG51bWJlciA9IGFnZ3JlZ2F0ZVNuYXBzaG90LmRhdGEoKS5jb3VudE9mRG9jcztcbiAqIGNvbnN0IHRvdGFsSG91cnM6IG51bWJlciA9IGFnZ3JlZ2F0ZVNuYXBzaG90LmRhdGEoKS50b3RhbEhvdXJzO1xuICogY29uc3QgYXZlcmFnZVNjb3JlOiBudW1iZXIgfCBudWxsID0gYWdncmVnYXRlU25hcHNob3QuZGF0YSgpLmF2ZXJhZ2VTY29yZTtcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBnZXRBZ2dyZWdhdGVGcm9tU2VydmVyKHF1ZXJ5LCBhZ2dyZWdhdGVTcGVjKSB7XG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChxdWVyeS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIGNvbnN0IGludGVybmFsQWdncmVnYXRlcyA9IG1hcFRvQXJyYXkoYWdncmVnYXRlU3BlYywgKGFnZ3JlZ2F0ZSwgYWxpYXMpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBBZ2dyZWdhdGVJbXBsKGFsaWFzLCBhZ2dyZWdhdGUuYWdncmVnYXRlVHlwZSwgYWdncmVnYXRlLl9pbnRlcm5hbEZpZWxkUGF0aCk7XG4gICAgfSk7XG4gICAgLy8gUnVuIHRoZSBhZ2dyZWdhdGlvbiBhbmQgY29udmVydCB0aGUgcmVzdWx0c1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRSdW5BZ2dyZWdhdGVRdWVyeShjbGllbnQsIHF1ZXJ5Ll9xdWVyeSwgaW50ZXJuYWxBZ2dyZWdhdGVzKS50aGVuKGFnZ3JlZ2F0ZVJlc3VsdCA9PiBjb252ZXJ0VG9BZ2dyZWdhdGVRdWVyeVNuYXBzaG90KGZpcmVzdG9yZSwgcXVlcnksIGFnZ3JlZ2F0ZVJlc3VsdCkpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgY29yZSBhZ2dyZWdhdGlvbiByZXN1bHQgdG8gYW4gYEFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3RgXG4gKiB0aGF0IGNhbiBiZSByZXR1cm5lZCB0byB0aGUgY29uc3VtZXIuXG4gKiBAcGFyYW0gcXVlcnlcbiAqIEBwYXJhbSBhZ2dyZWdhdGVSZXN1bHQgQ29yZSBhZ2dyZWdhdGlvbiByZXN1bHRcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBjb252ZXJ0VG9BZ2dyZWdhdGVRdWVyeVNuYXBzaG90KGZpcmVzdG9yZSwgcXVlcnksIGFnZ3JlZ2F0ZVJlc3VsdCkge1xuICAgIGNvbnN0IHVzZXJEYXRhV3JpdGVyID0gbmV3IEV4cFVzZXJEYXRhV3JpdGVyKGZpcmVzdG9yZSk7XG4gICAgY29uc3QgcXVlcnlTbmFwc2hvdCA9IG5ldyBBZ2dyZWdhdGVRdWVyeVNuYXBzaG90KHF1ZXJ5LCB1c2VyRGF0YVdyaXRlciwgYWdncmVnYXRlUmVzdWx0KTtcbiAgICByZXR1cm4gcXVlcnlTbmFwc2hvdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIE1lbW9yeUxvY2FsQ2FjaGVJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgICAgICB0aGlzLmtpbmQgPSAnbWVtb3J5JztcbiAgICAgICAgdGhpcy5fb25saW5lQ29tcG9uZW50UHJvdmlkZXIgPSBPbmxpbmVDb21wb25lbnRQcm92aWRlci5wcm92aWRlcjtcbiAgICAgICAgaWYgKHNldHRpbmdzID09PSBudWxsIHx8IHNldHRpbmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXR0aW5ncy5nYXJiYWdlQ29sbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIgPVxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmdhcmJhZ2VDb2xsZWN0b3IuX29mZmxpbmVDb21wb25lbnRQcm92aWRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX29mZmxpbmVDb21wb25lbnRQcm92aWRlciA9IHtcbiAgICAgICAgICAgICAgICBidWlsZDogKCkgPT4gbmV3IExydUdjTWVtb3J5T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKHVuZGVmaW5lZClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBraW5kOiB0aGlzLmtpbmQgfTtcbiAgICB9XG59XG5jbGFzcyBQZXJzaXN0ZW50TG9jYWxDYWNoZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMua2luZCA9ICdwZXJzaXN0ZW50JztcbiAgICAgICAgbGV0IHRhYk1hbmFnZXI7XG4gICAgICAgIGlmIChzZXR0aW5ncyA9PT0gbnVsbCB8fCBzZXR0aW5ncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2V0dGluZ3MudGFiTWFuYWdlcikge1xuICAgICAgICAgICAgc2V0dGluZ3MudGFiTWFuYWdlci5faW5pdGlhbGl6ZShzZXR0aW5ncyk7XG4gICAgICAgICAgICB0YWJNYW5hZ2VyID0gc2V0dGluZ3MudGFiTWFuYWdlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhYk1hbmFnZXIgPSBwZXJzaXN0ZW50U2luZ2xlVGFiTWFuYWdlcih1bmRlZmluZWQpO1xuICAgICAgICAgICAgdGFiTWFuYWdlci5faW5pdGlhbGl6ZShzZXR0aW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb25saW5lQ29tcG9uZW50UHJvdmlkZXIgPSB0YWJNYW5hZ2VyLl9vbmxpbmVDb21wb25lbnRQcm92aWRlcjtcbiAgICAgICAgdGhpcy5fb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyID0gdGFiTWFuYWdlci5fb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IGtpbmQ6IHRoaXMua2luZCB9O1xuICAgIH1cbn1cbmNsYXNzIE1lbW9yeUVhZ2VyR2FyYmFnZUNvbGxlY3RvckltcGwge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmtpbmQgPSAnbWVtb3J5RWFnZXInO1xuICAgICAgICB0aGlzLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIgPSBNZW1vcnlPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIucHJvdmlkZXI7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsga2luZDogdGhpcy5raW5kIH07XG4gICAgfVxufVxuY2xhc3MgTWVtb3J5THJ1R2FyYmFnZUNvbGxlY3RvckltcGwge1xuICAgIGNvbnN0cnVjdG9yKGNhY2hlU2l6ZSkge1xuICAgICAgICB0aGlzLmtpbmQgPSAnbWVtb3J5THJ1JztcbiAgICAgICAgdGhpcy5fb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyID0ge1xuICAgICAgICAgICAgYnVpbGQ6ICgpID0+IG5ldyBMcnVHY01lbW9yeU9mZmxpbmVDb21wb25lbnRQcm92aWRlcihjYWNoZVNpemUpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsga2luZDogdGhpcy5raW5kIH07XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGBNZW1vcnlFYWdlckdhcmJhZ2VDb2xsZWN0b3JgLiBUaGlzIGlzIGFsc28gdGhlXG4gKiBkZWZhdWx0IGdhcmJhZ2UgY29sbGVjdG9yIHVubGVzcyBpdCBpcyBleHBsaWNpdGx5IHNwZWNpZmllZCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIG1lbW9yeUVhZ2VyR2FyYmFnZUNvbGxlY3RvcigpIHtcbiAgICByZXR1cm4gbmV3IE1lbW9yeUVhZ2VyR2FyYmFnZUNvbGxlY3RvckltcGwoKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBgTWVtb3J5THJ1R2FyYmFnZUNvbGxlY3RvcmAuXG4gKlxuICogQSB0YXJnZXQgc2l6ZSBjYW4gYmUgc3BlY2lmaWVkIGFzIHBhcnQgb2YgdGhlIHNldHRpbmcgcGFyYW1ldGVyLiBUaGVcbiAqIGNvbGxlY3RvciB3aWxsIHN0YXJ0IGRlbGV0aW5nIGRvY3VtZW50cyBvbmNlIHRoZSBjYWNoZSBzaXplIGV4Y2VlZHNcbiAqIHRoZSBnaXZlbiBzaXplLiBUaGUgZGVmYXVsdCBjYWNoZSBzaXplIGlzIDQwTUIgKDQwICogMTAyNCAqIDEwMjQgYnl0ZXMpLlxuICovXG5mdW5jdGlvbiBtZW1vcnlMcnVHYXJiYWdlQ29sbGVjdG9yKHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIG5ldyBNZW1vcnlMcnVHYXJiYWdlQ29sbGVjdG9ySW1wbChzZXR0aW5ncyA9PT0gbnVsbCB8fCBzZXR0aW5ncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2V0dGluZ3MuY2FjaGVTaXplQnl0ZXMpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGBNZW1vcnlMb2NhbENhY2hlYC4gVGhlIGluc3RhbmNlIGNhbiBiZSBzZXQgdG9cbiAqIGBGaXJlc3RvcmVTZXR0aW5ncy5jYWNoZWAgdG8gdGVsbCB0aGUgU0RLIHdoaWNoIGNhY2hlIGxheWVyIHRvIHVzZS5cbiAqL1xuZnVuY3Rpb24gbWVtb3J5TG9jYWxDYWNoZShzZXR0aW5ncykge1xuICAgIHJldHVybiBuZXcgTWVtb3J5TG9jYWxDYWNoZUltcGwoc2V0dGluZ3MpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGBQZXJzaXN0ZW50TG9jYWxDYWNoZWAuIFRoZSBpbnN0YW5jZSBjYW4gYmUgc2V0IHRvXG4gKiBgRmlyZXN0b3JlU2V0dGluZ3MuY2FjaGVgIHRvIHRlbGwgdGhlIFNESyB3aGljaCBjYWNoZSBsYXllciB0byB1c2UuXG4gKlxuICogUGVyc2lzdGVudCBjYWNoZSBjYW5ub3QgYmUgdXNlZCBpbiBhIE5vZGUuanMgZW52aXJvbm1lbnQuXG4gKi9cbmZ1bmN0aW9uIHBlcnNpc3RlbnRMb2NhbENhY2hlKHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW50TG9jYWxDYWNoZUltcGwoc2V0dGluZ3MpO1xufVxuY2xhc3MgU2luZ2xlVGFiTWFuYWdlckltcGwge1xuICAgIGNvbnN0cnVjdG9yKGZvcmNlT3duZXJzaGlwKSB7XG4gICAgICAgIHRoaXMuZm9yY2VPd25lcnNoaXAgPSBmb3JjZU93bmVyc2hpcDtcbiAgICAgICAgdGhpcy5raW5kID0gJ3BlcnNpc3RlbnRTaW5nbGVUYWInO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IGtpbmQ6IHRoaXMua2luZCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZShzZXR0aW5ncykge1xuICAgICAgICB0aGlzLl9vbmxpbmVDb21wb25lbnRQcm92aWRlciA9IE9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnByb3ZpZGVyO1xuICAgICAgICB0aGlzLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIgPSB7XG4gICAgICAgICAgICBidWlsZDogKG9ubGluZUNvbXBvbmVudHMpID0+IG5ldyBJbmRleGVkRGJPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIob25saW5lQ29tcG9uZW50cywgc2V0dGluZ3MgPT09IG51bGwgfHwgc2V0dGluZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzLCB0aGlzLmZvcmNlT3duZXJzaGlwKVxuICAgICAgICB9O1xuICAgIH1cbn1cbmNsYXNzIE11bHRpVGFiTWFuYWdlckltcGwge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmtpbmQgPSAnUGVyc2lzdGVudE11bHRpcGxlVGFiJztcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBraW5kOiB0aGlzLmtpbmQgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2luaXRpYWxpemUoc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5fb25saW5lQ29tcG9uZW50UHJvdmlkZXIgPSBPbmxpbmVDb21wb25lbnRQcm92aWRlci5wcm92aWRlcjtcbiAgICAgICAgdGhpcy5fb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyID0ge1xuICAgICAgICAgICAgYnVpbGQ6IChvbmxpbmVDb21wb25lbnRzKSA9PiBuZXcgTXVsdGlUYWJPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIob25saW5lQ29tcG9uZW50cywgc2V0dGluZ3MgPT09IG51bGwgfHwgc2V0dGluZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzKVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBgUGVyc2lzdGVudFNpbmdsZVRhYk1hbmFnZXJgLlxuICpcbiAqIEBwYXJhbSBzZXR0aW5ncyBDb25maWd1cmVzIHRoZSBjcmVhdGVkIHRhYiBtYW5hZ2VyLlxuICovXG5mdW5jdGlvbiBwZXJzaXN0ZW50U2luZ2xlVGFiTWFuYWdlcihzZXR0aW5ncykge1xuICAgIHJldHVybiBuZXcgU2luZ2xlVGFiTWFuYWdlckltcGwoc2V0dGluZ3MgPT09IG51bGwgfHwgc2V0dGluZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNldHRpbmdzLmZvcmNlT3duZXJzaGlwKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBgUGVyc2lzdGVudE11bHRpcGxlVGFiTWFuYWdlcmAuXG4gKi9cbmZ1bmN0aW9uIHBlcnNpc3RlbnRNdWx0aXBsZVRhYk1hbmFnZXIoKSB7XG4gICAgcmV0dXJuIG5ldyBNdWx0aVRhYk1hbmFnZXJJbXBsKCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBERUZBVUxUX1RSQU5TQUNUSU9OX09QVElPTlMgPSB7XG4gICAgbWF4QXR0ZW1wdHM6IDVcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZVRyYW5zYWN0aW9uT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMubWF4QXR0ZW1wdHMgPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdNYXggYXR0ZW1wdHMgbXVzdCBiZSBhdCBsZWFzdCAxJyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIHdyaXRlIGJhdGNoLCB1c2VkIHRvIHBlcmZvcm0gbXVsdGlwbGUgd3JpdGVzIGFzIGEgc2luZ2xlIGF0b21pYyB1bml0LlxuICpcbiAqIEEgYFdyaXRlQmF0Y2hgIG9iamVjdCBjYW4gYmUgYWNxdWlyZWQgYnkgY2FsbGluZyB7QGxpbmsgd3JpdGVCYXRjaH0uIEl0XG4gKiBwcm92aWRlcyBtZXRob2RzIGZvciBhZGRpbmcgd3JpdGVzIHRvIHRoZSB3cml0ZSBiYXRjaC4gTm9uZSBvZiB0aGUgd3JpdGVzXG4gKiB3aWxsIGJlIGNvbW1pdHRlZCAob3IgdmlzaWJsZSBsb2NhbGx5KSB1bnRpbCB7QGxpbmsgV3JpdGVCYXRjaC5jb21taXR9IGlzXG4gKiBjYWxsZWQuXG4gKi9cbmNsYXNzIFdyaXRlQmF0Y2gge1xuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXG4gICAgY29uc3RydWN0b3IoX2ZpcmVzdG9yZSwgX2NvbW1pdEhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fZmlyZXN0b3JlID0gX2ZpcmVzdG9yZTtcbiAgICAgICAgdGhpcy5fY29tbWl0SGFuZGxlciA9IF9jb21taXRIYW5kbGVyO1xuICAgICAgICB0aGlzLl9tdXRhdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5fY29tbWl0dGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2RhdGFSZWFkZXIgPSBuZXdVc2VyRGF0YVJlYWRlcihfZmlyZXN0b3JlKTtcbiAgICB9XG4gICAgc2V0KGRvY3VtZW50UmVmLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3ZlcmlmeU5vdENvbW1pdHRlZCgpO1xuICAgICAgICBjb25zdCByZWYgPSB2YWxpZGF0ZVJlZmVyZW5jZShkb2N1bWVudFJlZiwgdGhpcy5fZmlyZXN0b3JlKTtcbiAgICAgICAgY29uc3QgY29udmVydGVkVmFsdWUgPSBhcHBseUZpcmVzdG9yZURhdGFDb252ZXJ0ZXIocmVmLmNvbnZlcnRlciwgZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlU2V0RGF0YSh0aGlzLl9kYXRhUmVhZGVyLCAnV3JpdGVCYXRjaC5zZXQnLCByZWYuX2tleSwgY29udmVydGVkVmFsdWUsIHJlZi5jb252ZXJ0ZXIgIT09IG51bGwsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9tdXRhdGlvbnMucHVzaChwYXJzZWQudG9NdXRhdGlvbihyZWYuX2tleSwgUHJlY29uZGl0aW9uLm5vbmUoKSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdXBkYXRlKGRvY3VtZW50UmVmLCBmaWVsZE9yVXBkYXRlRGF0YSwgdmFsdWUsIC4uLm1vcmVGaWVsZHNBbmRWYWx1ZXMpIHtcbiAgICAgICAgdGhpcy5fdmVyaWZ5Tm90Q29tbWl0dGVkKCk7XG4gICAgICAgIGNvbnN0IHJlZiA9IHZhbGlkYXRlUmVmZXJlbmNlKGRvY3VtZW50UmVmLCB0aGlzLl9maXJlc3RvcmUpO1xuICAgICAgICAvLyBGb3IgQ29tcGF0IHR5cGVzLCB3ZSBoYXZlIHRvIFwiZXh0cmFjdFwiIHRoZSB1bmRlcmx5aW5nIHR5cGVzIGJlZm9yZVxuICAgICAgICAvLyBwZXJmb3JtaW5nIHZhbGlkYXRpb24uXG4gICAgICAgIGZpZWxkT3JVcGRhdGVEYXRhID0gZ2V0TW9kdWxhckluc3RhbmNlKGZpZWxkT3JVcGRhdGVEYXRhKTtcbiAgICAgICAgbGV0IHBhcnNlZDtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZE9yVXBkYXRlRGF0YSA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIGZpZWxkT3JVcGRhdGVEYXRhIGluc3RhbmNlb2YgRmllbGRQYXRoKSB7XG4gICAgICAgICAgICBwYXJzZWQgPSBwYXJzZVVwZGF0ZVZhcmFyZ3ModGhpcy5fZGF0YVJlYWRlciwgJ1dyaXRlQmF0Y2gudXBkYXRlJywgcmVmLl9rZXksIGZpZWxkT3JVcGRhdGVEYXRhLCB2YWx1ZSwgbW9yZUZpZWxkc0FuZFZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJzZWQgPSBwYXJzZVVwZGF0ZURhdGEodGhpcy5fZGF0YVJlYWRlciwgJ1dyaXRlQmF0Y2gudXBkYXRlJywgcmVmLl9rZXksIGZpZWxkT3JVcGRhdGVEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tdXRhdGlvbnMucHVzaChwYXJzZWQudG9NdXRhdGlvbihyZWYuX2tleSwgUHJlY29uZGl0aW9uLmV4aXN0cyh0cnVlKSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgZG9jdW1lbnQgcmVmZXJyZWQgdG8gYnkgdGhlIHByb3ZpZGVkIHtAbGluayBEb2N1bWVudFJlZmVyZW5jZX0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRSZWYgLSBBIHJlZmVyZW5jZSB0byB0aGUgZG9jdW1lbnQgdG8gYmUgZGVsZXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGlzIGBXcml0ZUJhdGNoYCBpbnN0YW5jZS4gVXNlZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgICAqL1xuICAgIGRlbGV0ZShkb2N1bWVudFJlZikge1xuICAgICAgICB0aGlzLl92ZXJpZnlOb3RDb21taXR0ZWQoKTtcbiAgICAgICAgY29uc3QgcmVmID0gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIHRoaXMuX2ZpcmVzdG9yZSk7XG4gICAgICAgIHRoaXMuX211dGF0aW9ucyA9IHRoaXMuX211dGF0aW9ucy5jb25jYXQobmV3IERlbGV0ZU11dGF0aW9uKHJlZi5fa2V5LCBQcmVjb25kaXRpb24ubm9uZSgpKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21taXRzIGFsbCBvZiB0aGUgd3JpdGVzIGluIHRoaXMgd3JpdGUgYmF0Y2ggYXMgYSBzaW5nbGUgYXRvbWljIHVuaXQuXG4gICAgICpcbiAgICAgKiBUaGUgcmVzdWx0IG9mIHRoZXNlIHdyaXRlcyB3aWxsIG9ubHkgYmUgcmVmbGVjdGVkIGluIGRvY3VtZW50IHJlYWRzIHRoYXRcbiAgICAgKiBvY2N1ciBhZnRlciB0aGUgcmV0dXJuZWQgcHJvbWlzZSByZXNvbHZlcy4gSWYgdGhlIGNsaWVudCBpcyBvZmZsaW5lLCB0aGVcbiAgICAgKiB3cml0ZSBmYWlscy4gSWYgeW91IHdvdWxkIGxpa2UgdG8gc2VlIGxvY2FsIG1vZGlmaWNhdGlvbnMgb3IgYnVmZmVyIHdyaXRlc1xuICAgICAqIHVudGlsIHRoZSBjbGllbnQgaXMgb25saW5lLCB1c2UgdGhlIGZ1bGwgRmlyZXN0b3JlIFNESy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgYFByb21pc2VgIHJlc29sdmVkIG9uY2UgYWxsIG9mIHRoZSB3cml0ZXMgaW4gdGhlIGJhdGNoIGhhdmUgYmVlblxuICAgICAqIHN1Y2Nlc3NmdWxseSB3cml0dGVuIHRvIHRoZSBiYWNrZW5kIGFzIGFuIGF0b21pYyB1bml0IChub3RlIHRoYXQgaXQgd29uJ3RcbiAgICAgKiByZXNvbHZlIHdoaWxlIHlvdSdyZSBvZmZsaW5lKS5cbiAgICAgKi9cbiAgICBjb21taXQoKSB7XG4gICAgICAgIHRoaXMuX3ZlcmlmeU5vdENvbW1pdHRlZCgpO1xuICAgICAgICB0aGlzLl9jb21taXR0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fbXV0YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21taXRIYW5kbGVyKHRoaXMuX211dGF0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBfdmVyaWZ5Tm90Q29tbWl0dGVkKCkge1xuICAgICAgICBpZiAodGhpcy5fY29tbWl0dGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnQSB3cml0ZSBiYXRjaCBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgYWZ0ZXIgY29tbWl0KCkgJyArXG4gICAgICAgICAgICAgICAgJ2hhcyBiZWVuIGNhbGxlZC4nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUmVmZXJlbmNlKGRvY3VtZW50UmVmLCBmaXJlc3RvcmUpIHtcbiAgICBkb2N1bWVudFJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShkb2N1bWVudFJlZik7XG4gICAgaWYgKGRvY3VtZW50UmVmLmZpcmVzdG9yZSAhPT0gZmlyZXN0b3JlKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdQcm92aWRlZCBkb2N1bWVudCByZWZlcmVuY2UgaXMgZnJvbSBhIGRpZmZlcmVudCBGaXJlc3RvcmUgaW5zdGFuY2UuJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnRSZWY7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gVE9ETyhtcnNjaG1pZHQpIENvbnNpZGVyIHVzaW5nIGBCYXNlVHJhbnNhY3Rpb25gIGFzIHRoZSBiYXNlIGNsYXNzIGluIHRoZVxuLy8gbGVnYWN5IFNESy5cbi8qKlxuICogQSByZWZlcmVuY2UgdG8gYSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBUaGUgYFRyYW5zYWN0aW9uYCBvYmplY3QgcGFzc2VkIHRvIGEgdHJhbnNhY3Rpb24ncyBgdXBkYXRlRnVuY3Rpb25gIHByb3ZpZGVzXG4gKiB0aGUgbWV0aG9kcyB0byByZWFkIGFuZCB3cml0ZSBkYXRhIHdpdGhpbiB0aGUgdHJhbnNhY3Rpb24gY29udGV4dC4gU2VlXG4gKiB7QGxpbmsgcnVuVHJhbnNhY3Rpb259LlxuICovXG5jbGFzcyBUcmFuc2FjdGlvbiQxIHtcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xuICAgIGNvbnN0cnVjdG9yKF9maXJlc3RvcmUsIF90cmFuc2FjdGlvbikge1xuICAgICAgICB0aGlzLl9maXJlc3RvcmUgPSBfZmlyZXN0b3JlO1xuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbiA9IF90cmFuc2FjdGlvbjtcbiAgICAgICAgdGhpcy5fZGF0YVJlYWRlciA9IG5ld1VzZXJEYXRhUmVhZGVyKF9maXJlc3RvcmUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyB0aGUgZG9jdW1lbnQgcmVmZXJlbmNlZCBieSB0aGUgcHJvdmlkZWQge0BsaW5rIERvY3VtZW50UmVmZXJlbmNlfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkb2N1bWVudFJlZiAtIEEgcmVmZXJlbmNlIHRvIHRoZSBkb2N1bWVudCB0byBiZSByZWFkLlxuICAgICAqIEByZXR1cm5zIEEgYERvY3VtZW50U25hcHNob3RgIHdpdGggdGhlIHJlYWQgZGF0YS5cbiAgICAgKi9cbiAgICBnZXQoZG9jdW1lbnRSZWYpIHtcbiAgICAgICAgY29uc3QgcmVmID0gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIHRoaXMuX2ZpcmVzdG9yZSk7XG4gICAgICAgIGNvbnN0IHVzZXJEYXRhV3JpdGVyID0gbmV3IExpdGVVc2VyRGF0YVdyaXRlcih0aGlzLl9maXJlc3RvcmUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb24ubG9va3VwKFtyZWYuX2tleV0pLnRoZW4oZG9jcyA9PiB7XG4gICAgICAgICAgICBpZiAoIWRvY3MgfHwgZG9jcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZG9jID0gZG9jc1swXTtcbiAgICAgICAgICAgIGlmIChkb2MuaXNGb3VuZERvY3VtZW50KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50U25hcHNob3QkMSh0aGlzLl9maXJlc3RvcmUsIHVzZXJEYXRhV3JpdGVyLCBkb2Mua2V5LCBkb2MsIHJlZi5jb252ZXJ0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZG9jLmlzTm9Eb2N1bWVudCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFNuYXBzaG90JDEodGhpcy5fZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwgcmVmLl9rZXksIG51bGwsIHJlZi5jb252ZXJ0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZmFpbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0KGRvY3VtZW50UmVmLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCByZWYgPSB2YWxpZGF0ZVJlZmVyZW5jZShkb2N1bWVudFJlZiwgdGhpcy5fZmlyZXN0b3JlKTtcbiAgICAgICAgY29uc3QgY29udmVydGVkVmFsdWUgPSBhcHBseUZpcmVzdG9yZURhdGFDb252ZXJ0ZXIocmVmLmNvbnZlcnRlciwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZVNldERhdGEodGhpcy5fZGF0YVJlYWRlciwgJ1RyYW5zYWN0aW9uLnNldCcsIHJlZi5fa2V5LCBjb252ZXJ0ZWRWYWx1ZSwgcmVmLmNvbnZlcnRlciAhPT0gbnVsbCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uLnNldChyZWYuX2tleSwgcGFyc2VkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVwZGF0ZShkb2N1bWVudFJlZiwgZmllbGRPclVwZGF0ZURhdGEsIHZhbHVlLCAuLi5tb3JlRmllbGRzQW5kVmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IHJlZiA9IHZhbGlkYXRlUmVmZXJlbmNlKGRvY3VtZW50UmVmLCB0aGlzLl9maXJlc3RvcmUpO1xuICAgICAgICAvLyBGb3IgQ29tcGF0IHR5cGVzLCB3ZSBoYXZlIHRvIFwiZXh0cmFjdFwiIHRoZSB1bmRlcmx5aW5nIHR5cGVzIGJlZm9yZVxuICAgICAgICAvLyBwZXJmb3JtaW5nIHZhbGlkYXRpb24uXG4gICAgICAgIGZpZWxkT3JVcGRhdGVEYXRhID0gZ2V0TW9kdWxhckluc3RhbmNlKGZpZWxkT3JVcGRhdGVEYXRhKTtcbiAgICAgICAgbGV0IHBhcnNlZDtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZE9yVXBkYXRlRGF0YSA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIGZpZWxkT3JVcGRhdGVEYXRhIGluc3RhbmNlb2YgRmllbGRQYXRoKSB7XG4gICAgICAgICAgICBwYXJzZWQgPSBwYXJzZVVwZGF0ZVZhcmFyZ3ModGhpcy5fZGF0YVJlYWRlciwgJ1RyYW5zYWN0aW9uLnVwZGF0ZScsIHJlZi5fa2V5LCBmaWVsZE9yVXBkYXRlRGF0YSwgdmFsdWUsIG1vcmVGaWVsZHNBbmRWYWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VkID0gcGFyc2VVcGRhdGVEYXRhKHRoaXMuX2RhdGFSZWFkZXIsICdUcmFuc2FjdGlvbi51cGRhdGUnLCByZWYuX2tleSwgZmllbGRPclVwZGF0ZURhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uLnVwZGF0ZShyZWYuX2tleSwgcGFyc2VkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgdGhlIGRvY3VtZW50IHJlZmVycmVkIHRvIGJ5IHRoZSBwcm92aWRlZCB7QGxpbmsgRG9jdW1lbnRSZWZlcmVuY2V9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50UmVmIC0gQSByZWZlcmVuY2UgdG8gdGhlIGRvY3VtZW50IHRvIGJlIGRlbGV0ZWQuXG4gICAgICogQHJldHVybnMgVGhpcyBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBVc2VkIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAgICovXG4gICAgZGVsZXRlKGRvY3VtZW50UmVmKSB7XG4gICAgICAgIGNvbnN0IHJlZiA9IHZhbGlkYXRlUmVmZXJlbmNlKGRvY3VtZW50UmVmLCB0aGlzLl9maXJlc3RvcmUpO1xuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbi5kZWxldGUocmVmLl9rZXkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEEgcmVmZXJlbmNlIHRvIGEgdHJhbnNhY3Rpb24uXG4gKlxuICogVGhlIGBUcmFuc2FjdGlvbmAgb2JqZWN0IHBhc3NlZCB0byBhIHRyYW5zYWN0aW9uJ3MgYHVwZGF0ZUZ1bmN0aW9uYCBwcm92aWRlc1xuICogdGhlIG1ldGhvZHMgdG8gcmVhZCBhbmQgd3JpdGUgZGF0YSB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uIGNvbnRleHQuIFNlZVxuICoge0BsaW5rIHJ1blRyYW5zYWN0aW9ufS5cbiAqL1xuY2xhc3MgVHJhbnNhY3Rpb24gZXh0ZW5kcyBUcmFuc2FjdGlvbiQxIHtcbiAgICAvLyBUaGlzIGNsYXNzIGltcGxlbWVudHMgdGhlIHNhbWUgbG9naWMgYXMgdGhlIFRyYW5zYWN0aW9uIEFQSSBpbiB0aGUgTGl0ZSBTREtcbiAgICAvLyBidXQgaXMgc3ViY2xhc3NlZCBpbiBvcmRlciB0byByZXR1cm4gaXRzIG93biBEb2N1bWVudFNuYXBzaG90IHR5cGVzLlxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXG4gICAgY29uc3RydWN0b3IoX2ZpcmVzdG9yZSwgX3RyYW5zYWN0aW9uKSB7XG4gICAgICAgIHN1cGVyKF9maXJlc3RvcmUsIF90cmFuc2FjdGlvbik7XG4gICAgICAgIHRoaXMuX2ZpcmVzdG9yZSA9IF9maXJlc3RvcmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIHRoZSBkb2N1bWVudCByZWZlcmVuY2VkIGJ5IHRoZSBwcm92aWRlZCB7QGxpbmsgRG9jdW1lbnRSZWZlcmVuY2V9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50UmVmIC0gQSByZWZlcmVuY2UgdG8gdGhlIGRvY3VtZW50IHRvIGJlIHJlYWQuXG4gICAgICogQHJldHVybnMgQSBgRG9jdW1lbnRTbmFwc2hvdGAgd2l0aCB0aGUgcmVhZCBkYXRhLlxuICAgICAqL1xuICAgIGdldChkb2N1bWVudFJlZikge1xuICAgICAgICBjb25zdCByZWYgPSB2YWxpZGF0ZVJlZmVyZW5jZShkb2N1bWVudFJlZiwgdGhpcy5fZmlyZXN0b3JlKTtcbiAgICAgICAgY29uc3QgdXNlckRhdGFXcml0ZXIgPSBuZXcgRXhwVXNlckRhdGFXcml0ZXIodGhpcy5fZmlyZXN0b3JlKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyXG4gICAgICAgICAgICAuZ2V0KGRvY3VtZW50UmVmKVxuICAgICAgICAgICAgLnRoZW4obGl0ZURvY3VtZW50U25hcHNob3QgPT4gbmV3IERvY3VtZW50U25hcHNob3QodGhpcy5fZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwgcmVmLl9rZXksIGxpdGVEb2N1bWVudFNuYXBzaG90Ll9kb2N1bWVudCwgbmV3IFNuYXBzaG90TWV0YWRhdGEoXG4gICAgICAgIC8qIGhhc1BlbmRpbmdXcml0ZXM9ICovIGZhbHNlLCBcbiAgICAgICAgLyogZnJvbUNhY2hlPSAqLyBmYWxzZSksIHJlZi5jb252ZXJ0ZXIpKTtcbiAgICB9XG59XG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBnaXZlbiBgdXBkYXRlRnVuY3Rpb25gIGFuZCB0aGVuIGF0dGVtcHRzIHRvIGNvbW1pdCB0aGUgY2hhbmdlc1xuICogYXBwbGllZCB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uLiBJZiBhbnkgZG9jdW1lbnQgcmVhZCB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uXG4gKiBoYXMgY2hhbmdlZCwgQ2xvdWQgRmlyZXN0b3JlIHJldHJpZXMgdGhlIGB1cGRhdGVGdW5jdGlvbmAuIElmIGl0IGZhaWxzIHRvXG4gKiBjb21taXQgYWZ0ZXIgNSBhdHRlbXB0cywgdGhlIHRyYW5zYWN0aW9uIGZhaWxzLlxuICpcbiAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiB3cml0ZXMgYWxsb3dlZCBpbiBhIHNpbmdsZSB0cmFuc2FjdGlvbiBpcyA1MDAuXG4gKlxuICogQHBhcmFtIGZpcmVzdG9yZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBGaXJlc3RvcmUgZGF0YWJhc2UgdG8gcnVuIHRoaXNcbiAqIHRyYW5zYWN0aW9uIGFnYWluc3QuXG4gKiBAcGFyYW0gdXBkYXRlRnVuY3Rpb24gLSBUaGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uXG4gKiBjb250ZXh0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25zIG9iamVjdCB0byBjb25maWd1cmUgbWF4aW11bSBudW1iZXIgb2YgYXR0ZW1wdHMgdG9cbiAqIGNvbW1pdC5cbiAqIEByZXR1cm5zIElmIHRoZSB0cmFuc2FjdGlvbiBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5IG9yIHdhcyBleHBsaWNpdGx5IGFib3J0ZWRcbiAqICh0aGUgYHVwZGF0ZUZ1bmN0aW9uYCByZXR1cm5lZCBhIGZhaWxlZCBwcm9taXNlKSwgdGhlIHByb21pc2UgcmV0dXJuZWQgYnkgdGhlXG4gKiBgdXBkYXRlRnVuY3Rpb24gYGlzIHJldHVybmVkIGhlcmUuIE90aGVyd2lzZSwgaWYgdGhlIHRyYW5zYWN0aW9uIGZhaWxlZCwgYVxuICogcmVqZWN0ZWQgcHJvbWlzZSB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGZhaWx1cmUgZXJyb3IgaXMgcmV0dXJuZWQuXG4gKi9cbmZ1bmN0aW9uIHJ1blRyYW5zYWN0aW9uKGZpcmVzdG9yZSwgdXBkYXRlRnVuY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcbiAgICBjb25zdCBvcHRpb25zV2l0aERlZmF1bHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1RSQU5TQUNUSU9OX09QVElPTlMpLCBvcHRpb25zKTtcbiAgICB2YWxpZGF0ZVRyYW5zYWN0aW9uT3B0aW9ucyhvcHRpb25zV2l0aERlZmF1bHRzKTtcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudFRyYW5zYWN0aW9uKGNsaWVudCwgaW50ZXJuYWxUcmFuc2FjdGlvbiA9PiB1cGRhdGVGdW5jdGlvbihuZXcgVHJhbnNhY3Rpb24oZmlyZXN0b3JlLCBpbnRlcm5hbFRyYW5zYWN0aW9uKSksIG9wdGlvbnNXaXRoRGVmYXVsdHMpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXR1cm5zIGEgc2VudGluZWwgZm9yIHVzZSB3aXRoIHtAbGluayBAZmlyZWJhc2UvZmlyZXN0b3JlL2xpdGUjKHVwZGF0ZURvYzoxKX0gb3JcbiAqIHtAbGluayBAZmlyZWJhc2UvZmlyZXN0b3JlL2xpdGUjKHNldERvYzoxKX0gd2l0aCBge21lcmdlOiB0cnVlfWAgdG8gbWFyayBhIGZpZWxkIGZvciBkZWxldGlvbi5cbiAqL1xuZnVuY3Rpb24gZGVsZXRlRmllbGQoKSB7XG4gICAgcmV0dXJuIG5ldyBEZWxldGVGaWVsZFZhbHVlSW1wbCgnZGVsZXRlRmllbGQnKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHNlbnRpbmVsIHVzZWQgd2l0aCB7QGxpbmsgQGZpcmViYXNlL2ZpcmVzdG9yZS9saXRlIyhzZXREb2M6MSl9IG9yIHtAbGluayBAZmlyZWJhc2UvZmlyZXN0b3JlL2xpdGUjKHVwZGF0ZURvYzoxKX0gdG9cbiAqIGluY2x1ZGUgYSBzZXJ2ZXItZ2VuZXJhdGVkIHRpbWVzdGFtcCBpbiB0aGUgd3JpdHRlbiBkYXRhLlxuICovXG5mdW5jdGlvbiBzZXJ2ZXJUaW1lc3RhbXAoKSB7XG4gICAgcmV0dXJuIG5ldyBTZXJ2ZXJUaW1lc3RhbXBGaWVsZFZhbHVlSW1wbCgnc2VydmVyVGltZXN0YW1wJyk7XG59XG4vKipcbiAqIFJldHVybnMgYSBzcGVjaWFsIHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCB7QGxpbmsgQGZpcmViYXNlL2ZpcmVzdG9yZS9saXRlIyhzZXREb2M6MSl9IG9yIHtAbGlua1xuICogQGZpcmViYXNlL2ZpcmVzdG9yZS9saXRlIyh1cGRhdGVEb2M6MSl9IHRoYXQgdGVsbHMgdGhlIHNlcnZlciB0byB1bmlvbiB0aGUgZ2l2ZW4gZWxlbWVudHMgd2l0aCBhbnkgYXJyYXlcbiAqIHZhbHVlIHRoYXQgYWxyZWFkeSBleGlzdHMgb24gdGhlIHNlcnZlci4gRWFjaCBzcGVjaWZpZWQgZWxlbWVudCB0aGF0IGRvZXNuJ3RcbiAqIGFscmVhZHkgZXhpc3QgaW4gdGhlIGFycmF5IHdpbGwgYmUgYWRkZWQgdG8gdGhlIGVuZC4gSWYgdGhlIGZpZWxkIGJlaW5nXG4gKiBtb2RpZmllZCBpcyBub3QgYWxyZWFkeSBhbiBhcnJheSBpdCB3aWxsIGJlIG92ZXJ3cml0dGVuIHdpdGggYW4gYXJyYXlcbiAqIGNvbnRhaW5pbmcgZXhhY3RseSB0aGUgc3BlY2lmaWVkIGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSBlbGVtZW50cyAtIFRoZSBlbGVtZW50cyB0byB1bmlvbiBpbnRvIHRoZSBhcnJheS5cbiAqIEByZXR1cm5zIFRoZSBgRmllbGRWYWx1ZWAgc2VudGluZWwgZm9yIHVzZSBpbiBhIGNhbGwgdG8gYHNldERvYygpYCBvclxuICogYHVwZGF0ZURvYygpYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlVbmlvbiguLi5lbGVtZW50cykge1xuICAgIC8vIE5PVEU6IFdlIGRvbid0IGFjdHVhbGx5IHBhcnNlIHRoZSBkYXRhIHVudGlsIGl0J3MgdXNlZCBpbiBzZXQoKSBvclxuICAgIC8vIHVwZGF0ZSgpIHNpbmNlIHdlJ2QgbmVlZCB0aGUgRmlyZXN0b3JlIGluc3RhbmNlIHRvIGRvIHRoaXMuXG4gICAgcmV0dXJuIG5ldyBBcnJheVVuaW9uRmllbGRWYWx1ZUltcGwoJ2FycmF5VW5pb24nLCBlbGVtZW50cyk7XG59XG4vKipcbiAqIFJldHVybnMgYSBzcGVjaWFsIHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCB7QGxpbmsgKHNldERvYzoxKX0gb3Ige0BsaW5rXG4gKiB1cGRhdGVEb2M6MX0gdGhhdCB0ZWxscyB0aGUgc2VydmVyIHRvIHJlbW92ZSB0aGUgZ2l2ZW4gZWxlbWVudHMgZnJvbSBhbnlcbiAqIGFycmF5IHZhbHVlIHRoYXQgYWxyZWFkeSBleGlzdHMgb24gdGhlIHNlcnZlci4gQWxsIGluc3RhbmNlcyBvZiBlYWNoIGVsZW1lbnRcbiAqIHNwZWNpZmllZCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgYXJyYXkuIElmIHRoZSBmaWVsZCBiZWluZyBtb2RpZmllZCBpcyBub3RcbiAqIGFscmVhZHkgYW4gYXJyYXkgaXQgd2lsbCBiZSBvdmVyd3JpdHRlbiB3aXRoIGFuIGVtcHR5IGFycmF5LlxuICpcbiAqIEBwYXJhbSBlbGVtZW50cyAtIFRoZSBlbGVtZW50cyB0byByZW1vdmUgZnJvbSB0aGUgYXJyYXkuXG4gKiBAcmV0dXJucyBUaGUgYEZpZWxkVmFsdWVgIHNlbnRpbmVsIGZvciB1c2UgaW4gYSBjYWxsIHRvIGBzZXREb2MoKWAgb3JcbiAqIGB1cGRhdGVEb2MoKWBcbiAqL1xuZnVuY3Rpb24gYXJyYXlSZW1vdmUoLi4uZWxlbWVudHMpIHtcbiAgICAvLyBOT1RFOiBXZSBkb24ndCBhY3R1YWxseSBwYXJzZSB0aGUgZGF0YSB1bnRpbCBpdCdzIHVzZWQgaW4gc2V0KCkgb3JcbiAgICAvLyB1cGRhdGUoKSBzaW5jZSB3ZSdkIG5lZWQgdGhlIEZpcmVzdG9yZSBpbnN0YW5jZSB0byBkbyB0aGlzLlxuICAgIHJldHVybiBuZXcgQXJyYXlSZW1vdmVGaWVsZFZhbHVlSW1wbCgnYXJyYXlSZW1vdmUnLCBlbGVtZW50cyk7XG59XG4vKipcbiAqIFJldHVybnMgYSBzcGVjaWFsIHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCB7QGxpbmsgQGZpcmViYXNlL2ZpcmVzdG9yZS9saXRlIyhzZXREb2M6MSl9IG9yIHtAbGlua1xuICogQGZpcmViYXNlL2ZpcmVzdG9yZS9saXRlIyh1cGRhdGVEb2M6MSl9IHRoYXQgdGVsbHMgdGhlIHNlcnZlciB0byBpbmNyZW1lbnQgdGhlIGZpZWxkJ3MgY3VycmVudCB2YWx1ZSBieVxuICogdGhlIGdpdmVuIHZhbHVlLlxuICpcbiAqIElmIGVpdGhlciB0aGUgb3BlcmFuZCBvciB0aGUgY3VycmVudCBmaWVsZCB2YWx1ZSB1c2VzIGZsb2F0aW5nIHBvaW50XG4gKiBwcmVjaXNpb24sIGFsbCBhcml0aG1ldGljIGZvbGxvd3MgSUVFRSA3NTQgc2VtYW50aWNzLiBJZiBib3RoIHZhbHVlcyBhcmVcbiAqIGludGVnZXJzLCB2YWx1ZXMgb3V0c2lkZSBvZiBKYXZhU2NyaXB0J3Mgc2FmZSBudW1iZXIgcmFuZ2VcbiAqIChgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVJgIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmApIGFyZSBhbHNvIHN1YmplY3QgdG9cbiAqIHByZWNpc2lvbiBsb3NzLiBGdXJ0aGVybW9yZSwgb25jZSBwcm9jZXNzZWQgYnkgdGhlIEZpcmVzdG9yZSBiYWNrZW5kLCBhbGxcbiAqIGludGVnZXIgb3BlcmF0aW9ucyBhcmUgY2FwcGVkIGJldHdlZW4gLTJeNjMgYW5kIDJeNjMtMS5cbiAqXG4gKiBJZiB0aGUgY3VycmVudCBmaWVsZCB2YWx1ZSBpcyBub3Qgb2YgdHlwZSBgbnVtYmVyYCwgb3IgaWYgdGhlIGZpZWxkIGRvZXMgbm90XG4gKiB5ZXQgZXhpc3QsIHRoZSB0cmFuc2Zvcm1hdGlvbiBzZXRzIHRoZSBmaWVsZCB0byB0aGUgZ2l2ZW4gdmFsdWUuXG4gKlxuICogQHBhcmFtIG4gLSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IGJ5LlxuICogQHJldHVybnMgVGhlIGBGaWVsZFZhbHVlYCBzZW50aW5lbCBmb3IgdXNlIGluIGEgY2FsbCB0byBgc2V0RG9jKClgIG9yXG4gKiBgdXBkYXRlRG9jKClgXG4gKi9cbmZ1bmN0aW9uIGluY3JlbWVudChuKSB7XG4gICAgcmV0dXJuIG5ldyBOdW1lcmljSW5jcmVtZW50RmllbGRWYWx1ZUltcGwoJ2luY3JlbWVudCcsIG4pO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBWZWN0b3JWYWx1ZWAgY29uc3RydWN0ZWQgd2l0aCBhIGNvcHkgb2YgdGhlIGdpdmVuIGFycmF5IG9mIG51bWJlcnMuXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIENyZWF0ZSBhIGBWZWN0b3JWYWx1ZWAgaW5zdGFuY2Ugd2l0aCBhIGNvcHkgb2YgdGhpcyBhcnJheSBvZiBudW1iZXJzLlxuICpcbiAqIEByZXR1cm5zIEEgbmV3IGBWZWN0b3JWYWx1ZWAgY29uc3RydWN0ZWQgd2l0aCBhIGNvcHkgb2YgdGhlIGdpdmVuIGFycmF5IG9mIG51bWJlcnMuXG4gKi9cbmZ1bmN0aW9uIHZlY3Rvcih2YWx1ZXMpIHtcbiAgICByZXR1cm4gbmV3IFZlY3RvclZhbHVlKHZhbHVlcyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIENyZWF0ZXMgYSB3cml0ZSBiYXRjaCwgdXNlZCBmb3IgcGVyZm9ybWluZyBtdWx0aXBsZSB3cml0ZXMgYXMgYSBzaW5nbGVcbiAqIGF0b21pYyBvcGVyYXRpb24uIFRoZSBtYXhpbXVtIG51bWJlciBvZiB3cml0ZXMgYWxsb3dlZCBpbiBhIHNpbmdsZSB7QGxpbmsgV3JpdGVCYXRjaH1cbiAqIGlzIDUwMC5cbiAqXG4gKiBVbmxpa2UgdHJhbnNhY3Rpb25zLCB3cml0ZSBiYXRjaGVzIGFyZSBwZXJzaXN0ZWQgb2ZmbGluZSBhbmQgdGhlcmVmb3JlIGFyZVxuICogcHJlZmVyYWJsZSB3aGVuIHlvdSBkb24ndCBuZWVkIHRvIGNvbmRpdGlvbiB5b3VyIHdyaXRlcyBvbiByZWFkIGRhdGEuXG4gKlxuICogQHJldHVybnMgQSB7QGxpbmsgV3JpdGVCYXRjaH0gdGhhdCBjYW4gYmUgdXNlZCB0byBhdG9taWNhbGx5IGV4ZWN1dGUgbXVsdGlwbGVcbiAqIHdyaXRlcy5cbiAqL1xuZnVuY3Rpb24gd3JpdGVCYXRjaChmaXJlc3RvcmUpIHtcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcbiAgICBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XG4gICAgcmV0dXJuIG5ldyBXcml0ZUJhdGNoKGZpcmVzdG9yZSwgbXV0YXRpb25zID0+IGV4ZWN1dGVXcml0ZShmaXJlc3RvcmUsIG11dGF0aW9ucykpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gc2V0SW5kZXhDb25maWd1cmF0aW9uKGZpcmVzdG9yZSwganNvbk9yQ29uZmlndXJhdGlvbikge1xuICAgIGZpcmVzdG9yZSA9IGNhc3QoZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcbiAgICBpZiAoIWNsaWVudC5fdW5pbml0aWFsaXplZENvbXBvbmVudHNQcm92aWRlciB8fFxuICAgICAgICBjbGllbnQuX3VuaW5pdGlhbGl6ZWRDb21wb25lbnRzUHJvdmlkZXIuX29mZmxpbmUua2luZCA9PT0gJ21lbW9yeScpIHtcbiAgICAgICAgLy8gUE9SVElORyBOT1RFOiBXZSBkb24ndCByZXR1cm4gYW4gZXJyb3IgaWYgdGhlIHVzZXIgaGFzIG5vdCBlbmFibGVkXG4gICAgICAgIC8vIHBlcnNpc3RlbmNlIHNpbmNlIGBlbmFibGVJbmRleGVkZGJQZXJzaXN0ZW5jZSgpYCBjYW4gZmFpbCBvbiB0aGUgV2ViLlxuICAgICAgICBsb2dXYXJuKCdDYW5ub3QgZW5hYmxlIGluZGV4ZXMgd2hlbiBwZXJzaXN0ZW5jZSBpcyBkaXNhYmxlZCcpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZEluZGV4ZXMgPSBwYXJzZUluZGV4ZXMoanNvbk9yQ29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudFNldEluZGV4Q29uZmlndXJhdGlvbihjbGllbnQsIHBhcnNlZEluZGV4ZXMpO1xufVxuZnVuY3Rpb24gcGFyc2VJbmRleGVzKGpzb25PckNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBpbmRleENvbmZpZ3VyYXRpb24gPSB0eXBlb2YganNvbk9yQ29uZmlndXJhdGlvbiA9PT0gJ3N0cmluZydcbiAgICAgICAgPyB0cnlQYXJzZUpzb24oanNvbk9yQ29uZmlndXJhdGlvbilcbiAgICAgICAgOiBqc29uT3JDb25maWd1cmF0aW9uO1xuICAgIGNvbnN0IHBhcnNlZEluZGV4ZXMgPSBbXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbmRleENvbmZpZ3VyYXRpb24uaW5kZXhlcykpIHtcbiAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBpbmRleENvbmZpZ3VyYXRpb24uaW5kZXhlcykge1xuICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvbkdyb3VwID0gdHJ5R2V0U3RyaW5nKGluZGV4LCAnY29sbGVjdGlvbkdyb3VwJyk7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50cyA9IFtdO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5kZXguZmllbGRzKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgaW5kZXguZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkUGF0aFN0cmluZyA9IHRyeUdldFN0cmluZyhmaWVsZCwgJ2ZpZWxkUGF0aCcpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFBhdGggPSBmaWVsZFBhdGhGcm9tRG90U2VwYXJhdGVkU3RyaW5nKCdzZXRJbmRleENvbmZpZ3VyYXRpb24nLCBmaWVsZFBhdGhTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQuYXJyYXlDb25maWcgPT09ICdDT05UQUlOUycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2gobmV3IEluZGV4U2VnbWVudChmaWVsZFBhdGgsIDIgLyogSW5kZXhLaW5kLkNPTlRBSU5TICovKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQub3JkZXIgPT09ICdBU0NFTkRJTkcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKG5ldyBJbmRleFNlZ21lbnQoZmllbGRQYXRoLCAwIC8qIEluZGV4S2luZC5BU0NFTkRJTkcgKi8pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5vcmRlciA9PT0gJ0RFU0NFTkRJTkcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKG5ldyBJbmRleFNlZ21lbnQoZmllbGRQYXRoLCAxIC8qIEluZGV4S2luZC5ERVNDRU5ESU5HICovKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZWRJbmRleGVzLnB1c2gobmV3IEZpZWxkSW5kZXgoRmllbGRJbmRleC5VTktOT1dOX0lELCBjb2xsZWN0aW9uR3JvdXAsIHNlZ21lbnRzLCBJbmRleFN0YXRlLmVtcHR5KCkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkSW5kZXhlcztcbn1cbmZ1bmN0aW9uIHRyeVBhcnNlSnNvbihqc29uKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvbik7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdGYWlsZWQgdG8gcGFyc2UgSlNPTjogJyArIChlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyeUdldFN0cmluZyhkYXRhLCBwcm9wZXJ0eSkge1xuICAgIGlmICh0eXBlb2YgZGF0YVtwcm9wZXJ0eV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdNaXNzaW5nIHN0cmluZyB2YWx1ZSBmb3I6ICcgKyBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhW3Byb3BlcnR5XTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSBgUGVyc2lzdGVudENhY2hlSW5kZXhNYW5hZ2VyYCBmb3IgY29uZmlndXJpbmcgcGVyc2lzdGVudCBjYWNoZSBpbmRleGVzIHVzZWRcbiAqIGZvciBsb2NhbCBxdWVyeSBleGVjdXRpb24uXG4gKlxuICogVG8gdXNlLCBjYWxsIGBnZXRQZXJzaXN0ZW50Q2FjaGVJbmRleE1hbmFnZXIoKWAgdG8gZ2V0IGFuIGluc3RhbmNlLlxuICovXG5jbGFzcyBQZXJzaXN0ZW50Q2FjaGVJbmRleE1hbmFnZXIge1xuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXG4gICAgY29uc3RydWN0b3IoX2ZpcmVzdG9yZSkge1xuICAgICAgICB0aGlzLl9maXJlc3RvcmUgPSBfZmlyZXN0b3JlO1xuICAgICAgICAvKiogQSB0eXBlIHN0cmluZyB0byB1bmlxdWVseSBpZGVudGlmeSBpbnN0YW5jZXMgb2YgdGhpcyBjbGFzcy4gKi9cbiAgICAgICAgdGhpcy50eXBlID0gJ1BlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlcic7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBQZXJzaXN0ZW50Q2FjaGUgSW5kZXggTWFuYWdlciB1c2VkIGJ5IHRoZSBnaXZlbiBgRmlyZXN0b3JlYFxuICogb2JqZWN0LlxuICpcbiAqIEByZXR1cm4gVGhlIGBQZXJzaXN0ZW50Q2FjaGVJbmRleE1hbmFnZXJgIGluc3RhbmNlLCBvciBgbnVsbGAgaWYgbG9jYWxcbiAqIHBlcnNpc3RlbnQgc3RvcmFnZSBpcyBub3QgaW4gdXNlLlxuICovXG5mdW5jdGlvbiBnZXRQZXJzaXN0ZW50Q2FjaGVJbmRleE1hbmFnZXIoZmlyZXN0b3JlKSB7XG4gICAgdmFyIF9hO1xuICAgIGZpcmVzdG9yZSA9IGNhc3QoZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgIGNvbnN0IGNhY2hlZEluc3RhbmNlID0gcGVyc2lzdGVudENhY2hlSW5kZXhNYW5hZ2VyQnlGaXJlc3RvcmUuZ2V0KGZpcmVzdG9yZSk7XG4gICAgaWYgKGNhY2hlZEluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRJbnN0YW5jZTtcbiAgICB9XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIGlmICgoKF9hID0gY2xpZW50Ll91bmluaXRpYWxpemVkQ29tcG9uZW50c1Byb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX29mZmxpbmUua2luZCkgIT09ICdwZXJzaXN0ZW50Jykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgUGVyc2lzdGVudENhY2hlSW5kZXhNYW5hZ2VyKGZpcmVzdG9yZSk7XG4gICAgcGVyc2lzdGVudENhY2hlSW5kZXhNYW5hZ2VyQnlGaXJlc3RvcmUuc2V0KGZpcmVzdG9yZSwgaW5zdGFuY2UpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cbi8qKlxuICogRW5hYmxlcyB0aGUgU0RLIHRvIGNyZWF0ZSBwZXJzaXN0ZW50IGNhY2hlIGluZGV4ZXMgYXV0b21hdGljYWxseSBmb3IgbG9jYWxcbiAqIHF1ZXJ5IGV4ZWN1dGlvbiB3aGVuIHRoZSBTREsgYmVsaWV2ZXMgY2FjaGUgaW5kZXhlcyBjYW4gaGVscCBpbXByb3ZlXG4gKiBwZXJmb3JtYW5jZS5cbiAqXG4gKiBUaGlzIGZlYXR1cmUgaXMgZGlzYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuZnVuY3Rpb24gZW5hYmxlUGVyc2lzdGVudENhY2hlSW5kZXhBdXRvQ3JlYXRpb24oaW5kZXhNYW5hZ2VyKSB7XG4gICAgc2V0UGVyc2lzdGVudENhY2hlSW5kZXhBdXRvQ3JlYXRpb25FbmFibGVkKGluZGV4TWFuYWdlciwgdHJ1ZSk7XG59XG4vKipcbiAqIFN0b3BzIGNyZWF0aW5nIHBlcnNpc3RlbnQgY2FjaGUgaW5kZXhlcyBhdXRvbWF0aWNhbGx5IGZvciBsb2NhbCBxdWVyeVxuICogZXhlY3V0aW9uLiBUaGUgaW5kZXhlcyB3aGljaCBoYXZlIGJlZW4gY3JlYXRlZCBieSBjYWxsaW5nXG4gKiBgZW5hYmxlUGVyc2lzdGVudENhY2hlSW5kZXhBdXRvQ3JlYXRpb24oKWAgc3RpbGwgdGFrZSBlZmZlY3QuXG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVQZXJzaXN0ZW50Q2FjaGVJbmRleEF1dG9DcmVhdGlvbihpbmRleE1hbmFnZXIpIHtcbiAgICBzZXRQZXJzaXN0ZW50Q2FjaGVJbmRleEF1dG9DcmVhdGlvbkVuYWJsZWQoaW5kZXhNYW5hZ2VyLCBmYWxzZSk7XG59XG4vKipcbiAqIFJlbW92ZXMgYWxsIHBlcnNpc3RlbnQgY2FjaGUgaW5kZXhlcy5cbiAqXG4gKiBQbGVhc2Ugbm90ZSB0aGlzIGZ1bmN0aW9uIHdpbGwgYWxzbyBkZWxldGVzIGluZGV4ZXMgZ2VuZXJhdGVkIGJ5XG4gKiBgc2V0SW5kZXhDb25maWd1cmF0aW9uKClgLCB3aGljaCBpcyBkZXByZWNhdGVkLlxuICovXG5mdW5jdGlvbiBkZWxldGVBbGxQZXJzaXN0ZW50Q2FjaGVJbmRleGVzKGluZGV4TWFuYWdlcikge1xuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoaW5kZXhNYW5hZ2VyLl9maXJlc3RvcmUpO1xuICAgIGNvbnN0IHByb21pc2UgPSBmaXJlc3RvcmVDbGllbnREZWxldGVBbGxGaWVsZEluZGV4ZXMoY2xpZW50KTtcbiAgICBwcm9taXNlXG4gICAgICAgIC50aGVuKF8gPT4gbG9nRGVidWcoJ2RlbGV0aW5nIGFsbCBwZXJzaXN0ZW50IGNhY2hlIGluZGV4ZXMgc3VjY2VlZGVkJykpXG4gICAgICAgIC5jYXRjaChlcnJvciA9PiBsb2dXYXJuKCdkZWxldGluZyBhbGwgcGVyc2lzdGVudCBjYWNoZSBpbmRleGVzIGZhaWxlZCcsIGVycm9yKSk7XG59XG5mdW5jdGlvbiBzZXRQZXJzaXN0ZW50Q2FjaGVJbmRleEF1dG9DcmVhdGlvbkVuYWJsZWQoaW5kZXhNYW5hZ2VyLCBpc0VuYWJsZWQpIHtcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGluZGV4TWFuYWdlci5fZmlyZXN0b3JlKTtcbiAgICBjb25zdCBwcm9taXNlID0gZmlyZXN0b3JlQ2xpZW50U2V0UGVyc2lzdGVudENhY2hlSW5kZXhBdXRvQ3JlYXRpb25FbmFibGVkKGNsaWVudCwgaXNFbmFibGVkKTtcbiAgICBwcm9taXNlXG4gICAgICAgIC50aGVuKF8gPT4gbG9nRGVidWcoYHNldHRpbmcgcGVyc2lzdGVudCBjYWNoZSBpbmRleCBhdXRvIGNyZWF0aW9uIGAgK1xuICAgICAgICBgaXNFbmFibGVkPSR7aXNFbmFibGVkfSBzdWNjZWVkZWRgKSlcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IGxvZ1dhcm4oYHNldHRpbmcgcGVyc2lzdGVudCBjYWNoZSBpbmRleCBhdXRvIGNyZWF0aW9uIGAgK1xuICAgICAgICBgaXNFbmFibGVkPSR7aXNFbmFibGVkfSBmYWlsZWRgLCBlcnJvcikpO1xufVxuLyoqXG4gKiBNYXBzIGBGaXJlc3RvcmVgIGluc3RhbmNlcyB0byB0aGVpciBjb3JyZXNwb25kaW5nXG4gKiBgUGVyc2lzdGVudENhY2hlSW5kZXhNYW5hZ2VyYCBpbnN0YW5jZXMuXG4gKlxuICogVXNlIGEgYFdlYWtNYXBgIHNvIHRoYXQgdGhlIG1hcHBpbmcgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGRyb3BwZWQgd2hlbiB0aGVcbiAqIGBGaXJlc3RvcmVgIGluc3RhbmNlIGlzIGdhcmJhZ2UgY29sbGVjdGVkLiBUaGlzIGVtdWxhdGVzIGEgcHJpdmF0ZSBtZW1iZXJcbiAqIGFzIGRlc2NyaWJlZCBpbiBodHRwczovL2dvby5nbGUvNDU0eXZ1Zy5cbiAqL1xuY29uc3QgcGVyc2lzdGVudENhY2hlSW5kZXhNYW5hZ2VyQnlGaXJlc3RvcmUgPSBuZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBwcml2YXRlXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBmb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4gKlxuICogUmV0dXJucyB0aGUgYFF1ZXJ5VGFyZ2V0YCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gcXVlcnkuIFJldHVybnMgYG51bGxgXG4gKiBpZiB0aGUgRmlyZXN0b3JlIGNsaWVudCBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIHF1ZXJ5IGhhcyBub3QgYmVlblxuICogaW5pdGlhbGl6ZWQgb3IgaGFzIGJlZW4gdGVybWluYXRlZC5cbiAqXG4gKiBAcGFyYW0gcXVlcnkgLSBUaGUgUXVlcnkgdG8gY29udmVydCB0byBwcm90byByZXByZXNlbnRhdGlvbi5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIF9pbnRlcm5hbFF1ZXJ5VG9Qcm90b1F1ZXJ5VGFyZ2V0KHF1ZXJ5KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGZpcmVzdG9yZSA9IGNhc3QocXVlcnkuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcbiAgICBjb25zdCBzZXJpYWxpemVyID0gKF9hID0gY2xpZW50Ll9vbmxpbmVDb21wb25lbnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGF0YXN0b3JlLnNlcmlhbGl6ZXI7XG4gICAgaWYgKHNlcmlhbGl6ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRvUXVlcnlUYXJnZXQoc2VyaWFsaXplciwgcXVlcnlUb1RhcmdldChxdWVyeS5fcXVlcnkpKS5xdWVyeVRhcmdldDtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAcHJpdmF0ZVxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgZm9yIGludGVybmFsIHVzZSBvbmx5LlxuICpcbiAqIFJldHVybnMgYFJ1bkFnZ3JlZ2F0aW9uUXVlcnlSZXF1ZXN0YCB3aGljaCBjb250YWlucyB0aGUgcHJvdG8gcmVwcmVzZW50YXRpb25cbiAqIG9mIHRoZSBnaXZlbiBhZ2dyZWdhdGlvbiBxdWVyeSByZXF1ZXN0LiBSZXR1cm5zIG51bGwgaWYgdGhlIEZpcmVzdG9yZSBjbGllbnRcbiAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gcXVlcnkgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIG9yIGhhcyBiZWVuXG4gKiB0ZXJtaW5hdGVkLlxuICpcbiAqIEBwYXJhbSBxdWVyeSAtIFRoZSBRdWVyeSB0byBjb252ZXJ0IHRvIHByb3RvIHJlcHJlc2VudGF0aW9uLlxuICogQHBhcmFtIGFnZ3JlZ2F0ZVNwZWMgLSBUaGUgc2V0IG9mIGFnZ3JlZ2F0aW9ucyBhbmQgdGhlaXIgYWxpYXNlcy5cbiAqL1xuZnVuY3Rpb24gX2ludGVybmFsQWdncmVnYXRpb25RdWVyeVRvUHJvdG9SdW5BZ2dyZWdhdGlvblF1ZXJ5UmVxdWVzdChxdWVyeSwgYWdncmVnYXRlU3BlYykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBhZ2dyZWdhdGVzID0gbWFwVG9BcnJheShhZ2dyZWdhdGVTcGVjLCAoYWdncmVnYXRlLCBhbGlhcykgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IEFnZ3JlZ2F0ZUltcGwoYWxpYXMsIGFnZ3JlZ2F0ZS5hZ2dyZWdhdGVUeXBlLCBhZ2dyZWdhdGUuX2ludGVybmFsRmllbGRQYXRoKTtcbiAgICB9KTtcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHF1ZXJ5LmZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XG4gICAgY29uc3Qgc2VyaWFsaXplciA9IChfYSA9IGNsaWVudC5fb25saW5lQ29tcG9uZW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRhdGFzdG9yZS5zZXJpYWxpemVyO1xuICAgIGlmIChzZXJpYWxpemVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0b1J1bkFnZ3JlZ2F0aW9uUXVlcnlSZXF1ZXN0KHNlcmlhbGl6ZXIsIHF1ZXJ5VG9BZ2dyZWdhdGVUYXJnZXQocXVlcnkuX3F1ZXJ5KSwgYWdncmVnYXRlcywgXG4gICAgLyogc2tpcEFsaWFzaW5nPSAqLyB0cnVlKS5yZXF1ZXN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUZXN0aW5nIGhvb2tzIGZvciB1c2UgYnkgRmlyZXN0b3JlJ3MgaW50ZWdyYXRpb24gdGVzdCBzdWl0ZSB0byByZWFjaCBpbnRvIHRoZVxuICogU0RLIGludGVybmFscyB0byB2YWxpZGF0ZSBsb2dpYyBhbmQgYmVoYXZpb3IgdGhhdCBpcyBub3QgdmlzaWJsZSBmcm9tIHRoZVxuICogcHVibGljIEFQSSBzdXJmYWNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBUZXN0aW5nSG9va3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luc3RhbmNlcyBvZiB0aGlzIGNsYXNzIHNob3VsZCBub3QgYmUgY3JlYXRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0byBiZSBub3RpZmllZCB3aGVuIGFuIGV4aXN0ZW5jZSBmaWx0ZXIgbWlzbWF0Y2hcbiAgICAgKiBvY2N1cnMgaW4gdGhlIFdhdGNoIGxpc3RlbiBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBUaGUgcmVsYXRpdmUgb3JkZXIgaW4gd2hpY2ggY2FsbGJhY2tzIGFyZSBub3RpZmllZCBpcyB1bnNwZWNpZmllZDsgZG8gbm90XG4gICAgICogcmVseSBvbiBhbnkgcGFydGljdWxhciBvcmRlcmluZy4gSWYgYSBnaXZlbiBjYWxsYmFjayBpcyByZWdpc3RlcmVkIG11bHRpcGxlXG4gICAgICogdGltZXMgdGhlbiBpdCB3aWxsIGJlIG5vdGlmaWVkIG11bHRpcGxlIHRpbWVzLCBvbmNlIHBlciByZWdpc3RyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIHRvIGludm9rZSB1cG9uIGV4aXN0ZW5jZSBmaWx0ZXIgbWlzbWF0Y2guXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIHVucmVnaXN0ZXJzIHRoZSBnaXZlbiBjYWxsYmFjazsgb25seVxuICAgICAqIHRoZSBmaXJzdCBpbnZvY2F0aW9uIG9mIHRoZSByZXR1cm5lZCBmdW5jdGlvbiBkb2VzIGFueXRoaW5nOyBhbGwgc3Vic2VxdWVudFxuICAgICAqIGludm9jYXRpb25zIGRvIG5vdGhpbmcuXG4gICAgICovXG4gICAgc3RhdGljIG9uRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2goY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIFRlc3RpbmdIb29rc1NwaUltcGwuaW5zdGFuY2Uub25FeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaChjYWxsYmFjayk7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgYFRlc3RpbmdIb29rc1NwaWAuXG4gKi9cbmNsYXNzIFRlc3RpbmdIb29rc1NwaUltcGwge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmV4aXN0ZW5jZUZpbHRlck1pc21hdGNoQ2FsbGJhY2tzQnlJZCA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBpbnN0YW5jZSgpIHtcbiAgICAgICAgaWYgKCF0ZXN0aW5nSG9va3NTcGlJbXBsSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRlc3RpbmdIb29rc1NwaUltcGxJbnN0YW5jZSA9IG5ldyBUZXN0aW5nSG9va3NTcGlJbXBsKCk7XG4gICAgICAgICAgICBzZXRUZXN0aW5nSG9va3NTcGkodGVzdGluZ0hvb2tzU3BpSW1wbEluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVzdGluZ0hvb2tzU3BpSW1wbEluc3RhbmNlO1xuICAgIH1cbiAgICBub3RpZnlPbkV4aXN0ZW5jZUZpbHRlck1pc21hdGNoKGluZm8pIHtcbiAgICAgICAgdGhpcy5leGlzdGVuY2VGaWx0ZXJNaXNtYXRjaENhbGxiYWNrc0J5SWQuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayhpbmZvKSk7XG4gICAgfVxuICAgIG9uRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2goY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgaWQgPSBTeW1ib2woKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5leGlzdGVuY2VGaWx0ZXJNaXNtYXRjaENhbGxiYWNrc0J5SWQ7XG4gICAgICAgIGNhbGxiYWNrcy5zZXQoaWQsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGNhbGxiYWNrcy5kZWxldGUoaWQpO1xuICAgIH1cbn1cbmxldCB0ZXN0aW5nSG9va3NTcGlJbXBsSW5zdGFuY2UgPSBudWxsO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xucmVnaXN0ZXJGaXJlc3RvcmUoJ25vZGUnKTtcblxuZXhwb3J0IHsgQWJzdHJhY3RVc2VyRGF0YVdyaXRlciwgQWdncmVnYXRlRmllbGQsIEFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3QsIEJ5dGVzLCBDQUNIRV9TSVpFX1VOTElNSVRFRCwgQ29sbGVjdGlvblJlZmVyZW5jZSwgRG9jdW1lbnRSZWZlcmVuY2UsIERvY3VtZW50U25hcHNob3QsIEZpZWxkUGF0aCwgRmllbGRWYWx1ZSwgRmlyZXN0b3JlLCBGaXJlc3RvcmVFcnJvciwgR2VvUG9pbnQsIExvYWRCdW5kbGVUYXNrLCBQZXJzaXN0ZW50Q2FjaGVJbmRleE1hbmFnZXIsIFF1ZXJ5LCBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnQsIFF1ZXJ5Q29uc3RyYWludCwgUXVlcnlEb2N1bWVudFNuYXBzaG90LCBRdWVyeUVuZEF0Q29uc3RyYWludCwgUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnQsIFF1ZXJ5TGltaXRDb25zdHJhaW50LCBRdWVyeU9yZGVyQnlDb25zdHJhaW50LCBRdWVyeVNuYXBzaG90LCBRdWVyeVN0YXJ0QXRDb25zdHJhaW50LCBTbmFwc2hvdE1ldGFkYXRhLCBUaW1lc3RhbXAsIFRyYW5zYWN0aW9uLCBWZWN0b3JWYWx1ZSwgV3JpdGVCYXRjaCwgQXV0b0lkIGFzIF9BdXRvSWQsIEJ5dGVTdHJpbmcgYXMgX0J5dGVTdHJpbmcsIERhdGFiYXNlSWQgYXMgX0RhdGFiYXNlSWQsIERvY3VtZW50S2V5IGFzIF9Eb2N1bWVudEtleSwgRW1wdHlBcHBDaGVja1Rva2VuUHJvdmlkZXIgYXMgX0VtcHR5QXBwQ2hlY2tUb2tlblByb3ZpZGVyLCBFbXB0eUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyIGFzIF9FbXB0eUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyLCBGaWVsZFBhdGgkMSBhcyBfRmllbGRQYXRoLCBUZXN0aW5nSG9va3MgYXMgX1Rlc3RpbmdIb29rcywgY2FzdCBhcyBfY2FzdCwgZGVidWdBc3NlcnQgYXMgX2RlYnVnQXNzZXJ0LCBfaW50ZXJuYWxBZ2dyZWdhdGlvblF1ZXJ5VG9Qcm90b1J1bkFnZ3JlZ2F0aW9uUXVlcnlSZXF1ZXN0LCBfaW50ZXJuYWxRdWVyeVRvUHJvdG9RdWVyeVRhcmdldCwgaXNCYXNlNjRBdmFpbGFibGUgYXMgX2lzQmFzZTY0QXZhaWxhYmxlLCBsb2dXYXJuIGFzIF9sb2dXYXJuLCB2YWxpZGF0ZUlzTm90VXNlZFRvZ2V0aGVyIGFzIF92YWxpZGF0ZUlzTm90VXNlZFRvZ2V0aGVyLCBhZGREb2MsIGFnZ3JlZ2F0ZUZpZWxkRXF1YWwsIGFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3RFcXVhbCwgYW5kLCBhcnJheVJlbW92ZSwgYXJyYXlVbmlvbiwgYXZlcmFnZSwgY2xlYXJJbmRleGVkRGJQZXJzaXN0ZW5jZSwgY29sbGVjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBjb25uZWN0RmlyZXN0b3JlRW11bGF0b3IsIGNvdW50LCBkZWxldGVBbGxQZXJzaXN0ZW50Q2FjaGVJbmRleGVzLCBkZWxldGVEb2MsIGRlbGV0ZUZpZWxkLCBkaXNhYmxlTmV0d29yaywgZGlzYWJsZVBlcnNpc3RlbnRDYWNoZUluZGV4QXV0b0NyZWF0aW9uLCBkb2MsIGRvY3VtZW50SWQsIGVuYWJsZUluZGV4ZWREYlBlcnNpc3RlbmNlLCBlbmFibGVNdWx0aVRhYkluZGV4ZWREYlBlcnNpc3RlbmNlLCBlbmFibGVOZXR3b3JrLCBlbmFibGVQZXJzaXN0ZW50Q2FjaGVJbmRleEF1dG9DcmVhdGlvbiwgZW5kQXQsIGVuZEJlZm9yZSwgZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZCwgZXhlY3V0ZVdyaXRlLCBnZXRBZ2dyZWdhdGVGcm9tU2VydmVyLCBnZXRDb3VudEZyb21TZXJ2ZXIsIGdldERvYywgZ2V0RG9jRnJvbUNhY2hlLCBnZXREb2NGcm9tU2VydmVyLCBnZXREb2NzLCBnZXREb2NzRnJvbUNhY2hlLCBnZXREb2NzRnJvbVNlcnZlciwgZ2V0RmlyZXN0b3JlLCBnZXRQZXJzaXN0ZW50Q2FjaGVJbmRleE1hbmFnZXIsIGluY3JlbWVudCwgaW5pdGlhbGl6ZUZpcmVzdG9yZSwgbGltaXQsIGxpbWl0VG9MYXN0LCBsb2FkQnVuZGxlLCBtZW1vcnlFYWdlckdhcmJhZ2VDb2xsZWN0b3IsIG1lbW9yeUxvY2FsQ2FjaGUsIG1lbW9yeUxydUdhcmJhZ2VDb2xsZWN0b3IsIG5hbWVkUXVlcnksIG9uU25hcHNob3QsIG9uU25hcHNob3RzSW5TeW5jLCBvciwgb3JkZXJCeSwgcGVyc2lzdGVudExvY2FsQ2FjaGUsIHBlcnNpc3RlbnRNdWx0aXBsZVRhYk1hbmFnZXIsIHBlcnNpc3RlbnRTaW5nbGVUYWJNYW5hZ2VyLCBxdWVyeSwgcXVlcnlFcXVhbCwgcmVmRXF1YWwsIHJ1blRyYW5zYWN0aW9uLCBzZXJ2ZXJUaW1lc3RhbXAsIHNldERvYywgc2V0SW5kZXhDb25maWd1cmF0aW9uLCBzZXRMb2dMZXZlbCwgc25hcHNob3RFcXVhbCwgc3RhcnRBZnRlciwgc3RhcnRBdCwgc3VtLCB0ZXJtaW5hdGUsIHVwZGF0ZURvYywgdmVjdG9yLCB3YWl0Rm9yUGVuZGluZ1dyaXRlcywgd2hlcmUsIHdyaXRlQmF0Y2ggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/firestore/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@firebase/logger/dist/esm/index.esm2017.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   Logger: () => (/* binding */ Logger),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   setUserLogHandler: () => (/* binding */ setUserLogHandler)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A container for all of the Logger instances\n */\nconst instances = [];\n/**\n * The JS SDK supports 5 log levels and also allows a user the ability to\n * silence the logs altogether.\n *\n * The order is a follows:\n * DEBUG < VERBOSE < INFO < WARN < ERROR\n *\n * All of the log types above the current log level will be captured (i.e. if\n * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and\n * `VERBOSE` logs will not)\n */\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogLevel[LogLevel[\"VERBOSE\"] = 1] = \"VERBOSE\";\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n    LogLevel[LogLevel[\"WARN\"] = 3] = \"WARN\";\n    LogLevel[LogLevel[\"ERROR\"] = 4] = \"ERROR\";\n    LogLevel[LogLevel[\"SILENT\"] = 5] = \"SILENT\";\n})(LogLevel || (LogLevel = {}));\nconst levelStringToEnum = {\n    'debug': LogLevel.DEBUG,\n    'verbose': LogLevel.VERBOSE,\n    'info': LogLevel.INFO,\n    'warn': LogLevel.WARN,\n    'error': LogLevel.ERROR,\n    'silent': LogLevel.SILENT\n};\n/**\n * The default log level\n */\nconst defaultLogLevel = LogLevel.INFO;\n/**\n * By default, `console.debug` is not displayed in the developer console (in\n * chrome). To avoid forcing users to have to opt-in to these logs twice\n * (i.e. once for firebase, and once in the console), we are sending `DEBUG`\n * logs to the `console.log` function.\n */\nconst ConsoleMethod = {\n    [LogLevel.DEBUG]: 'log',\n    [LogLevel.VERBOSE]: 'log',\n    [LogLevel.INFO]: 'info',\n    [LogLevel.WARN]: 'warn',\n    [LogLevel.ERROR]: 'error'\n};\n/**\n * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR\n * messages on to their corresponding console counterparts (if the log method\n * is supported by the current log level)\n */\nconst defaultLogHandler = (instance, logType, ...args) => {\n    if (logType < instance.logLevel) {\n        return;\n    }\n    const now = new Date().toISOString();\n    const method = ConsoleMethod[logType];\n    if (method) {\n        console[method](`[${now}]  ${instance.name}:`, ...args);\n    }\n    else {\n        throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);\n    }\n};\nclass Logger {\n    /**\n     * Gives you an instance of a Logger to capture messages according to\n     * Firebase's logging scheme.\n     *\n     * @param name The name that the logs will be associated with\n     */\n    constructor(name) {\n        this.name = name;\n        /**\n         * The log level of the given Logger instance.\n         */\n        this._logLevel = defaultLogLevel;\n        /**\n         * The main (internal) log handler for the Logger instance.\n         * Can be set to a new function in internal package code but not by user.\n         */\n        this._logHandler = defaultLogHandler;\n        /**\n         * The optional, additional, user-defined log handler for the Logger instance.\n         */\n        this._userLogHandler = null;\n        /**\n         * Capture the current instance for later use\n         */\n        instances.push(this);\n    }\n    get logLevel() {\n        return this._logLevel;\n    }\n    set logLevel(val) {\n        if (!(val in LogLevel)) {\n            throw new TypeError(`Invalid value \"${val}\" assigned to \\`logLevel\\``);\n        }\n        this._logLevel = val;\n    }\n    // Workaround for setter/getter having to be the same type.\n    setLogLevel(val) {\n        this._logLevel = typeof val === 'string' ? levelStringToEnum[val] : val;\n    }\n    get logHandler() {\n        return this._logHandler;\n    }\n    set logHandler(val) {\n        if (typeof val !== 'function') {\n            throw new TypeError('Value assigned to `logHandler` must be a function');\n        }\n        this._logHandler = val;\n    }\n    get userLogHandler() {\n        return this._userLogHandler;\n    }\n    set userLogHandler(val) {\n        this._userLogHandler = val;\n    }\n    /**\n     * The functions below are all based on the `console` interface\n     */\n    debug(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);\n        this._logHandler(this, LogLevel.DEBUG, ...args);\n    }\n    log(...args) {\n        this._userLogHandler &&\n            this._userLogHandler(this, LogLevel.VERBOSE, ...args);\n        this._logHandler(this, LogLevel.VERBOSE, ...args);\n    }\n    info(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);\n        this._logHandler(this, LogLevel.INFO, ...args);\n    }\n    warn(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);\n        this._logHandler(this, LogLevel.WARN, ...args);\n    }\n    error(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);\n        this._logHandler(this, LogLevel.ERROR, ...args);\n    }\n}\nfunction setLogLevel(level) {\n    instances.forEach(inst => {\n        inst.setLogLevel(level);\n    });\n}\nfunction setUserLogHandler(logCallback, options) {\n    for (const instance of instances) {\n        let customLogLevel = null;\n        if (options && options.level) {\n            customLogLevel = levelStringToEnum[options.level];\n        }\n        if (logCallback === null) {\n            instance.userLogHandler = null;\n        }\n        else {\n            instance.userLogHandler = (instance, level, ...args) => {\n                const message = args\n                    .map(arg => {\n                    if (arg == null) {\n                        return null;\n                    }\n                    else if (typeof arg === 'string') {\n                        return arg;\n                    }\n                    else if (typeof arg === 'number' || typeof arg === 'boolean') {\n                        return arg.toString();\n                    }\n                    else if (arg instanceof Error) {\n                        return arg.message;\n                    }\n                    else {\n                        try {\n                            return JSON.stringify(arg);\n                        }\n                        catch (ignored) {\n                            return null;\n                        }\n                    }\n                })\n                    .filter(arg => arg)\n                    .join(' ');\n                if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance.logLevel)) {\n                    logCallback({\n                        level: LogLevel[level].toLowerCase(),\n                        message,\n                        args,\n                        type: instance.name\n                    });\n                }\n            };\n        }\n    }\n}\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2xvZ2dlci9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixJQUFJLEtBQUssY0FBYztBQUNuRDtBQUNBO0FBQ0Esc0ZBQXNGLFFBQVE7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsSUFBSTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEQ7QUFDNUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy92dHBhdGVsMDcvUGF0ZWxDTVAyMzNGaW5hbFByb2plY3Qvbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9sb2dnZXIvZGlzdC9lc20vaW5kZXguZXNtMjAxNy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIGNvbnRhaW5lciBmb3IgYWxsIG9mIHRoZSBMb2dnZXIgaW5zdGFuY2VzXG4gKi9cbmNvbnN0IGluc3RhbmNlcyA9IFtdO1xuLyoqXG4gKiBUaGUgSlMgU0RLIHN1cHBvcnRzIDUgbG9nIGxldmVscyBhbmQgYWxzbyBhbGxvd3MgYSB1c2VyIHRoZSBhYmlsaXR5IHRvXG4gKiBzaWxlbmNlIHRoZSBsb2dzIGFsdG9nZXRoZXIuXG4gKlxuICogVGhlIG9yZGVyIGlzIGEgZm9sbG93czpcbiAqIERFQlVHIDwgVkVSQk9TRSA8IElORk8gPCBXQVJOIDwgRVJST1JcbiAqXG4gKiBBbGwgb2YgdGhlIGxvZyB0eXBlcyBhYm92ZSB0aGUgY3VycmVudCBsb2cgbGV2ZWwgd2lsbCBiZSBjYXB0dXJlZCAoaS5lLiBpZlxuICogeW91IHNldCB0aGUgbG9nIGxldmVsIHRvIGBJTkZPYCwgZXJyb3JzIHdpbGwgc3RpbGwgYmUgbG9nZ2VkLCBidXQgYERFQlVHYCBhbmRcbiAqIGBWRVJCT1NFYCBsb2dzIHdpbGwgbm90KVxuICovXG52YXIgTG9nTGV2ZWw7XG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJERUJVR1wiXSA9IDBdID0gXCJERUJVR1wiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiVkVSQk9TRVwiXSA9IDFdID0gXCJWRVJCT1NFXCI7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJJTkZPXCJdID0gMl0gPSBcIklORk9cIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIldBUk5cIl0gPSAzXSA9IFwiV0FSTlwiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRVJST1JcIl0gPSA0XSA9IFwiRVJST1JcIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIlNJTEVOVFwiXSA9IDVdID0gXCJTSUxFTlRcIjtcbn0pKExvZ0xldmVsIHx8IChMb2dMZXZlbCA9IHt9KSk7XG5jb25zdCBsZXZlbFN0cmluZ1RvRW51bSA9IHtcbiAgICAnZGVidWcnOiBMb2dMZXZlbC5ERUJVRyxcbiAgICAndmVyYm9zZSc6IExvZ0xldmVsLlZFUkJPU0UsXG4gICAgJ2luZm8nOiBMb2dMZXZlbC5JTkZPLFxuICAgICd3YXJuJzogTG9nTGV2ZWwuV0FSTixcbiAgICAnZXJyb3InOiBMb2dMZXZlbC5FUlJPUixcbiAgICAnc2lsZW50JzogTG9nTGV2ZWwuU0lMRU5UXG59O1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBsb2cgbGV2ZWxcbiAqL1xuY29uc3QgZGVmYXVsdExvZ0xldmVsID0gTG9nTGV2ZWwuSU5GTztcbi8qKlxuICogQnkgZGVmYXVsdCwgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBkaXNwbGF5ZWQgaW4gdGhlIGRldmVsb3BlciBjb25zb2xlIChpblxuICogY2hyb21lKS4gVG8gYXZvaWQgZm9yY2luZyB1c2VycyB0byBoYXZlIHRvIG9wdC1pbiB0byB0aGVzZSBsb2dzIHR3aWNlXG4gKiAoaS5lLiBvbmNlIGZvciBmaXJlYmFzZSwgYW5kIG9uY2UgaW4gdGhlIGNvbnNvbGUpLCB3ZSBhcmUgc2VuZGluZyBgREVCVUdgXG4gKiBsb2dzIHRvIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uLlxuICovXG5jb25zdCBDb25zb2xlTWV0aG9kID0ge1xuICAgIFtMb2dMZXZlbC5ERUJVR106ICdsb2cnLFxuICAgIFtMb2dMZXZlbC5WRVJCT1NFXTogJ2xvZycsXG4gICAgW0xvZ0xldmVsLklORk9dOiAnaW5mbycsXG4gICAgW0xvZ0xldmVsLldBUk5dOiAnd2FybicsXG4gICAgW0xvZ0xldmVsLkVSUk9SXTogJ2Vycm9yJ1xufTtcbi8qKlxuICogVGhlIGRlZmF1bHQgbG9nIGhhbmRsZXIgd2lsbCBmb3J3YXJkIERFQlVHLCBWRVJCT1NFLCBJTkZPLCBXQVJOLCBhbmQgRVJST1JcbiAqIG1lc3NhZ2VzIG9uIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgY29uc29sZSBjb3VudGVycGFydHMgKGlmIHRoZSBsb2cgbWV0aG9kXG4gKiBpcyBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgbG9nIGxldmVsKVxuICovXG5jb25zdCBkZWZhdWx0TG9nSGFuZGxlciA9IChpbnN0YW5jZSwgbG9nVHlwZSwgLi4uYXJncykgPT4ge1xuICAgIGlmIChsb2dUeXBlIDwgaW5zdGFuY2UubG9nTGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgY29uc3QgbWV0aG9kID0gQ29uc29sZU1ldGhvZFtsb2dUeXBlXTtcbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgIGNvbnNvbGVbbWV0aG9kXShgWyR7bm93fV0gICR7aW5zdGFuY2UubmFtZX06YCwgLi4uYXJncyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0dGVtcHRlZCB0byBsb2cgYSBtZXNzYWdlIHdpdGggYW4gaW52YWxpZCBsb2dUeXBlICh2YWx1ZTogJHtsb2dUeXBlfSlgKTtcbiAgICB9XG59O1xuY2xhc3MgTG9nZ2VyIHtcbiAgICAvKipcbiAgICAgKiBHaXZlcyB5b3UgYW4gaW5zdGFuY2Ugb2YgYSBMb2dnZXIgdG8gY2FwdHVyZSBtZXNzYWdlcyBhY2NvcmRpbmcgdG9cbiAgICAgKiBGaXJlYmFzZSdzIGxvZ2dpbmcgc2NoZW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgdGhhdCB0aGUgbG9ncyB3aWxsIGJlIGFzc29jaWF0ZWQgd2l0aFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsb2cgbGV2ZWwgb2YgdGhlIGdpdmVuIExvZ2dlciBpbnN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gZGVmYXVsdExvZ0xldmVsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1haW4gKGludGVybmFsKSBsb2cgaGFuZGxlciBmb3IgdGhlIExvZ2dlciBpbnN0YW5jZS5cbiAgICAgICAgICogQ2FuIGJlIHNldCB0byBhIG5ldyBmdW5jdGlvbiBpbiBpbnRlcm5hbCBwYWNrYWdlIGNvZGUgYnV0IG5vdCBieSB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlciA9IGRlZmF1bHRMb2dIYW5kbGVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG9wdGlvbmFsLCBhZGRpdGlvbmFsLCB1c2VyLWRlZmluZWQgbG9nIGhhbmRsZXIgZm9yIHRoZSBMb2dnZXIgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYXB0dXJlIHRoZSBjdXJyZW50IGluc3RhbmNlIGZvciBsYXRlciB1c2VcbiAgICAgICAgICovXG4gICAgICAgIGluc3RhbmNlcy5wdXNoKHRoaXMpO1xuICAgIH1cbiAgICBnZXQgbG9nTGV2ZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dMZXZlbDtcbiAgICB9XG4gICAgc2V0IGxvZ0xldmVsKHZhbCkge1xuICAgICAgICBpZiAoISh2YWwgaW4gTG9nTGV2ZWwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHZhbHVlIFwiJHt2YWx9XCIgYXNzaWduZWQgdG8gXFxgbG9nTGV2ZWxcXGBgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2dMZXZlbCA9IHZhbDtcbiAgICB9XG4gICAgLy8gV29ya2Fyb3VuZCBmb3Igc2V0dGVyL2dldHRlciBoYXZpbmcgdG8gYmUgdGhlIHNhbWUgdHlwZS5cbiAgICBzZXRMb2dMZXZlbCh2YWwpIHtcbiAgICAgICAgdGhpcy5fbG9nTGV2ZWwgPSB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/IGxldmVsU3RyaW5nVG9FbnVtW3ZhbF0gOiB2YWw7XG4gICAgfVxuICAgIGdldCBsb2dIYW5kbGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9nSGFuZGxlcjtcbiAgICB9XG4gICAgc2V0IGxvZ0hhbmRsZXIodmFsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdWYWx1ZSBhc3NpZ25lZCB0byBgbG9nSGFuZGxlcmAgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlciA9IHZhbDtcbiAgICB9XG4gICAgZ2V0IHVzZXJMb2dIYW5kbGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXNlckxvZ0hhbmRsZXI7XG4gICAgfVxuICAgIHNldCB1c2VyTG9nSGFuZGxlcih2YWwpIHtcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbnMgYmVsb3cgYXJlIGFsbCBiYXNlZCBvbiB0aGUgYGNvbnNvbGVgIGludGVyZmFjZVxuICAgICAqL1xuICAgIGRlYnVnKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiYgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuREVCVUcsIC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkRFQlVHLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgbG9nKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiZcbiAgICAgICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLlZFUkJPU0UsIC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLlZFUkJPU0UsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBpbmZvKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiYgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuSU5GTywgLi4uYXJncyk7XG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuSU5GTywgLi4uYXJncyk7XG4gICAgfVxuICAgIHdhcm4oLi4uYXJncykge1xuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5XQVJOLCAuLi5hcmdzKTtcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5XQVJOLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgZXJyb3IoLi4uYXJncykge1xuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5FUlJPUiwgLi4uYXJncyk7XG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuRVJST1IsIC4uLmFyZ3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxldmVsKSB7XG4gICAgaW5zdGFuY2VzLmZvckVhY2goaW5zdCA9PiB7XG4gICAgICAgIGluc3Quc2V0TG9nTGV2ZWwobGV2ZWwpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gc2V0VXNlckxvZ0hhbmRsZXIobG9nQ2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIGluc3RhbmNlcykge1xuICAgICAgICBsZXQgY3VzdG9tTG9nTGV2ZWwgPSBudWxsO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmxldmVsKSB7XG4gICAgICAgICAgICBjdXN0b21Mb2dMZXZlbCA9IGxldmVsU3RyaW5nVG9FbnVtW29wdGlvbnMubGV2ZWxdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2dDYWxsYmFjayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2UudXNlckxvZ0hhbmRsZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5zdGFuY2UudXNlckxvZ0hhbmRsZXIgPSAoaW5zdGFuY2UsIGxldmVsLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGFyZ3NcbiAgICAgICAgICAgICAgICAgICAgLm1hcChhcmcgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8IHR5cGVvZiBhcmcgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoYXJnID0+IGFyZylcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyAnKTtcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPj0gKGN1c3RvbUxvZ0xldmVsICE9PSBudWxsICYmIGN1c3RvbUxvZ0xldmVsICE9PSB2b2lkIDAgPyBjdXN0b21Mb2dMZXZlbCA6IGluc3RhbmNlLmxvZ0xldmVsKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dDYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogTG9nTGV2ZWxbbGV2ZWxdLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGluc3RhbmNlLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgTG9nTGV2ZWwsIExvZ2dlciwgc2V0TG9nTGV2ZWwsIHNldFVzZXJMb2dIYW5kbGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20yMDE3LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@firebase/util/dist/node-esm/index.node.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONSTANTS: () => (/* binding */ CONSTANTS),\n/* harmony export */   DecodeBase64StringError: () => (/* binding */ DecodeBase64StringError),\n/* harmony export */   Deferred: () => (/* binding */ Deferred),\n/* harmony export */   ErrorFactory: () => (/* binding */ ErrorFactory),\n/* harmony export */   FirebaseError: () => (/* binding */ FirebaseError),\n/* harmony export */   MAX_VALUE_MILLIS: () => (/* binding */ MAX_VALUE_MILLIS),\n/* harmony export */   RANDOM_FACTOR: () => (/* binding */ RANDOM_FACTOR),\n/* harmony export */   Sha1: () => (/* binding */ Sha1),\n/* harmony export */   areCookiesEnabled: () => (/* binding */ areCookiesEnabled),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertionError: () => (/* binding */ assertionError),\n/* harmony export */   async: () => (/* binding */ async),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64Decode: () => (/* binding */ base64Decode),\n/* harmony export */   base64Encode: () => (/* binding */ base64Encode),\n/* harmony export */   base64urlEncodeWithoutPadding: () => (/* binding */ base64urlEncodeWithoutPadding),\n/* harmony export */   calculateBackoffMillis: () => (/* binding */ calculateBackoffMillis),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   createMockUserToken: () => (/* binding */ createMockUserToken),\n/* harmony export */   createSubscribe: () => (/* binding */ createSubscribe),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   deepCopy: () => (/* binding */ deepCopy),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual),\n/* harmony export */   deepExtend: () => (/* binding */ deepExtend),\n/* harmony export */   errorPrefix: () => (/* binding */ errorPrefix),\n/* harmony export */   extractQuerystring: () => (/* binding */ extractQuerystring),\n/* harmony export */   getDefaultAppConfig: () => (/* binding */ getDefaultAppConfig),\n/* harmony export */   getDefaultEmulatorHost: () => (/* binding */ getDefaultEmulatorHost),\n/* harmony export */   getDefaultEmulatorHostnameAndPort: () => (/* binding */ getDefaultEmulatorHostnameAndPort),\n/* harmony export */   getDefaults: () => (/* binding */ getDefaults),\n/* harmony export */   getExperimentalSetting: () => (/* binding */ getExperimentalSetting),\n/* harmony export */   getGlobal: () => (/* binding */ getGlobal),\n/* harmony export */   getModularInstance: () => (/* binding */ getModularInstance),\n/* harmony export */   getUA: () => (/* binding */ getUA),\n/* harmony export */   isAdmin: () => (/* binding */ isAdmin),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isBrowserExtension: () => (/* binding */ isBrowserExtension),\n/* harmony export */   isCloudflareWorker: () => (/* binding */ isCloudflareWorker),\n/* harmony export */   isElectron: () => (/* binding */ isElectron),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isIE: () => (/* binding */ isIE),\n/* harmony export */   isIndexedDBAvailable: () => (/* binding */ isIndexedDBAvailable),\n/* harmony export */   isMobileCordova: () => (/* binding */ isMobileCordova),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isNodeSdk: () => (/* binding */ isNodeSdk),\n/* harmony export */   isReactNative: () => (/* binding */ isReactNative),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   isUWP: () => (/* binding */ isUWP),\n/* harmony export */   isValidFormat: () => (/* binding */ isValidFormat),\n/* harmony export */   isValidTimestamp: () => (/* binding */ isValidTimestamp),\n/* harmony export */   isWebWorker: () => (/* binding */ isWebWorker),\n/* harmony export */   issuedAtTime: () => (/* binding */ issuedAtTime),\n/* harmony export */   jsonEval: () => (/* binding */ jsonEval),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   ordinal: () => (/* binding */ ordinal),\n/* harmony export */   promiseWithTimeout: () => (/* binding */ promiseWithTimeout),\n/* harmony export */   querystring: () => (/* binding */ querystring),\n/* harmony export */   querystringDecode: () => (/* binding */ querystringDecode),\n/* harmony export */   safeGet: () => (/* binding */ safeGet),\n/* harmony export */   stringLength: () => (/* binding */ stringLength),\n/* harmony export */   stringToByteArray: () => (/* binding */ stringToByteArray),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   uuidv4: () => (/* binding */ uuidv4),\n/* harmony export */   validateArgCount: () => (/* binding */ validateArgCount),\n/* harmony export */   validateCallback: () => (/* binding */ validateCallback),\n/* harmony export */   validateContextObject: () => (/* binding */ validateContextObject),\n/* harmony export */   validateIndexedDBOpenable: () => (/* binding */ validateIndexedDBOpenable),\n/* harmony export */   validateNamespace: () => (/* binding */ validateNamespace)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.\n */\nconst CONSTANTS = {\n    /**\n     * @define {boolean} Whether this is the client Node.js SDK.\n     */\n    NODE_CLIENT: false,\n    /**\n     * @define {boolean} Whether this is the Admin Node.js SDK.\n     */\n    NODE_ADMIN: false,\n    /**\n     * Firebase SDK Version\n     */\n    SDK_VERSION: '${JSCORE_VERSION}'\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Throws an error if the provided assertion is falsy\n */\nconst assert = function (assertion, message) {\n    if (!assertion) {\n        throw assertionError(message);\n    }\n};\n/**\n * Returns an Error object suitable for throwing.\n */\nconst assertionError = function (message) {\n    return new Error('Firebase Database (' +\n        CONSTANTS.SDK_VERSION +\n        ') INTERNAL ASSERT FAILED: ' +\n        message);\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst stringToByteArray$1 = function (str) {\n    // TODO(user): Use native implementations if/when available\n    const out = [];\n    let p = 0;\n    for (let i = 0; i < str.length; i++) {\n        let c = str.charCodeAt(i);\n        if (c < 128) {\n            out[p++] = c;\n        }\n        else if (c < 2048) {\n            out[p++] = (c >> 6) | 192;\n            out[p++] = (c & 63) | 128;\n        }\n        else if ((c & 0xfc00) === 0xd800 &&\n            i + 1 < str.length &&\n            (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {\n            // Surrogate Pair\n            c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);\n            out[p++] = (c >> 18) | 240;\n            out[p++] = ((c >> 12) & 63) | 128;\n            out[p++] = ((c >> 6) & 63) | 128;\n            out[p++] = (c & 63) | 128;\n        }\n        else {\n            out[p++] = (c >> 12) | 224;\n            out[p++] = ((c >> 6) & 63) | 128;\n            out[p++] = (c & 63) | 128;\n        }\n    }\n    return out;\n};\n/**\n * Turns an array of numbers into the string given by the concatenation of the\n * characters to which the numbers correspond.\n * @param bytes Array of numbers representing characters.\n * @return Stringification of the array.\n */\nconst byteArrayToString = function (bytes) {\n    // TODO(user): Use native implementations if/when available\n    const out = [];\n    let pos = 0, c = 0;\n    while (pos < bytes.length) {\n        const c1 = bytes[pos++];\n        if (c1 < 128) {\n            out[c++] = String.fromCharCode(c1);\n        }\n        else if (c1 > 191 && c1 < 224) {\n            const c2 = bytes[pos++];\n            out[c++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));\n        }\n        else if (c1 > 239 && c1 < 365) {\n            // Surrogate Pair\n            const c2 = bytes[pos++];\n            const c3 = bytes[pos++];\n            const c4 = bytes[pos++];\n            const u = (((c1 & 7) << 18) | ((c2 & 63) << 12) | ((c3 & 63) << 6) | (c4 & 63)) -\n                0x10000;\n            out[c++] = String.fromCharCode(0xd800 + (u >> 10));\n            out[c++] = String.fromCharCode(0xdc00 + (u & 1023));\n        }\n        else {\n            const c2 = bytes[pos++];\n            const c3 = bytes[pos++];\n            out[c++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n        }\n    }\n    return out.join('');\n};\n// We define it as an object literal instead of a class because a class compiled down to es5 can't\n// be treeshaked. https://github.com/rollup/rollup/issues/1691\n// Static lookup maps, lazily populated by init_()\n// TODO(dlarocque): Define this as a class, since we no longer target ES5.\nconst base64 = {\n    /**\n     * Maps bytes to characters.\n     */\n    byteToCharMap_: null,\n    /**\n     * Maps characters to bytes.\n     */\n    charToByteMap_: null,\n    /**\n     * Maps bytes to websafe characters.\n     * @private\n     */\n    byteToCharMapWebSafe_: null,\n    /**\n     * Maps websafe characters to bytes.\n     * @private\n     */\n    charToByteMapWebSafe_: null,\n    /**\n     * Our default alphabet, shared between\n     * ENCODED_VALS and ENCODED_VALS_WEBSAFE\n     */\n    ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',\n    /**\n     * Our default alphabet. Value 64 (=) is special; it means \"nothing.\"\n     */\n    get ENCODED_VALS() {\n        return this.ENCODED_VALS_BASE + '+/=';\n    },\n    /**\n     * Our websafe alphabet.\n     */\n    get ENCODED_VALS_WEBSAFE() {\n        return this.ENCODED_VALS_BASE + '-_.';\n    },\n    /**\n     * Whether this browser supports the atob and btoa functions. This extension\n     * started at Mozilla but is now implemented by many browsers. We use the\n     * ASSUME_* variables to avoid pulling in the full useragent detection library\n     * but still allowing the standard per-browser compilations.\n     *\n     */\n    HAS_NATIVE_SUPPORT: typeof atob === 'function',\n    /**\n     * Base64-encode an array of bytes.\n     *\n     * @param input An array of bytes (numbers with\n     *     value in [0, 255]) to encode.\n     * @param webSafe Boolean indicating we should use the\n     *     alternative alphabet.\n     * @return The base64 encoded string.\n     */\n    encodeByteArray(input, webSafe) {\n        if (!Array.isArray(input)) {\n            throw Error('encodeByteArray takes an array as a parameter');\n        }\n        this.init_();\n        const byteToCharMap = webSafe\n            ? this.byteToCharMapWebSafe_\n            : this.byteToCharMap_;\n        const output = [];\n        for (let i = 0; i < input.length; i += 3) {\n            const byte1 = input[i];\n            const haveByte2 = i + 1 < input.length;\n            const byte2 = haveByte2 ? input[i + 1] : 0;\n            const haveByte3 = i + 2 < input.length;\n            const byte3 = haveByte3 ? input[i + 2] : 0;\n            const outByte1 = byte1 >> 2;\n            const outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);\n            let outByte3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);\n            let outByte4 = byte3 & 0x3f;\n            if (!haveByte3) {\n                outByte4 = 64;\n                if (!haveByte2) {\n                    outByte3 = 64;\n                }\n            }\n            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);\n        }\n        return output.join('');\n    },\n    /**\n     * Base64-encode a string.\n     *\n     * @param input A string to encode.\n     * @param webSafe If true, we should use the\n     *     alternative alphabet.\n     * @return The base64 encoded string.\n     */\n    encodeString(input, webSafe) {\n        // Shortcut for Mozilla browsers that implement\n        // a native base64 encoder in the form of \"btoa/atob\"\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n            return btoa(input);\n        }\n        return this.encodeByteArray(stringToByteArray$1(input), webSafe);\n    },\n    /**\n     * Base64-decode a string.\n     *\n     * @param input to decode.\n     * @param webSafe True if we should use the\n     *     alternative alphabet.\n     * @return string representing the decoded value.\n     */\n    decodeString(input, webSafe) {\n        // Shortcut for Mozilla browsers that implement\n        // a native base64 encoder in the form of \"btoa/atob\"\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n            return atob(input);\n        }\n        return byteArrayToString(this.decodeStringToByteArray(input, webSafe));\n    },\n    /**\n     * Base64-decode a string.\n     *\n     * In base-64 decoding, groups of four characters are converted into three\n     * bytes.  If the encoder did not apply padding, the input length may not\n     * be a multiple of 4.\n     *\n     * In this case, the last group will have fewer than 4 characters, and\n     * padding will be inferred.  If the group has one or two characters, it decodes\n     * to one byte.  If the group has three characters, it decodes to two bytes.\n     *\n     * @param input Input to decode.\n     * @param webSafe True if we should use the web-safe alphabet.\n     * @return bytes representing the decoded value.\n     */\n    decodeStringToByteArray(input, webSafe) {\n        this.init_();\n        const charToByteMap = webSafe\n            ? this.charToByteMapWebSafe_\n            : this.charToByteMap_;\n        const output = [];\n        for (let i = 0; i < input.length;) {\n            const byte1 = charToByteMap[input.charAt(i++)];\n            const haveByte2 = i < input.length;\n            const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;\n            ++i;\n            const haveByte3 = i < input.length;\n            const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;\n            ++i;\n            const haveByte4 = i < input.length;\n            const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;\n            ++i;\n            if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {\n                throw new DecodeBase64StringError();\n            }\n            const outByte1 = (byte1 << 2) | (byte2 >> 4);\n            output.push(outByte1);\n            if (byte3 !== 64) {\n                const outByte2 = ((byte2 << 4) & 0xf0) | (byte3 >> 2);\n                output.push(outByte2);\n                if (byte4 !== 64) {\n                    const outByte3 = ((byte3 << 6) & 0xc0) | byte4;\n                    output.push(outByte3);\n                }\n            }\n        }\n        return output;\n    },\n    /**\n     * Lazy static initialization function. Called before\n     * accessing any of the static map variables.\n     * @private\n     */\n    init_() {\n        if (!this.byteToCharMap_) {\n            this.byteToCharMap_ = {};\n            this.charToByteMap_ = {};\n            this.byteToCharMapWebSafe_ = {};\n            this.charToByteMapWebSafe_ = {};\n            // We want quick mappings back and forth, so we precompute two maps.\n            for (let i = 0; i < this.ENCODED_VALS.length; i++) {\n                this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);\n                this.charToByteMap_[this.byteToCharMap_[i]] = i;\n                this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);\n                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;\n                // Be forgiving when decoding and correctly decode both encodings.\n                if (i >= this.ENCODED_VALS_BASE.length) {\n                    this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;\n                    this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;\n                }\n            }\n        }\n    }\n};\n/**\n * An error encountered while decoding base64 string.\n */\nclass DecodeBase64StringError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'DecodeBase64StringError';\n    }\n}\n/**\n * URL-safe base64 encoding\n */\nconst base64Encode = function (str) {\n    const utf8Bytes = stringToByteArray$1(str);\n    return base64.encodeByteArray(utf8Bytes, true);\n};\n/**\n * URL-safe base64 encoding (without \".\" padding in the end).\n * e.g. Used in JSON Web Token (JWT) parts.\n */\nconst base64urlEncodeWithoutPadding = function (str) {\n    // Use base64url encoding and remove padding in the end (dot characters).\n    return base64Encode(str).replace(/\\./g, '');\n};\n/**\n * URL-safe base64 decoding\n *\n * NOTE: DO NOT use the global atob() function - it does NOT support the\n * base64Url variant encoding.\n *\n * @param str To be decoded\n * @return Decoded result, if possible\n */\nconst base64Decode = function (str) {\n    try {\n        return base64.decodeString(str, true);\n    }\n    catch (e) {\n        console.error('base64Decode failed: ', e);\n    }\n    return null;\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Do a deep-copy of basic JavaScript Objects or Arrays.\n */\nfunction deepCopy(value) {\n    return deepExtend(undefined, value);\n}\n/**\n * Copy properties from source to target (recursively allows extension\n * of Objects and Arrays).  Scalar values in the target are over-written.\n * If target is undefined, an object of the appropriate type will be created\n * (and returned).\n *\n * We recursively copy all child properties of plain Objects in the source- so\n * that namespace- like dictionaries are merged.\n *\n * Note that the target can be a function, in which case the properties in\n * the source Object are copied onto it as static properties of the Function.\n *\n * Note: we don't merge __proto__ to prevent prototype pollution\n */\nfunction deepExtend(target, source) {\n    if (!(source instanceof Object)) {\n        return source;\n    }\n    switch (source.constructor) {\n        case Date:\n            // Treat Dates like scalars; if the target date object had any child\n            // properties - they will be lost!\n            const dateValue = source;\n            return new Date(dateValue.getTime());\n        case Object:\n            if (target === undefined) {\n                target = {};\n            }\n            break;\n        case Array:\n            // Always copy the array source and overwrite the target.\n            target = [];\n            break;\n        default:\n            // Not a plain Object - treat it as a scalar.\n            return source;\n    }\n    for (const prop in source) {\n        // use isValidKey to guard against prototype pollution. See https://snyk.io/vuln/SNYK-JS-LODASH-450202\n        if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {\n            continue;\n        }\n        target[prop] = deepExtend(target[prop], source[prop]);\n    }\n    return target;\n}\nfunction isValidKey(key) {\n    return key !== '__proto__';\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Polyfill for `globalThis` object.\n * @returns the `globalThis` object for the given environment.\n * @public\n */\nfunction getGlobal() {\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    throw new Error('Unable to locate global object.');\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst getDefaultsFromGlobal = () => getGlobal().__FIREBASE_DEFAULTS__;\n/**\n * Attempt to read defaults from a JSON string provided to\n * process(.)env(.)__FIREBASE_DEFAULTS__ or a JSON file whose path is in\n * process(.)env(.)__FIREBASE_DEFAULTS_PATH__\n * The dots are in parens because certain compilers (Vite?) cannot\n * handle seeing that variable in comments.\n * See https://github.com/firebase/firebase-js-sdk/issues/6838\n */\nconst getDefaultsFromEnvVariable = () => {\n    if (typeof process === 'undefined' || typeof process.env === 'undefined') {\n        return;\n    }\n    const defaultsJsonString = process.env.__FIREBASE_DEFAULTS__;\n    if (defaultsJsonString) {\n        return JSON.parse(defaultsJsonString);\n    }\n};\nconst getDefaultsFromCookie = () => {\n    if (typeof document === 'undefined') {\n        return;\n    }\n    let match;\n    try {\n        match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);\n    }\n    catch (e) {\n        // Some environments such as Angular Universal SSR have a\n        // `document` object but error on accessing `document.cookie`.\n        return;\n    }\n    const decoded = match && base64Decode(match[1]);\n    return decoded && JSON.parse(decoded);\n};\n/**\n * Get the __FIREBASE_DEFAULTS__ object. It checks in order:\n * (1) if such an object exists as a property of `globalThis`\n * (2) if such an object was provided on a shell environment variable\n * (3) if such an object exists in a cookie\n * @public\n */\nconst getDefaults = () => {\n    try {\n        return (getDefaultsFromGlobal() ||\n            getDefaultsFromEnvVariable() ||\n            getDefaultsFromCookie());\n    }\n    catch (e) {\n        /**\n         * Catch-all for being unable to get __FIREBASE_DEFAULTS__ due\n         * to any environment case we have not accounted for. Log to\n         * info instead of swallowing so we can find these unknown cases\n         * and add paths for them if needed.\n         */\n        console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);\n        return;\n    }\n};\n/**\n * Returns emulator host stored in the __FIREBASE_DEFAULTS__ object\n * for the given product.\n * @returns a URL host formatted like `127.0.0.1:9999` or `[::1]:4000` if available\n * @public\n */\nconst getDefaultEmulatorHost = (productName) => { var _a, _b; return (_b = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.emulatorHosts) === null || _b === void 0 ? void 0 : _b[productName]; };\n/**\n * Returns emulator hostname and port stored in the __FIREBASE_DEFAULTS__ object\n * for the given product.\n * @returns a pair of hostname and port like `[\"::1\", 4000]` if available\n * @public\n */\nconst getDefaultEmulatorHostnameAndPort = (productName) => {\n    const host = getDefaultEmulatorHost(productName);\n    if (!host) {\n        return undefined;\n    }\n    const separatorIndex = host.lastIndexOf(':'); // Finding the last since IPv6 addr also has colons.\n    if (separatorIndex <= 0 || separatorIndex + 1 === host.length) {\n        throw new Error(`Invalid host ${host} with no separate hostname and port!`);\n    }\n    // eslint-disable-next-line no-restricted-globals\n    const port = parseInt(host.substring(separatorIndex + 1), 10);\n    if (host[0] === '[') {\n        // Bracket-quoted `[ipv6addr]:port` => return \"ipv6addr\" (without brackets).\n        return [host.substring(1, separatorIndex - 1), port];\n    }\n    else {\n        return [host.substring(0, separatorIndex), port];\n    }\n};\n/**\n * Returns Firebase app config stored in the __FIREBASE_DEFAULTS__ object.\n * @public\n */\nconst getDefaultAppConfig = () => { var _a; return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.config; };\n/**\n * Returns an experimental setting on the __FIREBASE_DEFAULTS__ object (properties\n * prefixed by \"_\")\n * @public\n */\nconst getExperimentalSetting = (name) => { var _a; return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a[`_${name}`]; };\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass Deferred {\n    constructor() {\n        this.reject = () => { };\n        this.resolve = () => { };\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n    /**\n     * Our API internals are not promisified and cannot because our callback APIs have subtle expectations around\n     * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback\n     * and returns a node-style callback which will resolve or reject the Deferred's promise.\n     */\n    wrapCallback(callback) {\n        return (error, value) => {\n            if (error) {\n                this.reject(error);\n            }\n            else {\n                this.resolve(value);\n            }\n            if (typeof callback === 'function') {\n                // Attaching noop handler just in case developer wasn't expecting\n                // promises\n                this.promise.catch(() => { });\n                // Some of our callbacks don't expect a value and our own tests\n                // assert that the parameter length is 1\n                if (callback.length === 1) {\n                    callback(error);\n                }\n                else {\n                    callback(error, value);\n                }\n            }\n        };\n    }\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction createMockUserToken(token, projectId) {\n    if (token.uid) {\n        throw new Error('The \"uid\" field is no longer supported by mockUserToken. Please use \"sub\" instead for Firebase Auth User ID.');\n    }\n    // Unsecured JWTs use \"none\" as the algorithm.\n    const header = {\n        alg: 'none',\n        type: 'JWT'\n    };\n    const project = projectId || 'demo-project';\n    const iat = token.iat || 0;\n    const sub = token.sub || token.user_id;\n    if (!sub) {\n        throw new Error(\"mockUserToken must contain 'sub' or 'user_id' field!\");\n    }\n    const payload = Object.assign({ \n        // Set all required fields to decent defaults\n        iss: `https://securetoken.google.com/${project}`, aud: project, iat, exp: iat + 3600, auth_time: iat, sub, user_id: sub, firebase: {\n            sign_in_provider: 'custom',\n            identities: {}\n        } }, token);\n    // Unsecured JWTs use the empty string as a signature.\n    const signature = '';\n    return [\n        base64urlEncodeWithoutPadding(JSON.stringify(header)),\n        base64urlEncodeWithoutPadding(JSON.stringify(payload)),\n        signature\n    ].join('.');\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns navigator.userAgent string or '' if it's not defined.\n * @return user agent string\n */\nfunction getUA() {\n    if (typeof navigator !== 'undefined' &&\n        typeof navigator['userAgent'] === 'string') {\n        return navigator['userAgent'];\n    }\n    else {\n        return '';\n    }\n}\n/**\n * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.\n *\n * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap\n * in the Ripple emulator) nor Cordova `onDeviceReady`, which would normally\n * wait for a callback.\n */\nfunction isMobileCordova() {\n    return (typeof window !== 'undefined' &&\n        // @ts-ignore Setting up an broadly applicable index signature for Window\n        // just to deal with this case would probably be a bad idea.\n        !!(window['cordova'] || window['phonegap'] || window['PhoneGap']) &&\n        /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA()));\n}\n/**\n * Detect Node.js.\n *\n * @return true if Node.js environment is detected or specified.\n */\n// Node detection logic from: https://github.com/iliakan/detect-node/\nfunction isNode() {\n    var _a;\n    const forceEnvironment = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.forceEnvironment;\n    if (forceEnvironment === 'node') {\n        return true;\n    }\n    else if (forceEnvironment === 'browser') {\n        return false;\n    }\n    try {\n        return (Object.prototype.toString.call(global.process) === '[object process]');\n    }\n    catch (e) {\n        return false;\n    }\n}\n/**\n * Detect Browser Environment.\n * Note: This will return true for certain test frameworks that are incompletely\n * mimicking a browser, and should not lead to assuming all browser APIs are\n * available.\n */\nfunction isBrowser() {\n    return typeof window !== 'undefined' || isWebWorker();\n}\n/**\n * Detect Web Worker context.\n */\nfunction isWebWorker() {\n    return (typeof WorkerGlobalScope !== 'undefined' &&\n        typeof self !== 'undefined' &&\n        self instanceof WorkerGlobalScope);\n}\n/**\n * Detect Cloudflare Worker context.\n */\nfunction isCloudflareWorker() {\n    return (typeof navigator !== 'undefined' &&\n        navigator.userAgent === 'Cloudflare-Workers');\n}\nfunction isBrowserExtension() {\n    const runtime = typeof chrome === 'object'\n        ? chrome.runtime\n        : typeof browser === 'object'\n            ? browser.runtime\n            : undefined;\n    return typeof runtime === 'object' && runtime.id !== undefined;\n}\n/**\n * Detect React Native.\n *\n * @return true if ReactNative environment is detected.\n */\nfunction isReactNative() {\n    return (typeof navigator === 'object' && navigator['product'] === 'ReactNative');\n}\n/** Detects Electron apps. */\nfunction isElectron() {\n    return getUA().indexOf('Electron/') >= 0;\n}\n/** Detects Internet Explorer. */\nfunction isIE() {\n    const ua = getUA();\n    return ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;\n}\n/** Detects Universal Windows Platform apps. */\nfunction isUWP() {\n    return getUA().indexOf('MSAppHost/') >= 0;\n}\n/**\n * Detect whether the current SDK build is the Node version.\n *\n * @return true if it's the Node SDK build.\n */\nfunction isNodeSdk() {\n    return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;\n}\n/** Returns true if we are running in Safari. */\nfunction isSafari() {\n    return (!isNode() &&\n        !!navigator.userAgent &&\n        navigator.userAgent.includes('Safari') &&\n        !navigator.userAgent.includes('Chrome'));\n}\n/**\n * This method checks if indexedDB is supported by current browser/service worker context\n * @return true if indexedDB is supported by current browser/service worker context\n */\nfunction isIndexedDBAvailable() {\n    try {\n        return typeof indexedDB === 'object';\n    }\n    catch (e) {\n        return false;\n    }\n}\n/**\n * This method validates browser/sw context for indexedDB by opening a dummy indexedDB database and reject\n * if errors occur during the database open operation.\n *\n * @throws exception if current browser/sw context can't run idb.open (ex: Safari iframe, Firefox\n * private browsing)\n */\nfunction validateIndexedDBOpenable() {\n    return new Promise((resolve, reject) => {\n        try {\n            let preExist = true;\n            const DB_CHECK_NAME = 'validate-browser-context-for-indexeddb-analytics-module';\n            const request = self.indexedDB.open(DB_CHECK_NAME);\n            request.onsuccess = () => {\n                request.result.close();\n                // delete database only when it doesn't pre-exist\n                if (!preExist) {\n                    self.indexedDB.deleteDatabase(DB_CHECK_NAME);\n                }\n                resolve(true);\n            };\n            request.onupgradeneeded = () => {\n                preExist = false;\n            };\n            request.onerror = () => {\n                var _a;\n                reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || '');\n            };\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n}\n/**\n *\n * This method checks whether cookie is enabled within current browser\n * @return true if cookie is enabled within current browser\n */\nfunction areCookiesEnabled() {\n    if (typeof navigator === 'undefined' || !navigator.cookieEnabled) {\n        return false;\n    }\n    return true;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Standardized Firebase Error.\n *\n * Usage:\n *\n *   // TypeScript string literals for type-safe codes\n *   type Err =\n *     'unknown' |\n *     'object-not-found'\n *     ;\n *\n *   // Closure enum for type-safe error codes\n *   // at-enum {string}\n *   var Err = {\n *     UNKNOWN: 'unknown',\n *     OBJECT_NOT_FOUND: 'object-not-found',\n *   }\n *\n *   let errors: Map<Err, string> = {\n *     'generic-error': \"Unknown error\",\n *     'file-not-found': \"Could not find file: {$file}\",\n *   };\n *\n *   // Type-safe function - must pass a valid error code as param.\n *   let error = new ErrorFactory<Err>('service', 'Service', errors);\n *\n *   ...\n *   throw error.create(Err.GENERIC);\n *   ...\n *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});\n *   ...\n *   // Service: Could not file file: foo.txt (service/file-not-found).\n *\n *   catch (e) {\n *     assert(e.message === \"Could not find file: foo.txt.\");\n *     if ((e as FirebaseError)?.code === 'service/file-not-found') {\n *       console.log(\"Could not read file: \" + e['file']);\n *     }\n *   }\n */\nconst ERROR_NAME = 'FirebaseError';\n// Based on code from:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types\nclass FirebaseError extends Error {\n    constructor(\n    /** The error code for this error. */\n    code, message, \n    /** Custom data for this error. */\n    customData) {\n        super(message);\n        this.code = code;\n        this.customData = customData;\n        /** The custom name for all FirebaseErrors. */\n        this.name = ERROR_NAME;\n        // Fix For ES5\n        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        // TODO(dlarocque): Replace this with `new.target`: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#support-for-newtarget\n        //                   which we can now use since we no longer target ES5.\n        Object.setPrototypeOf(this, FirebaseError.prototype);\n        // Maintains proper stack trace for where our error was thrown.\n        // Only available on V8.\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, ErrorFactory.prototype.create);\n        }\n    }\n}\nclass ErrorFactory {\n    constructor(service, serviceName, errors) {\n        this.service = service;\n        this.serviceName = serviceName;\n        this.errors = errors;\n    }\n    create(code, ...data) {\n        const customData = data[0] || {};\n        const fullCode = `${this.service}/${code}`;\n        const template = this.errors[code];\n        const message = template ? replaceTemplate(template, customData) : 'Error';\n        // Service Name: Error message (service/code).\n        const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;\n        const error = new FirebaseError(fullCode, fullMessage, customData);\n        return error;\n    }\n}\nfunction replaceTemplate(template, data) {\n    return template.replace(PATTERN, (_, key) => {\n        const value = data[key];\n        return value != null ? String(value) : `<${key}?>`;\n    });\n}\nconst PATTERN = /\\{\\$([^}]+)}/g;\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Evaluates a JSON string into a javascript object.\n *\n * @param {string} str A string containing JSON.\n * @return {*} The javascript object representing the specified JSON.\n */\nfunction jsonEval(str) {\n    return JSON.parse(str);\n}\n/**\n * Returns JSON representing a javascript object.\n * @param {*} data JavaScript object to be stringified.\n * @return {string} The JSON contents of the object.\n */\nfunction stringify(data) {\n    return JSON.stringify(data);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Decodes a Firebase auth. token into constituent parts.\n *\n * Notes:\n * - May return with invalid / incomplete claims if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst decode = function (token) {\n    let header = {}, claims = {}, data = {}, signature = '';\n    try {\n        const parts = token.split('.');\n        header = jsonEval(base64Decode(parts[0]) || '');\n        claims = jsonEval(base64Decode(parts[1]) || '');\n        signature = parts[2];\n        data = claims['d'] || {};\n        delete claims['d'];\n    }\n    catch (e) { }\n    return {\n        header,\n        claims,\n        data,\n        signature\n    };\n};\n/**\n * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the\n * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst isValidTimestamp = function (token) {\n    const claims = decode(token).claims;\n    const now = Math.floor(new Date().getTime() / 1000);\n    let validSince = 0, validUntil = 0;\n    if (typeof claims === 'object') {\n        if (claims.hasOwnProperty('nbf')) {\n            validSince = claims['nbf'];\n        }\n        else if (claims.hasOwnProperty('iat')) {\n            validSince = claims['iat'];\n        }\n        if (claims.hasOwnProperty('exp')) {\n            validUntil = claims['exp'];\n        }\n        else {\n            // token will expire after 24h by default\n            validUntil = validSince + 86400;\n        }\n    }\n    return (!!now &&\n        !!validSince &&\n        !!validUntil &&\n        now >= validSince &&\n        now <= validUntil);\n};\n/**\n * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.\n *\n * Notes:\n * - May return null if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst issuedAtTime = function (token) {\n    const claims = decode(token).claims;\n    if (typeof claims === 'object' && claims.hasOwnProperty('iat')) {\n        return claims['iat'];\n    }\n    return null;\n};\n/**\n * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst isValidFormat = function (token) {\n    const decoded = decode(token), claims = decoded.claims;\n    return !!claims && typeof claims === 'object' && claims.hasOwnProperty('iat');\n};\n/**\n * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst isAdmin = function (token) {\n    const claims = decode(token).claims;\n    return typeof claims === 'object' && claims['admin'] === true;\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction contains(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\nfunction safeGet(obj, key) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        return obj[key];\n    }\n    else {\n        return undefined;\n    }\n}\nfunction isEmpty(obj) {\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction map(obj, fn, contextObj) {\n    const res = {};\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            res[key] = fn.call(contextObj, obj[key], key, obj);\n        }\n    }\n    return res;\n}\n/**\n * Deep equal two objects. Support Arrays and Objects.\n */\nfunction deepEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n    for (const k of aKeys) {\n        if (!bKeys.includes(k)) {\n            return false;\n        }\n        const aProp = a[k];\n        const bProp = b[k];\n        if (isObject(aProp) && isObject(bProp)) {\n            if (!deepEqual(aProp, bProp)) {\n                return false;\n            }\n        }\n        else if (aProp !== bProp) {\n            return false;\n        }\n    }\n    for (const k of bKeys) {\n        if (!aKeys.includes(k)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isObject(thing) {\n    return thing !== null && typeof thing === 'object';\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Rejects if the given promise doesn't resolve in timeInMS milliseconds.\n * @internal\n */\nfunction promiseWithTimeout(promise, timeInMS = 2000) {\n    const deferredPromise = new Deferred();\n    setTimeout(() => deferredPromise.reject('timeout!'), timeInMS);\n    promise.then(deferredPromise.resolve, deferredPromise.reject);\n    return deferredPromise.promise;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a\n * params object (e.g. {arg: 'val', arg2: 'val2'})\n * Note: You must prepend it with ? when adding it to a URL.\n */\nfunction querystring(querystringParams) {\n    const params = [];\n    for (const [key, value] of Object.entries(querystringParams)) {\n        if (Array.isArray(value)) {\n            value.forEach(arrayVal => {\n                params.push(encodeURIComponent(key) + '=' + encodeURIComponent(arrayVal));\n            });\n        }\n        else {\n            params.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\n        }\n    }\n    return params.length ? '&' + params.join('&') : '';\n}\n/**\n * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object\n * (e.g. {arg: 'val', arg2: 'val2'})\n */\nfunction querystringDecode(querystring) {\n    const obj = {};\n    const tokens = querystring.replace(/^\\?/, '').split('&');\n    tokens.forEach(token => {\n        if (token) {\n            const [key, value] = token.split('=');\n            obj[decodeURIComponent(key)] = decodeURIComponent(value);\n        }\n    });\n    return obj;\n}\n/**\n * Extract the query string part of a URL, including the leading question mark (if present).\n */\nfunction extractQuerystring(url) {\n    const queryStart = url.indexOf('?');\n    if (!queryStart) {\n        return '';\n    }\n    const fragmentStart = url.indexOf('#', queryStart);\n    return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : undefined);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview SHA-1 cryptographic hash.\n * Variable names follow the notation in FIPS PUB 180-3:\n * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.\n *\n * Usage:\n *   var sha1 = new sha1();\n *   sha1.update(bytes);\n *   var hash = sha1.digest();\n *\n * Performance:\n *   Chrome 23:   ~400 Mbit/s\n *   Firefox 16:  ~250 Mbit/s\n *\n */\n/**\n * SHA-1 cryptographic hash constructor.\n *\n * The properties declared here are discussed in the above algorithm document.\n * @constructor\n * @final\n * @struct\n */\nclass Sha1 {\n    constructor() {\n        /**\n         * Holds the previous values of accumulated variables a-e in the compress_\n         * function.\n         * @private\n         */\n        this.chain_ = [];\n        /**\n         * A buffer holding the partially computed hash result.\n         * @private\n         */\n        this.buf_ = [];\n        /**\n         * An array of 80 bytes, each a part of the message to be hashed.  Referred to\n         * as the message schedule in the docs.\n         * @private\n         */\n        this.W_ = [];\n        /**\n         * Contains data needed to pad messages less than 64 bytes.\n         * @private\n         */\n        this.pad_ = [];\n        /**\n         * @private {number}\n         */\n        this.inbuf_ = 0;\n        /**\n         * @private {number}\n         */\n        this.total_ = 0;\n        this.blockSize = 512 / 8;\n        this.pad_[0] = 128;\n        for (let i = 1; i < this.blockSize; ++i) {\n            this.pad_[i] = 0;\n        }\n        this.reset();\n    }\n    reset() {\n        this.chain_[0] = 0x67452301;\n        this.chain_[1] = 0xefcdab89;\n        this.chain_[2] = 0x98badcfe;\n        this.chain_[3] = 0x10325476;\n        this.chain_[4] = 0xc3d2e1f0;\n        this.inbuf_ = 0;\n        this.total_ = 0;\n    }\n    /**\n     * Internal compress helper function.\n     * @param buf Block to compress.\n     * @param offset Offset of the block in the buffer.\n     * @private\n     */\n    compress_(buf, offset) {\n        if (!offset) {\n            offset = 0;\n        }\n        const W = this.W_;\n        // get 16 big endian words\n        if (typeof buf === 'string') {\n            for (let i = 0; i < 16; i++) {\n                // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS\n                // have a bug that turns the post-increment ++ operator into pre-increment\n                // during JIT compilation.  We have code that depends heavily on SHA-1 for\n                // correctness and which is affected by this bug, so I've removed all uses\n                // of post-increment ++ in which the result value is used.  We can revert\n                // this change once the Safari bug\n                // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and\n                // most clients have been updated.\n                W[i] =\n                    (buf.charCodeAt(offset) << 24) |\n                        (buf.charCodeAt(offset + 1) << 16) |\n                        (buf.charCodeAt(offset + 2) << 8) |\n                        buf.charCodeAt(offset + 3);\n                offset += 4;\n            }\n        }\n        else {\n            for (let i = 0; i < 16; i++) {\n                W[i] =\n                    (buf[offset] << 24) |\n                        (buf[offset + 1] << 16) |\n                        (buf[offset + 2] << 8) |\n                        buf[offset + 3];\n                offset += 4;\n            }\n        }\n        // expand to 80 words\n        for (let i = 16; i < 80; i++) {\n            const t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n            W[i] = ((t << 1) | (t >>> 31)) & 0xffffffff;\n        }\n        let a = this.chain_[0];\n        let b = this.chain_[1];\n        let c = this.chain_[2];\n        let d = this.chain_[3];\n        let e = this.chain_[4];\n        let f, k;\n        // TODO(user): Try to unroll this loop to speed up the computation.\n        for (let i = 0; i < 80; i++) {\n            if (i < 40) {\n                if (i < 20) {\n                    f = d ^ (b & (c ^ d));\n                    k = 0x5a827999;\n                }\n                else {\n                    f = b ^ c ^ d;\n                    k = 0x6ed9eba1;\n                }\n            }\n            else {\n                if (i < 60) {\n                    f = (b & c) | (d & (b | c));\n                    k = 0x8f1bbcdc;\n                }\n                else {\n                    f = b ^ c ^ d;\n                    k = 0xca62c1d6;\n                }\n            }\n            const t = (((a << 5) | (a >>> 27)) + f + e + k + W[i]) & 0xffffffff;\n            e = d;\n            d = c;\n            c = ((b << 30) | (b >>> 2)) & 0xffffffff;\n            b = a;\n            a = t;\n        }\n        this.chain_[0] = (this.chain_[0] + a) & 0xffffffff;\n        this.chain_[1] = (this.chain_[1] + b) & 0xffffffff;\n        this.chain_[2] = (this.chain_[2] + c) & 0xffffffff;\n        this.chain_[3] = (this.chain_[3] + d) & 0xffffffff;\n        this.chain_[4] = (this.chain_[4] + e) & 0xffffffff;\n    }\n    update(bytes, length) {\n        // TODO(johnlenz): tighten the function signature and remove this check\n        if (bytes == null) {\n            return;\n        }\n        if (length === undefined) {\n            length = bytes.length;\n        }\n        const lengthMinusBlock = length - this.blockSize;\n        let n = 0;\n        // Using local instead of member variables gives ~5% speedup on Firefox 16.\n        const buf = this.buf_;\n        let inbuf = this.inbuf_;\n        // The outer while loop should execute at most twice.\n        while (n < length) {\n            // When we have no data in the block to top up, we can directly process the\n            // input buffer (assuming it contains sufficient data). This gives ~25%\n            // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that\n            // the data is provided in large chunks (or in multiples of 64 bytes).\n            if (inbuf === 0) {\n                while (n <= lengthMinusBlock) {\n                    this.compress_(bytes, n);\n                    n += this.blockSize;\n                }\n            }\n            if (typeof bytes === 'string') {\n                while (n < length) {\n                    buf[inbuf] = bytes.charCodeAt(n);\n                    ++inbuf;\n                    ++n;\n                    if (inbuf === this.blockSize) {\n                        this.compress_(buf);\n                        inbuf = 0;\n                        // Jump to the outer loop so we use the full-block optimization.\n                        break;\n                    }\n                }\n            }\n            else {\n                while (n < length) {\n                    buf[inbuf] = bytes[n];\n                    ++inbuf;\n                    ++n;\n                    if (inbuf === this.blockSize) {\n                        this.compress_(buf);\n                        inbuf = 0;\n                        // Jump to the outer loop so we use the full-block optimization.\n                        break;\n                    }\n                }\n            }\n        }\n        this.inbuf_ = inbuf;\n        this.total_ += length;\n    }\n    /** @override */\n    digest() {\n        const digest = [];\n        let totalBits = this.total_ * 8;\n        // Add pad 0x80 0x00*.\n        if (this.inbuf_ < 56) {\n            this.update(this.pad_, 56 - this.inbuf_);\n        }\n        else {\n            this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));\n        }\n        // Add # bits.\n        for (let i = this.blockSize - 1; i >= 56; i--) {\n            this.buf_[i] = totalBits & 255;\n            totalBits /= 256; // Don't use bit-shifting here!\n        }\n        this.compress_(this.buf_);\n        let n = 0;\n        for (let i = 0; i < 5; i++) {\n            for (let j = 24; j >= 0; j -= 8) {\n                digest[n] = (this.chain_[i] >> j) & 255;\n                ++n;\n            }\n        }\n        return digest;\n    }\n}\n\n/**\n * Helper to make a Subscribe function (just like Promise helps make a\n * Thenable).\n *\n * @param executor Function which can make calls to a single Observer\n *     as a proxy.\n * @param onNoObservers Callback when count of Observers goes to zero.\n */\nfunction createSubscribe(executor, onNoObservers) {\n    const proxy = new ObserverProxy(executor, onNoObservers);\n    return proxy.subscribe.bind(proxy);\n}\n/**\n * Implement fan-out for any number of Observers attached via a subscribe\n * function.\n */\nclass ObserverProxy {\n    /**\n     * @param executor Function which can make calls to a single Observer\n     *     as a proxy.\n     * @param onNoObservers Callback when count of Observers goes to zero.\n     */\n    constructor(executor, onNoObservers) {\n        this.observers = [];\n        this.unsubscribes = [];\n        this.observerCount = 0;\n        // Micro-task scheduling by calling task.then().\n        this.task = Promise.resolve();\n        this.finalized = false;\n        this.onNoObservers = onNoObservers;\n        // Call the executor asynchronously so subscribers that are called\n        // synchronously after the creation of the subscribe function\n        // can still receive the very first value generated in the executor.\n        this.task\n            .then(() => {\n            executor(this);\n        })\n            .catch(e => {\n            this.error(e);\n        });\n    }\n    next(value) {\n        this.forEachObserver((observer) => {\n            observer.next(value);\n        });\n    }\n    error(error) {\n        this.forEachObserver((observer) => {\n            observer.error(error);\n        });\n        this.close(error);\n    }\n    complete() {\n        this.forEachObserver((observer) => {\n            observer.complete();\n        });\n        this.close();\n    }\n    /**\n     * Subscribe function that can be used to add an Observer to the fan-out list.\n     *\n     * - We require that no event is sent to a subscriber synchronously to their\n     *   call to subscribe().\n     */\n    subscribe(nextOrObserver, error, complete) {\n        let observer;\n        if (nextOrObserver === undefined &&\n            error === undefined &&\n            complete === undefined) {\n            throw new Error('Missing Observer.');\n        }\n        // Assemble an Observer object when passed as callback functions.\n        if (implementsAnyMethods(nextOrObserver, [\n            'next',\n            'error',\n            'complete'\n        ])) {\n            observer = nextOrObserver;\n        }\n        else {\n            observer = {\n                next: nextOrObserver,\n                error,\n                complete\n            };\n        }\n        if (observer.next === undefined) {\n            observer.next = noop;\n        }\n        if (observer.error === undefined) {\n            observer.error = noop;\n        }\n        if (observer.complete === undefined) {\n            observer.complete = noop;\n        }\n        const unsub = this.unsubscribeOne.bind(this, this.observers.length);\n        // Attempt to subscribe to a terminated Observable - we\n        // just respond to the Observer with the final error or complete\n        // event.\n        if (this.finalized) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this.task.then(() => {\n                try {\n                    if (this.finalError) {\n                        observer.error(this.finalError);\n                    }\n                    else {\n                        observer.complete();\n                    }\n                }\n                catch (e) {\n                    // nothing\n                }\n                return;\n            });\n        }\n        this.observers.push(observer);\n        return unsub;\n    }\n    // Unsubscribe is synchronous - we guarantee that no events are sent to\n    // any unsubscribed Observer.\n    unsubscribeOne(i) {\n        if (this.observers === undefined || this.observers[i] === undefined) {\n            return;\n        }\n        delete this.observers[i];\n        this.observerCount -= 1;\n        if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n            this.onNoObservers(this);\n        }\n    }\n    forEachObserver(fn) {\n        if (this.finalized) {\n            // Already closed by previous event....just eat the additional values.\n            return;\n        }\n        // Since sendOne calls asynchronously - there is no chance that\n        // this.observers will become undefined.\n        for (let i = 0; i < this.observers.length; i++) {\n            this.sendOne(i, fn);\n        }\n    }\n    // Call the Observer via one of it's callback function. We are careful to\n    // confirm that the observe has not been unsubscribed since this asynchronous\n    // function had been queued.\n    sendOne(i, fn) {\n        // Execute the callback asynchronously\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.task.then(() => {\n            if (this.observers !== undefined && this.observers[i] !== undefined) {\n                try {\n                    fn(this.observers[i]);\n                }\n                catch (e) {\n                    // Ignore exceptions raised in Observers or missing methods of an\n                    // Observer.\n                    // Log error to console. b/31404806\n                    if (typeof console !== 'undefined' && console.error) {\n                        console.error(e);\n                    }\n                }\n            }\n        });\n    }\n    close(err) {\n        if (this.finalized) {\n            return;\n        }\n        this.finalized = true;\n        if (err !== undefined) {\n            this.finalError = err;\n        }\n        // Proxy is no longer needed - garbage collect references\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.task.then(() => {\n            this.observers = undefined;\n            this.onNoObservers = undefined;\n        });\n    }\n}\n/** Turn synchronous function into one called asynchronously. */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction async(fn, onError) {\n    return (...args) => {\n        Promise.resolve(true)\n            .then(() => {\n            fn(...args);\n        })\n            .catch((error) => {\n            if (onError) {\n                onError(error);\n            }\n        });\n    };\n}\n/**\n * Return true if the object passed in implements any of the named methods.\n */\nfunction implementsAnyMethods(obj, methods) {\n    if (typeof obj !== 'object' || obj === null) {\n        return false;\n    }\n    for (const method of methods) {\n        if (method in obj && typeof obj[method] === 'function') {\n            return true;\n        }\n    }\n    return false;\n}\nfunction noop() {\n    // do nothing\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Check to make sure the appropriate number of arguments are provided for a public function.\n * Throws an error if it fails.\n *\n * @param fnName The function name\n * @param minCount The minimum number of arguments to allow for the function call\n * @param maxCount The maximum number of argument to allow for the function call\n * @param argCount The actual number of arguments provided.\n */\nconst validateArgCount = function (fnName, minCount, maxCount, argCount) {\n    let argError;\n    if (argCount < minCount) {\n        argError = 'at least ' + minCount;\n    }\n    else if (argCount > maxCount) {\n        argError = maxCount === 0 ? 'none' : 'no more than ' + maxCount;\n    }\n    if (argError) {\n        const error = fnName +\n            ' failed: Was called with ' +\n            argCount +\n            (argCount === 1 ? ' argument.' : ' arguments.') +\n            ' Expects ' +\n            argError +\n            '.';\n        throw new Error(error);\n    }\n};\n/**\n * Generates a string to prefix an error message about failed argument validation\n *\n * @param fnName The function name\n * @param argName The name of the argument\n * @return The prefix to add to the error thrown for validation.\n */\nfunction errorPrefix(fnName, argName) {\n    return `${fnName} failed: ${argName} argument `;\n}\n/**\n * @param fnName\n * @param argumentNumber\n * @param namespace\n * @param optional\n */\nfunction validateNamespace(fnName, namespace, optional) {\n    if (optional && !namespace) {\n        return;\n    }\n    if (typeof namespace !== 'string') {\n        //TODO: I should do more validation here. We only allow certain chars in namespaces.\n        throw new Error(errorPrefix(fnName, 'namespace') + 'must be a valid firebase namespace.');\n    }\n}\nfunction validateCallback(fnName, argumentName, \n// eslint-disable-next-line @typescript-eslint/ban-types\ncallback, optional) {\n    if (optional && !callback) {\n        return;\n    }\n    if (typeof callback !== 'function') {\n        throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid function.');\n    }\n}\nfunction validateContextObject(fnName, argumentName, context, optional) {\n    if (optional && !context) {\n        return;\n    }\n    if (typeof context !== 'object' || context === null) {\n        throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid context object.');\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they\n// automatically replaced '\\r\\n' with '\\n', and they didn't handle surrogate pairs,\n// so it's been modified.\n// Note that not all Unicode characters appear as single characters in JavaScript strings.\n// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters\n// use 2 characters in JavaScript.  All 4-byte UTF-8 characters begin with a first\n// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate\n// pair).\n// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3\n/**\n * @param {string} str\n * @return {Array}\n */\nconst stringToByteArray = function (str) {\n    const out = [];\n    let p = 0;\n    for (let i = 0; i < str.length; i++) {\n        let c = str.charCodeAt(i);\n        // Is this the lead surrogate in a surrogate pair?\n        if (c >= 0xd800 && c <= 0xdbff) {\n            const high = c - 0xd800; // the high 10 bits.\n            i++;\n            assert(i < str.length, 'Surrogate pair missing trail surrogate.');\n            const low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.\n            c = 0x10000 + (high << 10) + low;\n        }\n        if (c < 128) {\n            out[p++] = c;\n        }\n        else if (c < 2048) {\n            out[p++] = (c >> 6) | 192;\n            out[p++] = (c & 63) | 128;\n        }\n        else if (c < 65536) {\n            out[p++] = (c >> 12) | 224;\n            out[p++] = ((c >> 6) & 63) | 128;\n            out[p++] = (c & 63) | 128;\n        }\n        else {\n            out[p++] = (c >> 18) | 240;\n            out[p++] = ((c >> 12) & 63) | 128;\n            out[p++] = ((c >> 6) & 63) | 128;\n            out[p++] = (c & 63) | 128;\n        }\n    }\n    return out;\n};\n/**\n * Calculate length without actually converting; useful for doing cheaper validation.\n * @param {string} str\n * @return {number}\n */\nconst stringLength = function (str) {\n    let p = 0;\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n        if (c < 128) {\n            p++;\n        }\n        else if (c < 2048) {\n            p += 2;\n        }\n        else if (c >= 0xd800 && c <= 0xdbff) {\n            // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.\n            p += 4;\n            i++; // skip trail surrogate.\n        }\n        else {\n            p += 3;\n        }\n    }\n    return p;\n};\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Copied from https://stackoverflow.com/a/2117523\n * Generates a new uuid.\n * @public\n */\nconst uuidv4 = function () {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n        const r = (Math.random() * 16) | 0, v = c === 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n};\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The amount of milliseconds to exponentially increase.\n */\nconst DEFAULT_INTERVAL_MILLIS = 1000;\n/**\n * The factor to backoff by.\n * Should be a number greater than 1.\n */\nconst DEFAULT_BACKOFF_FACTOR = 2;\n/**\n * The maximum milliseconds to increase to.\n *\n * <p>Visible for testing\n */\nconst MAX_VALUE_MILLIS = 4 * 60 * 60 * 1000; // Four hours, like iOS and Android.\n/**\n * The percentage of backoff time to randomize by.\n * See\n * http://go/safe-client-behavior#step-1-determine-the-appropriate-retry-interval-to-handle-spike-traffic\n * for context.\n *\n * <p>Visible for testing\n */\nconst RANDOM_FACTOR = 0.5;\n/**\n * Based on the backoff method from\n * https://github.com/google/closure-library/blob/master/closure/goog/math/exponentialbackoff.js.\n * Extracted here so we don't need to pass metadata and a stateful ExponentialBackoff object around.\n */\nfunction calculateBackoffMillis(backoffCount, intervalMillis = DEFAULT_INTERVAL_MILLIS, backoffFactor = DEFAULT_BACKOFF_FACTOR) {\n    // Calculates an exponentially increasing value.\n    // Deviation: calculates value from count and a constant interval, so we only need to save value\n    // and count to restore state.\n    const currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);\n    // A random \"fuzz\" to avoid waves of retries.\n    // Deviation: randomFactor is required.\n    const randomWait = Math.round(\n    // A fraction of the backoff value to add/subtract.\n    // Deviation: changes multiplication order to improve readability.\n    RANDOM_FACTOR *\n        currBaseValue *\n        // A random float (rounded to int by Math.round above) in the range [-1, 1]. Determines\n        // if we add or subtract.\n        (Math.random() - 0.5) *\n        2);\n    // Limits backoff to max to avoid effectively permanent backoff.\n    return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provide English ordinal letters after a number\n */\nfunction ordinal(i) {\n    if (!Number.isFinite(i)) {\n        return `${i}`;\n    }\n    return i + indicator(i);\n}\nfunction indicator(i) {\n    i = Math.abs(i);\n    const cent = i % 100;\n    if (cent >= 10 && cent <= 20) {\n        return 'th';\n    }\n    const dec = i % 10;\n    if (dec === 1) {\n        return 'st';\n    }\n    if (dec === 2) {\n        return 'nd';\n    }\n    if (dec === 3) {\n        return 'rd';\n    }\n    return 'th';\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction getModularInstance(service) {\n    if (service && service._delegate) {\n        return service._delegate;\n    }\n    else {\n        return service;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Overriding the constant (we should be the only ones doing this)\nCONSTANTS.NODE_CLIENT = true;\n\n\n//# sourceMappingURL=index.node.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9ub2RlLWVzbS9pbmRleC5ub2RlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLEVBQUU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLHdDQUF3QyxNQUFNO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUSx3RUFBd0UsS0FBSzs7QUFFaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxNQUFNO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUJBQWlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYSxHQUFHLEtBQUs7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlCQUFpQixJQUFJLFNBQVMsR0FBRyxTQUFTO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELElBQUk7QUFDdkQsS0FBSztBQUNMO0FBQ0EsbUJBQW1CLE1BQU0sSUFBSTs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxHQUFHO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixhQUFhLFdBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseUJBQXlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUSxVQUFVLFNBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsRUFBRTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNi9CO0FBQzcvQiIsInNvdXJjZXMiOlsiL1VzZXJzL3Z0cGF0ZWwwNy9QYXRlbENNUDIzM0ZpbmFsUHJvamVjdC9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9ub2RlLWVzbS9pbmRleC5ub2RlLmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEZpcmViYXNlIGNvbnN0YW50cy4gIFNvbWUgb2YgdGhlc2UgKEBkZWZpbmVzKSBjYW4gYmUgb3ZlcnJpZGRlbiBhdCBjb21waWxlLXRpbWUuXG4gKi9cbmNvbnN0IENPTlNUQU5UUyA9IHtcbiAgICAvKipcbiAgICAgKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRoaXMgaXMgdGhlIGNsaWVudCBOb2RlLmpzIFNESy5cbiAgICAgKi9cbiAgICBOT0RFX0NMSUVOVDogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIGlzIHRoZSBBZG1pbiBOb2RlLmpzIFNESy5cbiAgICAgKi9cbiAgICBOT0RFX0FETUlOOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBGaXJlYmFzZSBTREsgVmVyc2lvblxuICAgICAqL1xuICAgIFNES19WRVJTSU9OOiAnJHtKU0NPUkVfVkVSU0lPTn0nXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHByb3ZpZGVkIGFzc2VydGlvbiBpcyBmYWxzeVxuICovXG5jb25zdCBhc3NlcnQgPSBmdW5jdGlvbiAoYXNzZXJ0aW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFhc3NlcnRpb24pIHtcbiAgICAgICAgdGhyb3cgYXNzZXJ0aW9uRXJyb3IobWVzc2FnZSk7XG4gICAgfVxufTtcbi8qKlxuICogUmV0dXJucyBhbiBFcnJvciBvYmplY3Qgc3VpdGFibGUgZm9yIHRocm93aW5nLlxuICovXG5jb25zdCBhc3NlcnRpb25FcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignRmlyZWJhc2UgRGF0YWJhc2UgKCcgK1xuICAgICAgICBDT05TVEFOVFMuU0RLX1ZFUlNJT04gK1xuICAgICAgICAnKSBJTlRFUk5BTCBBU1NFUlQgRkFJTEVEOiAnICtcbiAgICAgICAgbWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3Qgc3RyaW5nVG9CeXRlQXJyYXkkMSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAvLyBUT0RPKHVzZXIpOiBVc2UgbmF0aXZlIGltcGxlbWVudGF0aW9ucyBpZi93aGVuIGF2YWlsYWJsZVxuICAgIGNvbnN0IG91dCA9IFtdO1xuICAgIGxldCBwID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgICAgICAgb3V0W3ArK10gPSBjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KSB7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDYpIHwgMTkyO1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJlxuICAgICAgICAgICAgaSArIDEgPCBzdHIubGVuZ3RoICYmXG4gICAgICAgICAgICAoc3RyLmNoYXJDb2RlQXQoaSArIDEpICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgICAgICAvLyBTdXJyb2dhdGUgUGFpclxuICAgICAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgJiAweDAzZmYpIDw8IDEwKSArIChzdHIuY2hhckNvZGVBdCgrK2kpICYgMHgwM2ZmKTtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gMTgpIHwgMjQwO1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gMTIpICYgNjMpIHwgMTI4O1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiAxMikgfCAyMjQ7XG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG4vKipcbiAqIFR1cm5zIGFuIGFycmF5IG9mIG51bWJlcnMgaW50byB0aGUgc3RyaW5nIGdpdmVuIGJ5IHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZVxuICogY2hhcmFjdGVycyB0byB3aGljaCB0aGUgbnVtYmVycyBjb3JyZXNwb25kLlxuICogQHBhcmFtIGJ5dGVzIEFycmF5IG9mIG51bWJlcnMgcmVwcmVzZW50aW5nIGNoYXJhY3RlcnMuXG4gKiBAcmV0dXJuIFN0cmluZ2lmaWNhdGlvbiBvZiB0aGUgYXJyYXkuXG4gKi9cbmNvbnN0IGJ5dGVBcnJheVRvU3RyaW5nID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgLy8gVE9ETyh1c2VyKTogVXNlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbnMgaWYvd2hlbiBhdmFpbGFibGVcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBsZXQgcG9zID0gMCwgYyA9IDA7XG4gICAgd2hpbGUgKHBvcyA8IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjMSA9IGJ5dGVzW3BvcysrXTtcbiAgICAgICAgaWYgKGMxIDwgMTI4KSB7XG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYzEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMxID4gMTkxICYmIGMxIDwgMjI0KSB7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGJ5dGVzW3BvcysrXTtcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMxICYgMzEpIDw8IDYpIHwgKGMyICYgNjMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjMSA+IDIzOSAmJiBjMSA8IDM2NSkge1xuICAgICAgICAgICAgLy8gU3Vycm9nYXRlIFBhaXJcbiAgICAgICAgICAgIGNvbnN0IGMyID0gYnl0ZXNbcG9zKytdO1xuICAgICAgICAgICAgY29uc3QgYzMgPSBieXRlc1twb3MrK107XG4gICAgICAgICAgICBjb25zdCBjNCA9IGJ5dGVzW3BvcysrXTtcbiAgICAgICAgICAgIGNvbnN0IHUgPSAoKChjMSAmIDcpIDw8IDE4KSB8ICgoYzIgJiA2MykgPDwgMTIpIHwgKChjMyAmIDYzKSA8PCA2KSB8IChjNCAmIDYzKSkgLVxuICAgICAgICAgICAgICAgIDB4MTAwMDA7XG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODAwICsgKHUgPj4gMTApKTtcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGRjMDAgKyAodSAmIDEwMjMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gYnl0ZXNbcG9zKytdO1xuICAgICAgICAgICAgY29uc3QgYzMgPSBieXRlc1twb3MrK107XG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjMSAmIDE1KSA8PCAxMikgfCAoKGMyICYgNjMpIDw8IDYpIHwgKGMzICYgNjMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0LmpvaW4oJycpO1xufTtcbi8vIFdlIGRlZmluZSBpdCBhcyBhbiBvYmplY3QgbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY2xhc3MgYmVjYXVzZSBhIGNsYXNzIGNvbXBpbGVkIGRvd24gdG8gZXM1IGNhbid0XG4vLyBiZSB0cmVlc2hha2VkLiBodHRwczovL2dpdGh1Yi5jb20vcm9sbHVwL3JvbGx1cC9pc3N1ZXMvMTY5MVxuLy8gU3RhdGljIGxvb2t1cCBtYXBzLCBsYXppbHkgcG9wdWxhdGVkIGJ5IGluaXRfKClcbi8vIFRPRE8oZGxhcm9jcXVlKTogRGVmaW5lIHRoaXMgYXMgYSBjbGFzcywgc2luY2Ugd2Ugbm8gbG9uZ2VyIHRhcmdldCBFUzUuXG5jb25zdCBiYXNlNjQgPSB7XG4gICAgLyoqXG4gICAgICogTWFwcyBieXRlcyB0byBjaGFyYWN0ZXJzLlxuICAgICAqL1xuICAgIGJ5dGVUb0NoYXJNYXBfOiBudWxsLFxuICAgIC8qKlxuICAgICAqIE1hcHMgY2hhcmFjdGVycyB0byBieXRlcy5cbiAgICAgKi9cbiAgICBjaGFyVG9CeXRlTWFwXzogbnVsbCxcbiAgICAvKipcbiAgICAgKiBNYXBzIGJ5dGVzIHRvIHdlYnNhZmUgY2hhcmFjdGVycy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGJ5dGVUb0NoYXJNYXBXZWJTYWZlXzogbnVsbCxcbiAgICAvKipcbiAgICAgKiBNYXBzIHdlYnNhZmUgY2hhcmFjdGVycyB0byBieXRlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNoYXJUb0J5dGVNYXBXZWJTYWZlXzogbnVsbCxcbiAgICAvKipcbiAgICAgKiBPdXIgZGVmYXVsdCBhbHBoYWJldCwgc2hhcmVkIGJldHdlZW5cbiAgICAgKiBFTkNPREVEX1ZBTFMgYW5kIEVOQ09ERURfVkFMU19XRUJTQUZFXG4gICAgICovXG4gICAgRU5DT0RFRF9WQUxTX0JBU0U6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWicgKyAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonICsgJzAxMjM0NTY3ODknLFxuICAgIC8qKlxuICAgICAqIE91ciBkZWZhdWx0IGFscGhhYmV0LiBWYWx1ZSA2NCAoPSkgaXMgc3BlY2lhbDsgaXQgbWVhbnMgXCJub3RoaW5nLlwiXG4gICAgICovXG4gICAgZ2V0IEVOQ09ERURfVkFMUygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UgKyAnKy89JztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIE91ciB3ZWJzYWZlIGFscGhhYmV0LlxuICAgICAqL1xuICAgIGdldCBFTkNPREVEX1ZBTFNfV0VCU0FGRSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UgKyAnLV8uJztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBicm93c2VyIHN1cHBvcnRzIHRoZSBhdG9iIGFuZCBidG9hIGZ1bmN0aW9ucy4gVGhpcyBleHRlbnNpb25cbiAgICAgKiBzdGFydGVkIGF0IE1vemlsbGEgYnV0IGlzIG5vdyBpbXBsZW1lbnRlZCBieSBtYW55IGJyb3dzZXJzLiBXZSB1c2UgdGhlXG4gICAgICogQVNTVU1FXyogdmFyaWFibGVzIHRvIGF2b2lkIHB1bGxpbmcgaW4gdGhlIGZ1bGwgdXNlcmFnZW50IGRldGVjdGlvbiBsaWJyYXJ5XG4gICAgICogYnV0IHN0aWxsIGFsbG93aW5nIHRoZSBzdGFuZGFyZCBwZXItYnJvd3NlciBjb21waWxhdGlvbnMuXG4gICAgICpcbiAgICAgKi9cbiAgICBIQVNfTkFUSVZFX1NVUFBPUlQ6IHR5cGVvZiBhdG9iID09PSAnZnVuY3Rpb24nLFxuICAgIC8qKlxuICAgICAqIEJhc2U2NC1lbmNvZGUgYW4gYXJyYXkgb2YgYnl0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgQW4gYXJyYXkgb2YgYnl0ZXMgKG51bWJlcnMgd2l0aFxuICAgICAqICAgICB2YWx1ZSBpbiBbMCwgMjU1XSkgdG8gZW5jb2RlLlxuICAgICAqIEBwYXJhbSB3ZWJTYWZlIEJvb2xlYW4gaW5kaWNhdGluZyB3ZSBzaG91bGQgdXNlIHRoZVxuICAgICAqICAgICBhbHRlcm5hdGl2ZSBhbHBoYWJldC5cbiAgICAgKiBAcmV0dXJuIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZW5jb2RlQnl0ZUFycmF5KGlucHV0LCB3ZWJTYWZlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdlbmNvZGVCeXRlQXJyYXkgdGFrZXMgYW4gYXJyYXkgYXMgYSBwYXJhbWV0ZXInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRfKCk7XG4gICAgICAgIGNvbnN0IGJ5dGVUb0NoYXJNYXAgPSB3ZWJTYWZlXG4gICAgICAgICAgICA/IHRoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfXG4gICAgICAgICAgICA6IHRoaXMuYnl0ZVRvQ2hhck1hcF87XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBjb25zdCBieXRlMSA9IGlucHV0W2ldO1xuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGUyID0gaSArIDEgPCBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBieXRlMiA9IGhhdmVCeXRlMiA/IGlucHV0W2kgKyAxXSA6IDA7XG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTMgPSBpICsgMiA8IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUzID0gaGF2ZUJ5dGUzID8gaW5wdXRbaSArIDJdIDogMDtcbiAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUxID0gYnl0ZTEgPj4gMjtcbiAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUyID0gKChieXRlMSAmIDB4MDMpIDw8IDQpIHwgKGJ5dGUyID4+IDQpO1xuICAgICAgICAgICAgbGV0IG91dEJ5dGUzID0gKChieXRlMiAmIDB4MGYpIDw8IDIpIHwgKGJ5dGUzID4+IDYpO1xuICAgICAgICAgICAgbGV0IG91dEJ5dGU0ID0gYnl0ZTMgJiAweDNmO1xuICAgICAgICAgICAgaWYgKCFoYXZlQnl0ZTMpIHtcbiAgICAgICAgICAgICAgICBvdXRCeXRlNCA9IDY0O1xuICAgICAgICAgICAgICAgIGlmICghaGF2ZUJ5dGUyKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dEJ5dGUzID0gNjQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0LnB1c2goYnl0ZVRvQ2hhck1hcFtvdXRCeXRlMV0sIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTJdLCBieXRlVG9DaGFyTWFwW291dEJ5dGUzXSwgYnl0ZVRvQ2hhck1hcFtvdXRCeXRlNF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQuam9pbignJyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBCYXNlNjQtZW5jb2RlIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IEEgc3RyaW5nIHRvIGVuY29kZS5cbiAgICAgKiBAcGFyYW0gd2ViU2FmZSBJZiB0cnVlLCB3ZSBzaG91bGQgdXNlIHRoZVxuICAgICAqICAgICBhbHRlcm5hdGl2ZSBhbHBoYWJldC5cbiAgICAgKiBAcmV0dXJuIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZW5jb2RlU3RyaW5nKGlucHV0LCB3ZWJTYWZlKSB7XG4gICAgICAgIC8vIFNob3J0Y3V0IGZvciBNb3ppbGxhIGJyb3dzZXJzIHRoYXQgaW1wbGVtZW50XG4gICAgICAgIC8vIGEgbmF0aXZlIGJhc2U2NCBlbmNvZGVyIGluIHRoZSBmb3JtIG9mIFwiYnRvYS9hdG9iXCJcbiAgICAgICAgaWYgKHRoaXMuSEFTX05BVElWRV9TVVBQT1JUICYmICF3ZWJTYWZlKSB7XG4gICAgICAgICAgICByZXR1cm4gYnRvYShpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlQnl0ZUFycmF5KHN0cmluZ1RvQnl0ZUFycmF5JDEoaW5wdXQpLCB3ZWJTYWZlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEJhc2U2NC1kZWNvZGUgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgdG8gZGVjb2RlLlxuICAgICAqIEBwYXJhbSB3ZWJTYWZlIFRydWUgaWYgd2Ugc2hvdWxkIHVzZSB0aGVcbiAgICAgKiAgICAgYWx0ZXJuYXRpdmUgYWxwaGFiZXQuXG4gICAgICogQHJldHVybiBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBkZWNvZGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGRlY29kZVN0cmluZyhpbnB1dCwgd2ViU2FmZSkge1xuICAgICAgICAvLyBTaG9ydGN1dCBmb3IgTW96aWxsYSBicm93c2VycyB0aGF0IGltcGxlbWVudFxuICAgICAgICAvLyBhIG5hdGl2ZSBiYXNlNjQgZW5jb2RlciBpbiB0aGUgZm9ybSBvZiBcImJ0b2EvYXRvYlwiXG4gICAgICAgIGlmICh0aGlzLkhBU19OQVRJVkVfU1VQUE9SVCAmJiAhd2ViU2FmZSkge1xuICAgICAgICAgICAgcmV0dXJuIGF0b2IoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBieXRlQXJyYXlUb1N0cmluZyh0aGlzLmRlY29kZVN0cmluZ1RvQnl0ZUFycmF5KGlucHV0LCB3ZWJTYWZlKSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBCYXNlNjQtZGVjb2RlIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogSW4gYmFzZS02NCBkZWNvZGluZywgZ3JvdXBzIG9mIGZvdXIgY2hhcmFjdGVycyBhcmUgY29udmVydGVkIGludG8gdGhyZWVcbiAgICAgKiBieXRlcy4gIElmIHRoZSBlbmNvZGVyIGRpZCBub3QgYXBwbHkgcGFkZGluZywgdGhlIGlucHV0IGxlbmd0aCBtYXkgbm90XG4gICAgICogYmUgYSBtdWx0aXBsZSBvZiA0LlxuICAgICAqXG4gICAgICogSW4gdGhpcyBjYXNlLCB0aGUgbGFzdCBncm91cCB3aWxsIGhhdmUgZmV3ZXIgdGhhbiA0IGNoYXJhY3RlcnMsIGFuZFxuICAgICAqIHBhZGRpbmcgd2lsbCBiZSBpbmZlcnJlZC4gIElmIHRoZSBncm91cCBoYXMgb25lIG9yIHR3byBjaGFyYWN0ZXJzLCBpdCBkZWNvZGVzXG4gICAgICogdG8gb25lIGJ5dGUuICBJZiB0aGUgZ3JvdXAgaGFzIHRocmVlIGNoYXJhY3RlcnMsIGl0IGRlY29kZXMgdG8gdHdvIGJ5dGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IElucHV0IHRvIGRlY29kZS5cbiAgICAgKiBAcGFyYW0gd2ViU2FmZSBUcnVlIGlmIHdlIHNob3VsZCB1c2UgdGhlIHdlYi1zYWZlIGFscGhhYmV0LlxuICAgICAqIEByZXR1cm4gYnl0ZXMgcmVwcmVzZW50aW5nIHRoZSBkZWNvZGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGRlY29kZVN0cmluZ1RvQnl0ZUFycmF5KGlucHV0LCB3ZWJTYWZlKSB7XG4gICAgICAgIHRoaXMuaW5pdF8oKTtcbiAgICAgICAgY29uc3QgY2hhclRvQnl0ZU1hcCA9IHdlYlNhZmVcbiAgICAgICAgICAgID8gdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV9cbiAgICAgICAgICAgIDogdGhpcy5jaGFyVG9CeXRlTWFwXztcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOykge1xuICAgICAgICAgICAgY29uc3QgYnl0ZTEgPSBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgIGNvbnN0IGhhdmVCeXRlMiA9IGkgPCBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBieXRlMiA9IGhhdmVCeXRlMiA/IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkpXSA6IDA7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTMgPSBpIDwgaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgYnl0ZTMgPSBoYXZlQnl0ZTMgPyBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKV0gOiA2NDtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIGNvbnN0IGhhdmVCeXRlNCA9IGkgPCBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBieXRlNCA9IGhhdmVCeXRlNCA/IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkpXSA6IDY0O1xuICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgaWYgKGJ5dGUxID09IG51bGwgfHwgYnl0ZTIgPT0gbnVsbCB8fCBieXRlMyA9PSBudWxsIHx8IGJ5dGU0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUxID0gKGJ5dGUxIDw8IDIpIHwgKGJ5dGUyID4+IDQpO1xuICAgICAgICAgICAgb3V0cHV0LnB1c2gob3V0Qnl0ZTEpO1xuICAgICAgICAgICAgaWYgKGJ5dGUzICE9PSA2NCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUyID0gKChieXRlMiA8PCA0KSAmIDB4ZjApIHwgKGJ5dGUzID4+IDIpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKG91dEJ5dGUyKTtcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZTQgIT09IDY0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUzID0gKChieXRlMyA8PCA2KSAmIDB4YzApIHwgYnl0ZTQ7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKG91dEJ5dGUzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIExhenkgc3RhdGljIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9uLiBDYWxsZWQgYmVmb3JlXG4gICAgICogYWNjZXNzaW5nIGFueSBvZiB0aGUgc3RhdGljIG1hcCB2YXJpYWJsZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbml0XygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ5dGVUb0NoYXJNYXBfKSB7XG4gICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBfID0ge307XG4gICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBfID0ge307XG4gICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlXyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV8gPSB7fTtcbiAgICAgICAgICAgIC8vIFdlIHdhbnQgcXVpY2sgbWFwcGluZ3MgYmFjayBhbmQgZm9ydGgsIHNvIHdlIHByZWNvbXB1dGUgdHdvIG1hcHMuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRU5DT0RFRF9WQUxTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwX1tpXSA9IHRoaXMuRU5DT0RFRF9WQUxTLmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBfW3RoaXMuYnl0ZVRvQ2hhck1hcF9baV1dID0gaTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlX1tpXSA9IHRoaXMuRU5DT0RFRF9WQUxTX1dFQlNBRkUuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfW3RoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfW2ldXSA9IGk7XG4gICAgICAgICAgICAgICAgLy8gQmUgZm9yZ2l2aW5nIHdoZW4gZGVjb2RpbmcgYW5kIGNvcnJlY3RseSBkZWNvZGUgYm90aCBlbmNvZGluZ3MuXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gdGhpcy5FTkNPREVEX1ZBTFNfQkFTRS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwX1t0aGlzLkVOQ09ERURfVkFMU19XRUJTQUZFLmNoYXJBdChpKV0gPSBpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBXZWJTYWZlX1t0aGlzLkVOQ09ERURfVkFMUy5jaGFyQXQoaSldID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyoqXG4gKiBBbiBlcnJvciBlbmNvdW50ZXJlZCB3aGlsZSBkZWNvZGluZyBiYXNlNjQgc3RyaW5nLlxuICovXG5jbGFzcyBEZWNvZGVCYXNlNjRTdHJpbmdFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0RlY29kZUJhc2U2NFN0cmluZ0Vycm9yJztcbiAgICB9XG59XG4vKipcbiAqIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZ1xuICovXG5jb25zdCBiYXNlNjRFbmNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgY29uc3QgdXRmOEJ5dGVzID0gc3RyaW5nVG9CeXRlQXJyYXkkMShzdHIpO1xuICAgIHJldHVybiBiYXNlNjQuZW5jb2RlQnl0ZUFycmF5KHV0ZjhCeXRlcywgdHJ1ZSk7XG59O1xuLyoqXG4gKiBVUkwtc2FmZSBiYXNlNjQgZW5jb2RpbmcgKHdpdGhvdXQgXCIuXCIgcGFkZGluZyBpbiB0aGUgZW5kKS5cbiAqIGUuZy4gVXNlZCBpbiBKU09OIFdlYiBUb2tlbiAoSldUKSBwYXJ0cy5cbiAqL1xuY29uc3QgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgLy8gVXNlIGJhc2U2NHVybCBlbmNvZGluZyBhbmQgcmVtb3ZlIHBhZGRpbmcgaW4gdGhlIGVuZCAoZG90IGNoYXJhY3RlcnMpLlxuICAgIHJldHVybiBiYXNlNjRFbmNvZGUoc3RyKS5yZXBsYWNlKC9cXC4vZywgJycpO1xufTtcbi8qKlxuICogVVJMLXNhZmUgYmFzZTY0IGRlY29kaW5nXG4gKlxuICogTk9URTogRE8gTk9UIHVzZSB0aGUgZ2xvYmFsIGF0b2IoKSBmdW5jdGlvbiAtIGl0IGRvZXMgTk9UIHN1cHBvcnQgdGhlXG4gKiBiYXNlNjRVcmwgdmFyaWFudCBlbmNvZGluZy5cbiAqXG4gKiBAcGFyYW0gc3RyIFRvIGJlIGRlY29kZWRcbiAqIEByZXR1cm4gRGVjb2RlZCByZXN1bHQsIGlmIHBvc3NpYmxlXG4gKi9cbmNvbnN0IGJhc2U2NERlY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYmFzZTY0LmRlY29kZVN0cmluZyhzdHIsIHRydWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdiYXNlNjREZWNvZGUgZmFpbGVkOiAnLCBlKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBEbyBhIGRlZXAtY29weSBvZiBiYXNpYyBKYXZhU2NyaXB0IE9iamVjdHMgb3IgQXJyYXlzLlxuICovXG5mdW5jdGlvbiBkZWVwQ29weSh2YWx1ZSkge1xuICAgIHJldHVybiBkZWVwRXh0ZW5kKHVuZGVmaW5lZCwgdmFsdWUpO1xufVxuLyoqXG4gKiBDb3B5IHByb3BlcnRpZXMgZnJvbSBzb3VyY2UgdG8gdGFyZ2V0IChyZWN1cnNpdmVseSBhbGxvd3MgZXh0ZW5zaW9uXG4gKiBvZiBPYmplY3RzIGFuZCBBcnJheXMpLiAgU2NhbGFyIHZhbHVlcyBpbiB0aGUgdGFyZ2V0IGFyZSBvdmVyLXdyaXR0ZW4uXG4gKiBJZiB0YXJnZXQgaXMgdW5kZWZpbmVkLCBhbiBvYmplY3Qgb2YgdGhlIGFwcHJvcHJpYXRlIHR5cGUgd2lsbCBiZSBjcmVhdGVkXG4gKiAoYW5kIHJldHVybmVkKS5cbiAqXG4gKiBXZSByZWN1cnNpdmVseSBjb3B5IGFsbCBjaGlsZCBwcm9wZXJ0aWVzIG9mIHBsYWluIE9iamVjdHMgaW4gdGhlIHNvdXJjZS0gc29cbiAqIHRoYXQgbmFtZXNwYWNlLSBsaWtlIGRpY3Rpb25hcmllcyBhcmUgbWVyZ2VkLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgdGFyZ2V0IGNhbiBiZSBhIGZ1bmN0aW9uLCBpbiB3aGljaCBjYXNlIHRoZSBwcm9wZXJ0aWVzIGluXG4gKiB0aGUgc291cmNlIE9iamVjdCBhcmUgY29waWVkIG9udG8gaXQgYXMgc3RhdGljIHByb3BlcnRpZXMgb2YgdGhlIEZ1bmN0aW9uLlxuICpcbiAqIE5vdGU6IHdlIGRvbid0IG1lcmdlIF9fcHJvdG9fXyB0byBwcmV2ZW50IHByb3RvdHlwZSBwb2xsdXRpb25cbiAqL1xuZnVuY3Rpb24gZGVlcEV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9XG4gICAgc3dpdGNoIChzb3VyY2UuY29uc3RydWN0b3IpIHtcbiAgICAgICAgY2FzZSBEYXRlOlxuICAgICAgICAgICAgLy8gVHJlYXQgRGF0ZXMgbGlrZSBzY2FsYXJzOyBpZiB0aGUgdGFyZ2V0IGRhdGUgb2JqZWN0IGhhZCBhbnkgY2hpbGRcbiAgICAgICAgICAgIC8vIHByb3BlcnRpZXMgLSB0aGV5IHdpbGwgYmUgbG9zdCFcbiAgICAgICAgICAgIGNvbnN0IGRhdGVWYWx1ZSA9IHNvdXJjZTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlVmFsdWUuZ2V0VGltZSgpKTtcbiAgICAgICAgY2FzZSBPYmplY3Q6XG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFycmF5OlxuICAgICAgICAgICAgLy8gQWx3YXlzIGNvcHkgdGhlIGFycmF5IHNvdXJjZSBhbmQgb3ZlcndyaXRlIHRoZSB0YXJnZXQuXG4gICAgICAgICAgICB0YXJnZXQgPSBbXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gTm90IGEgcGxhaW4gT2JqZWN0IC0gdHJlYXQgaXQgYXMgYSBzY2FsYXIuXG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIC8vIHVzZSBpc1ZhbGlkS2V5IHRvIGd1YXJkIGFnYWluc3QgcHJvdG90eXBlIHBvbGx1dGlvbi4gU2VlIGh0dHBzOi8vc255ay5pby92dWxuL1NOWUstSlMtTE9EQVNILTQ1MDIwMlxuICAgICAgICBpZiAoIXNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSB8fCAhaXNWYWxpZEtleShwcm9wKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gZGVlcEV4dGVuZCh0YXJnZXRbcHJvcF0sIHNvdXJjZVtwcm9wXSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleSkge1xuICAgIHJldHVybiBrZXkgIT09ICdfX3Byb3RvX18nO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBQb2x5ZmlsbCBmb3IgYGdsb2JhbFRoaXNgIG9iamVjdC5cbiAqIEByZXR1cm5zIHRoZSBgZ2xvYmFsVGhpc2Agb2JqZWN0IGZvciB0aGUgZ2l2ZW4gZW52aXJvbm1lbnQuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGdldEdsb2JhbCgpIHtcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWw7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0LicpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgZ2V0RGVmYXVsdHNGcm9tR2xvYmFsID0gKCkgPT4gZ2V0R2xvYmFsKCkuX19GSVJFQkFTRV9ERUZBVUxUU19fO1xuLyoqXG4gKiBBdHRlbXB0IHRvIHJlYWQgZGVmYXVsdHMgZnJvbSBhIEpTT04gc3RyaW5nIHByb3ZpZGVkIHRvXG4gKiBwcm9jZXNzKC4pZW52KC4pX19GSVJFQkFTRV9ERUZBVUxUU19fIG9yIGEgSlNPTiBmaWxlIHdob3NlIHBhdGggaXMgaW5cbiAqIHByb2Nlc3MoLillbnYoLilfX0ZJUkVCQVNFX0RFRkFVTFRTX1BBVEhfX1xuICogVGhlIGRvdHMgYXJlIGluIHBhcmVucyBiZWNhdXNlIGNlcnRhaW4gY29tcGlsZXJzIChWaXRlPykgY2Fubm90XG4gKiBoYW5kbGUgc2VlaW5nIHRoYXQgdmFyaWFibGUgaW4gY29tbWVudHMuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2ZpcmViYXNlLWpzLXNkay9pc3N1ZXMvNjgzOFxuICovXG5jb25zdCBnZXREZWZhdWx0c0Zyb21FbnZWYXJpYWJsZSA9ICgpID0+IHtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBwcm9jZXNzLmVudiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkZWZhdWx0c0pzb25TdHJpbmcgPSBwcm9jZXNzLmVudi5fX0ZJUkVCQVNFX0RFRkFVTFRTX187XG4gICAgaWYgKGRlZmF1bHRzSnNvblN0cmluZykge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkZWZhdWx0c0pzb25TdHJpbmcpO1xuICAgIH1cbn07XG5jb25zdCBnZXREZWZhdWx0c0Zyb21Db29raWUgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbWF0Y2g7XG4gICAgdHJ5IHtcbiAgICAgICAgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2goL19fRklSRUJBU0VfREVGQVVMVFNfXz0oW147XSspLyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFNvbWUgZW52aXJvbm1lbnRzIHN1Y2ggYXMgQW5ndWxhciBVbml2ZXJzYWwgU1NSIGhhdmUgYVxuICAgICAgICAvLyBgZG9jdW1lbnRgIG9iamVjdCBidXQgZXJyb3Igb24gYWNjZXNzaW5nIGBkb2N1bWVudC5jb29raWVgLlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRlY29kZWQgPSBtYXRjaCAmJiBiYXNlNjREZWNvZGUobWF0Y2hbMV0pO1xuICAgIHJldHVybiBkZWNvZGVkICYmIEpTT04ucGFyc2UoZGVjb2RlZCk7XG59O1xuLyoqXG4gKiBHZXQgdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3QuIEl0IGNoZWNrcyBpbiBvcmRlcjpcbiAqICgxKSBpZiBzdWNoIGFuIG9iamVjdCBleGlzdHMgYXMgYSBwcm9wZXJ0eSBvZiBgZ2xvYmFsVGhpc2BcbiAqICgyKSBpZiBzdWNoIGFuIG9iamVjdCB3YXMgcHJvdmlkZWQgb24gYSBzaGVsbCBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICogKDMpIGlmIHN1Y2ggYW4gb2JqZWN0IGV4aXN0cyBpbiBhIGNvb2tpZVxuICogQHB1YmxpY1xuICovXG5jb25zdCBnZXREZWZhdWx0cyA9ICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKGdldERlZmF1bHRzRnJvbUdsb2JhbCgpIHx8XG4gICAgICAgICAgICBnZXREZWZhdWx0c0Zyb21FbnZWYXJpYWJsZSgpIHx8XG4gICAgICAgICAgICBnZXREZWZhdWx0c0Zyb21Db29raWUoKSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYXRjaC1hbGwgZm9yIGJlaW5nIHVuYWJsZSB0byBnZXQgX19GSVJFQkFTRV9ERUZBVUxUU19fIGR1ZVxuICAgICAgICAgKiB0byBhbnkgZW52aXJvbm1lbnQgY2FzZSB3ZSBoYXZlIG5vdCBhY2NvdW50ZWQgZm9yLiBMb2cgdG9cbiAgICAgICAgICogaW5mbyBpbnN0ZWFkIG9mIHN3YWxsb3dpbmcgc28gd2UgY2FuIGZpbmQgdGhlc2UgdW5rbm93biBjYXNlc1xuICAgICAgICAgKiBhbmQgYWRkIHBhdGhzIGZvciB0aGVtIGlmIG5lZWRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnNvbGUuaW5mbyhgVW5hYmxlIHRvIGdldCBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gZHVlIHRvOiAke2V9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG59O1xuLyoqXG4gKiBSZXR1cm5zIGVtdWxhdG9yIGhvc3Qgc3RvcmVkIGluIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0XG4gKiBmb3IgdGhlIGdpdmVuIHByb2R1Y3QuXG4gKiBAcmV0dXJucyBhIFVSTCBob3N0IGZvcm1hdHRlZCBsaWtlIGAxMjcuMC4wLjE6OTk5OWAgb3IgYFs6OjFdOjQwMDBgIGlmIGF2YWlsYWJsZVxuICogQHB1YmxpY1xuICovXG5jb25zdCBnZXREZWZhdWx0RW11bGF0b3JIb3N0ID0gKHByb2R1Y3ROYW1lKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoX2IgPSAoX2EgPSBnZXREZWZhdWx0cygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW11bGF0b3JIb3N0cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW3Byb2R1Y3ROYW1lXTsgfTtcbi8qKlxuICogUmV0dXJucyBlbXVsYXRvciBob3N0bmFtZSBhbmQgcG9ydCBzdG9yZWQgaW4gdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3RcbiAqIGZvciB0aGUgZ2l2ZW4gcHJvZHVjdC5cbiAqIEByZXR1cm5zIGEgcGFpciBvZiBob3N0bmFtZSBhbmQgcG9ydCBsaWtlIGBbXCI6OjFcIiwgNDAwMF1gIGlmIGF2YWlsYWJsZVxuICogQHB1YmxpY1xuICovXG5jb25zdCBnZXREZWZhdWx0RW11bGF0b3JIb3N0bmFtZUFuZFBvcnQgPSAocHJvZHVjdE5hbWUpID0+IHtcbiAgICBjb25zdCBob3N0ID0gZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdChwcm9kdWN0TmFtZSk7XG4gICAgaWYgKCFob3N0KSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHNlcGFyYXRvckluZGV4ID0gaG9zdC5sYXN0SW5kZXhPZignOicpOyAvLyBGaW5kaW5nIHRoZSBsYXN0IHNpbmNlIElQdjYgYWRkciBhbHNvIGhhcyBjb2xvbnMuXG4gICAgaWYgKHNlcGFyYXRvckluZGV4IDw9IDAgfHwgc2VwYXJhdG9ySW5kZXggKyAxID09PSBob3N0Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaG9zdCAke2hvc3R9IHdpdGggbm8gc2VwYXJhdGUgaG9zdG5hbWUgYW5kIHBvcnQhYCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICBjb25zdCBwb3J0ID0gcGFyc2VJbnQoaG9zdC5zdWJzdHJpbmcoc2VwYXJhdG9ySW5kZXggKyAxKSwgMTApO1xuICAgIGlmIChob3N0WzBdID09PSAnWycpIHtcbiAgICAgICAgLy8gQnJhY2tldC1xdW90ZWQgYFtpcHY2YWRkcl06cG9ydGAgPT4gcmV0dXJuIFwiaXB2NmFkZHJcIiAod2l0aG91dCBicmFja2V0cykuXG4gICAgICAgIHJldHVybiBbaG9zdC5zdWJzdHJpbmcoMSwgc2VwYXJhdG9ySW5kZXggLSAxKSwgcG9ydF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW2hvc3Quc3Vic3RyaW5nKDAsIHNlcGFyYXRvckluZGV4KSwgcG9ydF07XG4gICAgfVxufTtcbi8qKlxuICogUmV0dXJucyBGaXJlYmFzZSBhcHAgY29uZmlnIHN0b3JlZCBpbiB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdC5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgZ2V0RGVmYXVsdEFwcENvbmZpZyA9ICgpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gZ2V0RGVmYXVsdHMoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbmZpZzsgfTtcbi8qKlxuICogUmV0dXJucyBhbiBleHBlcmltZW50YWwgc2V0dGluZyBvbiB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdCAocHJvcGVydGllc1xuICogcHJlZml4ZWQgYnkgXCJfXCIpXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IGdldEV4cGVyaW1lbnRhbFNldHRpbmcgPSAobmFtZSkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBnZXREZWZhdWx0cygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbYF8ke25hbWV9YF07IH07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBEZWZlcnJlZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucmVqZWN0ID0gKCkgPT4geyB9O1xuICAgICAgICB0aGlzLnJlc29sdmUgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE91ciBBUEkgaW50ZXJuYWxzIGFyZSBub3QgcHJvbWlzaWZpZWQgYW5kIGNhbm5vdCBiZWNhdXNlIG91ciBjYWxsYmFjayBBUElzIGhhdmUgc3VidGxlIGV4cGVjdGF0aW9ucyBhcm91bmRcbiAgICAgKiBpbnZva2luZyBwcm9taXNlcyBpbmxpbmUsIHdoaWNoIFByb21pc2VzIGFyZSBmb3JiaWRkZW4gdG8gZG8uIFRoaXMgbWV0aG9kIGFjY2VwdHMgYW4gb3B0aW9uYWwgbm9kZS1zdHlsZSBjYWxsYmFja1xuICAgICAqIGFuZCByZXR1cm5zIGEgbm9kZS1zdHlsZSBjYWxsYmFjayB3aGljaCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0IHRoZSBEZWZlcnJlZCdzIHByb21pc2UuXG4gICAgICovXG4gICAgd3JhcENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiAoZXJyb3IsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIEF0dGFjaGluZyBub29wIGhhbmRsZXIganVzdCBpbiBjYXNlIGRldmVsb3BlciB3YXNuJ3QgZXhwZWN0aW5nXG4gICAgICAgICAgICAgICAgLy8gcHJvbWlzZXNcbiAgICAgICAgICAgICAgICB0aGlzLnByb21pc2UuY2F0Y2goKCkgPT4geyB9KTtcbiAgICAgICAgICAgICAgICAvLyBTb21lIG9mIG91ciBjYWxsYmFja3MgZG9uJ3QgZXhwZWN0IGEgdmFsdWUgYW5kIG91ciBvd24gdGVzdHNcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQgdGhhdCB0aGUgcGFyYW1ldGVyIGxlbmd0aCBpcyAxXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVNb2NrVXNlclRva2VuKHRva2VuLCBwcm9qZWN0SWQpIHtcbiAgICBpZiAodG9rZW4udWlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIFwidWlkXCIgZmllbGQgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBieSBtb2NrVXNlclRva2VuLiBQbGVhc2UgdXNlIFwic3ViXCIgaW5zdGVhZCBmb3IgRmlyZWJhc2UgQXV0aCBVc2VyIElELicpO1xuICAgIH1cbiAgICAvLyBVbnNlY3VyZWQgSldUcyB1c2UgXCJub25lXCIgYXMgdGhlIGFsZ29yaXRobS5cbiAgICBjb25zdCBoZWFkZXIgPSB7XG4gICAgICAgIGFsZzogJ25vbmUnLFxuICAgICAgICB0eXBlOiAnSldUJ1xuICAgIH07XG4gICAgY29uc3QgcHJvamVjdCA9IHByb2plY3RJZCB8fCAnZGVtby1wcm9qZWN0JztcbiAgICBjb25zdCBpYXQgPSB0b2tlbi5pYXQgfHwgMDtcbiAgICBjb25zdCBzdWIgPSB0b2tlbi5zdWIgfHwgdG9rZW4udXNlcl9pZDtcbiAgICBpZiAoIXN1Yikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtb2NrVXNlclRva2VuIG11c3QgY29udGFpbiAnc3ViJyBvciAndXNlcl9pZCcgZmllbGQhXCIpO1xuICAgIH1cbiAgICBjb25zdCBwYXlsb2FkID0gT2JqZWN0LmFzc2lnbih7IFxuICAgICAgICAvLyBTZXQgYWxsIHJlcXVpcmVkIGZpZWxkcyB0byBkZWNlbnQgZGVmYXVsdHNcbiAgICAgICAgaXNzOiBgaHR0cHM6Ly9zZWN1cmV0b2tlbi5nb29nbGUuY29tLyR7cHJvamVjdH1gLCBhdWQ6IHByb2plY3QsIGlhdCwgZXhwOiBpYXQgKyAzNjAwLCBhdXRoX3RpbWU6IGlhdCwgc3ViLCB1c2VyX2lkOiBzdWIsIGZpcmViYXNlOiB7XG4gICAgICAgICAgICBzaWduX2luX3Byb3ZpZGVyOiAnY3VzdG9tJyxcbiAgICAgICAgICAgIGlkZW50aXRpZXM6IHt9XG4gICAgICAgIH0gfSwgdG9rZW4pO1xuICAgIC8vIFVuc2VjdXJlZCBKV1RzIHVzZSB0aGUgZW1wdHkgc3RyaW5nIGFzIGEgc2lnbmF0dXJlLlxuICAgIGNvbnN0IHNpZ25hdHVyZSA9ICcnO1xuICAgIHJldHVybiBbXG4gICAgICAgIGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nKEpTT04uc3RyaW5naWZ5KGhlYWRlcikpLFxuICAgICAgICBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSksXG4gICAgICAgIHNpZ25hdHVyZVxuICAgIF0uam9pbignLicpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXR1cm5zIG5hdmlnYXRvci51c2VyQWdlbnQgc3RyaW5nIG9yICcnIGlmIGl0J3Mgbm90IGRlZmluZWQuXG4gKiBAcmV0dXJuIHVzZXIgYWdlbnQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGdldFVBKCkge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB0eXBlb2YgbmF2aWdhdG9yWyd1c2VyQWdlbnQnXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvclsndXNlckFnZW50J107XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxufVxuLyoqXG4gKiBEZXRlY3QgQ29yZG92YSAvIFBob25lR2FwIC8gSW9uaWMgZnJhbWV3b3JrcyBvbiBhIG1vYmlsZSBkZXZpY2UuXG4gKlxuICogRGVsaWJlcmF0ZWx5IGRvZXMgbm90IHJlbHkgb24gY2hlY2tpbmcgYGZpbGU6Ly9gIFVSTHMgKGFzIHRoaXMgZmFpbHMgUGhvbmVHYXBcbiAqIGluIHRoZSBSaXBwbGUgZW11bGF0b3IpIG5vciBDb3Jkb3ZhIGBvbkRldmljZVJlYWR5YCwgd2hpY2ggd291bGQgbm9ybWFsbHlcbiAqIHdhaXQgZm9yIGEgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGlzTW9iaWxlQ29yZG92YSgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgU2V0dGluZyB1cCBhbiBicm9hZGx5IGFwcGxpY2FibGUgaW5kZXggc2lnbmF0dXJlIGZvciBXaW5kb3dcbiAgICAgICAgLy8ganVzdCB0byBkZWFsIHdpdGggdGhpcyBjYXNlIHdvdWxkIHByb2JhYmx5IGJlIGEgYmFkIGlkZWEuXG4gICAgICAgICEhKHdpbmRvd1snY29yZG92YSddIHx8IHdpbmRvd1sncGhvbmVnYXAnXSB8fCB3aW5kb3dbJ1Bob25lR2FwJ10pICYmXG4gICAgICAgIC9pb3N8aXBob25lfGlwb2R8aXBhZHxhbmRyb2lkfGJsYWNrYmVycnl8aWVtb2JpbGUvaS50ZXN0KGdldFVBKCkpKTtcbn1cbi8qKlxuICogRGV0ZWN0IE5vZGUuanMuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIE5vZGUuanMgZW52aXJvbm1lbnQgaXMgZGV0ZWN0ZWQgb3Igc3BlY2lmaWVkLlxuICovXG4vLyBOb2RlIGRldGVjdGlvbiBsb2dpYyBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vaWxpYWthbi9kZXRlY3Qtbm9kZS9cbmZ1bmN0aW9uIGlzTm9kZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZm9yY2VFbnZpcm9ubWVudCA9IChfYSA9IGdldERlZmF1bHRzKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JjZUVudmlyb25tZW50O1xuICAgIGlmIChmb3JjZUVudmlyb25tZW50ID09PSAnbm9kZScpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZvcmNlRW52aXJvbm1lbnQgPT09ICdicm93c2VyJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogRGV0ZWN0IEJyb3dzZXIgRW52aXJvbm1lbnQuXG4gKiBOb3RlOiBUaGlzIHdpbGwgcmV0dXJuIHRydWUgZm9yIGNlcnRhaW4gdGVzdCBmcmFtZXdvcmtzIHRoYXQgYXJlIGluY29tcGxldGVseVxuICogbWltaWNraW5nIGEgYnJvd3NlciwgYW5kIHNob3VsZCBub3QgbGVhZCB0byBhc3N1bWluZyBhbGwgYnJvd3NlciBBUElzIGFyZVxuICogYXZhaWxhYmxlLlxuICovXG5mdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnIHx8IGlzV2ViV29ya2VyKCk7XG59XG4vKipcbiAqIERldGVjdCBXZWIgV29ya2VyIGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGlzV2ViV29ya2VyKCkge1xuICAgIHJldHVybiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKTtcbn1cbi8qKlxuICogRGV0ZWN0IENsb3VkZmxhcmUgV29ya2VyIGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGlzQ2xvdWRmbGFyZVdvcmtlcigpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQgPT09ICdDbG91ZGZsYXJlLVdvcmtlcnMnKTtcbn1cbmZ1bmN0aW9uIGlzQnJvd3NlckV4dGVuc2lvbigpIHtcbiAgICBjb25zdCBydW50aW1lID0gdHlwZW9mIGNocm9tZSA9PT0gJ29iamVjdCdcbiAgICAgICAgPyBjaHJvbWUucnVudGltZVxuICAgICAgICA6IHR5cGVvZiBicm93c2VyID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgPyBicm93c2VyLnJ1bnRpbWVcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiB0eXBlb2YgcnVudGltZSA9PT0gJ29iamVjdCcgJiYgcnVudGltZS5pZCAhPT0gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBEZXRlY3QgUmVhY3QgTmF0aXZlLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiBSZWFjdE5hdGl2ZSBlbnZpcm9ubWVudCBpcyBkZXRlY3RlZC5cbiAqL1xuZnVuY3Rpb24gaXNSZWFjdE5hdGl2ZSgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnICYmIG5hdmlnYXRvclsncHJvZHVjdCddID09PSAnUmVhY3ROYXRpdmUnKTtcbn1cbi8qKiBEZXRlY3RzIEVsZWN0cm9uIGFwcHMuICovXG5mdW5jdGlvbiBpc0VsZWN0cm9uKCkge1xuICAgIHJldHVybiBnZXRVQSgpLmluZGV4T2YoJ0VsZWN0cm9uLycpID49IDA7XG59XG4vKiogRGV0ZWN0cyBJbnRlcm5ldCBFeHBsb3Jlci4gKi9cbmZ1bmN0aW9uIGlzSUUoKSB7XG4gICAgY29uc3QgdWEgPSBnZXRVQSgpO1xuICAgIHJldHVybiB1YS5pbmRleE9mKCdNU0lFICcpID49IDAgfHwgdWEuaW5kZXhPZignVHJpZGVudC8nKSA+PSAwO1xufVxuLyoqIERldGVjdHMgVW5pdmVyc2FsIFdpbmRvd3MgUGxhdGZvcm0gYXBwcy4gKi9cbmZ1bmN0aW9uIGlzVVdQKCkge1xuICAgIHJldHVybiBnZXRVQSgpLmluZGV4T2YoJ01TQXBwSG9zdC8nKSA+PSAwO1xufVxuLyoqXG4gKiBEZXRlY3Qgd2hldGhlciB0aGUgY3VycmVudCBTREsgYnVpbGQgaXMgdGhlIE5vZGUgdmVyc2lvbi5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgaXQncyB0aGUgTm9kZSBTREsgYnVpbGQuXG4gKi9cbmZ1bmN0aW9uIGlzTm9kZVNkaygpIHtcbiAgICByZXR1cm4gQ09OU1RBTlRTLk5PREVfQ0xJRU5UID09PSB0cnVlIHx8IENPTlNUQU5UUy5OT0RFX0FETUlOID09PSB0cnVlO1xufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiB3ZSBhcmUgcnVubmluZyBpbiBTYWZhcmkuICovXG5mdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgICByZXR1cm4gKCFpc05vZGUoKSAmJlxuICAgICAgICAhIW5hdmlnYXRvci51c2VyQWdlbnQgJiZcbiAgICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcygnU2FmYXJpJykgJiZcbiAgICAgICAgIW5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoJ0Nocm9tZScpKTtcbn1cbi8qKlxuICogVGhpcyBtZXRob2QgY2hlY2tzIGlmIGluZGV4ZWREQiBpcyBzdXBwb3J0ZWQgYnkgY3VycmVudCBicm93c2VyL3NlcnZpY2Ugd29ya2VyIGNvbnRleHRcbiAqIEByZXR1cm4gdHJ1ZSBpZiBpbmRleGVkREIgaXMgc3VwcG9ydGVkIGJ5IGN1cnJlbnQgYnJvd3Nlci9zZXJ2aWNlIHdvcmtlciBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXhlZERCQXZhaWxhYmxlKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaW5kZXhlZERCID09PSAnb2JqZWN0JztcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogVGhpcyBtZXRob2QgdmFsaWRhdGVzIGJyb3dzZXIvc3cgY29udGV4dCBmb3IgaW5kZXhlZERCIGJ5IG9wZW5pbmcgYSBkdW1teSBpbmRleGVkREIgZGF0YWJhc2UgYW5kIHJlamVjdFxuICogaWYgZXJyb3JzIG9jY3VyIGR1cmluZyB0aGUgZGF0YWJhc2Ugb3BlbiBvcGVyYXRpb24uXG4gKlxuICogQHRocm93cyBleGNlcHRpb24gaWYgY3VycmVudCBicm93c2VyL3N3IGNvbnRleHQgY2FuJ3QgcnVuIGlkYi5vcGVuIChleDogU2FmYXJpIGlmcmFtZSwgRmlyZWZveFxuICogcHJpdmF0ZSBicm93c2luZylcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHByZUV4aXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IERCX0NIRUNLX05BTUUgPSAndmFsaWRhdGUtYnJvd3Nlci1jb250ZXh0LWZvci1pbmRleGVkZGItYW5hbHl0aWNzLW1vZHVsZSc7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gc2VsZi5pbmRleGVkREIub3BlbihEQl9DSEVDS19OQU1FKTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzdWx0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIGRhdGFiYXNlIG9ubHkgd2hlbiBpdCBkb2Vzbid0IHByZS1leGlzdFxuICAgICAgICAgICAgICAgIGlmICghcHJlRXhpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbmRleGVkREIuZGVsZXRlRGF0YWJhc2UoREJfQ0hFQ0tfTkFNRSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcHJlRXhpc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHJlamVjdCgoKF9hID0gcmVxdWVzdC5lcnJvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1lc3NhZ2UpIHx8ICcnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqXG4gKiBUaGlzIG1ldGhvZCBjaGVja3Mgd2hldGhlciBjb29raWUgaXMgZW5hYmxlZCB3aXRoaW4gY3VycmVudCBicm93c2VyXG4gKiBAcmV0dXJuIHRydWUgaWYgY29va2llIGlzIGVuYWJsZWQgd2l0aGluIGN1cnJlbnQgYnJvd3NlclxuICovXG5mdW5jdGlvbiBhcmVDb29raWVzRW5hYmxlZCgpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgIW5hdmlnYXRvci5jb29raWVFbmFibGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU3RhbmRhcmRpemVkIEZpcmViYXNlIEVycm9yLlxuICpcbiAqIFVzYWdlOlxuICpcbiAqICAgLy8gVHlwZVNjcmlwdCBzdHJpbmcgbGl0ZXJhbHMgZm9yIHR5cGUtc2FmZSBjb2Rlc1xuICogICB0eXBlIEVyciA9XG4gKiAgICAgJ3Vua25vd24nIHxcbiAqICAgICAnb2JqZWN0LW5vdC1mb3VuZCdcbiAqICAgICA7XG4gKlxuICogICAvLyBDbG9zdXJlIGVudW0gZm9yIHR5cGUtc2FmZSBlcnJvciBjb2Rlc1xuICogICAvLyBhdC1lbnVtIHtzdHJpbmd9XG4gKiAgIHZhciBFcnIgPSB7XG4gKiAgICAgVU5LTk9XTjogJ3Vua25vd24nLFxuICogICAgIE9CSkVDVF9OT1RfRk9VTkQ6ICdvYmplY3Qtbm90LWZvdW5kJyxcbiAqICAgfVxuICpcbiAqICAgbGV0IGVycm9yczogTWFwPEVyciwgc3RyaW5nPiA9IHtcbiAqICAgICAnZ2VuZXJpYy1lcnJvcic6IFwiVW5rbm93biBlcnJvclwiLFxuICogICAgICdmaWxlLW5vdC1mb3VuZCc6IFwiQ291bGQgbm90IGZpbmQgZmlsZTogeyRmaWxlfVwiLFxuICogICB9O1xuICpcbiAqICAgLy8gVHlwZS1zYWZlIGZ1bmN0aW9uIC0gbXVzdCBwYXNzIGEgdmFsaWQgZXJyb3IgY29kZSBhcyBwYXJhbS5cbiAqICAgbGV0IGVycm9yID0gbmV3IEVycm9yRmFjdG9yeTxFcnI+KCdzZXJ2aWNlJywgJ1NlcnZpY2UnLCBlcnJvcnMpO1xuICpcbiAqICAgLi4uXG4gKiAgIHRocm93IGVycm9yLmNyZWF0ZShFcnIuR0VORVJJQyk7XG4gKiAgIC4uLlxuICogICB0aHJvdyBlcnJvci5jcmVhdGUoRXJyLkZJTEVfTk9UX0ZPVU5ELCB7J2ZpbGUnOiBmaWxlTmFtZX0pO1xuICogICAuLi5cbiAqICAgLy8gU2VydmljZTogQ291bGQgbm90IGZpbGUgZmlsZTogZm9vLnR4dCAoc2VydmljZS9maWxlLW5vdC1mb3VuZCkuXG4gKlxuICogICBjYXRjaCAoZSkge1xuICogICAgIGFzc2VydChlLm1lc3NhZ2UgPT09IFwiQ291bGQgbm90IGZpbmQgZmlsZTogZm9vLnR4dC5cIik7XG4gKiAgICAgaWYgKChlIGFzIEZpcmViYXNlRXJyb3IpPy5jb2RlID09PSAnc2VydmljZS9maWxlLW5vdC1mb3VuZCcpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKFwiQ291bGQgbm90IHJlYWQgZmlsZTogXCIgKyBlWydmaWxlJ10pO1xuICogICAgIH1cbiAqICAgfVxuICovXG5jb25zdCBFUlJPUl9OQU1FID0gJ0ZpcmViYXNlRXJyb3InO1xuLy8gQmFzZWQgb24gY29kZSBmcm9tOlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjQ3VzdG9tX0Vycm9yX1R5cGVzXG5jbGFzcyBGaXJlYmFzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBUaGUgZXJyb3IgY29kZSBmb3IgdGhpcyBlcnJvci4gKi9cbiAgICBjb2RlLCBtZXNzYWdlLCBcbiAgICAvKiogQ3VzdG9tIGRhdGEgZm9yIHRoaXMgZXJyb3IuICovXG4gICAgY3VzdG9tRGF0YSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5jdXN0b21EYXRhID0gY3VzdG9tRGF0YTtcbiAgICAgICAgLyoqIFRoZSBjdXN0b20gbmFtZSBmb3IgYWxsIEZpcmViYXNlRXJyb3JzLiAqL1xuICAgICAgICB0aGlzLm5hbWUgPSBFUlJPUl9OQU1FO1xuICAgICAgICAvLyBGaXggRm9yIEVTNVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQtd2lraS9ibG9iL21hc3Rlci9CcmVha2luZy1DaGFuZ2VzLm1kI2V4dGVuZGluZy1idWlsdC1pbnMtbGlrZS1lcnJvci1hcnJheS1hbmQtbWFwLW1heS1uby1sb25nZXItd29ya1xuICAgICAgICAvLyBUT0RPKGRsYXJvY3F1ZSk6IFJlcGxhY2UgdGhpcyB3aXRoIGBuZXcudGFyZ2V0YDogaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svcmVsZWFzZS1ub3Rlcy90eXBlc2NyaXB0LTItMi5odG1sI3N1cHBvcnQtZm9yLW5ld3RhcmdldFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICB3aGljaCB3ZSBjYW4gbm93IHVzZSBzaW5jZSB3ZSBubyBsb25nZXIgdGFyZ2V0IEVTNS5cbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEZpcmViYXNlRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgLy8gTWFpbnRhaW5zIHByb3BlciBzdGFjayB0cmFjZSBmb3Igd2hlcmUgb3VyIGVycm9yIHdhcyB0aHJvd24uXG4gICAgICAgIC8vIE9ubHkgYXZhaWxhYmxlIG9uIFY4LlxuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEVycm9yRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIEVycm9yRmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSwgc2VydmljZU5hbWUsIGVycm9ycykge1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgICAgICB0aGlzLnNlcnZpY2VOYW1lID0gc2VydmljZU5hbWU7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH1cbiAgICBjcmVhdGUoY29kZSwgLi4uZGF0YSkge1xuICAgICAgICBjb25zdCBjdXN0b21EYXRhID0gZGF0YVswXSB8fCB7fTtcbiAgICAgICAgY29uc3QgZnVsbENvZGUgPSBgJHt0aGlzLnNlcnZpY2V9LyR7Y29kZX1gO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMuZXJyb3JzW2NvZGVdO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gdGVtcGxhdGUgPyByZXBsYWNlVGVtcGxhdGUodGVtcGxhdGUsIGN1c3RvbURhdGEpIDogJ0Vycm9yJztcbiAgICAgICAgLy8gU2VydmljZSBOYW1lOiBFcnJvciBtZXNzYWdlIChzZXJ2aWNlL2NvZGUpLlxuICAgICAgICBjb25zdCBmdWxsTWVzc2FnZSA9IGAke3RoaXMuc2VydmljZU5hbWV9OiAke21lc3NhZ2V9ICgke2Z1bGxDb2RlfSkuYDtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRmlyZWJhc2VFcnJvcihmdWxsQ29kZSwgZnVsbE1lc3NhZ2UsIGN1c3RvbURhdGEpO1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVwbGFjZVRlbXBsYXRlKHRlbXBsYXRlLCBkYXRhKSB7XG4gICAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoUEFUVEVSTiwgKF8sIGtleSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGRhdGFba2V5XTtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyBTdHJpbmcodmFsdWUpIDogYDwke2tleX0/PmA7XG4gICAgfSk7XG59XG5jb25zdCBQQVRURVJOID0gL1xce1xcJChbXn1dKyl9L2c7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEV2YWx1YXRlcyBhIEpTT04gc3RyaW5nIGludG8gYSBqYXZhc2NyaXB0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIEEgc3RyaW5nIGNvbnRhaW5pbmcgSlNPTi5cbiAqIEByZXR1cm4geyp9IFRoZSBqYXZhc2NyaXB0IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNwZWNpZmllZCBKU09OLlxuICovXG5mdW5jdGlvbiBqc29uRXZhbChzdHIpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHIpO1xufVxuLyoqXG4gKiBSZXR1cm5zIEpTT04gcmVwcmVzZW50aW5nIGEgamF2YXNjcmlwdCBvYmplY3QuXG4gKiBAcGFyYW0geyp9IGRhdGEgSmF2YVNjcmlwdCBvYmplY3QgdG8gYmUgc3RyaW5naWZpZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBKU09OIGNvbnRlbnRzIG9mIHRoZSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeShkYXRhKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gaW50byBjb25zdGl0dWVudCBwYXJ0cy5cbiAqXG4gKiBOb3RlczpcbiAqIC0gTWF5IHJldHVybiB3aXRoIGludmFsaWQgLyBpbmNvbXBsZXRlIGNsYWltcyBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXG4gKi9cbmNvbnN0IGRlY29kZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIGxldCBoZWFkZXIgPSB7fSwgY2xhaW1zID0ge30sIGRhdGEgPSB7fSwgc2lnbmF0dXJlID0gJyc7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFydHMgPSB0b2tlbi5zcGxpdCgnLicpO1xuICAgICAgICBoZWFkZXIgPSBqc29uRXZhbChiYXNlNjREZWNvZGUocGFydHNbMF0pIHx8ICcnKTtcbiAgICAgICAgY2xhaW1zID0ganNvbkV2YWwoYmFzZTY0RGVjb2RlKHBhcnRzWzFdKSB8fCAnJyk7XG4gICAgICAgIHNpZ25hdHVyZSA9IHBhcnRzWzJdO1xuICAgICAgICBkYXRhID0gY2xhaW1zWydkJ10gfHwge307XG4gICAgICAgIGRlbGV0ZSBjbGFpbXNbJ2QnXTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHsgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGhlYWRlcixcbiAgICAgICAgY2xhaW1zLFxuICAgICAgICBkYXRhLFxuICAgICAgICBzaWduYXR1cmVcbiAgICB9O1xufTtcbi8qKlxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGFuZCBjaGVja3MgdGhlIHZhbGlkaXR5IG9mIGl0cyB0aW1lLWJhc2VkIGNsYWltcy4gV2lsbCByZXR1cm4gdHJ1ZSBpZiB0aGVcbiAqIHRva2VuIGlzIHdpdGhpbiB0aGUgdGltZSB3aW5kb3cgYXV0aG9yaXplZCBieSB0aGUgJ25iZicgKG5vdC1iZWZvcmUpIGFuZCAnaWF0JyAoaXNzdWVkLWF0KSBjbGFpbXMuXG4gKlxuICogTm90ZXM6XG4gKiAtIE1heSByZXR1cm4gYSBmYWxzZSBuZWdhdGl2ZSBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXG4gKi9cbmNvbnN0IGlzVmFsaWRUaW1lc3RhbXAgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICBjb25zdCBjbGFpbXMgPSBkZWNvZGUodG9rZW4pLmNsYWltcztcbiAgICBjb25zdCBub3cgPSBNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCk7XG4gICAgbGV0IHZhbGlkU2luY2UgPSAwLCB2YWxpZFVudGlsID0gMDtcbiAgICBpZiAodHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnbmJmJykpIHtcbiAgICAgICAgICAgIHZhbGlkU2luY2UgPSBjbGFpbXNbJ25iZiddO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnaWF0JykpIHtcbiAgICAgICAgICAgIHZhbGlkU2luY2UgPSBjbGFpbXNbJ2lhdCddO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2V4cCcpKSB7XG4gICAgICAgICAgICB2YWxpZFVudGlsID0gY2xhaW1zWydleHAnXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRva2VuIHdpbGwgZXhwaXJlIGFmdGVyIDI0aCBieSBkZWZhdWx0XG4gICAgICAgICAgICB2YWxpZFVudGlsID0gdmFsaWRTaW5jZSArIDg2NDAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoISFub3cgJiZcbiAgICAgICAgISF2YWxpZFNpbmNlICYmXG4gICAgICAgICEhdmFsaWRVbnRpbCAmJlxuICAgICAgICBub3cgPj0gdmFsaWRTaW5jZSAmJlxuICAgICAgICBub3cgPD0gdmFsaWRVbnRpbCk7XG59O1xuLyoqXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gYW5kIHJldHVybnMgaXRzIGlzc3VlZCBhdCB0aW1lIGlmIHZhbGlkLCBudWxsIG90aGVyd2lzZS5cbiAqXG4gKiBOb3RlczpcbiAqIC0gTWF5IHJldHVybiBudWxsIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cbiAqL1xuY29uc3QgaXNzdWVkQXRUaW1lID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgY29uc3QgY2xhaW1zID0gZGVjb2RlKHRva2VuKS5jbGFpbXM7XG4gICAgaWYgKHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnICYmIGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnaWF0JykpIHtcbiAgICAgICAgcmV0dXJuIGNsYWltc1snaWF0J107XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbi8qKlxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGFuZCBjaGVja3MgdGhlIHZhbGlkaXR5IG9mIGl0cyBmb3JtYXQuIEV4cGVjdHMgYSB2YWxpZCBpc3N1ZWQtYXQgdGltZS5cbiAqXG4gKiBOb3RlczpcbiAqIC0gTWF5IHJldHVybiBhIGZhbHNlIG5lZ2F0aXZlIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cbiAqL1xuY29uc3QgaXNWYWxpZEZvcm1hdCA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGUodG9rZW4pLCBjbGFpbXMgPSBkZWNvZGVkLmNsYWltcztcbiAgICByZXR1cm4gISFjbGFpbXMgJiYgdHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcgJiYgY2xhaW1zLmhhc093blByb3BlcnR5KCdpYXQnKTtcbn07XG4vKipcbiAqIEF0dGVtcHRzIHRvIHBlZXIgaW50byBhbiBhdXRoIHRva2VuIGFuZCBkZXRlcm1pbmUgaWYgaXQncyBhbiBhZG1pbiBhdXRoIHRva2VuIGJ5IGxvb2tpbmcgYXQgdGhlIGNsYWltcyBwb3J0aW9uLlxuICpcbiAqIE5vdGVzOlxuICogLSBNYXkgcmV0dXJuIGEgZmFsc2UgbmVnYXRpdmUgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxuICovXG5jb25zdCBpc0FkbWluID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgY29uc3QgY2xhaW1zID0gZGVjb2RlKHRva2VuKS5jbGFpbXM7XG4gICAgcmV0dXJuIHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnICYmIGNsYWltc1snYWRtaW4nXSA9PT0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBjb250YWlucyhvYmosIGtleSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuZnVuY3Rpb24gc2FmZUdldChvYmosIGtleSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG1hcChvYmosIGZuLCBjb250ZXh0T2JqKSB7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICByZXNba2V5XSA9IGZuLmNhbGwoY29udGV4dE9iaiwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBEZWVwIGVxdWFsIHR3byBvYmplY3RzLiBTdXBwb3J0IEFycmF5cyBhbmQgT2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBjb25zdCBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuICAgIGZvciAoY29uc3QgayBvZiBhS2V5cykge1xuICAgICAgICBpZiAoIWJLZXlzLmluY2x1ZGVzKGspKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYVByb3AgPSBhW2tdO1xuICAgICAgICBjb25zdCBiUHJvcCA9IGJba107XG4gICAgICAgIGlmIChpc09iamVjdChhUHJvcCkgJiYgaXNPYmplY3QoYlByb3ApKSB7XG4gICAgICAgICAgICBpZiAoIWRlZXBFcXVhbChhUHJvcCwgYlByb3ApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFQcm9wICE9PSBiUHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgayBvZiBiS2V5cykge1xuICAgICAgICBpZiAoIWFLZXlzLmluY2x1ZGVzKGspKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBpc09iamVjdCh0aGluZykge1xuICAgIHJldHVybiB0aGluZyAhPT0gbnVsbCAmJiB0eXBlb2YgdGhpbmcgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZWplY3RzIGlmIHRoZSBnaXZlbiBwcm9taXNlIGRvZXNuJ3QgcmVzb2x2ZSBpbiB0aW1lSW5NUyBtaWxsaXNlY29uZHMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gcHJvbWlzZVdpdGhUaW1lb3V0KHByb21pc2UsIHRpbWVJbk1TID0gMjAwMCkge1xuICAgIGNvbnN0IGRlZmVycmVkUHJvbWlzZSA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4gZGVmZXJyZWRQcm9taXNlLnJlamVjdCgndGltZW91dCEnKSwgdGltZUluTVMpO1xuICAgIHByb21pc2UudGhlbihkZWZlcnJlZFByb21pc2UucmVzb2x2ZSwgZGVmZXJyZWRQcm9taXNlLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkUHJvbWlzZS5wcm9taXNlO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXR1cm5zIGEgcXVlcnlzdHJpbmctZm9ybWF0dGVkIHN0cmluZyAoZS5nLiAmYXJnPXZhbCZhcmcyPXZhbDIpIGZyb20gYVxuICogcGFyYW1zIG9iamVjdCAoZS5nLiB7YXJnOiAndmFsJywgYXJnMjogJ3ZhbDInfSlcbiAqIE5vdGU6IFlvdSBtdXN0IHByZXBlbmQgaXQgd2l0aCA/IHdoZW4gYWRkaW5nIGl0IHRvIGEgVVJMLlxuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZyhxdWVyeXN0cmluZ1BhcmFtcykge1xuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHF1ZXJ5c3RyaW5nUGFyYW1zKSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goYXJyYXlWYWwgPT4ge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFycmF5VmFsKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcy5sZW5ndGggPyAnJicgKyBwYXJhbXMuam9pbignJicpIDogJyc7XG59XG4vKipcbiAqIERlY29kZXMgYSBxdWVyeXN0cmluZyAoZS5nLiA/YXJnPXZhbCZhcmcyPXZhbDIpIGludG8gYSBwYXJhbXMgb2JqZWN0XG4gKiAoZS5nLiB7YXJnOiAndmFsJywgYXJnMjogJ3ZhbDInfSlcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmdEZWNvZGUocXVlcnlzdHJpbmcpIHtcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBjb25zdCB0b2tlbnMgPSBxdWVyeXN0cmluZy5yZXBsYWNlKC9eXFw/LywgJycpLnNwbGl0KCcmJyk7XG4gICAgdG9rZW5zLmZvckVhY2godG9rZW4gPT4ge1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHRva2VuLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICBvYmpbZGVjb2RlVVJJQ29tcG9uZW50KGtleSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59XG4vKipcbiAqIEV4dHJhY3QgdGhlIHF1ZXJ5IHN0cmluZyBwYXJ0IG9mIGEgVVJMLCBpbmNsdWRpbmcgdGhlIGxlYWRpbmcgcXVlc3Rpb24gbWFyayAoaWYgcHJlc2VudCkuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RRdWVyeXN0cmluZyh1cmwpIHtcbiAgICBjb25zdCBxdWVyeVN0YXJ0ID0gdXJsLmluZGV4T2YoJz8nKTtcbiAgICBpZiAoIXF1ZXJ5U3RhcnQpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjb25zdCBmcmFnbWVudFN0YXJ0ID0gdXJsLmluZGV4T2YoJyMnLCBxdWVyeVN0YXJ0KTtcbiAgICByZXR1cm4gdXJsLnN1YnN0cmluZyhxdWVyeVN0YXJ0LCBmcmFnbWVudFN0YXJ0ID4gMCA/IGZyYWdtZW50U3RhcnQgOiB1bmRlZmluZWQpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNIQS0xIGNyeXB0b2dyYXBoaWMgaGFzaC5cbiAqIFZhcmlhYmxlIG5hbWVzIGZvbGxvdyB0aGUgbm90YXRpb24gaW4gRklQUyBQVUIgMTgwLTM6XG4gKiBodHRwOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZmlwcy9maXBzMTgwLTMvZmlwczE4MC0zX2ZpbmFsLnBkZi5cbiAqXG4gKiBVc2FnZTpcbiAqICAgdmFyIHNoYTEgPSBuZXcgc2hhMSgpO1xuICogICBzaGExLnVwZGF0ZShieXRlcyk7XG4gKiAgIHZhciBoYXNoID0gc2hhMS5kaWdlc3QoKTtcbiAqXG4gKiBQZXJmb3JtYW5jZTpcbiAqICAgQ2hyb21lIDIzOiAgIH40MDAgTWJpdC9zXG4gKiAgIEZpcmVmb3ggMTY6ICB+MjUwIE1iaXQvc1xuICpcbiAqL1xuLyoqXG4gKiBTSEEtMSBjcnlwdG9ncmFwaGljIGhhc2ggY29uc3RydWN0b3IuXG4gKlxuICogVGhlIHByb3BlcnRpZXMgZGVjbGFyZWQgaGVyZSBhcmUgZGlzY3Vzc2VkIGluIHRoZSBhYm92ZSBhbGdvcml0aG0gZG9jdW1lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBmaW5hbFxuICogQHN0cnVjdFxuICovXG5jbGFzcyBTaGExIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvbGRzIHRoZSBwcmV2aW91cyB2YWx1ZXMgb2YgYWNjdW11bGF0ZWQgdmFyaWFibGVzIGEtZSBpbiB0aGUgY29tcHJlc3NfXG4gICAgICAgICAqIGZ1bmN0aW9uLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFpbl8gPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgYnVmZmVyIGhvbGRpbmcgdGhlIHBhcnRpYWxseSBjb21wdXRlZCBoYXNoIHJlc3VsdC5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYnVmXyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgODAgYnl0ZXMsIGVhY2ggYSBwYXJ0IG9mIHRoZSBtZXNzYWdlIHRvIGJlIGhhc2hlZC4gIFJlZmVycmVkIHRvXG4gICAgICAgICAqIGFzIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGluIHRoZSBkb2NzLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5XXyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29udGFpbnMgZGF0YSBuZWVkZWQgdG8gcGFkIG1lc3NhZ2VzIGxlc3MgdGhhbiA2NCBieXRlcy5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFkXyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5idWZfID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRvdGFsXyA9IDA7XG4gICAgICAgIHRoaXMuYmxvY2tTaXplID0gNTEyIC8gODtcbiAgICAgICAgdGhpcy5wYWRfWzBdID0gMTI4O1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuYmxvY2tTaXplOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMucGFkX1tpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5jaGFpbl9bMF0gPSAweDY3NDUyMzAxO1xuICAgICAgICB0aGlzLmNoYWluX1sxXSA9IDB4ZWZjZGFiODk7XG4gICAgICAgIHRoaXMuY2hhaW5fWzJdID0gMHg5OGJhZGNmZTtcbiAgICAgICAgdGhpcy5jaGFpbl9bM10gPSAweDEwMzI1NDc2O1xuICAgICAgICB0aGlzLmNoYWluX1s0XSA9IDB4YzNkMmUxZjA7XG4gICAgICAgIHRoaXMuaW5idWZfID0gMDtcbiAgICAgICAgdGhpcy50b3RhbF8gPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBjb21wcmVzcyBoZWxwZXIgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIGJ1ZiBCbG9jayB0byBjb21wcmVzcy5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IE9mZnNldCBvZiB0aGUgYmxvY2sgaW4gdGhlIGJ1ZmZlci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbXByZXNzXyhidWYsIG9mZnNldCkge1xuICAgICAgICBpZiAoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBXID0gdGhpcy5XXztcbiAgICAgICAgLy8gZ2V0IDE2IGJpZyBlbmRpYW4gd29yZHNcbiAgICAgICAgaWYgKHR5cGVvZiBidWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKHVzZXIpOiBbYnVnIDgxNDAxMjJdIFJlY2VudCB2ZXJzaW9ucyBvZiBTYWZhcmkgZm9yIE1hYyBPUyBhbmQgaU9TXG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBhIGJ1ZyB0aGF0IHR1cm5zIHRoZSBwb3N0LWluY3JlbWVudCArKyBvcGVyYXRvciBpbnRvIHByZS1pbmNyZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBkdXJpbmcgSklUIGNvbXBpbGF0aW9uLiAgV2UgaGF2ZSBjb2RlIHRoYXQgZGVwZW5kcyBoZWF2aWx5IG9uIFNIQS0xIGZvclxuICAgICAgICAgICAgICAgIC8vIGNvcnJlY3RuZXNzIGFuZCB3aGljaCBpcyBhZmZlY3RlZCBieSB0aGlzIGJ1Zywgc28gSSd2ZSByZW1vdmVkIGFsbCB1c2VzXG4gICAgICAgICAgICAgICAgLy8gb2YgcG9zdC1pbmNyZW1lbnQgKysgaW4gd2hpY2ggdGhlIHJlc3VsdCB2YWx1ZSBpcyB1c2VkLiAgV2UgY2FuIHJldmVydFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY2hhbmdlIG9uY2UgdGhlIFNhZmFyaSBidWdcbiAgICAgICAgICAgICAgICAvLyAoaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEwOTAzNikgaGFzIGJlZW4gZml4ZWQgYW5kXG4gICAgICAgICAgICAgICAgLy8gbW9zdCBjbGllbnRzIGhhdmUgYmVlbiB1cGRhdGVkLlxuICAgICAgICAgICAgICAgIFdbaV0gPVxuICAgICAgICAgICAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob2Zmc2V0KSA8PCAyNCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ1Zi5jaGFyQ29kZUF0KG9mZnNldCArIDEpIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob2Zmc2V0ICsgMikgPDwgOCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmLmNoYXJDb2RlQXQob2Zmc2V0ICsgMyk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgICAgICBXW2ldID1cbiAgICAgICAgICAgICAgICAgICAgKGJ1ZltvZmZzZXRdIDw8IDI0KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZltvZmZzZXQgKyAzXTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBleHBhbmQgdG8gODAgd29yZHNcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdCA9IFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl07XG4gICAgICAgICAgICBXW2ldID0gKCh0IDw8IDEpIHwgKHQgPj4+IDMxKSkgJiAweGZmZmZmZmZmO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhID0gdGhpcy5jaGFpbl9bMF07XG4gICAgICAgIGxldCBiID0gdGhpcy5jaGFpbl9bMV07XG4gICAgICAgIGxldCBjID0gdGhpcy5jaGFpbl9bMl07XG4gICAgICAgIGxldCBkID0gdGhpcy5jaGFpbl9bM107XG4gICAgICAgIGxldCBlID0gdGhpcy5jaGFpbl9bNF07XG4gICAgICAgIGxldCBmLCBrO1xuICAgICAgICAvLyBUT0RPKHVzZXIpOiBUcnkgdG8gdW5yb2xsIHRoaXMgbG9vcCB0byBzcGVlZCB1cCB0aGUgY29tcHV0YXRpb24uXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPCA0MCkge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgMjApIHtcbiAgICAgICAgICAgICAgICAgICAgZiA9IGQgXiAoYiAmIChjIF4gZCkpO1xuICAgICAgICAgICAgICAgICAgICBrID0gMHg1YTgyNzk5OTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICAgICAgICAgICAgICAgIGsgPSAweDZlZDllYmExO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgNjApIHtcbiAgICAgICAgICAgICAgICAgICAgZiA9IChiICYgYykgfCAoZCAmIChiIHwgYykpO1xuICAgICAgICAgICAgICAgICAgICBrID0gMHg4ZjFiYmNkYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICAgICAgICAgICAgICAgIGsgPSAweGNhNjJjMWQ2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHQgPSAoKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIGsgKyBXW2ldKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgICAgICBlID0gZDtcbiAgICAgICAgICAgIGQgPSBjO1xuICAgICAgICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpICYgMHhmZmZmZmZmZjtcbiAgICAgICAgICAgIGIgPSBhO1xuICAgICAgICAgICAgYSA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFpbl9bMF0gPSAodGhpcy5jaGFpbl9bMF0gKyBhKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgIHRoaXMuY2hhaW5fWzFdID0gKHRoaXMuY2hhaW5fWzFdICsgYikgJiAweGZmZmZmZmZmO1xuICAgICAgICB0aGlzLmNoYWluX1syXSA9ICh0aGlzLmNoYWluX1syXSArIGMpICYgMHhmZmZmZmZmZjtcbiAgICAgICAgdGhpcy5jaGFpbl9bM10gPSAodGhpcy5jaGFpbl9bM10gKyBkKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgIHRoaXMuY2hhaW5fWzRdID0gKHRoaXMuY2hhaW5fWzRdICsgZSkgJiAweGZmZmZmZmZmO1xuICAgIH1cbiAgICB1cGRhdGUoYnl0ZXMsIGxlbmd0aCkge1xuICAgICAgICAvLyBUT0RPKGpvaG5sZW56KTogdGlnaHRlbiB0aGUgZnVuY3Rpb24gc2lnbmF0dXJlIGFuZCByZW1vdmUgdGhpcyBjaGVja1xuICAgICAgICBpZiAoYnl0ZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aE1pbnVzQmxvY2sgPSBsZW5ndGggLSB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICAvLyBVc2luZyBsb2NhbCBpbnN0ZWFkIG9mIG1lbWJlciB2YXJpYWJsZXMgZ2l2ZXMgfjUlIHNwZWVkdXAgb24gRmlyZWZveCAxNi5cbiAgICAgICAgY29uc3QgYnVmID0gdGhpcy5idWZfO1xuICAgICAgICBsZXQgaW5idWYgPSB0aGlzLmluYnVmXztcbiAgICAgICAgLy8gVGhlIG91dGVyIHdoaWxlIGxvb3Agc2hvdWxkIGV4ZWN1dGUgYXQgbW9zdCB0d2ljZS5cbiAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgaGF2ZSBubyBkYXRhIGluIHRoZSBibG9jayB0byB0b3AgdXAsIHdlIGNhbiBkaXJlY3RseSBwcm9jZXNzIHRoZVxuICAgICAgICAgICAgLy8gaW5wdXQgYnVmZmVyIChhc3N1bWluZyBpdCBjb250YWlucyBzdWZmaWNpZW50IGRhdGEpLiBUaGlzIGdpdmVzIH4yNSVcbiAgICAgICAgICAgIC8vIHNwZWVkdXAgb24gQ2hyb21lIDIzIGFuZCB+MTUlIHNwZWVkdXAgb24gRmlyZWZveCAxNiwgYnV0IHJlcXVpcmVzIHRoYXRcbiAgICAgICAgICAgIC8vIHRoZSBkYXRhIGlzIHByb3ZpZGVkIGluIGxhcmdlIGNodW5rcyAob3IgaW4gbXVsdGlwbGVzIG9mIDY0IGJ5dGVzKS5cbiAgICAgICAgICAgIGlmIChpbmJ1ZiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChuIDw9IGxlbmd0aE1pbnVzQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wcmVzc18oYnl0ZXMsIG4pO1xuICAgICAgICAgICAgICAgICAgICBuICs9IHRoaXMuYmxvY2tTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2luYnVmXSA9IGJ5dGVzLmNoYXJDb2RlQXQobik7XG4gICAgICAgICAgICAgICAgICAgICsraW5idWY7XG4gICAgICAgICAgICAgICAgICAgICsrbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluYnVmID09PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wcmVzc18oYnVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluYnVmID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1bXAgdG8gdGhlIG91dGVyIGxvb3Agc28gd2UgdXNlIHRoZSBmdWxsLWJsb2NrIG9wdGltaXphdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2luYnVmXSA9IGJ5dGVzW25dO1xuICAgICAgICAgICAgICAgICAgICArK2luYnVmO1xuICAgICAgICAgICAgICAgICAgICArK247XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmJ1ZiA9PT0gdGhpcy5ibG9ja1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHJlc3NfKGJ1Zik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmJ1ZiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBKdW1wIHRvIHRoZSBvdXRlciBsb29wIHNvIHdlIHVzZSB0aGUgZnVsbC1ibG9jayBvcHRpbWl6YXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluYnVmXyA9IGluYnVmO1xuICAgICAgICB0aGlzLnRvdGFsXyArPSBsZW5ndGg7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IGRpZ2VzdCA9IFtdO1xuICAgICAgICBsZXQgdG90YWxCaXRzID0gdGhpcy50b3RhbF8gKiA4O1xuICAgICAgICAvLyBBZGQgcGFkIDB4ODAgMHgwMCouXG4gICAgICAgIGlmICh0aGlzLmluYnVmXyA8IDU2KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLnBhZF8sIDU2IC0gdGhpcy5pbmJ1Zl8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUodGhpcy5wYWRfLCB0aGlzLmJsb2NrU2l6ZSAtICh0aGlzLmluYnVmXyAtIDU2KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkICMgYml0cy5cbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuYmxvY2tTaXplIC0gMTsgaSA+PSA1NjsgaS0tKSB7XG4gICAgICAgICAgICB0aGlzLmJ1Zl9baV0gPSB0b3RhbEJpdHMgJiAyNTU7XG4gICAgICAgICAgICB0b3RhbEJpdHMgLz0gMjU2OyAvLyBEb24ndCB1c2UgYml0LXNoaWZ0aW5nIGhlcmUhXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21wcmVzc18odGhpcy5idWZfKTtcbiAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDI0OyBqID49IDA7IGogLT0gOCkge1xuICAgICAgICAgICAgICAgIGRpZ2VzdFtuXSA9ICh0aGlzLmNoYWluX1tpXSA+PiBqKSAmIDI1NTtcbiAgICAgICAgICAgICAgICArK247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpZ2VzdDtcbiAgICB9XG59XG5cbi8qKlxuICogSGVscGVyIHRvIG1ha2UgYSBTdWJzY3JpYmUgZnVuY3Rpb24gKGp1c3QgbGlrZSBQcm9taXNlIGhlbHBzIG1ha2UgYVxuICogVGhlbmFibGUpLlxuICpcbiAqIEBwYXJhbSBleGVjdXRvciBGdW5jdGlvbiB3aGljaCBjYW4gbWFrZSBjYWxscyB0byBhIHNpbmdsZSBPYnNlcnZlclxuICogICAgIGFzIGEgcHJveHkuXG4gKiBAcGFyYW0gb25Ob09ic2VydmVycyBDYWxsYmFjayB3aGVuIGNvdW50IG9mIE9ic2VydmVycyBnb2VzIHRvIHplcm8uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN1YnNjcmliZShleGVjdXRvciwgb25Ob09ic2VydmVycykge1xuICAgIGNvbnN0IHByb3h5ID0gbmV3IE9ic2VydmVyUHJveHkoZXhlY3V0b3IsIG9uTm9PYnNlcnZlcnMpO1xuICAgIHJldHVybiBwcm94eS5zdWJzY3JpYmUuYmluZChwcm94eSk7XG59XG4vKipcbiAqIEltcGxlbWVudCBmYW4tb3V0IGZvciBhbnkgbnVtYmVyIG9mIE9ic2VydmVycyBhdHRhY2hlZCB2aWEgYSBzdWJzY3JpYmVcbiAqIGZ1bmN0aW9uLlxuICovXG5jbGFzcyBPYnNlcnZlclByb3h5IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZXhlY3V0b3IgRnVuY3Rpb24gd2hpY2ggY2FuIG1ha2UgY2FsbHMgdG8gYSBzaW5nbGUgT2JzZXJ2ZXJcbiAgICAgKiAgICAgYXMgYSBwcm94eS5cbiAgICAgKiBAcGFyYW0gb25Ob09ic2VydmVycyBDYWxsYmFjayB3aGVuIGNvdW50IG9mIE9ic2VydmVycyBnb2VzIHRvIHplcm8uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZXhlY3V0b3IsIG9uTm9PYnNlcnZlcnMpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZXMgPSBbXTtcbiAgICAgICAgdGhpcy5vYnNlcnZlckNvdW50ID0gMDtcbiAgICAgICAgLy8gTWljcm8tdGFzayBzY2hlZHVsaW5nIGJ5IGNhbGxpbmcgdGFzay50aGVuKCkuXG4gICAgICAgIHRoaXMudGFzayA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLmZpbmFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uTm9PYnNlcnZlcnMgPSBvbk5vT2JzZXJ2ZXJzO1xuICAgICAgICAvLyBDYWxsIHRoZSBleGVjdXRvciBhc3luY2hyb25vdXNseSBzbyBzdWJzY3JpYmVycyB0aGF0IGFyZSBjYWxsZWRcbiAgICAgICAgLy8gc3luY2hyb25vdXNseSBhZnRlciB0aGUgY3JlYXRpb24gb2YgdGhlIHN1YnNjcmliZSBmdW5jdGlvblxuICAgICAgICAvLyBjYW4gc3RpbGwgcmVjZWl2ZSB0aGUgdmVyeSBmaXJzdCB2YWx1ZSBnZW5lcmF0ZWQgaW4gdGhlIGV4ZWN1dG9yLlxuICAgICAgICB0aGlzLnRhc2tcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGV4ZWN1dG9yKHRoaXMpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5leHQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5mb3JFYWNoT2JzZXJ2ZXIoKG9ic2VydmVyKSA9PiB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVycm9yKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZm9yRWFjaE9ic2VydmVyKChvYnNlcnZlcikgPT4ge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jbG9zZShlcnJvcik7XG4gICAgfVxuICAgIGNvbXBsZXRlKCkge1xuICAgICAgICB0aGlzLmZvckVhY2hPYnNlcnZlcigob2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGFkZCBhbiBPYnNlcnZlciB0byB0aGUgZmFuLW91dCBsaXN0LlxuICAgICAqXG4gICAgICogLSBXZSByZXF1aXJlIHRoYXQgbm8gZXZlbnQgaXMgc2VudCB0byBhIHN1YnNjcmliZXIgc3luY2hyb25vdXNseSB0byB0aGVpclxuICAgICAqICAgY2FsbCB0byBzdWJzY3JpYmUoKS5cbiAgICAgKi9cbiAgICBzdWJzY3JpYmUobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICBsZXQgb2JzZXJ2ZXI7XG4gICAgICAgIGlmIChuZXh0T3JPYnNlcnZlciA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBlcnJvciA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBjb21wbGV0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgT2JzZXJ2ZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXNzZW1ibGUgYW4gT2JzZXJ2ZXIgb2JqZWN0IHdoZW4gcGFzc2VkIGFzIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgICAgICAgaWYgKGltcGxlbWVudHNBbnlNZXRob2RzKG5leHRPck9ic2VydmVyLCBbXG4gICAgICAgICAgICAnbmV4dCcsXG4gICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgJ2NvbXBsZXRlJ1xuICAgICAgICBdKSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIgPSBuZXh0T3JPYnNlcnZlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9ic2VydmVyID0ge1xuICAgICAgICAgICAgICAgIG5leHQ6IG5leHRPck9ic2VydmVyLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYnNlcnZlci5uZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYnNlcnZlci5lcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvciA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9ic2VydmVyLmNvbXBsZXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1bnN1YiA9IHRoaXMudW5zdWJzY3JpYmVPbmUuYmluZCh0aGlzLCB0aGlzLm9ic2VydmVycy5sZW5ndGgpO1xuICAgICAgICAvLyBBdHRlbXB0IHRvIHN1YnNjcmliZSB0byBhIHRlcm1pbmF0ZWQgT2JzZXJ2YWJsZSAtIHdlXG4gICAgICAgIC8vIGp1c3QgcmVzcG9uZCB0byB0aGUgT2JzZXJ2ZXIgd2l0aCB0aGUgZmluYWwgZXJyb3Igb3IgY29tcGxldGVcbiAgICAgICAgLy8gZXZlbnQuXG4gICAgICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICAgICAgdGhpcy50YXNrLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmFsRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKHRoaXMuZmluYWxFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdGhpbmdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgICAgIHJldHVybiB1bnN1YjtcbiAgICB9XG4gICAgLy8gVW5zdWJzY3JpYmUgaXMgc3luY2hyb25vdXMgLSB3ZSBndWFyYW50ZWUgdGhhdCBubyBldmVudHMgYXJlIHNlbnQgdG9cbiAgICAvLyBhbnkgdW5zdWJzY3JpYmVkIE9ic2VydmVyLlxuICAgIHVuc3Vic2NyaWJlT25lKGkpIHtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXJzID09PSB1bmRlZmluZWQgfHwgdGhpcy5vYnNlcnZlcnNbaV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLm9ic2VydmVyc1tpXTtcbiAgICAgICAgdGhpcy5vYnNlcnZlckNvdW50IC09IDE7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyQ291bnQgPT09IDAgJiYgdGhpcy5vbk5vT2JzZXJ2ZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25Ob09ic2VydmVycyh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3JFYWNoT2JzZXJ2ZXIoZm4pIHtcbiAgICAgICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICAgICAgICAvLyBBbHJlYWR5IGNsb3NlZCBieSBwcmV2aW91cyBldmVudC4uLi5qdXN0IGVhdCB0aGUgYWRkaXRpb25hbCB2YWx1ZXMuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2Ugc2VuZE9uZSBjYWxscyBhc3luY2hyb25vdXNseSAtIHRoZXJlIGlzIG5vIGNoYW5jZSB0aGF0XG4gICAgICAgIC8vIHRoaXMub2JzZXJ2ZXJzIHdpbGwgYmVjb21lIHVuZGVmaW5lZC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9ic2VydmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5zZW5kT25lKGksIGZuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDYWxsIHRoZSBPYnNlcnZlciB2aWEgb25lIG9mIGl0J3MgY2FsbGJhY2sgZnVuY3Rpb24uIFdlIGFyZSBjYXJlZnVsIHRvXG4gICAgLy8gY29uZmlybSB0aGF0IHRoZSBvYnNlcnZlIGhhcyBub3QgYmVlbiB1bnN1YnNjcmliZWQgc2luY2UgdGhpcyBhc3luY2hyb25vdXNcbiAgICAvLyBmdW5jdGlvbiBoYWQgYmVlbiBxdWV1ZWQuXG4gICAgc2VuZE9uZShpLCBmbikge1xuICAgICAgICAvLyBFeGVjdXRlIHRoZSBjYWxsYmFjayBhc3luY2hyb25vdXNseVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICAgIHRoaXMudGFzay50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9ic2VydmVycyAhPT0gdW5kZWZpbmVkICYmIHRoaXMub2JzZXJ2ZXJzW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmbih0aGlzLm9ic2VydmVyc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBleGNlcHRpb25zIHJhaXNlZCBpbiBPYnNlcnZlcnMgb3IgbWlzc2luZyBtZXRob2RzIG9mIGFuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ic2VydmVyLlxuICAgICAgICAgICAgICAgICAgICAvLyBMb2cgZXJyb3IgdG8gY29uc29sZS4gYi8zMTQwNDgwNlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbG9zZShlcnIpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maW5hbGl6ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoZXJyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmluYWxFcnJvciA9IGVycjtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcm94eSBpcyBubyBsb25nZXIgbmVlZGVkIC0gZ2FyYmFnZSBjb2xsZWN0IHJlZmVyZW5jZXNcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICB0aGlzLnRhc2sudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMub25Ob09ic2VydmVycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFR1cm4gc3luY2hyb25vdXMgZnVuY3Rpb24gaW50byBvbmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5LiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbmZ1bmN0aW9uIGFzeW5jKGZuLCBvbkVycm9yKSB7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSh0cnVlKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgZm4oLi4uYXJncyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgb2JqZWN0IHBhc3NlZCBpbiBpbXBsZW1lbnRzIGFueSBvZiB0aGUgbmFtZWQgbWV0aG9kcy5cbiAqL1xuZnVuY3Rpb24gaW1wbGVtZW50c0FueU1ldGhvZHMob2JqLCBtZXRob2RzKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIG1ldGhvZHMpIHtcbiAgICAgICAgaWYgKG1ldGhvZCBpbiBvYmogJiYgdHlwZW9mIG9ialttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBub29wKCkge1xuICAgIC8vIGRvIG5vdGhpbmdcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQ2hlY2sgdG8gbWFrZSBzdXJlIHRoZSBhcHByb3ByaWF0ZSBudW1iZXIgb2YgYXJndW1lbnRzIGFyZSBwcm92aWRlZCBmb3IgYSBwdWJsaWMgZnVuY3Rpb24uXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgaXQgZmFpbHMuXG4gKlxuICogQHBhcmFtIGZuTmFtZSBUaGUgZnVuY3Rpb24gbmFtZVxuICogQHBhcmFtIG1pbkNvdW50IFRoZSBtaW5pbXVtIG51bWJlciBvZiBhcmd1bWVudHMgdG8gYWxsb3cgZm9yIHRoZSBmdW5jdGlvbiBjYWxsXG4gKiBAcGFyYW0gbWF4Q291bnQgVGhlIG1heGltdW0gbnVtYmVyIG9mIGFyZ3VtZW50IHRvIGFsbG93IGZvciB0aGUgZnVuY3Rpb24gY2FsbFxuICogQHBhcmFtIGFyZ0NvdW50IFRoZSBhY3R1YWwgbnVtYmVyIG9mIGFyZ3VtZW50cyBwcm92aWRlZC5cbiAqL1xuY29uc3QgdmFsaWRhdGVBcmdDb3VudCA9IGZ1bmN0aW9uIChmbk5hbWUsIG1pbkNvdW50LCBtYXhDb3VudCwgYXJnQ291bnQpIHtcbiAgICBsZXQgYXJnRXJyb3I7XG4gICAgaWYgKGFyZ0NvdW50IDwgbWluQ291bnQpIHtcbiAgICAgICAgYXJnRXJyb3IgPSAnYXQgbGVhc3QgJyArIG1pbkNvdW50O1xuICAgIH1cbiAgICBlbHNlIGlmIChhcmdDb3VudCA+IG1heENvdW50KSB7XG4gICAgICAgIGFyZ0Vycm9yID0gbWF4Q291bnQgPT09IDAgPyAnbm9uZScgOiAnbm8gbW9yZSB0aGFuICcgKyBtYXhDb3VudDtcbiAgICB9XG4gICAgaWYgKGFyZ0Vycm9yKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gZm5OYW1lICtcbiAgICAgICAgICAgICcgZmFpbGVkOiBXYXMgY2FsbGVkIHdpdGggJyArXG4gICAgICAgICAgICBhcmdDb3VudCArXG4gICAgICAgICAgICAoYXJnQ291bnQgPT09IDEgPyAnIGFyZ3VtZW50LicgOiAnIGFyZ3VtZW50cy4nKSArXG4gICAgICAgICAgICAnIEV4cGVjdHMgJyArXG4gICAgICAgICAgICBhcmdFcnJvciArXG4gICAgICAgICAgICAnLic7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gICAgfVxufTtcbi8qKlxuICogR2VuZXJhdGVzIGEgc3RyaW5nIHRvIHByZWZpeCBhbiBlcnJvciBtZXNzYWdlIGFib3V0IGZhaWxlZCBhcmd1bWVudCB2YWxpZGF0aW9uXG4gKlxuICogQHBhcmFtIGZuTmFtZSBUaGUgZnVuY3Rpb24gbmFtZVxuICogQHBhcmFtIGFyZ05hbWUgVGhlIG5hbWUgb2YgdGhlIGFyZ3VtZW50XG4gKiBAcmV0dXJuIFRoZSBwcmVmaXggdG8gYWRkIHRvIHRoZSBlcnJvciB0aHJvd24gZm9yIHZhbGlkYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGVycm9yUHJlZml4KGZuTmFtZSwgYXJnTmFtZSkge1xuICAgIHJldHVybiBgJHtmbk5hbWV9IGZhaWxlZDogJHthcmdOYW1lfSBhcmd1bWVudCBgO1xufVxuLyoqXG4gKiBAcGFyYW0gZm5OYW1lXG4gKiBAcGFyYW0gYXJndW1lbnROdW1iZXJcbiAqIEBwYXJhbSBuYW1lc3BhY2VcbiAqIEBwYXJhbSBvcHRpb25hbFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU5hbWVzcGFjZShmbk5hbWUsIG5hbWVzcGFjZSwgb3B0aW9uYWwpIHtcbiAgICBpZiAob3B0aW9uYWwgJiYgIW5hbWVzcGFjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAvL1RPRE86IEkgc2hvdWxkIGRvIG1vcmUgdmFsaWRhdGlvbiBoZXJlLiBXZSBvbmx5IGFsbG93IGNlcnRhaW4gY2hhcnMgaW4gbmFtZXNwYWNlcy5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgJ25hbWVzcGFjZScpICsgJ211c3QgYmUgYSB2YWxpZCBmaXJlYmFzZSBuYW1lc3BhY2UuJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVDYWxsYmFjayhmbk5hbWUsIGFyZ3VtZW50TmFtZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuY2FsbGJhY2ssIG9wdGlvbmFsKSB7XG4gICAgaWYgKG9wdGlvbmFsICYmICFjYWxsYmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROYW1lKSArICdtdXN0IGJlIGEgdmFsaWQgZnVuY3Rpb24uJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVDb250ZXh0T2JqZWN0KGZuTmFtZSwgYXJndW1lbnROYW1lLCBjb250ZXh0LCBvcHRpb25hbCkge1xuICAgIGlmIChvcHRpb25hbCAmJiAhY29udGV4dCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gJ29iamVjdCcgfHwgY29udGV4dCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE5hbWUpICsgJ211c3QgYmUgYSB2YWxpZCBjb250ZXh0IG9iamVjdC4nKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBDb2RlIG9yaWdpbmFsbHkgY2FtZSBmcm9tIGdvb2cuY3J5cHQuc3RyaW5nVG9VdGY4Qnl0ZUFycmF5LCBidXQgZm9yIHNvbWUgcmVhc29uIHRoZXlcbi8vIGF1dG9tYXRpY2FsbHkgcmVwbGFjZWQgJ1xcclxcbicgd2l0aCAnXFxuJywgYW5kIHRoZXkgZGlkbid0IGhhbmRsZSBzdXJyb2dhdGUgcGFpcnMsXG4vLyBzbyBpdCdzIGJlZW4gbW9kaWZpZWQuXG4vLyBOb3RlIHRoYXQgbm90IGFsbCBVbmljb2RlIGNoYXJhY3RlcnMgYXBwZWFyIGFzIHNpbmdsZSBjaGFyYWN0ZXJzIGluIEphdmFTY3JpcHQgc3RyaW5ncy5cbi8vIGZyb21DaGFyQ29kZSByZXR1cm5zIHRoZSBVVEYtMTYgZW5jb2Rpbmcgb2YgYSBjaGFyYWN0ZXIgLSBzbyBzb21lIFVuaWNvZGUgY2hhcmFjdGVyc1xuLy8gdXNlIDIgY2hhcmFjdGVycyBpbiBKYXZhU2NyaXB0LiAgQWxsIDQtYnl0ZSBVVEYtOCBjaGFyYWN0ZXJzIGJlZ2luIHdpdGggYSBmaXJzdFxuLy8gY2hhcmFjdGVyIGluIHRoZSByYW5nZSAweEQ4MDAgLSAweERCRkYgKHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzby1jYWxsZWQgc3Vycm9nYXRlXG4vLyBwYWlyKS5cbi8vIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtMTUuMS4zXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5jb25zdCBzdHJpbmdUb0J5dGVBcnJheSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBsZXQgcCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgLy8gSXMgdGhpcyB0aGUgbGVhZCBzdXJyb2dhdGUgaW4gYSBzdXJyb2dhdGUgcGFpcj9cbiAgICAgICAgaWYgKGMgPj0gMHhkODAwICYmIGMgPD0gMHhkYmZmKSB7XG4gICAgICAgICAgICBjb25zdCBoaWdoID0gYyAtIDB4ZDgwMDsgLy8gdGhlIGhpZ2ggMTAgYml0cy5cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGFzc2VydChpIDwgc3RyLmxlbmd0aCwgJ1N1cnJvZ2F0ZSBwYWlyIG1pc3NpbmcgdHJhaWwgc3Vycm9nYXRlLicpO1xuICAgICAgICAgICAgY29uc3QgbG93ID0gc3RyLmNoYXJDb2RlQXQoaSkgLSAweGRjMDA7IC8vIHRoZSBsb3cgMTAgYml0cy5cbiAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKGhpZ2ggPDwgMTApICsgbG93O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IGM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpIHtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gNikgfCAxOTI7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCA2NTUzNikge1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiAxMikgfCAyMjQ7XG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDE4KSB8IDI0MDtcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDEyKSAmIDYzKSB8IDEyODtcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcbi8qKlxuICogQ2FsY3VsYXRlIGxlbmd0aCB3aXRob3V0IGFjdHVhbGx5IGNvbnZlcnRpbmc7IHVzZWZ1bCBmb3IgZG9pbmcgY2hlYXBlciB2YWxpZGF0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5jb25zdCBzdHJpbmdMZW5ndGggPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgbGV0IHAgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcbiAgICAgICAgICAgIHArKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OCkge1xuICAgICAgICAgICAgcCArPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPj0gMHhkODAwICYmIGMgPD0gMHhkYmZmKSB7XG4gICAgICAgICAgICAvLyBMZWFkIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLiAgVGhlIHBhaXIgdG9nZXRoZXIgd2lsbCB0YWtlIDQgYnl0ZXMgdG8gcmVwcmVzZW50LlxuICAgICAgICAgICAgcCArPSA0O1xuICAgICAgICAgICAgaSsrOyAvLyBza2lwIHRyYWlsIHN1cnJvZ2F0ZS5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHAgKz0gMztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcDtcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIENvcGllZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMTE3NTIzXG4gKiBHZW5lcmF0ZXMgYSBuZXcgdXVpZC5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdXVpZHY0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGMgPT4ge1xuICAgICAgICBjb25zdCByID0gKE1hdGgucmFuZG9tKCkgKiAxNikgfCAwLCB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4ODtcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVGhlIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgdG8gZXhwb25lbnRpYWxseSBpbmNyZWFzZS5cbiAqL1xuY29uc3QgREVGQVVMVF9JTlRFUlZBTF9NSUxMSVMgPSAxMDAwO1xuLyoqXG4gKiBUaGUgZmFjdG9yIHRvIGJhY2tvZmYgYnkuXG4gKiBTaG91bGQgYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDEuXG4gKi9cbmNvbnN0IERFRkFVTFRfQkFDS09GRl9GQUNUT1IgPSAyO1xuLyoqXG4gKiBUaGUgbWF4aW11bSBtaWxsaXNlY29uZHMgdG8gaW5jcmVhc2UgdG8uXG4gKlxuICogPHA+VmlzaWJsZSBmb3IgdGVzdGluZ1xuICovXG5jb25zdCBNQVhfVkFMVUVfTUlMTElTID0gNCAqIDYwICogNjAgKiAxMDAwOyAvLyBGb3VyIGhvdXJzLCBsaWtlIGlPUyBhbmQgQW5kcm9pZC5cbi8qKlxuICogVGhlIHBlcmNlbnRhZ2Ugb2YgYmFja29mZiB0aW1lIHRvIHJhbmRvbWl6ZSBieS5cbiAqIFNlZVxuICogaHR0cDovL2dvL3NhZmUtY2xpZW50LWJlaGF2aW9yI3N0ZXAtMS1kZXRlcm1pbmUtdGhlLWFwcHJvcHJpYXRlLXJldHJ5LWludGVydmFsLXRvLWhhbmRsZS1zcGlrZS10cmFmZmljXG4gKiBmb3IgY29udGV4dC5cbiAqXG4gKiA8cD5WaXNpYmxlIGZvciB0ZXN0aW5nXG4gKi9cbmNvbnN0IFJBTkRPTV9GQUNUT1IgPSAwLjU7XG4vKipcbiAqIEJhc2VkIG9uIHRoZSBiYWNrb2ZmIG1ldGhvZCBmcm9tXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtbGlicmFyeS9ibG9iL21hc3Rlci9jbG9zdXJlL2dvb2cvbWF0aC9leHBvbmVudGlhbGJhY2tvZmYuanMuXG4gKiBFeHRyYWN0ZWQgaGVyZSBzbyB3ZSBkb24ndCBuZWVkIHRvIHBhc3MgbWV0YWRhdGEgYW5kIGEgc3RhdGVmdWwgRXhwb25lbnRpYWxCYWNrb2ZmIG9iamVjdCBhcm91bmQuXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUJhY2tvZmZNaWxsaXMoYmFja29mZkNvdW50LCBpbnRlcnZhbE1pbGxpcyA9IERFRkFVTFRfSU5URVJWQUxfTUlMTElTLCBiYWNrb2ZmRmFjdG9yID0gREVGQVVMVF9CQUNLT0ZGX0ZBQ1RPUikge1xuICAgIC8vIENhbGN1bGF0ZXMgYW4gZXhwb25lbnRpYWxseSBpbmNyZWFzaW5nIHZhbHVlLlxuICAgIC8vIERldmlhdGlvbjogY2FsY3VsYXRlcyB2YWx1ZSBmcm9tIGNvdW50IGFuZCBhIGNvbnN0YW50IGludGVydmFsLCBzbyB3ZSBvbmx5IG5lZWQgdG8gc2F2ZSB2YWx1ZVxuICAgIC8vIGFuZCBjb3VudCB0byByZXN0b3JlIHN0YXRlLlxuICAgIGNvbnN0IGN1cnJCYXNlVmFsdWUgPSBpbnRlcnZhbE1pbGxpcyAqIE1hdGgucG93KGJhY2tvZmZGYWN0b3IsIGJhY2tvZmZDb3VudCk7XG4gICAgLy8gQSByYW5kb20gXCJmdXp6XCIgdG8gYXZvaWQgd2F2ZXMgb2YgcmV0cmllcy5cbiAgICAvLyBEZXZpYXRpb246IHJhbmRvbUZhY3RvciBpcyByZXF1aXJlZC5cbiAgICBjb25zdCByYW5kb21XYWl0ID0gTWF0aC5yb3VuZChcbiAgICAvLyBBIGZyYWN0aW9uIG9mIHRoZSBiYWNrb2ZmIHZhbHVlIHRvIGFkZC9zdWJ0cmFjdC5cbiAgICAvLyBEZXZpYXRpb246IGNoYW5nZXMgbXVsdGlwbGljYXRpb24gb3JkZXIgdG8gaW1wcm92ZSByZWFkYWJpbGl0eS5cbiAgICBSQU5ET01fRkFDVE9SICpcbiAgICAgICAgY3VyckJhc2VWYWx1ZSAqXG4gICAgICAgIC8vIEEgcmFuZG9tIGZsb2F0IChyb3VuZGVkIHRvIGludCBieSBNYXRoLnJvdW5kIGFib3ZlKSBpbiB0aGUgcmFuZ2UgWy0xLCAxXS4gRGV0ZXJtaW5lc1xuICAgICAgICAvLyBpZiB3ZSBhZGQgb3Igc3VidHJhY3QuXG4gICAgICAgIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqXG4gICAgICAgIDIpO1xuICAgIC8vIExpbWl0cyBiYWNrb2ZmIHRvIG1heCB0byBhdm9pZCBlZmZlY3RpdmVseSBwZXJtYW5lbnQgYmFja29mZi5cbiAgICByZXR1cm4gTWF0aC5taW4oTUFYX1ZBTFVFX01JTExJUywgY3VyckJhc2VWYWx1ZSArIHJhbmRvbVdhaXQpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBQcm92aWRlIEVuZ2xpc2ggb3JkaW5hbCBsZXR0ZXJzIGFmdGVyIGEgbnVtYmVyXG4gKi9cbmZ1bmN0aW9uIG9yZGluYWwoaSkge1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGkpKSB7XG4gICAgICAgIHJldHVybiBgJHtpfWA7XG4gICAgfVxuICAgIHJldHVybiBpICsgaW5kaWNhdG9yKGkpO1xufVxuZnVuY3Rpb24gaW5kaWNhdG9yKGkpIHtcbiAgICBpID0gTWF0aC5hYnMoaSk7XG4gICAgY29uc3QgY2VudCA9IGkgJSAxMDA7XG4gICAgaWYgKGNlbnQgPj0gMTAgJiYgY2VudCA8PSAyMCkge1xuICAgICAgICByZXR1cm4gJ3RoJztcbiAgICB9XG4gICAgY29uc3QgZGVjID0gaSAlIDEwO1xuICAgIGlmIChkZWMgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuICdzdCc7XG4gICAgfVxuICAgIGlmIChkZWMgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuICduZCc7XG4gICAgfVxuICAgIGlmIChkZWMgPT09IDMpIHtcbiAgICAgICAgcmV0dXJuICdyZCc7XG4gICAgfVxuICAgIHJldHVybiAndGgnO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gZ2V0TW9kdWxhckluc3RhbmNlKHNlcnZpY2UpIHtcbiAgICBpZiAoc2VydmljZSAmJiBzZXJ2aWNlLl9kZWxlZ2F0ZSkge1xuICAgICAgICByZXR1cm4gc2VydmljZS5fZGVsZWdhdGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VydmljZTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBPdmVycmlkaW5nIHRoZSBjb25zdGFudCAod2Ugc2hvdWxkIGJlIHRoZSBvbmx5IG9uZXMgZG9pbmcgdGhpcylcbkNPTlNUQU5UUy5OT0RFX0NMSUVOVCA9IHRydWU7XG5cbmV4cG9ydCB7IENPTlNUQU5UUywgRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3IsIERlZmVycmVkLCBFcnJvckZhY3RvcnksIEZpcmViYXNlRXJyb3IsIE1BWF9WQUxVRV9NSUxMSVMsIFJBTkRPTV9GQUNUT1IsIFNoYTEsIGFyZUNvb2tpZXNFbmFibGVkLCBhc3NlcnQsIGFzc2VydGlvbkVycm9yLCBhc3luYywgYmFzZTY0LCBiYXNlNjREZWNvZGUsIGJhc2U2NEVuY29kZSwgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcsIGNhbGN1bGF0ZUJhY2tvZmZNaWxsaXMsIGNvbnRhaW5zLCBjcmVhdGVNb2NrVXNlclRva2VuLCBjcmVhdGVTdWJzY3JpYmUsIGRlY29kZSwgZGVlcENvcHksIGRlZXBFcXVhbCwgZGVlcEV4dGVuZCwgZXJyb3JQcmVmaXgsIGV4dHJhY3RRdWVyeXN0cmluZywgZ2V0RGVmYXVsdEFwcENvbmZpZywgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdCwgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0LCBnZXREZWZhdWx0cywgZ2V0RXhwZXJpbWVudGFsU2V0dGluZywgZ2V0R2xvYmFsLCBnZXRNb2R1bGFySW5zdGFuY2UsIGdldFVBLCBpc0FkbWluLCBpc0Jyb3dzZXIsIGlzQnJvd3NlckV4dGVuc2lvbiwgaXNDbG91ZGZsYXJlV29ya2VyLCBpc0VsZWN0cm9uLCBpc0VtcHR5LCBpc0lFLCBpc0luZGV4ZWREQkF2YWlsYWJsZSwgaXNNb2JpbGVDb3Jkb3ZhLCBpc05vZGUsIGlzTm9kZVNkaywgaXNSZWFjdE5hdGl2ZSwgaXNTYWZhcmksIGlzVVdQLCBpc1ZhbGlkRm9ybWF0LCBpc1ZhbGlkVGltZXN0YW1wLCBpc1dlYldvcmtlciwgaXNzdWVkQXRUaW1lLCBqc29uRXZhbCwgbWFwLCBvcmRpbmFsLCBwcm9taXNlV2l0aFRpbWVvdXQsIHF1ZXJ5c3RyaW5nLCBxdWVyeXN0cmluZ0RlY29kZSwgc2FmZUdldCwgc3RyaW5nTGVuZ3RoLCBzdHJpbmdUb0J5dGVBcnJheSwgc3RyaW5naWZ5LCB1dWlkdjQsIHZhbGlkYXRlQXJnQ291bnQsIHZhbGlkYXRlQ2FsbGJhY2ssIHZhbGlkYXRlQ29udGV4dE9iamVjdCwgdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSwgdmFsaWRhdGVOYW1lc3BhY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/webchannel-wrapper/dist/bloom-blob/esm/bloom_blob_es2018.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@firebase/webchannel-wrapper/dist/bloom-blob/esm/bloom_blob_es2018.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Integer: () => (/* binding */ Integer),\n/* harmony export */   Md5: () => (/* binding */ Md5),\n/* harmony export */   \"default\": () => (/* binding */ bloom_blob_es2018)\n/* harmony export */ });\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nvar bloom_blob_es2018 = {};\n\n/** @license\nCopyright The Closure Library Authors.\nSPDX-License-Identifier: Apache-2.0\n*/\n\nvar Integer;\nvar Md5;\n(function() {var h;/** @license\n\n Copyright The Closure Library Authors.\n SPDX-License-Identifier: Apache-2.0\n*/\nfunction k(f,a){function c(){}c.prototype=a.prototype;f.D=a.prototype;f.prototype=new c;f.prototype.constructor=f;f.C=function(d,e,g){for(var b=Array(arguments.length-2),r=2;r<arguments.length;r++)b[r-2]=arguments[r];return a.prototype[e].apply(d,b)};}function l(){this.blockSize=-1;}function m(){this.blockSize=-1;this.blockSize=64;this.g=Array(4);this.B=Array(this.blockSize);this.o=this.h=0;this.s();}k(m,l);m.prototype.s=function(){this.g[0]=1732584193;this.g[1]=4023233417;this.g[2]=2562383102;this.g[3]=271733878;this.o=this.h=0;};\nfunction n(f,a,c){c||(c=0);var d=Array(16);if(\"string\"===typeof a)for(var e=0;16>e;++e)d[e]=a.charCodeAt(c++)|a.charCodeAt(c++)<<8|a.charCodeAt(c++)<<16|a.charCodeAt(c++)<<24;else for(e=0;16>e;++e)d[e]=a[c++]|a[c++]<<8|a[c++]<<16|a[c++]<<24;a=f.g[0];c=f.g[1];e=f.g[2];var g=f.g[3];var b=a+(g^c&(e^g))+d[0]+3614090360&4294967295;a=c+(b<<7&4294967295|b>>>25);b=g+(e^a&(c^e))+d[1]+3905402710&4294967295;g=a+(b<<12&4294967295|b>>>20);b=e+(c^g&(a^c))+d[2]+606105819&4294967295;e=g+(b<<17&4294967295|b>>>15);\nb=c+(a^e&(g^a))+d[3]+3250441966&4294967295;c=e+(b<<22&4294967295|b>>>10);b=a+(g^c&(e^g))+d[4]+4118548399&4294967295;a=c+(b<<7&4294967295|b>>>25);b=g+(e^a&(c^e))+d[5]+1200080426&4294967295;g=a+(b<<12&4294967295|b>>>20);b=e+(c^g&(a^c))+d[6]+2821735955&4294967295;e=g+(b<<17&4294967295|b>>>15);b=c+(a^e&(g^a))+d[7]+4249261313&4294967295;c=e+(b<<22&4294967295|b>>>10);b=a+(g^c&(e^g))+d[8]+1770035416&4294967295;a=c+(b<<7&4294967295|b>>>25);b=g+(e^a&(c^e))+d[9]+2336552879&4294967295;g=a+(b<<12&4294967295|\nb>>>20);b=e+(c^g&(a^c))+d[10]+4294925233&4294967295;e=g+(b<<17&4294967295|b>>>15);b=c+(a^e&(g^a))+d[11]+2304563134&4294967295;c=e+(b<<22&4294967295|b>>>10);b=a+(g^c&(e^g))+d[12]+1804603682&4294967295;a=c+(b<<7&4294967295|b>>>25);b=g+(e^a&(c^e))+d[13]+4254626195&4294967295;g=a+(b<<12&4294967295|b>>>20);b=e+(c^g&(a^c))+d[14]+2792965006&4294967295;e=g+(b<<17&4294967295|b>>>15);b=c+(a^e&(g^a))+d[15]+1236535329&4294967295;c=e+(b<<22&4294967295|b>>>10);b=a+(e^g&(c^e))+d[1]+4129170786&4294967295;a=c+(b<<\n5&4294967295|b>>>27);b=g+(c^e&(a^c))+d[6]+3225465664&4294967295;g=a+(b<<9&4294967295|b>>>23);b=e+(a^c&(g^a))+d[11]+643717713&4294967295;e=g+(b<<14&4294967295|b>>>18);b=c+(g^a&(e^g))+d[0]+3921069994&4294967295;c=e+(b<<20&4294967295|b>>>12);b=a+(e^g&(c^e))+d[5]+3593408605&4294967295;a=c+(b<<5&4294967295|b>>>27);b=g+(c^e&(a^c))+d[10]+38016083&4294967295;g=a+(b<<9&4294967295|b>>>23);b=e+(a^c&(g^a))+d[15]+3634488961&4294967295;e=g+(b<<14&4294967295|b>>>18);b=c+(g^a&(e^g))+d[4]+3889429448&4294967295;c=\ne+(b<<20&4294967295|b>>>12);b=a+(e^g&(c^e))+d[9]+568446438&4294967295;a=c+(b<<5&4294967295|b>>>27);b=g+(c^e&(a^c))+d[14]+3275163606&4294967295;g=a+(b<<9&4294967295|b>>>23);b=e+(a^c&(g^a))+d[3]+4107603335&4294967295;e=g+(b<<14&4294967295|b>>>18);b=c+(g^a&(e^g))+d[8]+1163531501&4294967295;c=e+(b<<20&4294967295|b>>>12);b=a+(e^g&(c^e))+d[13]+2850285829&4294967295;a=c+(b<<5&4294967295|b>>>27);b=g+(c^e&(a^c))+d[2]+4243563512&4294967295;g=a+(b<<9&4294967295|b>>>23);b=e+(a^c&(g^a))+d[7]+1735328473&4294967295;\ne=g+(b<<14&4294967295|b>>>18);b=c+(g^a&(e^g))+d[12]+2368359562&4294967295;c=e+(b<<20&4294967295|b>>>12);b=a+(c^e^g)+d[5]+4294588738&4294967295;a=c+(b<<4&4294967295|b>>>28);b=g+(a^c^e)+d[8]+2272392833&4294967295;g=a+(b<<11&4294967295|b>>>21);b=e+(g^a^c)+d[11]+1839030562&4294967295;e=g+(b<<16&4294967295|b>>>16);b=c+(e^g^a)+d[14]+4259657740&4294967295;c=e+(b<<23&4294967295|b>>>9);b=a+(c^e^g)+d[1]+2763975236&4294967295;a=c+(b<<4&4294967295|b>>>28);b=g+(a^c^e)+d[4]+1272893353&4294967295;g=a+(b<<11&4294967295|\nb>>>21);b=e+(g^a^c)+d[7]+4139469664&4294967295;e=g+(b<<16&4294967295|b>>>16);b=c+(e^g^a)+d[10]+3200236656&4294967295;c=e+(b<<23&4294967295|b>>>9);b=a+(c^e^g)+d[13]+681279174&4294967295;a=c+(b<<4&4294967295|b>>>28);b=g+(a^c^e)+d[0]+3936430074&4294967295;g=a+(b<<11&4294967295|b>>>21);b=e+(g^a^c)+d[3]+3572445317&4294967295;e=g+(b<<16&4294967295|b>>>16);b=c+(e^g^a)+d[6]+76029189&4294967295;c=e+(b<<23&4294967295|b>>>9);b=a+(c^e^g)+d[9]+3654602809&4294967295;a=c+(b<<4&4294967295|b>>>28);b=g+(a^c^e)+d[12]+\n3873151461&4294967295;g=a+(b<<11&4294967295|b>>>21);b=e+(g^a^c)+d[15]+530742520&4294967295;e=g+(b<<16&4294967295|b>>>16);b=c+(e^g^a)+d[2]+3299628645&4294967295;c=e+(b<<23&4294967295|b>>>9);b=a+(e^(c|~g))+d[0]+4096336452&4294967295;a=c+(b<<6&4294967295|b>>>26);b=g+(c^(a|~e))+d[7]+1126891415&4294967295;g=a+(b<<10&4294967295|b>>>22);b=e+(a^(g|~c))+d[14]+2878612391&4294967295;e=g+(b<<15&4294967295|b>>>17);b=c+(g^(e|~a))+d[5]+4237533241&4294967295;c=e+(b<<21&4294967295|b>>>11);b=a+(e^(c|~g))+d[12]+1700485571&\n4294967295;a=c+(b<<6&4294967295|b>>>26);b=g+(c^(a|~e))+d[3]+2399980690&4294967295;g=a+(b<<10&4294967295|b>>>22);b=e+(a^(g|~c))+d[10]+4293915773&4294967295;e=g+(b<<15&4294967295|b>>>17);b=c+(g^(e|~a))+d[1]+2240044497&4294967295;c=e+(b<<21&4294967295|b>>>11);b=a+(e^(c|~g))+d[8]+1873313359&4294967295;a=c+(b<<6&4294967295|b>>>26);b=g+(c^(a|~e))+d[15]+4264355552&4294967295;g=a+(b<<10&4294967295|b>>>22);b=e+(a^(g|~c))+d[6]+2734768916&4294967295;e=g+(b<<15&4294967295|b>>>17);b=c+(g^(e|~a))+d[13]+1309151649&\n4294967295;c=e+(b<<21&4294967295|b>>>11);b=a+(e^(c|~g))+d[4]+4149444226&4294967295;a=c+(b<<6&4294967295|b>>>26);b=g+(c^(a|~e))+d[11]+3174756917&4294967295;g=a+(b<<10&4294967295|b>>>22);b=e+(a^(g|~c))+d[2]+718787259&4294967295;e=g+(b<<15&4294967295|b>>>17);b=c+(g^(e|~a))+d[9]+3951481745&4294967295;f.g[0]=f.g[0]+a&4294967295;f.g[1]=f.g[1]+(e+(b<<21&4294967295|b>>>11))&4294967295;f.g[2]=f.g[2]+e&4294967295;f.g[3]=f.g[3]+g&4294967295;}\nm.prototype.u=function(f,a){void 0===a&&(a=f.length);for(var c=a-this.blockSize,d=this.B,e=this.h,g=0;g<a;){if(0==e)for(;g<=c;)n(this,f,g),g+=this.blockSize;if(\"string\"===typeof f)for(;g<a;){if(d[e++]=f.charCodeAt(g++),e==this.blockSize){n(this,d);e=0;break}}else for(;g<a;)if(d[e++]=f[g++],e==this.blockSize){n(this,d);e=0;break}}this.h=e;this.o+=a;};\nm.prototype.v=function(){var f=Array((56>this.h?this.blockSize:2*this.blockSize)-this.h);f[0]=128;for(var a=1;a<f.length-8;++a)f[a]=0;var c=8*this.o;for(a=f.length-8;a<f.length;++a)f[a]=c&255,c/=256;this.u(f);f=Array(16);for(a=c=0;4>a;++a)for(var d=0;32>d;d+=8)f[c++]=this.g[a]>>>d&255;return f};function p(f,a){var c=q;return Object.prototype.hasOwnProperty.call(c,f)?c[f]:c[f]=a(f)}function t(f,a){this.h=a;for(var c=[],d=!0,e=f.length-1;0<=e;e--){var g=f[e]|0;d&&g==a||(c[e]=g,d=!1);}this.g=c;}var q={};function u(f){return -128<=f&&128>f?p(f,function(a){return new t([a|0],0>a?-1:0)}):new t([f|0],0>f?-1:0)}function v(f){if(isNaN(f)||!isFinite(f))return w;if(0>f)return x(v(-f));for(var a=[],c=1,d=0;f>=c;d++)a[d]=f/c|0,c*=4294967296;return new t(a,0)}\nfunction y(f,a){if(0==f.length)throw Error(\"number format error: empty string\");a=a||10;if(2>a||36<a)throw Error(\"radix out of range: \"+a);if(\"-\"==f.charAt(0))return x(y(f.substring(1),a));if(0<=f.indexOf(\"-\"))throw Error('number format error: interior \"-\" character');for(var c=v(Math.pow(a,8)),d=w,e=0;e<f.length;e+=8){var g=Math.min(8,f.length-e),b=parseInt(f.substring(e,e+g),a);8>g?(g=v(Math.pow(a,g)),d=d.j(g).add(v(b))):(d=d.j(c),d=d.add(v(b)));}return d}var w=u(0),z=u(1),A=u(16777216);h=t.prototype;\nh.m=function(){if(B(this))return -x(this).m();for(var f=0,a=1,c=0;c<this.g.length;c++){var d=this.i(c);f+=(0<=d?d:4294967296+d)*a;a*=4294967296;}return f};h.toString=function(f){f=f||10;if(2>f||36<f)throw Error(\"radix out of range: \"+f);if(C(this))return \"0\";if(B(this))return \"-\"+x(this).toString(f);for(var a=v(Math.pow(f,6)),c=this,d=\"\";;){var e=D(c,a).g;c=F(c,e.j(a));var g=((0<c.g.length?c.g[0]:c.h)>>>0).toString(f);c=e;if(C(c))return g+d;for(;6>g.length;)g=\"0\"+g;d=g+d;}};\nh.i=function(f){return 0>f?0:f<this.g.length?this.g[f]:this.h};function C(f){if(0!=f.h)return !1;for(var a=0;a<f.g.length;a++)if(0!=f.g[a])return !1;return !0}function B(f){return -1==f.h}h.l=function(f){f=F(this,f);return B(f)?-1:C(f)?0:1};function x(f){for(var a=f.g.length,c=[],d=0;d<a;d++)c[d]=~f.g[d];return (new t(c,~f.h)).add(z)}h.abs=function(){return B(this)?x(this):this};\nh.add=function(f){for(var a=Math.max(this.g.length,f.g.length),c=[],d=0,e=0;e<=a;e++){var g=d+(this.i(e)&65535)+(f.i(e)&65535),b=(g>>>16)+(this.i(e)>>>16)+(f.i(e)>>>16);d=b>>>16;g&=65535;b&=65535;c[e]=b<<16|g;}return new t(c,c[c.length-1]&-2147483648?-1:0)};function F(f,a){return f.add(x(a))}\nh.j=function(f){if(C(this)||C(f))return w;if(B(this))return B(f)?x(this).j(x(f)):x(x(this).j(f));if(B(f))return x(this.j(x(f)));if(0>this.l(A)&&0>f.l(A))return v(this.m()*f.m());for(var a=this.g.length+f.g.length,c=[],d=0;d<2*a;d++)c[d]=0;for(d=0;d<this.g.length;d++)for(var e=0;e<f.g.length;e++){var g=this.i(d)>>>16,b=this.i(d)&65535,r=f.i(e)>>>16,E=f.i(e)&65535;c[2*d+2*e]+=b*E;G(c,2*d+2*e);c[2*d+2*e+1]+=g*E;G(c,2*d+2*e+1);c[2*d+2*e+1]+=b*r;G(c,2*d+2*e+1);c[2*d+2*e+2]+=g*r;G(c,2*d+2*e+2);}for(d=0;d<\na;d++)c[d]=c[2*d+1]<<16|c[2*d];for(d=a;d<2*a;d++)c[d]=0;return new t(c,0)};function G(f,a){for(;(f[a]&65535)!=f[a];)f[a+1]+=f[a]>>>16,f[a]&=65535,a++;}function H(f,a){this.g=f;this.h=a;}\nfunction D(f,a){if(C(a))throw Error(\"division by zero\");if(C(f))return new H(w,w);if(B(f))return a=D(x(f),a),new H(x(a.g),x(a.h));if(B(a))return a=D(f,x(a)),new H(x(a.g),a.h);if(30<f.g.length){if(B(f)||B(a))throw Error(\"slowDivide_ only works with positive integers.\");for(var c=z,d=a;0>=d.l(f);)c=I(c),d=I(d);var e=J(c,1),g=J(d,1);d=J(d,2);for(c=J(c,2);!C(d);){var b=g.add(d);0>=b.l(f)&&(e=e.add(c),g=b);d=J(d,1);c=J(c,1);}a=F(f,e.j(a));return new H(e,a)}for(e=w;0<=f.l(a);){c=Math.max(1,Math.floor(f.m()/\na.m()));d=Math.ceil(Math.log(c)/Math.LN2);d=48>=d?1:Math.pow(2,d-48);g=v(c);for(b=g.j(a);B(b)||0<b.l(f);)c-=d,g=v(c),b=g.j(a);C(g)&&(g=z);e=e.add(g);f=F(f,b);}return new H(e,f)}h.A=function(f){return D(this,f).h};h.and=function(f){for(var a=Math.max(this.g.length,f.g.length),c=[],d=0;d<a;d++)c[d]=this.i(d)&f.i(d);return new t(c,this.h&f.h)};h.or=function(f){for(var a=Math.max(this.g.length,f.g.length),c=[],d=0;d<a;d++)c[d]=this.i(d)|f.i(d);return new t(c,this.h|f.h)};\nh.xor=function(f){for(var a=Math.max(this.g.length,f.g.length),c=[],d=0;d<a;d++)c[d]=this.i(d)^f.i(d);return new t(c,this.h^f.h)};function I(f){for(var a=f.g.length+1,c=[],d=0;d<a;d++)c[d]=f.i(d)<<1|f.i(d-1)>>>31;return new t(c,f.h)}function J(f,a){var c=a>>5;a%=32;for(var d=f.g.length-c,e=[],g=0;g<d;g++)e[g]=0<a?f.i(g+c)>>>a|f.i(g+c+1)<<32-a:f.i(g+c);return new t(e,f.h)}m.prototype.digest=m.prototype.v;m.prototype.reset=m.prototype.s;m.prototype.update=m.prototype.u;Md5 = bloom_blob_es2018.Md5=m;t.prototype.add=t.prototype.add;t.prototype.multiply=t.prototype.j;t.prototype.modulo=t.prototype.A;t.prototype.compare=t.prototype.l;t.prototype.toNumber=t.prototype.m;t.prototype.toString=t.prototype.toString;t.prototype.getBits=t.prototype.i;t.fromNumber=v;t.fromString=y;Integer = bloom_blob_es2018.Integer=t;}).apply( typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self  : typeof window !== 'undefined' ? window  : {});\n\n\n//# sourceMappingURL=bloom_blob_es2018.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3dlYmNoYW5uZWwtd3JhcHBlci9kaXN0L2Jsb29tLWJsb2IvZXNtL2Jsb29tX2Jsb2JfZXMyMDE4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE1BQU07O0FBRW5CO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjLHdCQUF3QixnQkFBZ0Isa0JBQWtCLDBCQUEwQixvQkFBb0Isd0NBQXdDLG1CQUFtQix3QkFBd0IsbUNBQW1DLGFBQWEsbUJBQW1CLGFBQWEsa0JBQWtCLGtCQUFrQixnQkFBZ0IsNkJBQTZCLGdCQUFnQixVQUFVLE9BQU8seUJBQXlCLHFCQUFxQixxQkFBcUIscUJBQXFCLG9CQUFvQjtBQUN2Z0Isa0JBQWtCLFNBQVMsZ0JBQWdCLG1DQUFtQyxLQUFLLDRGQUE0RixhQUFhLEtBQUssZ0RBQWdELFNBQVMsU0FBUyxTQUFTLGFBQWEsK0NBQStDLDZCQUE2QiwyQ0FBMkMsOEJBQThCLDBDQUEwQztBQUN4ZCwyQ0FBMkMsOEJBQThCLDJDQUEyQyw2QkFBNkIsMkNBQTJDLDhCQUE4QiwyQ0FBMkMsOEJBQThCLDJDQUEyQyw4QkFBOEIsMkNBQTJDLDZCQUE2QiwyQ0FBMkM7QUFDL2QsUUFBUSw0Q0FBNEMsOEJBQThCLDRDQUE0Qyw4QkFBOEIsNENBQTRDLDZCQUE2Qiw0Q0FBNEMsOEJBQThCLDRDQUE0Qyw4QkFBOEIsNENBQTRDLDhCQUE4QiwyQ0FBMkM7QUFDOWUscUJBQXFCLDJDQUEyQyw2QkFBNkIsMkNBQTJDLDhCQUE4QiwyQ0FBMkMsOEJBQThCLDJDQUEyQyw2QkFBNkIsMENBQTBDLDZCQUE2Qiw0Q0FBNEMsOEJBQThCLDJDQUEyQztBQUNuZiw0QkFBNEIsMENBQTBDLDZCQUE2Qiw0Q0FBNEMsNkJBQTZCLDJDQUEyQyw4QkFBOEIsMkNBQTJDLDhCQUE4Qiw0Q0FBNEMsNkJBQTZCLDJDQUEyQyw2QkFBNkI7QUFDL2MsOEJBQThCLDRDQUE0Qyw4QkFBOEIsdUNBQXVDLDZCQUE2Qix1Q0FBdUMsOEJBQThCLHdDQUF3Qyw4QkFBOEIsd0NBQXdDLDZCQUE2Qix1Q0FBdUMsNkJBQTZCLHVDQUF1QztBQUN2ZSxRQUFRLHVDQUF1Qyw4QkFBOEIsd0NBQXdDLDZCQUE2Qix1Q0FBdUMsNkJBQTZCLHVDQUF1Qyw4QkFBOEIsdUNBQXVDLDhCQUE4QixxQ0FBcUMsNkJBQTZCLHVDQUF1Qyw2QkFBNkI7QUFDdGUsc0JBQXNCLDhCQUE4Qix1Q0FBdUMsOEJBQThCLHVDQUF1Qyw2QkFBNkIsMENBQTBDLDZCQUE2QiwwQ0FBMEMsOEJBQThCLDJDQUEyQyw4QkFBOEIsMENBQTBDLDhCQUE4QjtBQUM3ZCxXQUFXLDZCQUE2QiwwQ0FBMEMsOEJBQThCLDJDQUEyQyw4QkFBOEIsMENBQTBDLDhCQUE4QiwwQ0FBMEMsNkJBQTZCLDJDQUEyQyw4QkFBOEIsMENBQTBDLDhCQUE4QjtBQUN6ZCxXQUFXLDhCQUE4QiwwQ0FBMEMsNkJBQTZCLDJDQUEyQyw4QkFBOEIseUNBQXlDLDhCQUE4QiwwQ0FBMEMsMkJBQTJCLHVEQUF1RCwyQkFBMkI7QUFDdlosNEJBQTRCLHlCQUF5QixpREFBaUQsSUFBSSxFQUFFLGFBQWEsS0FBSywrQkFBK0IsNEJBQTRCLElBQUksRUFBRSwrQ0FBK0MsVUFBVSxJQUFJLE9BQU8sVUFBVSxJQUFJLHFDQUFxQyxVQUFVLElBQUksT0FBTyxTQUFTO0FBQ3BWLHlCQUF5QixnRUFBZ0UsU0FBUyxZQUFZLGFBQWEsV0FBVyxlQUFlLGlCQUFpQixXQUFXLHNCQUFzQixVQUFVLFlBQVksVUFBVSxJQUFJLGdCQUFnQixLQUFLLDhCQUE4QixVQUFVLGdCQUFnQixRQUFRLGdFQUFnRSxnQkFBZ0IsU0FBUywrQkFBK0IsS0FBSyxLQUFLLGFBQWEsd0JBQXdCLFVBQVUsU0FBUyxjQUFjLHNDQUFzQyw2QkFBNkIsd0JBQXdCLGNBQWMsbUNBQW1DLHVCQUF1QixxQkFBcUIsS0FBSyw2QkFBNkI7QUFDbHVCLGdCQUFnQixnRUFBZ0UsUUFBUSxtREFBbUQsa0RBQWtELGdGQUFnRixtQ0FBbUMsV0FBVyxNQUFNLDhEQUE4RCxzRUFBc0UsU0FBUyxnQ0FBZ0M7QUFDOWUsZUFBZSwrQkFBK0Isb0JBQW9CLGdCQUFnQixLQUFLLGdCQUFnQiwyQkFBMkIsZUFBZSxVQUFVLHVCQUF1QixRQUFRLG1EQUFtRCxzQkFBc0IsMENBQTBDLHdDQUF3QyxFQUFFLGVBQWUsY0FBYyxrREFBa0QsSUFBSSxtQkFBbUIsS0FBSyxXQUFXLFNBQVM7QUFDdGQsZ0JBQWdCLCtDQUErQyxjQUFjLG9CQUFvQixZQUFZLGFBQWEsMkJBQTJCLFVBQVUsY0FBYyxlQUFlLGdCQUFnQixZQUFZLHlCQUF5QixjQUFjLDhCQUE4QixJQUFJLGlCQUFpQiw4QkFBOEIsaUJBQWlCO0FBQ2pXLGtCQUFrQiwwREFBMEQsS0FBSyxLQUFLLG1GQUFtRixTQUFTLFNBQVMsU0FBUyxjQUFjLGdEQUFnRCxnQkFBZ0I7QUFDbFIsZ0JBQWdCLDBCQUEwQix1REFBdUQsK0JBQStCLGtEQUFrRCw0Q0FBNEMsTUFBTSxXQUFXLFFBQVEsZ0JBQWdCLGdCQUFnQixhQUFhLEtBQUssb0VBQW9FLGdCQUFnQixhQUFhLGtCQUFrQixlQUFlLGtCQUFrQixlQUFlLGtCQUFrQixnQkFBZ0IsUUFBUTtBQUN0ZixFQUFFLDZCQUE2QixRQUFRLE1BQU0sV0FBVyxtQkFBbUIsZ0JBQWdCLEtBQUssbUJBQW1CLG9DQUFvQyxnQkFBZ0IsU0FBUztBQUNoTCxnQkFBZ0Isd0NBQXdDLDBCQUEwQixnREFBZ0QsNkNBQTZDLGtCQUFrQiw0RUFBNEUsZ0JBQWdCLFVBQVUsZUFBZSxzQkFBc0IsU0FBUyxhQUFhLE1BQU0sRUFBRSxlQUFlLDRCQUE0QixTQUFTLFVBQVUsY0FBYyxrQkFBa0IsUUFBUSxVQUFVLEVBQUU7QUFDNWQsUUFBUSxrQ0FBa0MsMkJBQTJCLE9BQU8sYUFBYSxlQUFlLHNCQUFzQixZQUFZLFdBQVcsVUFBVSxrQkFBa0IsZ0JBQWdCLG9CQUFvQixrQkFBa0Isc0RBQXNELElBQUksMEJBQTBCLDRCQUE0QixpQkFBaUIsc0RBQXNELElBQUksMEJBQTBCO0FBQzViLGtCQUFrQixzREFBc0QsSUFBSSwwQkFBMEIsNEJBQTRCLGNBQWMsZ0NBQWdDLElBQUksaUNBQWlDLG9CQUFvQixnQkFBZ0IsV0FBVyxNQUFNLGdDQUFnQyxJQUFJLG9EQUFvRCxvQkFBb0IsaUNBQWlDLGdDQUFnQyxpQ0FBaUMsOEJBQThCLGdDQUFnQyxtQ0FBbUMsaUNBQWlDLGtDQUFrQyxtQ0FBbUMsMENBQTBDLGtDQUFrQyxlQUFlLGVBQWUsdUNBQXVDLG9KQUFvSjs7QUFFOTRCO0FBQ3REIiwic291cmNlcyI6WyIvVXNlcnMvdnRwYXRlbDA3L1BhdGVsQ01QMjMzRmluYWxQcm9qZWN0L25vZGVfbW9kdWxlcy9AZmlyZWJhc2Uvd2ViY2hhbm5lbC13cmFwcGVyL2Rpc3QvYmxvb20tYmxvYi9lc20vYmxvb21fYmxvYl9lczIwMTguanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbnZhciBibG9vbV9ibG9iX2VzMjAxOCA9IHt9O1xuXG4vKiogQGxpY2Vuc2VcbkNvcHlyaWdodCBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuXG5TUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuKi9cblxudmFyIEludGVnZXI7XG52YXIgTWQ1O1xuKGZ1bmN0aW9uKCkge3ZhciBoOy8qKiBAbGljZW5zZVxuXG4gQ29weXJpZ2h0IFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy5cbiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuKi9cbmZ1bmN0aW9uIGsoZixhKXtmdW5jdGlvbiBjKCl7fWMucHJvdG90eXBlPWEucHJvdG90eXBlO2YuRD1hLnByb3RvdHlwZTtmLnByb3RvdHlwZT1uZXcgYztmLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1mO2YuQz1mdW5jdGlvbihkLGUsZyl7Zm9yKHZhciBiPUFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMikscj0yO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspYltyLTJdPWFyZ3VtZW50c1tyXTtyZXR1cm4gYS5wcm90b3R5cGVbZV0uYXBwbHkoZCxiKX07fWZ1bmN0aW9uIGwoKXt0aGlzLmJsb2NrU2l6ZT0tMTt9ZnVuY3Rpb24gbSgpe3RoaXMuYmxvY2tTaXplPS0xO3RoaXMuYmxvY2tTaXplPTY0O3RoaXMuZz1BcnJheSg0KTt0aGlzLkI9QXJyYXkodGhpcy5ibG9ja1NpemUpO3RoaXMubz10aGlzLmg9MDt0aGlzLnMoKTt9ayhtLGwpO20ucHJvdG90eXBlLnM9ZnVuY3Rpb24oKXt0aGlzLmdbMF09MTczMjU4NDE5Mzt0aGlzLmdbMV09NDAyMzIzMzQxNzt0aGlzLmdbMl09MjU2MjM4MzEwMjt0aGlzLmdbM109MjcxNzMzODc4O3RoaXMubz10aGlzLmg9MDt9O1xuZnVuY3Rpb24gbihmLGEsYyl7Y3x8KGM9MCk7dmFyIGQ9QXJyYXkoMTYpO2lmKFwic3RyaW5nXCI9PT10eXBlb2YgYSlmb3IodmFyIGU9MDsxNj5lOysrZSlkW2VdPWEuY2hhckNvZGVBdChjKyspfGEuY2hhckNvZGVBdChjKyspPDw4fGEuY2hhckNvZGVBdChjKyspPDwxNnxhLmNoYXJDb2RlQXQoYysrKTw8MjQ7ZWxzZSBmb3IoZT0wOzE2PmU7KytlKWRbZV09YVtjKytdfGFbYysrXTw8OHxhW2MrK108PDE2fGFbYysrXTw8MjQ7YT1mLmdbMF07Yz1mLmdbMV07ZT1mLmdbMl07dmFyIGc9Zi5nWzNdO3ZhciBiPWErKGdeYyYoZV5nKSkrZFswXSszNjE0MDkwMzYwJjQyOTQ5NjcyOTU7YT1jKyhiPDw3JjQyOTQ5NjcyOTV8Yj4+PjI1KTtiPWcrKGVeYSYoY15lKSkrZFsxXSszOTA1NDAyNzEwJjQyOTQ5NjcyOTU7Zz1hKyhiPDwxMiY0Mjk0OTY3Mjk1fGI+Pj4yMCk7Yj1lKyhjXmcmKGFeYykpK2RbMl0rNjA2MTA1ODE5JjQyOTQ5NjcyOTU7ZT1nKyhiPDwxNyY0Mjk0OTY3Mjk1fGI+Pj4xNSk7XG5iPWMrKGFeZSYoZ15hKSkrZFszXSszMjUwNDQxOTY2JjQyOTQ5NjcyOTU7Yz1lKyhiPDwyMiY0Mjk0OTY3Mjk1fGI+Pj4xMCk7Yj1hKyhnXmMmKGVeZykpK2RbNF0rNDExODU0ODM5OSY0Mjk0OTY3Mjk1O2E9YysoYjw8NyY0Mjk0OTY3Mjk1fGI+Pj4yNSk7Yj1nKyhlXmEmKGNeZSkpK2RbNV0rMTIwMDA4MDQyNiY0Mjk0OTY3Mjk1O2c9YSsoYjw8MTImNDI5NDk2NzI5NXxiPj4+MjApO2I9ZSsoY15nJihhXmMpKStkWzZdKzI4MjE3MzU5NTUmNDI5NDk2NzI5NTtlPWcrKGI8PDE3JjQyOTQ5NjcyOTV8Yj4+PjE1KTtiPWMrKGFeZSYoZ15hKSkrZFs3XSs0MjQ5MjYxMzEzJjQyOTQ5NjcyOTU7Yz1lKyhiPDwyMiY0Mjk0OTY3Mjk1fGI+Pj4xMCk7Yj1hKyhnXmMmKGVeZykpK2RbOF0rMTc3MDAzNTQxNiY0Mjk0OTY3Mjk1O2E9YysoYjw8NyY0Mjk0OTY3Mjk1fGI+Pj4yNSk7Yj1nKyhlXmEmKGNeZSkpK2RbOV0rMjMzNjU1Mjg3OSY0Mjk0OTY3Mjk1O2c9YSsoYjw8MTImNDI5NDk2NzI5NXxcbmI+Pj4yMCk7Yj1lKyhjXmcmKGFeYykpK2RbMTBdKzQyOTQ5MjUyMzMmNDI5NDk2NzI5NTtlPWcrKGI8PDE3JjQyOTQ5NjcyOTV8Yj4+PjE1KTtiPWMrKGFeZSYoZ15hKSkrZFsxMV0rMjMwNDU2MzEzNCY0Mjk0OTY3Mjk1O2M9ZSsoYjw8MjImNDI5NDk2NzI5NXxiPj4+MTApO2I9YSsoZ15jJihlXmcpKStkWzEyXSsxODA0NjAzNjgyJjQyOTQ5NjcyOTU7YT1jKyhiPDw3JjQyOTQ5NjcyOTV8Yj4+PjI1KTtiPWcrKGVeYSYoY15lKSkrZFsxM10rNDI1NDYyNjE5NSY0Mjk0OTY3Mjk1O2c9YSsoYjw8MTImNDI5NDk2NzI5NXxiPj4+MjApO2I9ZSsoY15nJihhXmMpKStkWzE0XSsyNzkyOTY1MDA2JjQyOTQ5NjcyOTU7ZT1nKyhiPDwxNyY0Mjk0OTY3Mjk1fGI+Pj4xNSk7Yj1jKyhhXmUmKGdeYSkpK2RbMTVdKzEyMzY1MzUzMjkmNDI5NDk2NzI5NTtjPWUrKGI8PDIyJjQyOTQ5NjcyOTV8Yj4+PjEwKTtiPWErKGVeZyYoY15lKSkrZFsxXSs0MTI5MTcwNzg2JjQyOTQ5NjcyOTU7YT1jKyhiPDxcbjUmNDI5NDk2NzI5NXxiPj4+MjcpO2I9ZysoY15lJihhXmMpKStkWzZdKzMyMjU0NjU2NjQmNDI5NDk2NzI5NTtnPWErKGI8PDkmNDI5NDk2NzI5NXxiPj4+MjMpO2I9ZSsoYV5jJihnXmEpKStkWzExXSs2NDM3MTc3MTMmNDI5NDk2NzI5NTtlPWcrKGI8PDE0JjQyOTQ5NjcyOTV8Yj4+PjE4KTtiPWMrKGdeYSYoZV5nKSkrZFswXSszOTIxMDY5OTk0JjQyOTQ5NjcyOTU7Yz1lKyhiPDwyMCY0Mjk0OTY3Mjk1fGI+Pj4xMik7Yj1hKyhlXmcmKGNeZSkpK2RbNV0rMzU5MzQwODYwNSY0Mjk0OTY3Mjk1O2E9YysoYjw8NSY0Mjk0OTY3Mjk1fGI+Pj4yNyk7Yj1nKyhjXmUmKGFeYykpK2RbMTBdKzM4MDE2MDgzJjQyOTQ5NjcyOTU7Zz1hKyhiPDw5JjQyOTQ5NjcyOTV8Yj4+PjIzKTtiPWUrKGFeYyYoZ15hKSkrZFsxNV0rMzYzNDQ4ODk2MSY0Mjk0OTY3Mjk1O2U9ZysoYjw8MTQmNDI5NDk2NzI5NXxiPj4+MTgpO2I9YysoZ15hJihlXmcpKStkWzRdKzM4ODk0Mjk0NDgmNDI5NDk2NzI5NTtjPVxuZSsoYjw8MjAmNDI5NDk2NzI5NXxiPj4+MTIpO2I9YSsoZV5nJihjXmUpKStkWzldKzU2ODQ0NjQzOCY0Mjk0OTY3Mjk1O2E9YysoYjw8NSY0Mjk0OTY3Mjk1fGI+Pj4yNyk7Yj1nKyhjXmUmKGFeYykpK2RbMTRdKzMyNzUxNjM2MDYmNDI5NDk2NzI5NTtnPWErKGI8PDkmNDI5NDk2NzI5NXxiPj4+MjMpO2I9ZSsoYV5jJihnXmEpKStkWzNdKzQxMDc2MDMzMzUmNDI5NDk2NzI5NTtlPWcrKGI8PDE0JjQyOTQ5NjcyOTV8Yj4+PjE4KTtiPWMrKGdeYSYoZV5nKSkrZFs4XSsxMTYzNTMxNTAxJjQyOTQ5NjcyOTU7Yz1lKyhiPDwyMCY0Mjk0OTY3Mjk1fGI+Pj4xMik7Yj1hKyhlXmcmKGNeZSkpK2RbMTNdKzI4NTAyODU4MjkmNDI5NDk2NzI5NTthPWMrKGI8PDUmNDI5NDk2NzI5NXxiPj4+MjcpO2I9ZysoY15lJihhXmMpKStkWzJdKzQyNDM1NjM1MTImNDI5NDk2NzI5NTtnPWErKGI8PDkmNDI5NDk2NzI5NXxiPj4+MjMpO2I9ZSsoYV5jJihnXmEpKStkWzddKzE3MzUzMjg0NzMmNDI5NDk2NzI5NTtcbmU9ZysoYjw8MTQmNDI5NDk2NzI5NXxiPj4+MTgpO2I9YysoZ15hJihlXmcpKStkWzEyXSsyMzY4MzU5NTYyJjQyOTQ5NjcyOTU7Yz1lKyhiPDwyMCY0Mjk0OTY3Mjk1fGI+Pj4xMik7Yj1hKyhjXmVeZykrZFs1XSs0Mjk0NTg4NzM4JjQyOTQ5NjcyOTU7YT1jKyhiPDw0JjQyOTQ5NjcyOTV8Yj4+PjI4KTtiPWcrKGFeY15lKStkWzhdKzIyNzIzOTI4MzMmNDI5NDk2NzI5NTtnPWErKGI8PDExJjQyOTQ5NjcyOTV8Yj4+PjIxKTtiPWUrKGdeYV5jKStkWzExXSsxODM5MDMwNTYyJjQyOTQ5NjcyOTU7ZT1nKyhiPDwxNiY0Mjk0OTY3Mjk1fGI+Pj4xNik7Yj1jKyhlXmdeYSkrZFsxNF0rNDI1OTY1Nzc0MCY0Mjk0OTY3Mjk1O2M9ZSsoYjw8MjMmNDI5NDk2NzI5NXxiPj4+OSk7Yj1hKyhjXmVeZykrZFsxXSsyNzYzOTc1MjM2JjQyOTQ5NjcyOTU7YT1jKyhiPDw0JjQyOTQ5NjcyOTV8Yj4+PjI4KTtiPWcrKGFeY15lKStkWzRdKzEyNzI4OTMzNTMmNDI5NDk2NzI5NTtnPWErKGI8PDExJjQyOTQ5NjcyOTV8XG5iPj4+MjEpO2I9ZSsoZ15hXmMpK2RbN10rNDEzOTQ2OTY2NCY0Mjk0OTY3Mjk1O2U9ZysoYjw8MTYmNDI5NDk2NzI5NXxiPj4+MTYpO2I9YysoZV5nXmEpK2RbMTBdKzMyMDAyMzY2NTYmNDI5NDk2NzI5NTtjPWUrKGI8PDIzJjQyOTQ5NjcyOTV8Yj4+PjkpO2I9YSsoY15lXmcpK2RbMTNdKzY4MTI3OTE3NCY0Mjk0OTY3Mjk1O2E9YysoYjw8NCY0Mjk0OTY3Mjk1fGI+Pj4yOCk7Yj1nKyhhXmNeZSkrZFswXSszOTM2NDMwMDc0JjQyOTQ5NjcyOTU7Zz1hKyhiPDwxMSY0Mjk0OTY3Mjk1fGI+Pj4yMSk7Yj1lKyhnXmFeYykrZFszXSszNTcyNDQ1MzE3JjQyOTQ5NjcyOTU7ZT1nKyhiPDwxNiY0Mjk0OTY3Mjk1fGI+Pj4xNik7Yj1jKyhlXmdeYSkrZFs2XSs3NjAyOTE4OSY0Mjk0OTY3Mjk1O2M9ZSsoYjw8MjMmNDI5NDk2NzI5NXxiPj4+OSk7Yj1hKyhjXmVeZykrZFs5XSszNjU0NjAyODA5JjQyOTQ5NjcyOTU7YT1jKyhiPDw0JjQyOTQ5NjcyOTV8Yj4+PjI4KTtiPWcrKGFeY15lKStkWzEyXStcbjM4NzMxNTE0NjEmNDI5NDk2NzI5NTtnPWErKGI8PDExJjQyOTQ5NjcyOTV8Yj4+PjIxKTtiPWUrKGdeYV5jKStkWzE1XSs1MzA3NDI1MjAmNDI5NDk2NzI5NTtlPWcrKGI8PDE2JjQyOTQ5NjcyOTV8Yj4+PjE2KTtiPWMrKGVeZ15hKStkWzJdKzMyOTk2Mjg2NDUmNDI5NDk2NzI5NTtjPWUrKGI8PDIzJjQyOTQ5NjcyOTV8Yj4+PjkpO2I9YSsoZV4oY3x+ZykpK2RbMF0rNDA5NjMzNjQ1MiY0Mjk0OTY3Mjk1O2E9YysoYjw8NiY0Mjk0OTY3Mjk1fGI+Pj4yNik7Yj1nKyhjXihhfH5lKSkrZFs3XSsxMTI2ODkxNDE1JjQyOTQ5NjcyOTU7Zz1hKyhiPDwxMCY0Mjk0OTY3Mjk1fGI+Pj4yMik7Yj1lKyhhXihnfH5jKSkrZFsxNF0rMjg3ODYxMjM5MSY0Mjk0OTY3Mjk1O2U9ZysoYjw8MTUmNDI5NDk2NzI5NXxiPj4+MTcpO2I9YysoZ14oZXx+YSkpK2RbNV0rNDIzNzUzMzI0MSY0Mjk0OTY3Mjk1O2M9ZSsoYjw8MjEmNDI5NDk2NzI5NXxiPj4+MTEpO2I9YSsoZV4oY3x+ZykpK2RbMTJdKzE3MDA0ODU1NzEmXG40Mjk0OTY3Mjk1O2E9YysoYjw8NiY0Mjk0OTY3Mjk1fGI+Pj4yNik7Yj1nKyhjXihhfH5lKSkrZFszXSsyMzk5OTgwNjkwJjQyOTQ5NjcyOTU7Zz1hKyhiPDwxMCY0Mjk0OTY3Mjk1fGI+Pj4yMik7Yj1lKyhhXihnfH5jKSkrZFsxMF0rNDI5MzkxNTc3MyY0Mjk0OTY3Mjk1O2U9ZysoYjw8MTUmNDI5NDk2NzI5NXxiPj4+MTcpO2I9YysoZ14oZXx+YSkpK2RbMV0rMjI0MDA0NDQ5NyY0Mjk0OTY3Mjk1O2M9ZSsoYjw8MjEmNDI5NDk2NzI5NXxiPj4+MTEpO2I9YSsoZV4oY3x+ZykpK2RbOF0rMTg3MzMxMzM1OSY0Mjk0OTY3Mjk1O2E9YysoYjw8NiY0Mjk0OTY3Mjk1fGI+Pj4yNik7Yj1nKyhjXihhfH5lKSkrZFsxNV0rNDI2NDM1NTU1MiY0Mjk0OTY3Mjk1O2c9YSsoYjw8MTAmNDI5NDk2NzI5NXxiPj4+MjIpO2I9ZSsoYV4oZ3x+YykpK2RbNl0rMjczNDc2ODkxNiY0Mjk0OTY3Mjk1O2U9ZysoYjw8MTUmNDI5NDk2NzI5NXxiPj4+MTcpO2I9YysoZ14oZXx+YSkpK2RbMTNdKzEzMDkxNTE2NDkmXG40Mjk0OTY3Mjk1O2M9ZSsoYjw8MjEmNDI5NDk2NzI5NXxiPj4+MTEpO2I9YSsoZV4oY3x+ZykpK2RbNF0rNDE0OTQ0NDIyNiY0Mjk0OTY3Mjk1O2E9YysoYjw8NiY0Mjk0OTY3Mjk1fGI+Pj4yNik7Yj1nKyhjXihhfH5lKSkrZFsxMV0rMzE3NDc1NjkxNyY0Mjk0OTY3Mjk1O2c9YSsoYjw8MTAmNDI5NDk2NzI5NXxiPj4+MjIpO2I9ZSsoYV4oZ3x+YykpK2RbMl0rNzE4Nzg3MjU5JjQyOTQ5NjcyOTU7ZT1nKyhiPDwxNSY0Mjk0OTY3Mjk1fGI+Pj4xNyk7Yj1jKyhnXihlfH5hKSkrZFs5XSszOTUxNDgxNzQ1JjQyOTQ5NjcyOTU7Zi5nWzBdPWYuZ1swXSthJjQyOTQ5NjcyOTU7Zi5nWzFdPWYuZ1sxXSsoZSsoYjw8MjEmNDI5NDk2NzI5NXxiPj4+MTEpKSY0Mjk0OTY3Mjk1O2YuZ1syXT1mLmdbMl0rZSY0Mjk0OTY3Mjk1O2YuZ1szXT1mLmdbM10rZyY0Mjk0OTY3Mjk1O31cbm0ucHJvdG90eXBlLnU9ZnVuY3Rpb24oZixhKXt2b2lkIDA9PT1hJiYoYT1mLmxlbmd0aCk7Zm9yKHZhciBjPWEtdGhpcy5ibG9ja1NpemUsZD10aGlzLkIsZT10aGlzLmgsZz0wO2c8YTspe2lmKDA9PWUpZm9yKDtnPD1jOyluKHRoaXMsZixnKSxnKz10aGlzLmJsb2NrU2l6ZTtpZihcInN0cmluZ1wiPT09dHlwZW9mIGYpZm9yKDtnPGE7KXtpZihkW2UrK109Zi5jaGFyQ29kZUF0KGcrKyksZT09dGhpcy5ibG9ja1NpemUpe24odGhpcyxkKTtlPTA7YnJlYWt9fWVsc2UgZm9yKDtnPGE7KWlmKGRbZSsrXT1mW2crK10sZT09dGhpcy5ibG9ja1NpemUpe24odGhpcyxkKTtlPTA7YnJlYWt9fXRoaXMuaD1lO3RoaXMubys9YTt9O1xubS5wcm90b3R5cGUudj1mdW5jdGlvbigpe3ZhciBmPUFycmF5KCg1Nj50aGlzLmg/dGhpcy5ibG9ja1NpemU6Mip0aGlzLmJsb2NrU2l6ZSktdGhpcy5oKTtmWzBdPTEyODtmb3IodmFyIGE9MTthPGYubGVuZ3RoLTg7KythKWZbYV09MDt2YXIgYz04KnRoaXMubztmb3IoYT1mLmxlbmd0aC04O2E8Zi5sZW5ndGg7KythKWZbYV09YyYyNTUsYy89MjU2O3RoaXMudShmKTtmPUFycmF5KDE2KTtmb3IoYT1jPTA7ND5hOysrYSlmb3IodmFyIGQ9MDszMj5kO2QrPTgpZltjKytdPXRoaXMuZ1thXT4+PmQmMjU1O3JldHVybiBmfTtmdW5jdGlvbiBwKGYsYSl7dmFyIGM9cTtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGMsZik/Y1tmXTpjW2ZdPWEoZil9ZnVuY3Rpb24gdChmLGEpe3RoaXMuaD1hO2Zvcih2YXIgYz1bXSxkPSEwLGU9Zi5sZW5ndGgtMTswPD1lO2UtLSl7dmFyIGc9ZltlXXwwO2QmJmc9PWF8fChjW2VdPWcsZD0hMSk7fXRoaXMuZz1jO312YXIgcT17fTtmdW5jdGlvbiB1KGYpe3JldHVybiAtMTI4PD1mJiYxMjg+Zj9wKGYsZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyB0KFthfDBdLDA+YT8tMTowKX0pOm5ldyB0KFtmfDBdLDA+Zj8tMTowKX1mdW5jdGlvbiB2KGYpe2lmKGlzTmFOKGYpfHwhaXNGaW5pdGUoZikpcmV0dXJuIHc7aWYoMD5mKXJldHVybiB4KHYoLWYpKTtmb3IodmFyIGE9W10sYz0xLGQ9MDtmPj1jO2QrKylhW2RdPWYvY3wwLGMqPTQyOTQ5NjcyOTY7cmV0dXJuIG5ldyB0KGEsMCl9XG5mdW5jdGlvbiB5KGYsYSl7aWYoMD09Zi5sZW5ndGgpdGhyb3cgRXJyb3IoXCJudW1iZXIgZm9ybWF0IGVycm9yOiBlbXB0eSBzdHJpbmdcIik7YT1hfHwxMDtpZigyPmF8fDM2PGEpdGhyb3cgRXJyb3IoXCJyYWRpeCBvdXQgb2YgcmFuZ2U6IFwiK2EpO2lmKFwiLVwiPT1mLmNoYXJBdCgwKSlyZXR1cm4geCh5KGYuc3Vic3RyaW5nKDEpLGEpKTtpZigwPD1mLmluZGV4T2YoXCItXCIpKXRocm93IEVycm9yKCdudW1iZXIgZm9ybWF0IGVycm9yOiBpbnRlcmlvciBcIi1cIiBjaGFyYWN0ZXInKTtmb3IodmFyIGM9dihNYXRoLnBvdyhhLDgpKSxkPXcsZT0wO2U8Zi5sZW5ndGg7ZSs9OCl7dmFyIGc9TWF0aC5taW4oOCxmLmxlbmd0aC1lKSxiPXBhcnNlSW50KGYuc3Vic3RyaW5nKGUsZStnKSxhKTs4Pmc/KGc9dihNYXRoLnBvdyhhLGcpKSxkPWQuaihnKS5hZGQodihiKSkpOihkPWQuaihjKSxkPWQuYWRkKHYoYikpKTt9cmV0dXJuIGR9dmFyIHc9dSgwKSx6PXUoMSksQT11KDE2Nzc3MjE2KTtoPXQucHJvdG90eXBlO1xuaC5tPWZ1bmN0aW9uKCl7aWYoQih0aGlzKSlyZXR1cm4gLXgodGhpcykubSgpO2Zvcih2YXIgZj0wLGE9MSxjPTA7Yzx0aGlzLmcubGVuZ3RoO2MrKyl7dmFyIGQ9dGhpcy5pKGMpO2YrPSgwPD1kP2Q6NDI5NDk2NzI5NitkKSphO2EqPTQyOTQ5NjcyOTY7fXJldHVybiBmfTtoLnRvU3RyaW5nPWZ1bmN0aW9uKGYpe2Y9Znx8MTA7aWYoMj5mfHwzNjxmKXRocm93IEVycm9yKFwicmFkaXggb3V0IG9mIHJhbmdlOiBcIitmKTtpZihDKHRoaXMpKXJldHVybiBcIjBcIjtpZihCKHRoaXMpKXJldHVybiBcIi1cIit4KHRoaXMpLnRvU3RyaW5nKGYpO2Zvcih2YXIgYT12KE1hdGgucG93KGYsNikpLGM9dGhpcyxkPVwiXCI7Oyl7dmFyIGU9RChjLGEpLmc7Yz1GKGMsZS5qKGEpKTt2YXIgZz0oKDA8Yy5nLmxlbmd0aD9jLmdbMF06Yy5oKT4+PjApLnRvU3RyaW5nKGYpO2M9ZTtpZihDKGMpKXJldHVybiBnK2Q7Zm9yKDs2PmcubGVuZ3RoOylnPVwiMFwiK2c7ZD1nK2Q7fX07XG5oLmk9ZnVuY3Rpb24oZil7cmV0dXJuIDA+Zj8wOmY8dGhpcy5nLmxlbmd0aD90aGlzLmdbZl06dGhpcy5ofTtmdW5jdGlvbiBDKGYpe2lmKDAhPWYuaClyZXR1cm4gITE7Zm9yKHZhciBhPTA7YTxmLmcubGVuZ3RoO2ErKylpZigwIT1mLmdbYV0pcmV0dXJuICExO3JldHVybiAhMH1mdW5jdGlvbiBCKGYpe3JldHVybiAtMT09Zi5ofWgubD1mdW5jdGlvbihmKXtmPUYodGhpcyxmKTtyZXR1cm4gQihmKT8tMTpDKGYpPzA6MX07ZnVuY3Rpb24geChmKXtmb3IodmFyIGE9Zi5nLmxlbmd0aCxjPVtdLGQ9MDtkPGE7ZCsrKWNbZF09fmYuZ1tkXTtyZXR1cm4gKG5ldyB0KGMsfmYuaCkpLmFkZCh6KX1oLmFicz1mdW5jdGlvbigpe3JldHVybiBCKHRoaXMpP3godGhpcyk6dGhpc307XG5oLmFkZD1mdW5jdGlvbihmKXtmb3IodmFyIGE9TWF0aC5tYXgodGhpcy5nLmxlbmd0aCxmLmcubGVuZ3RoKSxjPVtdLGQ9MCxlPTA7ZTw9YTtlKyspe3ZhciBnPWQrKHRoaXMuaShlKSY2NTUzNSkrKGYuaShlKSY2NTUzNSksYj0oZz4+PjE2KSsodGhpcy5pKGUpPj4+MTYpKyhmLmkoZSk+Pj4xNik7ZD1iPj4+MTY7ZyY9NjU1MzU7YiY9NjU1MzU7Y1tlXT1iPDwxNnxnO31yZXR1cm4gbmV3IHQoYyxjW2MubGVuZ3RoLTFdJi0yMTQ3NDgzNjQ4Py0xOjApfTtmdW5jdGlvbiBGKGYsYSl7cmV0dXJuIGYuYWRkKHgoYSkpfVxuaC5qPWZ1bmN0aW9uKGYpe2lmKEModGhpcyl8fEMoZikpcmV0dXJuIHc7aWYoQih0aGlzKSlyZXR1cm4gQihmKT94KHRoaXMpLmooeChmKSk6eCh4KHRoaXMpLmooZikpO2lmKEIoZikpcmV0dXJuIHgodGhpcy5qKHgoZikpKTtpZigwPnRoaXMubChBKSYmMD5mLmwoQSkpcmV0dXJuIHYodGhpcy5tKCkqZi5tKCkpO2Zvcih2YXIgYT10aGlzLmcubGVuZ3RoK2YuZy5sZW5ndGgsYz1bXSxkPTA7ZDwyKmE7ZCsrKWNbZF09MDtmb3IoZD0wO2Q8dGhpcy5nLmxlbmd0aDtkKyspZm9yKHZhciBlPTA7ZTxmLmcubGVuZ3RoO2UrKyl7dmFyIGc9dGhpcy5pKGQpPj4+MTYsYj10aGlzLmkoZCkmNjU1MzUscj1mLmkoZSk+Pj4xNixFPWYuaShlKSY2NTUzNTtjWzIqZCsyKmVdKz1iKkU7RyhjLDIqZCsyKmUpO2NbMipkKzIqZSsxXSs9ZypFO0coYywyKmQrMiplKzEpO2NbMipkKzIqZSsxXSs9YipyO0coYywyKmQrMiplKzEpO2NbMipkKzIqZSsyXSs9ZypyO0coYywyKmQrMiplKzIpO31mb3IoZD0wO2Q8XG5hO2QrKyljW2RdPWNbMipkKzFdPDwxNnxjWzIqZF07Zm9yKGQ9YTtkPDIqYTtkKyspY1tkXT0wO3JldHVybiBuZXcgdChjLDApfTtmdW5jdGlvbiBHKGYsYSl7Zm9yKDsoZlthXSY2NTUzNSkhPWZbYV07KWZbYSsxXSs9ZlthXT4+PjE2LGZbYV0mPTY1NTM1LGErKzt9ZnVuY3Rpb24gSChmLGEpe3RoaXMuZz1mO3RoaXMuaD1hO31cbmZ1bmN0aW9uIEQoZixhKXtpZihDKGEpKXRocm93IEVycm9yKFwiZGl2aXNpb24gYnkgemVyb1wiKTtpZihDKGYpKXJldHVybiBuZXcgSCh3LHcpO2lmKEIoZikpcmV0dXJuIGE9RCh4KGYpLGEpLG5ldyBIKHgoYS5nKSx4KGEuaCkpO2lmKEIoYSkpcmV0dXJuIGE9RChmLHgoYSkpLG5ldyBIKHgoYS5nKSxhLmgpO2lmKDMwPGYuZy5sZW5ndGgpe2lmKEIoZil8fEIoYSkpdGhyb3cgRXJyb3IoXCJzbG93RGl2aWRlXyBvbmx5IHdvcmtzIHdpdGggcG9zaXRpdmUgaW50ZWdlcnMuXCIpO2Zvcih2YXIgYz16LGQ9YTswPj1kLmwoZik7KWM9SShjKSxkPUkoZCk7dmFyIGU9SihjLDEpLGc9SihkLDEpO2Q9SihkLDIpO2ZvcihjPUooYywyKTshQyhkKTspe3ZhciBiPWcuYWRkKGQpOzA+PWIubChmKSYmKGU9ZS5hZGQoYyksZz1iKTtkPUooZCwxKTtjPUooYywxKTt9YT1GKGYsZS5qKGEpKTtyZXR1cm4gbmV3IEgoZSxhKX1mb3IoZT13OzA8PWYubChhKTspe2M9TWF0aC5tYXgoMSxNYXRoLmZsb29yKGYubSgpL1xuYS5tKCkpKTtkPU1hdGguY2VpbChNYXRoLmxvZyhjKS9NYXRoLkxOMik7ZD00OD49ZD8xOk1hdGgucG93KDIsZC00OCk7Zz12KGMpO2ZvcihiPWcuaihhKTtCKGIpfHwwPGIubChmKTspYy09ZCxnPXYoYyksYj1nLmooYSk7QyhnKSYmKGc9eik7ZT1lLmFkZChnKTtmPUYoZixiKTt9cmV0dXJuIG5ldyBIKGUsZil9aC5BPWZ1bmN0aW9uKGYpe3JldHVybiBEKHRoaXMsZikuaH07aC5hbmQ9ZnVuY3Rpb24oZil7Zm9yKHZhciBhPU1hdGgubWF4KHRoaXMuZy5sZW5ndGgsZi5nLmxlbmd0aCksYz1bXSxkPTA7ZDxhO2QrKyljW2RdPXRoaXMuaShkKSZmLmkoZCk7cmV0dXJuIG5ldyB0KGMsdGhpcy5oJmYuaCl9O2gub3I9ZnVuY3Rpb24oZil7Zm9yKHZhciBhPU1hdGgubWF4KHRoaXMuZy5sZW5ndGgsZi5nLmxlbmd0aCksYz1bXSxkPTA7ZDxhO2QrKyljW2RdPXRoaXMuaShkKXxmLmkoZCk7cmV0dXJuIG5ldyB0KGMsdGhpcy5ofGYuaCl9O1xuaC54b3I9ZnVuY3Rpb24oZil7Zm9yKHZhciBhPU1hdGgubWF4KHRoaXMuZy5sZW5ndGgsZi5nLmxlbmd0aCksYz1bXSxkPTA7ZDxhO2QrKyljW2RdPXRoaXMuaShkKV5mLmkoZCk7cmV0dXJuIG5ldyB0KGMsdGhpcy5oXmYuaCl9O2Z1bmN0aW9uIEkoZil7Zm9yKHZhciBhPWYuZy5sZW5ndGgrMSxjPVtdLGQ9MDtkPGE7ZCsrKWNbZF09Zi5pKGQpPDwxfGYuaShkLTEpPj4+MzE7cmV0dXJuIG5ldyB0KGMsZi5oKX1mdW5jdGlvbiBKKGYsYSl7dmFyIGM9YT4+NTthJT0zMjtmb3IodmFyIGQ9Zi5nLmxlbmd0aC1jLGU9W10sZz0wO2c8ZDtnKyspZVtnXT0wPGE/Zi5pKGcrYyk+Pj5hfGYuaShnK2MrMSk8PDMyLWE6Zi5pKGcrYyk7cmV0dXJuIG5ldyB0KGUsZi5oKX1tLnByb3RvdHlwZS5kaWdlc3Q9bS5wcm90b3R5cGUudjttLnByb3RvdHlwZS5yZXNldD1tLnByb3RvdHlwZS5zO20ucHJvdG90eXBlLnVwZGF0ZT1tLnByb3RvdHlwZS51O01kNSA9IGJsb29tX2Jsb2JfZXMyMDE4Lk1kNT1tO3QucHJvdG90eXBlLmFkZD10LnByb3RvdHlwZS5hZGQ7dC5wcm90b3R5cGUubXVsdGlwbHk9dC5wcm90b3R5cGUuajt0LnByb3RvdHlwZS5tb2R1bG89dC5wcm90b3R5cGUuQTt0LnByb3RvdHlwZS5jb21wYXJlPXQucHJvdG90eXBlLmw7dC5wcm90b3R5cGUudG9OdW1iZXI9dC5wcm90b3R5cGUubTt0LnByb3RvdHlwZS50b1N0cmluZz10LnByb3RvdHlwZS50b1N0cmluZzt0LnByb3RvdHlwZS5nZXRCaXRzPXQucHJvdG90eXBlLmk7dC5mcm9tTnVtYmVyPXY7dC5mcm9tU3RyaW5nPXk7SW50ZWdlciA9IGJsb29tX2Jsb2JfZXMyMDE4LkludGVnZXI9dDt9KS5hcHBseSggdHlwZW9mIGNvbW1vbmpzR2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGNvbW1vbmpzR2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiAgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyAgOiB7fSk7XG5cbmV4cG9ydCB7IEludGVnZXIsIE1kNSwgYmxvb21fYmxvYl9lczIwMTggYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ymxvb21fYmxvYl9lczIwMTguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/webchannel-wrapper/dist/bloom-blob/esm/bloom_blob_es2018.js\n");

/***/ })

};
;